"use strict";const N=require("ethers"),fe=require("@oasisprotocol/sapphire-paratime"),Xt=require("cbor-redux"),he=require("asn1js"),pe=require("mitt"),ge=require("pbkdf2");function Jt(n){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(n){for(const e in n)if(e!=="default"){const r=Object.getOwnPropertyDescriptor(n,e);Object.defineProperty(t,e,r.get?r:{enumerable:!0,get:()=>n[e]})}}return t.default=n,Object.freeze(t)}const ye=Jt(fe),It=Jt(he),Qt=["constructor()","error DER_Split_Error()","error expmod_Error()","error k256Decompress_Invalid_Length_Error()","error k256DeriveY_Invalid_Prefix_Error()","error recoverV_Error()","function createAccount((bytes32 hashedUsername, bytes credentialId, (uint8 kty, int8 alg, uint8 crv, uint256 x, uint256 y) pubkey, bytes32 optionalPassword) args)","function credentialIdsByUsername(bytes32 in_hashedUsername) view returns (bytes[] out_credentialIds)","function encryptedTx(bytes32 nonce, bytes ciphertext)","function gaspayingAddress() view returns (address)","function generateGaslessTx(bytes in_data, uint64 nonce, uint256 gasPrice, uint64 gasLimit, uint256 timestamp, bytes signature) view returns (bytes out_data)","function getAccount(bytes32 in_username) view returns (address account, address keypairAddress)","function manageCredential((bytes32 credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) resp, bytes data) args)","function manageCredentialPassword((bytes32 digest, bytes data) args)","function personalization() view returns (bytes32)","function proxyView(bytes32 in_credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) in_resp, bytes in_data) view returns (bytes out_data)","function proxyViewPassword(bytes32 in_hashedUsername, bytes32 in_digest, bytes in_data) view returns (bytes out_data)","function salt() view returns (bytes32)","function userExists(bytes32 in_username) view returns (bool)"],Et=["constructor()","error DER_Split_Error()","error expmod_Error()","error k256Decompress_Invalid_Length_Error()","error k256DeriveY_Invalid_Prefix_Error()","error recoverV_Error()","function call(address in_contract, bytes in_data) returns (bytes out_data)","function init(address starterOwner)","function isController(address who) view returns (bool)","function keypairAddress() view returns (address)","function modifyController(address who, bool status)","function sign(bytes32 digest) view returns ((bytes32 r, bytes32 s, uint256 v))","function signEIP155((uint64 nonce, uint256 gasPrice, uint64 gasLimit, address to, uint256 value, bytes data, uint256 chainId) txToSign) view returns (bytes)","function staticcall(address in_contract, bytes in_data) view returns (bytes out_data)","function transfer(address in_target, uint256 amount)"],we=[{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"address",name:"_receiver",type:"address"}],stateMutability:"nonpayable",type:"constructor"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"},{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"maxSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}];function Zt(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function be(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function xt(n,...t){if(!be(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${n.length}`)}function Ae(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Zt(n.outputLen),Zt(n.blockLen)}function _t(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function Ee(n,t){xt(n);const e=t.outputLen;if(n.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Ot=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const St=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),j=(n,t)=>n<<32-t|n>>>t;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function Ie(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function Pt(n){return typeof n=="string"&&(n=Ie(n)),xt(n),n}function me(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];xt(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const i=n[r];e.set(i,s),s+=i.length}return e}class te{clone(){return this._cloneInto()}}function _e(n){const t=r=>n().update(Pt(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function xe(n=32){if(Ot&&typeof Ot.getRandomValues=="function")return Ot.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}class ee extends te{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Ae(t);const r=Pt(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?t.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=t.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(t){return _t(this),this.iHash.update(t),this}digestInto(t){_t(this),xt(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:i,blockLen:c,outputLen:o}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=c,t.outputLen=o,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ne=(n,t,e)=>new ee(n,t).update(e).digest();ne.create=(n,t)=>new ee(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const re=BigInt(0),Tt=BigInt(1),Te=BigInt(2);function ct(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function wt(n){if(!ct(n))throw new Error("Uint8Array expected")}const Ne=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function ut(n){wt(n);let t="";for(let e=0;e<n.length;e++)t+=Ne[n[e]];return t}function se(n){const t=n.toString(16);return t.length&1?`0${t}`:t}function Ut(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}const K={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Ft(n){if(n>=K._0&&n<=K._9)return n-K._0;if(n>=K._A&&n<=K._F)return n-(K._A-10);if(n>=K._a&&n<=K._f)return n-(K._a-10)}function ft(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const c=Ft(n.charCodeAt(i)),o=Ft(n.charCodeAt(i+1));if(c===void 0||o===void 0){const a=n[i]+n[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}r[s]=c*16+o}return r}function at(n){return Ut(ut(n))}function Dt(n){return wt(n),Ut(ut(Uint8Array.from(n).reverse()))}function ht(n,t){return ft(n.toString(16).padStart(t*2,"0"))}function Lt(n,t){return ht(n,t).reverse()}function Oe(n){return ft(se(n))}function W(n,t,e){let r;if(typeof t=="string")try{r=ft(t)}catch(i){throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${i}`)}else if(ct(t))r=Uint8Array.from(t);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${n} expected ${e} bytes, got ${s}`);return r}function yt(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];wt(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const i=n[r];e.set(i,s),s+=i.length}return e}function Se(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n[r]^t[r];return e===0}function Ce(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function ve(n){let t;for(t=0;n>re;n>>=Tt,t+=1);return t}function Re(n,t){return n>>BigInt(t)&Tt}function Be(n,t,e){return n|(e?Tt:re)<<BigInt(t)}const Ht=n=>(Te<<BigInt(n-1))-Tt,Ct=n=>new Uint8Array(n),$t=n=>Uint8Array.from(n);function ie(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Ct(n),s=Ct(n),i=0;const c=()=>{r.fill(1),s.fill(0),i=0},o=(...l)=>e(s,r,...l),a=(l=Ct())=>{s=o($t([0]),l),r=o(),l.length!==0&&(s=o($t([1]),l),r=o())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const O=[];for(;l<t;){r=o();const C=r.slice();O.push(C),l+=r.length}return yt(...O)};return(l,O)=>{c(),a(l);let C;for(;!(C=O(u()));)a();return c(),C}}const Pe={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||ct(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function bt(n,t,e={}){const r=(s,i,c)=>{const o=Pe[i];if(typeof o!="function")throw new Error(`Invalid validator "${i}", expected function`);const a=n[s];if(!(c&&a===void 0)&&!o(a,n))throw new Error(`Invalid param ${String(s)}=${a} (${typeof a}), expected ${i}`)};for(const[s,i]of Object.entries(t))r(s,i,!1);for(const[s,i]of Object.entries(e))r(s,i,!0);return n}const Ue=Object.freeze(Object.defineProperty({__proto__:null,abytes:wt,bitGet:Re,bitLen:ve,bitMask:Ht,bitSet:Be,bytesToHex:ut,bytesToNumberBE:at,bytesToNumberLE:Dt,concatBytes:yt,createHmacDrbg:ie,ensureBytes:W,equalBytes:Se,hexToBytes:ft,hexToNumber:Ut,isBytes:ct,numberToBytesBE:ht,numberToBytesLE:Lt,numberToHexUnpadded:se,numberToVarBytesBE:Oe,utf8ToBytes:Ce,validateObject:bt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const L=BigInt(0),U=BigInt(1),it=BigInt(2),De=BigInt(3),Rt=BigInt(4),Gt=BigInt(5),Wt=BigInt(8);BigInt(9);BigInt(16);function $(n,t){const e=n%t;return e>=L?e:t+e}function Le(n,t,e){if(e<=L||t<L)throw new Error("Expected power/modulo > 0");if(e===U)return L;let r=U;for(;t>L;)t&U&&(r=r*n%e),n=n*n%e,t>>=U;return r}function Bt(n,t){if(n===L||t<=L)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=$(n,t),r=t,s=L,i=U;for(;e!==L;){const o=r/e,a=r%e,u=s-i*o;r=e,e=a,s=i,i=u}if(r!==U)throw new Error("invert: does not exist");return $(s,t)}function He(n){const t=(n-U)/it;let e,r,s;for(e=n-U,r=0;e%it===L;e/=it,r++);for(s=it;s<n&&Le(s,t,n)!==n-U;s++);if(r===1){const c=(n+U)/Rt;return function(a,u){const y=a.pow(u,c);if(!a.eql(a.sqr(y),u))throw new Error("Cannot find square root");return y}}const i=(e+U)/it;return function(o,a){if(o.pow(a,t)===o.neg(o.ONE))throw new Error("Cannot find square root");let u=r,y=o.pow(o.mul(o.ONE,s),e),l=o.pow(a,i),O=o.pow(a,e);for(;!o.eql(O,o.ONE);){if(o.eql(O,o.ZERO))return o.ZERO;let C=1;for(let d=o.sqr(O);C<u&&!o.eql(d,o.ONE);C++)d=o.sqr(d);const b=o.pow(y,U<<BigInt(u-C-1));y=o.sqr(b),l=o.mul(l,b),O=o.mul(O,y),u=C}return l}}function ke(n){if(n%Rt===De){const t=(n+U)/Rt;return function(r,s){const i=r.pow(s,t);if(!r.eql(r.sqr(i),s))throw new Error("Cannot find square root");return i}}if(n%Wt===Gt){const t=(n-Gt)/Wt;return function(r,s){const i=r.mul(s,it),c=r.pow(i,t),o=r.mul(s,c),a=r.mul(r.mul(o,it),c),u=r.mul(o,r.sub(a,r.ONE));if(!r.eql(r.sqr(u),s))throw new Error("Cannot find square root");return u}}return He(n)}const Me=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ve(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Me.reduce((r,s)=>(r[s]="function",r),t);return bt(n,e)}function qe(n,t,e){if(e<L)throw new Error("Expected power > 0");if(e===L)return n.ONE;if(e===U)return t;let r=n.ONE,s=t;for(;e>L;)e&U&&(r=n.mul(r,s)),s=n.sqr(s),e>>=U;return r}function Ze(n,t){const e=new Array(t.length),r=t.reduce((i,c,o)=>n.is0(c)?i:(e[o]=i,n.mul(i,c)),n.ONE),s=n.inv(r);return t.reduceRight((i,c,o)=>n.is0(c)?i:(e[o]=n.mul(i,e[o]),n.mul(i,c)),s),e}function oe(n,t){const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Fe(n,t,e=!1,r={}){if(n<=L)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:i}=oe(n,t);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=ke(n),o=Object.freeze({ORDER:n,BITS:s,BYTES:i,MASK:Ht(s),ZERO:L,ONE:U,create:a=>$(a,n),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return L<=a&&a<n},is0:a=>a===L,isOdd:a=>(a&U)===U,neg:a=>$(-a,n),eql:(a,u)=>a===u,sqr:a=>$(a*a,n),add:(a,u)=>$(a+u,n),sub:(a,u)=>$(a-u,n),mul:(a,u)=>$(a*u,n),pow:(a,u)=>qe(o,a,u),div:(a,u)=>$(a*Bt(u,n),n),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>Bt(a,n),sqrt:r.sqrt||(a=>c(o,a)),invertBatch:a=>Ze(o,a),cmov:(a,u,y)=>y?u:a,toBytes:a=>e?Lt(a,i):ht(a,i),fromBytes:a=>{if(a.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${a.length}`);return e?Dt(a):at(a)}});return Object.freeze(o)}function ae(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function ce(n){const t=ae(n);return t+Math.ceil(t/2)}function $e(n,t,e=!1){const r=n.length,s=ae(t),i=ce(t);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const c=e?at(n):Dt(n),o=$(c,t-U)+U;return e?Lt(o,s):ht(o,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ge=BigInt(0),vt=BigInt(1);function We(n,t){const e=(s,i)=>{const c=i.negate();return s?c:i},r=s=>{const i=Math.ceil(t/s)+1,c=2**(s-1);return{windows:i,windowSize:c}};return{constTimeNegate:e,unsafeLadder(s,i){let c=n.ZERO,o=s;for(;i>Ge;)i&vt&&(c=c.add(o)),o=o.double(),i>>=vt;return c},precomputeWindow(s,i){const{windows:c,windowSize:o}=r(i),a=[];let u=s,y=u;for(let l=0;l<c;l++){y=u,a.push(y);for(let O=1;O<o;O++)y=y.add(u),a.push(y);u=y.double()}return a},wNAF(s,i,c){const{windows:o,windowSize:a}=r(s);let u=n.ZERO,y=n.BASE;const l=BigInt(2**s-1),O=2**s,C=BigInt(s);for(let b=0;b<o;b++){const d=b*a;let h=Number(c&l);c>>=C,h>a&&(h-=O,c+=vt);const g=d,A=d+Math.abs(h)-1,I=b%2!==0,v=h<0;h===0?y=y.add(e(I,i[g])):u=u.add(e(v,i[A]))}return{p:u,f:y}},wNAFCached(s,i,c,o){const a=s._WINDOW_SIZE||1;let u=i.get(s);return u||(u=this.precomputeWindow(s,a),a!==1&&i.set(s,o(u))),this.wNAF(a,u,c)}}}function ue(n){return Ve(n.Fp),bt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oe(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ze(n){const t=ue(n);bt(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=t;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:je,hexToBytes:Ke}=Ue,ot={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(n){const{Err:t}=ot;if(n.length<2||n[0]!==2)throw new t("Invalid signature integer tag");const e=n[1],r=n.subarray(2,e+2);if(!e||r.length!==e)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:je(r),l:n.subarray(e+2)}},toSig(n){const{Err:t}=ot,e=typeof n=="string"?Ke(n):n;wt(e);let r=e.length;if(r<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:s,l:i}=ot._parseInt(e.subarray(2)),{d:c,l:o}=ot._parseInt(i);if(o.length)throw new t("Invalid signature: left bytes after parsing");return{r:s,s:c}},hexFromSig(n){const t=u=>Number.parseInt(u[0],16)&8?"00"+u:u,e=u=>{const y=u.toString(16);return y.length&1?`0${y}`:y},r=t(e(n.s)),s=t(e(n.r)),i=r.length/2,c=s.length/2,o=e(i),a=e(c);return`30${e(c+i+4)}02${a}${s}02${o}${r}`}},Y=BigInt(0),F=BigInt(1);BigInt(2);const zt=BigInt(3);BigInt(4);function Ye(n){const t=ze(n),{Fp:e}=t,r=t.toBytes||((b,d,h)=>{const g=d.toAffine();return yt(Uint8Array.from([4]),e.toBytes(g.x),e.toBytes(g.y))}),s=t.fromBytes||(b=>{const d=b.subarray(1),h=e.fromBytes(d.subarray(0,e.BYTES)),g=e.fromBytes(d.subarray(e.BYTES,2*e.BYTES));return{x:h,y:g}});function i(b){const{a:d,b:h}=t,g=e.sqr(b),A=e.mul(g,b);return e.add(e.add(A,e.mul(b,d)),h)}if(!e.eql(e.sqr(t.Gy),i(t.Gx)))throw new Error("bad generator point: equation left != right");function c(b){return typeof b=="bigint"&&Y<b&&b<t.n}function o(b){if(!c(b))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(b){const{allowedPrivateKeyLengths:d,nByteLength:h,wrapPrivateKey:g,n:A}=t;if(d&&typeof b!="bigint"){if(ct(b)&&(b=ut(b)),typeof b!="string"||!d.includes(b.length))throw new Error("Invalid key");b=b.padStart(h*2,"0")}let I;try{I=typeof b=="bigint"?b:at(W("private key",b,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof b}`)}return g&&(I=$(I,A)),o(I),I}const u=new Map;function y(b){if(!(b instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(d,h,g){if(this.px=d,this.py=h,this.pz=g,d==null||!e.isValid(d))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(g==null||!e.isValid(g))throw new Error("z required")}static fromAffine(d){const{x:h,y:g}=d||{};if(!d||!e.isValid(h)||!e.isValid(g))throw new Error("invalid affine point");if(d instanceof l)throw new Error("projective point not allowed");const A=I=>e.eql(I,e.ZERO);return A(h)&&A(g)?l.ZERO:new l(h,g,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const h=e.invertBatch(d.map(g=>g.pz));return d.map((g,A)=>g.toAffine(h[A])).map(l.fromAffine)}static fromHex(d){const h=l.fromAffine(s(W("pointHex",d)));return h.assertValidity(),h}static fromPrivateKey(d){return l.BASE.multiply(a(d))}_setWindowSize(d){this._WINDOW_SIZE=d,u.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:d,y:h}=this.toAffine();if(!e.isValid(d)||!e.isValid(h))throw new Error("bad point: x or y not FE");const g=e.sqr(h),A=i(d);if(!e.eql(g,A))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:d}=this.toAffine();if(e.isOdd)return!e.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){y(d);const{px:h,py:g,pz:A}=this,{px:I,py:v,pz:T}=d,w=e.eql(e.mul(h,T),e.mul(I,A)),E=e.eql(e.mul(g,T),e.mul(v,A));return w&&E}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){const{a:d,b:h}=t,g=e.mul(h,zt),{px:A,py:I,pz:v}=this;let T=e.ZERO,w=e.ZERO,E=e.ZERO,_=e.mul(A,A),q=e.mul(I,I),P=e.mul(v,v),S=e.mul(A,I);return S=e.add(S,S),E=e.mul(A,v),E=e.add(E,E),T=e.mul(d,E),w=e.mul(g,P),w=e.add(T,w),T=e.sub(q,w),w=e.add(q,w),w=e.mul(T,w),T=e.mul(S,T),E=e.mul(g,E),P=e.mul(d,P),S=e.sub(_,P),S=e.mul(d,S),S=e.add(S,E),E=e.add(_,_),_=e.add(E,_),_=e.add(_,P),_=e.mul(_,S),w=e.add(w,_),P=e.mul(I,v),P=e.add(P,P),_=e.mul(P,S),T=e.sub(T,_),E=e.mul(P,q),E=e.add(E,E),E=e.add(E,E),new l(T,w,E)}add(d){y(d);const{px:h,py:g,pz:A}=this,{px:I,py:v,pz:T}=d;let w=e.ZERO,E=e.ZERO,_=e.ZERO;const q=t.a,P=e.mul(t.b,zt);let S=e.mul(h,I),M=e.mul(g,v),V=e.mul(A,T),X=e.add(h,g),f=e.add(I,v);X=e.mul(X,f),f=e.add(S,M),X=e.sub(X,f),f=e.add(h,A);let p=e.add(I,T);return f=e.mul(f,p),p=e.add(S,V),f=e.sub(f,p),p=e.add(g,A),w=e.add(v,T),p=e.mul(p,w),w=e.add(M,V),p=e.sub(p,w),_=e.mul(q,f),w=e.mul(P,V),_=e.add(w,_),w=e.sub(M,_),_=e.add(M,_),E=e.mul(w,_),M=e.add(S,S),M=e.add(M,S),V=e.mul(q,V),f=e.mul(P,f),M=e.add(M,V),V=e.sub(S,V),V=e.mul(q,V),f=e.add(f,V),S=e.mul(M,f),E=e.add(E,S),S=e.mul(p,f),w=e.mul(X,w),w=e.sub(w,S),S=e.mul(X,M),_=e.mul(p,_),_=e.add(_,S),new l(w,E,_)}subtract(d){return this.add(d.negate())}is0(){return this.equals(l.ZERO)}wNAF(d){return C.wNAFCached(this,u,d,h=>{const g=e.invertBatch(h.map(A=>A.pz));return h.map((A,I)=>A.toAffine(g[I])).map(l.fromAffine)})}multiplyUnsafe(d){const h=l.ZERO;if(d===Y)return h;if(o(d),d===F)return this;const{endo:g}=t;if(!g)return C.unsafeLadder(this,d);let{k1neg:A,k1:I,k2neg:v,k2:T}=g.splitScalar(d),w=h,E=h,_=this;for(;I>Y||T>Y;)I&F&&(w=w.add(_)),T&F&&(E=E.add(_)),_=_.double(),I>>=F,T>>=F;return A&&(w=w.negate()),v&&(E=E.negate()),E=new l(e.mul(E.px,g.beta),E.py,E.pz),w.add(E)}multiply(d){o(d);let h=d,g,A;const{endo:I}=t;if(I){const{k1neg:v,k1:T,k2neg:w,k2:E}=I.splitScalar(h);let{p:_,f:q}=this.wNAF(T),{p:P,f:S}=this.wNAF(E);_=C.constTimeNegate(v,_),P=C.constTimeNegate(w,P),P=new l(e.mul(P.px,I.beta),P.py,P.pz),g=_.add(P),A=q.add(S)}else{const{p:v,f:T}=this.wNAF(h);g=v,A=T}return l.normalizeZ([g,A])[0]}multiplyAndAddUnsafe(d,h,g){const A=l.BASE,I=(T,w)=>w===Y||w===F||!T.equals(A)?T.multiplyUnsafe(w):T.multiply(w),v=I(this,h).add(I(d,g));return v.is0()?void 0:v}toAffine(d){const{px:h,py:g,pz:A}=this,I=this.is0();d==null&&(d=I?e.ONE:e.inv(A));const v=e.mul(h,d),T=e.mul(g,d),w=e.mul(A,d);if(I)return{x:e.ZERO,y:e.ZERO};if(!e.eql(w,e.ONE))throw new Error("invZ was invalid");return{x:v,y:T}}isTorsionFree(){const{h:d,isTorsionFree:h}=t;if(d===F)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:h}=t;return d===F?this:h?h(l,this):this.multiplyUnsafe(t.h)}toRawBytes(d=!0){return this.assertValidity(),r(l,this,d)}toHex(d=!0){return ut(this.toRawBytes(d))}}l.BASE=new l(t.Gx,t.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);const O=t.nBitLength,C=We(l,t.endo?Math.ceil(O/2):O);return{CURVE:t,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:i,isWithinCurveOrder:c}}function Xe(n){const t=ue(n);return bt(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function Je(n){const t=Xe(n),{Fp:e,n:r}=t,s=e.BYTES+1,i=2*e.BYTES+1;function c(f){return Y<f&&f<e.ORDER}function o(f){return $(f,r)}function a(f){return Bt(f,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:y,weierstrassEquation:l,isWithinCurveOrder:O}=Ye({...t,toBytes(f,p,m){const B=p.toAffine(),R=e.toBytes(B.x),D=yt;return m?D(Uint8Array.from([p.hasEvenY()?2:3]),R):D(Uint8Array.from([4]),R,e.toBytes(B.y))},fromBytes(f){const p=f.length,m=f[0],B=f.subarray(1);if(p===s&&(m===2||m===3)){const R=at(B);if(!c(R))throw new Error("Point is not on curve");const D=l(R);let H;try{H=e.sqrt(D)}catch(G){const Q=G instanceof Error?": "+G.message:"";throw new Error("Point is not on curve"+Q)}const k=(H&F)===F;return(m&1)===1!==k&&(H=e.neg(H)),{x:R,y:H}}else if(p===i&&m===4){const R=e.fromBytes(B.subarray(0,e.BYTES)),D=e.fromBytes(B.subarray(e.BYTES,2*e.BYTES));return{x:R,y:D}}else throw new Error(`Point of length ${p} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`)}}),C=f=>ut(ht(f,t.nByteLength));function b(f){const p=r>>F;return f>p}function d(f){return b(f)?o(-f):f}const h=(f,p,m)=>at(f.slice(p,m));class g{constructor(p,m,B){this.r=p,this.s=m,this.recovery=B,this.assertValidity()}static fromCompact(p){const m=t.nByteLength;return p=W("compactSignature",p,m*2),new g(h(p,0,m),h(p,m,2*m))}static fromDER(p){const{r:m,s:B}=ot.toSig(W("DER",p));return new g(m,B)}assertValidity(){if(!O(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!O(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(p){return new g(this.r,this.s,p)}recoverPublicKey(p){const{r:m,s:B,recovery:R}=this,D=E(W("msgHash",p));if(R==null||![0,1,2,3].includes(R))throw new Error("recovery id invalid");const H=R===2||R===3?m+t.n:m;if(H>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const k=R&1?"03":"02",J=u.fromHex(k+C(H)),G=a(H),Q=o(-D*G),pt=o(B*G),tt=u.BASE.multiplyAndAddUnsafe(J,Q,pt);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return ft(this.toDERHex())}toDERHex(){return ot.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ft(this.toCompactHex())}toCompactHex(){return C(this.r)+C(this.s)}}const A={isValidPrivateKey(f){try{return y(f),!0}catch{return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{const f=ce(t.n);return $e(t.randomBytes(f),t.n)},precompute(f=8,p=u.BASE){return p._setWindowSize(f),p.multiply(BigInt(3)),p}};function I(f,p=!0){return u.fromPrivateKey(f).toRawBytes(p)}function v(f){const p=ct(f),m=typeof f=="string",B=(p||m)&&f.length;return p?B===s||B===i:m?B===2*s||B===2*i:f instanceof u}function T(f,p,m=!0){if(v(f))throw new Error("first arg must be private key");if(!v(p))throw new Error("second arg must be public key");return u.fromHex(p).multiply(y(f)).toRawBytes(m)}const w=t.bits2int||function(f){const p=at(f),m=f.length*8-t.nBitLength;return m>0?p>>BigInt(m):p},E=t.bits2int_modN||function(f){return o(w(f))},_=Ht(t.nBitLength);function q(f){if(typeof f!="bigint")throw new Error("bigint expected");if(!(Y<=f&&f<_))throw new Error(`bigint expected < 2^${t.nBitLength}`);return ht(f,t.nByteLength)}function P(f,p,m=S){if(["recovered","canonical"].some(st=>st in m))throw new Error("sign() legacy options not supported");const{hash:B,randomBytes:R}=t;let{lowS:D,prehash:H,extraEntropy:k}=m;D==null&&(D=!0),f=W("msgHash",f),H&&(f=W("prehashed msgHash",B(f)));const J=E(f),G=y(p),Q=[q(G),q(J)];if(k!=null&&k!==!1){const st=k===!0?R(e.BYTES):k;Q.push(W("extraEntropy",st))}const pt=yt(...Q),tt=J;function Nt(st){const dt=w(st);if(!O(dt))return;const Mt=a(dt),z=u.BASE.multiply(dt).toAffine(),lt=o(z.x);if(lt===Y)return;const At=o(Mt*o(tt+lt*G));if(At===Y)return;let Vt=(z.x===lt?0:2)|Number(z.y&F),qt=At;return D&&b(At)&&(qt=d(At),Vt^=1),new g(lt,qt,Vt)}return{seed:pt,k2sig:Nt}}const S={lowS:t.lowS,prehash:!1},M={lowS:t.lowS,prehash:!1};function V(f,p,m=S){const{seed:B,k2sig:R}=P(f,p,m),D=t;return ie(D.hash.outputLen,D.nByteLength,D.hmac)(B,R)}u.BASE._setWindowSize(8);function X(f,p,m,B=M){const R=f;if(p=W("msgHash",p),m=W("publicKey",m),"strict"in B)throw new Error("options.strict was renamed to lowS");const{lowS:D,prehash:H}=B;let k,J;try{if(typeof R=="string"||ct(R))try{k=g.fromDER(R)}catch(z){if(!(z instanceof ot.Err))throw z;k=g.fromCompact(R)}else if(typeof R=="object"&&typeof R.r=="bigint"&&typeof R.s=="bigint"){const{r:z,s:lt}=R;k=new g(z,lt)}else throw new Error("PARSE");J=u.fromHex(m)}catch(z){if(z.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(D&&k.hasHighS())return!1;H&&(p=t.hash(p));const{r:G,s:Q}=k,pt=E(p),tt=a(Q),Nt=o(pt*tt),st=o(G*tt),dt=u.BASE.multiplyAndAddUnsafe(J,Nt,st)?.toAffine();return dt?o(dt.x)===G:!1}return{CURVE:t,getPublicKey:I,getSharedSecret:T,sign:V,verify:X,ProjectivePoint:u,Signature:g,utils:A}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Qe(n){return{hash:n,hmac:(t,...e)=>ne(n,t,me(...e)),randomBytes:xe}}function tn(n,t){const e=r=>Je({...n,...Qe(r)});return Object.freeze({...e(t),create:e})}function en(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),i=BigInt(4294967295),c=Number(e>>s&i),o=Number(e&i),a=r?4:0,u=r?0:4;n.setUint32(t+a,c,r),n.setUint32(t+u,o,r)}const nn=(n,t,e)=>n&t^~n&e,rn=(n,t,e)=>n&t^n&e^t&e;class sn extends te{constructor(t,e,r,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=St(this.buffer)}update(t){_t(this);const{view:e,buffer:r,blockLen:s}=this;t=Pt(t);const i=t.length;for(let c=0;c<i;){const o=Math.min(s-this.pos,i-c);if(o===s){const a=St(t);for(;s<=i-c;c+=s)this.process(a,c);continue}r.set(t.subarray(c,c+o),this.pos),this.pos+=o,c+=o,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){_t(this),Ee(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:i}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>s-c&&(this.process(r,0),c=0);for(let l=c;l<s;l++)e[l]=0;en(r,s-8,BigInt(this.length*8),i),this.process(r,0);const o=St(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,y=this.get();if(u>y.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)o.setUint32(4*l,y[l],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:i,destroyed:c,pos:o}=this;return t.length=s,t.pos=o,t.finished=i,t.destroyed=c,s%e&&t.buffer.set(r),t}}const on=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),et=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),nt=new Uint32Array(64);class an extends sn{constructor(){super(64,32,8,!1),this.A=et[0]|0,this.B=et[1]|0,this.C=et[2]|0,this.D=et[3]|0,this.E=et[4]|0,this.F=et[5]|0,this.G=et[6]|0,this.H=et[7]|0}get(){const{A:t,B:e,C:r,D:s,E:i,F:c,G:o,H:a}=this;return[t,e,r,s,i,c,o,a]}set(t,e,r,s,i,c,o,a){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=c|0,this.G=o|0,this.H=a|0}process(t,e){for(let l=0;l<16;l++,e+=4)nt[l]=t.getUint32(e,!1);for(let l=16;l<64;l++){const O=nt[l-15],C=nt[l-2],b=j(O,7)^j(O,18)^O>>>3,d=j(C,17)^j(C,19)^C>>>10;nt[l]=d+nt[l-7]+b+nt[l-16]|0}let{A:r,B:s,C:i,D:c,E:o,F:a,G:u,H:y}=this;for(let l=0;l<64;l++){const O=j(o,6)^j(o,11)^j(o,25),C=y+O+nn(o,a,u)+on[l]+nt[l]|0,d=(j(r,2)^j(r,13)^j(r,22))+rn(r,s,i)|0;y=u,u=a,a=o,o=c+C|0,c=i,i=s,s=r,r=C+d|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,c=c+this.D|0,o=o+this.E|0,a=a+this.F|0,u=u+this.G|0,y=y+this.H|0,this.set(r,s,i,c,o,a,u,y)}roundClean(){nt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const cn=_e(()=>new an);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const de=Fe(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),un=de.create(BigInt("-3")),dn=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),ln=tn({a:un,b:dn,Fp:de,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},cn),jt=ln,gt="oasisAppWallet",fn=23294,hn=23295,pn={WALLET_CONTEXT:"oaw_context",TRANSACTIONS_CONTEXT:"oaw_transactions",TOKENS_CONTEXT:"oaw_tokens"},Z={SAPPHIRE_PROVIDER_NOT_INITIALIZED:"OAW_SAPPHIRE_PROVIDER_NOT_INITIALIZED",ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED:"OAW_ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED",NO_USERNAME:"OAW_NO_USERNAME",NO_PASSWORD:"OAW_NO_PASSWORD",NO_LOGIN_PROXY_DATA:"OAW_NO_LOGIN_PROXY_DATA",AUTHENTICATION_DATA_NOT_PROVIDED:"OAW_AUTHENTICATION_DATA_NOT_PROVIDED",CANT_GET_ACCOUNT_ADDRESS:"OAW_CANT_GET_ACCOUNT_ADDRESS",NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID:"OAW_NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID",CROSS_CHAIN_PROVIDER_NOT_INITIALIZED:"OAW_CROSS_CHAIN_PROVIDER_NOT_INITIALIZED",OASIS_WALLET_NOT_INITIALIZED:"OAW_OASIS_WALLET_NOT_INITIALIZED",CANT_HASH_USERNAME:"OAW_CANT_HASH_USERNAME",CANT_GET_SIGNATURE:"CANT_GET_SIGNATURE"},gn={[Z.SAPPHIRE_PROVIDER_NOT_INITIALIZED]:"Sapphire provider not initialized",[Z.ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED]:"Account manager contract not initialized",[Z.NO_USERNAME]:"No username",[Z.NO_PASSWORD]:"No password",[Z.NO_LOGIN_PROXY_DATA]:"No login proxy data",[Z.AUTHENTICATION_DATA_NOT_PROVIDED]:"Authentication data not provided",[Z.CANT_GET_ACCOUNT_ADDRESS]:"Can't get account address",[Z.NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID]:"No rpc url configured for selected chainid",[Z.CROSS_CHAIN_PROVIDER_NOT_INITIALIZED]:"Cross chain provider not initialized",[Z.OASIS_WALLET_NOT_INITIALIZED]:"Oasis wallet not initialized",[Z.CANT_HASH_USERNAME]:"Can't hash username"};function yn(n){if(typeof window<"u")return window[gt]=new kt(n),window[gt]}function le(){if(typeof window<"u")return window[gt]||(window[gt]=new kt),window[gt]}async function rt(n=""){const e=await le()?.accountManagerContract?.salt();if(e)return ge.pbkdf2Sync(n,N.ethers.toBeArray(e),1e5,32,"sha256")}function mt(n){return[hn,fn].includes(n)}function x(n,t="Error"){const e=new Error(t);throw e.name=Z[n],e}class Kt{abiCoder=N.ethers.AbiCoder.defaultAbiCoder();async getRegisterData(t){t.username||x("NO_USERNAME"),t.password||x("NO_PASSWORD");const e=await rt(t.username);if(!e){x("CANT_HASH_USERNAME");return}const r=this.generateNewKeypair();return{hashedUsername:e,credentialId:r.credentialId,pubkey:{kty:2,alg:-7,crv:1,x:r.decoded_x,y:r.decoded_y},optionalPassword:N.ethers.encodeBytes32String(t.password)}}async getProxyResponse(t,e,r){r.username||x("NO_USERNAME"),r.password||x("NO_PASSWORD");const s=await rt(r.username);s||x("CANT_HASH_USERNAME");const i=N.ethers.solidityPackedKeccak256(["bytes32","bytes"],[N.ethers.encodeBytes32String(r.password),e]);return await t.proxyViewPassword(s,i,e)}generateNewKeypair(){const t=jt.utils.randomPrivateKey(),e=jt.getPublicKey(t,!1),r="0x"+ut(e),s=this.abiCoder.encode(["string"],[r]),i=r.slice(4,r.length),c=BigInt("0x"+i.slice(0,64)),o=BigInt("0x"+i.slice(64,i.length));return{credentialId:s,privateKey:t,decoded_x:c,decoded_y:o}}}function wn(n){return n[0]<<24|n[1]<<16|n[2]<<8|n[3]}function bn(n){return n[0]<<8|n[1]}function An(n){const t=Xt.CBOR.decode(n),e=t[1];if(e==2){const r={kty:e,alg:t[3],crv:t[-1],x:N.toBigInt(t[-2]),y:N.toBigInt(t[-3])};if(!(r.alg==-7&&r.crv==1)&&!(r.alg==-8&&r.crv==6))throw new Error(`Unknown alg: ${r.alg}, crv: ${r.crv}`);return r}throw new Error(`Unsupported kty: ${e}`)}function En(n){if(n.byteLength-n.byteOffset<37)throw new Error("Attestation Object must be at least 37 bytes or longer");const t=n.slice(32,33)[0],e={rpIdHash:n.slice(0,32),flags:{UP:(t&1)!=0,UV:(t&4)!=0,BE:(t&8)!=0,BS:(t&16)!=0,AT:(t&64)!=0,ED:(t&128)!=0},signCount:wn(n.slice(33,37))};if(e.flags.ED)throw new Error("Extension Data not supported!");if(e.flags.AT){const r=bn(n.slice(53,55));e.attestedCredentialData={aaguid:n.slice(37,53),credentialId:n.slice(55,55+r),credentialPublicKey:An(n.slice(55+r).buffer)}}return e}function In(n){const e=Xt.CBOR.decode(new Uint8Array(n).buffer).authData;return En(e)}async function mn(n,t,e){const r=await navigator.credentials.create({publicKey:{attestation:"none",challenge:e.buffer,pubKeyCredParams:[{alg:-7,type:"public-key"}],rp:n,user:t}});if(!r)throw new Error("No PublicKeyCredential returned!");const s=r.response,i=new TextDecoder("utf-8").decode(s.clientDataJSON);return{id:new Uint8Array(r.rawId),cd:i,ad:In(s.attestationObject)}}function _n(n){return Object.entries(n).map(([t,e])=>{if(typeof e=="boolean")return{t:1,k:t,v:e?"true":"false"};if(typeof e=="string")return{t:0,k:t,v:e};throw new Error(`Incompatible value type! Key:${t} Value:${e}`)})}const xn=new It.Sequence({name:"sig",value:[new It.Integer({name:"r"}),new It.Integer({name:"s"})]});async function Tn(n,t){t||(t=crypto.getRandomValues(new Uint8Array(32)));const e=await navigator.credentials.get({publicKey:{allowCredentials:n.map(u=>({id:u,type:"public-key"})),challenge:t}}),r=e.response,s=It.verifySchema(r.signature,xn);if(!s.verified)throw new Error("Unable to decode ASN.1 signature!");const i=s.result,c=i.r.toBigInt(),o=i.s.toBigInt(),a=JSON.parse(new TextDecoder().decode(r.clientDataJSON));return{credentialIdHashed:N.keccak256(new Uint8Array(e.rawId)),challenge:t,resp:{authenticatorData:new Uint8Array(r.authenticatorData),clientDataTokens:_n(a),sigR:c,sigS:o}}}class Yt{async getRegisterData(t){t.username||x("NO_USERNAME");const e=await rt(t.username);if(!e){x("CANT_HASH_USERNAME");return}const r=await mn({name:"Oasis Wallet Account",id:window.location.hostname},{id:e,name:t.username,displayName:t.username},crypto.getRandomValues(new Uint8Array(32)));return{hashedUsername:e,credentialId:r.id,pubkey:r.ad.attestedCredentialData.credentialPublicKey,optionalPassword:N.ethers.ZeroHash}}async getProxyResponse(t,e,r){r.username||x("NO_USERNAME");const s=r.hashedUsername||await rt(r.username);s||x("CANT_HASH_USERNAME");const i=await t.personalization(),c=await t.credentialIdsByUsername(s),o=await Tn(c.map(a=>N.ethers.toBeArray(a)),N.ethers.toBeArray(N.ethers.sha256(i+N.ethers.sha256(e).slice(2))));return await t.proxyView(o.credentialIdHashed,o.resp,e)}}class kt{sapphireProvider;accountManagerContract;abiCoder=N.ethers.AbiCoder.defaultAbiCoder();events;onGetSignature;defaultNetworkId=0;rpcUrls={};rpcProviders={};explorerUrls={23294:"https://explorer.oasis.io/mainnet/sapphire",23295:"https://explorer.oasis.io/testnet/sapphire"};lastAccount={username:"",authStrategy:"passkey",address:"",contractAddress:""};constructor(t){const e=new N.ethers.JsonRpcProvider(t?.sapphireUrl||"https://testnet.sapphire.oasis.dev");if(this.sapphireProvider=ye.wrap(e),this.accountManagerContract=new N.ethers.Contract(t?.accountManagerAddress||"0x5C357DaFfe6b1016C0c9A5607367E8f47765D4bC",Qt,new N.ethers.VoidSigner(N.ethers.ZeroAddress,this.sapphireProvider)),this.defaultNetworkId=t?.defaultNetworkId||this.defaultNetworkId,t?.networkConfig)for(const r in t.networkConfig)this.rpcUrls[r]=t.networkConfig[r].rpcUrl,this.explorerUrls[r]=t.networkConfig[r].explorerUrl;this.events=pe(),this.onGetSignature=t?.signatureCallback}async userExists(t){return this.sapphireProvider||x("SAPPHIRE_PROVIDER_NOT_INITIALIZED"),this.accountManagerContract||x("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED"),await this.accountManagerContract.userExists(await rt(t))||!1}async register(t,e){this.sapphireProvider||x("SAPPHIRE_PROVIDER_NOT_INITIALIZED"),this.accountManagerContract||x("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED");let r;t==="password"?r=await new Kt().getRegisterData(e):t==="passkey"&&(r=await new Yt().getRegisterData(e));const s=this.abiCoder.encode(["tuple(bytes funcData, uint8 txType)"],[{funcData:this.abiCoder.encode(["tuple(bytes32 hashedUsername, bytes credentialId, tuple(uint8 kty, int8 alg, uint8 crv, uint256 x, uint256 y) pubkey, bytes32 optionalPassword)"],[r]),txType:0}]),i=(await this.sapphireProvider.getFeeData()).gasPrice,c=await this.sapphireProvider.getTransactionCount(await this.accountManagerContract.gaspayingAddress());let o="";if(this.onGetSignature){const u=await this.onGetSignature(s);u.signature||x("CANT_GET_SIGNATURE"),o=await this.accountManagerContract.generateGaslessTx(s,c,u.gasPrice?BigInt(u.gasPrice):i,u.gasLimit?BigInt(u.gasLimit):1000000n,BigInt(u.timestamp),u.signature)}else o=await this.accountManagerContract.generateGaslessTx(s,c,i);const a=await this.sapphireProvider.send("eth_sendRawTransaction",[o]);if(this.lastAccount.authStrategy=t,this.lastAccount.username=e.username,await this.waitForTxReceipt(a))return await this.getAccountAddress(e.username)}async authenticate(t,e){this.sapphireProvider||x("SAPPHIRE_PROVIDER_NOT_INITIALIZED"),this.accountManagerContract||x("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED"),e.username||x("NO_USERNAME");const r="0x000000000000000000000000000000000000000000000000000000000000DEAD",s=await rt(e.username),i=new N.ethers.Interface(Et),c=i.encodeFunctionData("sign",[r]),o=await this.getProxyForStrategy(t,c,{...e,hashedUsername:s});o||x("NO_LOGIN_PROXY_DATA");const[[a,u,y]]=i.decodeFunctionResult("sign",o).toArray(),l=N.ethers.recoverAddress(r,{r:a,s:u,v:y}),O=await this.accountManagerContract.getAccount(s);if(this.lastAccount.authStrategy=t,this.lastAccount.username=e.username,O.length>1&&l===O[1])return await this.getAccountAddress(e.username)}async getAccountAddress(t){if(this.sapphireProvider||x("SAPPHIRE_PROVIDER_NOT_INITIALIZED"),this.accountManagerContract||x("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED"),!t){if(this.lastAccount.address)return{publicAddress:this.lastAccount.address,accountContractAddress:this.lastAccount.contractAddress};x("NO_USERNAME")}const e=await rt(t),r=await this.accountManagerContract.getAccount(e);if(Array.isArray(r)&&r.length>1)return this.lastAccount.address=r[1],this.lastAccount.contractAddress=r[0],{publicAddress:r[1],accountContractAddress:r[0]}}async getAccountBalance(t,e=this.defaultNetworkId,r=18){if(!e||mt(e))return N.ethers.formatUnits(await this.sapphireProvider?.getBalance(t)||0n,r);if(!this.rpcUrls[e])return"0";const s=this.rpcProviders[e]||new N.ethers.JsonRpcProvider(this.rpcUrls[e]);return N.ethers.formatUnits(await s.getBalance(t),r)}setAccount(t){this.lastAccount.username=t.username,this.lastAccount.authStrategy=t.strategy,this.lastAccount.address=t.address,this.lastAccount.contractAddress=t.contractAddress}async signMessage(t){this.sapphireProvider||x("SAPPHIRE_PROVIDER_NOT_INITIALIZED");const e=new N.ethers.Interface(Et);let r=t.data||"";const s=t.message;if((!r||t.mustConfirm)&&(typeof t.message=="string"&&(t.message=N.ethers.encodeBytes32String(t.message)),r=e.encodeFunctionData("sign",[t.message]),t.mustConfirm))return await new Promise(c=>{this.events.emit("signatureRequest",{...t,data:r,message:s,mustConfirm:!1,resolve:c})});t.authData||x("AUTHENTICATION_DATA_NOT_PROVIDED");const i=await this.getProxyForStrategy(t.strategy||this.lastAccount.authStrategy,r,t.authData);if(i){const[c]=e.decodeFunctionResult("sign",i).toArray();if(Array.isArray(c)&&c.length>2){const o=N.ethers.Signature.from({r:c[0],s:c[1],v:c[2]}).serialized;return t.resolve&&t.resolve(o),o}}}async signPlainTransaction(t){const e=this.validateChainId(t?.tx?.chainId&&+t.tx.chainId.toString()||0);if(t.tx.chainId=e,t.tx.nonce||(t.tx.nonce=await this.getRpcProviderForChainId(e).getTransactionCount(this.lastAccount.address)),t.tx.type==="eip1559"&&(t.tx.type=2,t.tx.gasLimit=t.tx.gas),t.tx.type===2&&(t.tx.gasPrice||(t.tx.gasPrice=2e10),t.tx.value||(t.tx.value=0n)),t.mustConfirm)return await new Promise(c=>{this.events.emit("txApprove",{plain:{...t,mustConfirm:!1,resolve:c}})});t.authData||x("AUTHENTICATION_DATA_NOT_PROVIDED");const r=new N.ethers.Interface(Et),s=r.encodeFunctionData("signEIP155",[t.tx]),i=await this.getProxyForStrategy(t.strategy,s,t.authData);if(i){const[c]=r.decodeFunctionResult("signEIP155",i).toArray();return t.resolve&&t.resolve({signedTxData:c,chainId:e}),{signedTxData:c,chainId:e}}}async broadcastTransaction(t,e,r="Transaction"){const s=this.getRpcProviderForChainId(e),i=await s.send("eth_sendRawTransaction",[t]),c={hash:i,label:r,rawData:t,owner:this.lastAccount.address||"none",status:"pending",chainId:e||this.defaultNetworkId,explorerUrl:this.explorerUrls[e||this.defaultNetworkId]?`${this.explorerUrls[e||this.defaultNetworkId]}/tx/${i}`:"",createdAt:Date.now()};return this.events.emit("txSubmitted",c),{txHash:i,ethProvider:s,txItem:c}}async signContractWrite(t){const e=this.validateChainId(t.chainId);if(t.mustConfirm)return await new Promise(y=>{this.events.emit("txApprove",{contractWrite:{...t,mustConfirm:!1,resolve:y}})});t.authData||x("AUTHENTICATION_DATA_NOT_PROVIDED");const r=await this.getAccountAddress(t.authData.username);r?.publicAddress||x("CANT_GET_ACCOUNT_ADDRESS");const i=new N.ethers.Interface(t.contractAbi).encodeFunctionData(t.contractFunctionName,t.contractFunctionValues),c=await new N.ethers.VoidSigner(r.publicAddress,this.getRpcProviderForChainId(e)).populateTransaction({from:r.publicAddress,to:t.contractAddress,gasLimit:1e6,value:0,data:i});c.gasPrice=2e10;const o=new N.ethers.Interface(Et),a=o.encodeFunctionData("signEIP155",[c]),u=await this.getProxyForStrategy(t.strategy||this.lastAccount.authStrategy,a,t.authData);if(u){const[y]=o.decodeFunctionResult("signEIP155",u).toArray();return t.resolve&&t.resolve({signedTxData:y,chainId:e}),{signedTxData:y,chainId:e}}}async contractRead(t){const e=this.validateChainId(t.chainId),r=this.getRpcProviderForChainId(e),s=new N.ethers.Contract(t.contractAddress,t.contractAbi,r);return t.contractFunctionValues?await s[t.contractFunctionName](...t.contractFunctionValues):await s[t.contractFunctionName]()}async getProxyForStrategy(t,e,r){if(this.accountManagerContract||x("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED"),t==="password")return await new Kt().getProxyResponse(this.accountManagerContract,e,r);if(t==="passkey")return await new Yt().getProxyResponse(this.accountManagerContract,e,r)}async waitForTxReceipt(t,e){!e&&!this.sapphireProvider&&x("SAPPHIRE_PROVIDER_NOT_INITIALIZED");const r=60;let s=0;for(;;){const i=await(e||this.sapphireProvider).getTransactionReceipt(t);if(i)return i;if(s+=1,s>=r)return;await new Promise(c=>setTimeout(c,1e3))}}setDefaultNetworkId(t){this.rpcUrls[t]&&(this.defaultNetworkId=t)}validateChainId(t){return(t&&!mt(t)&&!this.rpcUrls[t]||!t&&this.defaultNetworkId&&!this.rpcUrls[this.defaultNetworkId])&&x("NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID"),!t&&this.defaultNetworkId&&(t=this.defaultNetworkId),t}getRpcProviderForChainId(t){if(!t||t&&mt(+t.toString()))return this.sapphireProvider||x("SAPPHIRE_PROVIDER_NOT_INITIALIZED"),this.sapphireProvider;{const e=this.rpcProviders[t]||new N.ethers.JsonRpcProvider(this.rpcUrls[t]);return this.rpcProviders[t]=e,e||x("CROSS_CHAIN_PROVIDER_NOT_INITIALIZED"),e}}}exports.AccountManagerAbi=Qt;exports.ERC20Abi=we;exports.ErrorMessages=gn;exports.OasisAppWallet=kt;exports.WebStorageKeys=pn;exports.abort=x;exports.getHashedUsername=rt;exports.getOasisAppWallet=le;exports.initializeOnWindow=yn;exports.networkIdIsSapphire=mt;
