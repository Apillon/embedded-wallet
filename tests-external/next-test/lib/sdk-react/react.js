import './react.css';
import { jsxs as Re, Fragment as Yt, jsx as C } from "react/jsx-runtime";
import dE, { createContext as Jv, forwardRef as NP, useState as Ct, useEffect as Ln, useMemo as Kl, useReducer as Xv, useRef as Rn, useContext as ew } from "react";
import hx from "react-dom";
import { pbkdf2Sync as PP } from "pbkdf2";
import { ethers as Pv, hexlify as nA, AbstractSigner as OP } from "ethers";
import { fillOptions as RP, makeTaggedProxyObject as LP, isCalldataEnveloped as DP } from "@oasisprotocol/sapphire-paratime";
import { CBOR as px } from "cbor-redux";
import * as lg from "asn1js";
import BP from "mitt";
import { Transition as MP, Dialog as FP, TransitionChild as rA, DialogPanel as _P, TabGroup as UP, TabList as zP, Tab as HP, TabPanels as VP, TabPanel as WP, Field as hE, Label as pE, Input as gE, Select as GP } from "@headlessui/react";
import { QRCode as jP } from "react-qr-code";
var $P = Object.defineProperty, gx = (a) => {
  throw TypeError(a);
}, QP = (a, e, r) => e in a ? $P(a, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : a[e] = r, le = (a, e, r) => QP(a, typeof e != "symbol" ? e + "" : e, r), mE = (a, e, r) => e.has(a) || gx("Cannot " + r), R = (a, e, r) => (mE(a, e, "read from private field"), r ? r.call(a) : e.get(a)), ye = (a, e, r) => e.has(a) ? gx("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(a) : e.set(a, r), Q = (a, e, r, i) => (mE(a, e, "write to private field"), e.set(a, r), r), Oe = (a, e, r) => (mE(a, e, "access private method"), r), Y4 = (a, e, r, i) => ({
  set _(u) {
    Q(a, e, u);
  },
  get _() {
    return R(a, e, i);
  }
});
function mx(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
function ZP(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var yx = { exports: {} }, Jn = yx.exports = {}, Ql, Zl;
function a5() {
  throw new Error("setTimeout has not been defined");
}
function o5() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Ql = setTimeout : Ql = a5;
  } catch {
    Ql = a5;
  }
  try {
    typeof clearTimeout == "function" ? Zl = clearTimeout : Zl = o5;
  } catch {
    Zl = o5;
  }
})();
function bx(a) {
  if (Ql === setTimeout)
    return setTimeout(a, 0);
  if ((Ql === a5 || !Ql) && setTimeout)
    return Ql = setTimeout, setTimeout(a, 0);
  try {
    return Ql(a, 0);
  } catch {
    try {
      return Ql.call(null, a, 0);
    } catch {
      return Ql.call(this, a, 0);
    }
  }
}
function YP(a) {
  if (Zl === clearTimeout)
    return clearTimeout(a);
  if ((Zl === o5 || !Zl) && clearTimeout)
    return Zl = clearTimeout, clearTimeout(a);
  try {
    return Zl(a);
  } catch {
    try {
      return Zl.call(null, a);
    } catch {
      return Zl.call(this, a);
    }
  }
}
var Lc = [], Cy = !1, Xp, E4 = -1;
function qP() {
  !Cy || !Xp || (Cy = !1, Xp.length ? Lc = Xp.concat(Lc) : E4 = -1, Lc.length && vx());
}
function vx() {
  if (!Cy) {
    var a = bx(qP);
    Cy = !0;
    for (var e = Lc.length; e; ) {
      for (Xp = Lc, Lc = []; ++E4 < e; )
        Xp && Xp[E4].run();
      E4 = -1, e = Lc.length;
    }
    Xp = null, Cy = !1, YP(a);
  }
}
Jn.nextTick = function(a) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
  Lc.push(new wx(a, e)), Lc.length === 1 && !Cy && bx(vx);
};
function wx(a, e) {
  this.fun = a, this.array = e;
}
wx.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Jn.title = "browser";
Jn.browser = !0;
Jn.env = {};
Jn.argv = [];
Jn.version = "";
Jn.versions = {};
function _c() {
}
Jn.on = _c;
Jn.addListener = _c;
Jn.once = _c;
Jn.off = _c;
Jn.removeListener = _c;
Jn.removeAllListeners = _c;
Jn.emit = _c;
Jn.prependListener = _c;
Jn.prependOnceListener = _c;
Jn.listeners = function(a) {
  return [];
};
Jn.binding = function(a) {
  throw new Error("process.binding is not supported");
};
Jn.cwd = function() {
  return "/";
};
Jn.chdir = function(a) {
  throw new Error("process.chdir is not supported");
};
Jn.umask = function() {
  return 0;
};
var KP = yx.exports;
const Gs = /* @__PURE__ */ ZP(KP);
var s4 = { exports: {} }, M2 = {}, y8 = { exports: {} }, aA = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oA;
function JP() {
  return oA || (oA = 1, function(a) {
    function e(P, H) {
      var G = P.length;
      P.push(H);
      e: for (; 0 < G; ) {
        var ie = G - 1 >>> 1, ce = P[ie];
        if (0 < u(ce, H))
          P[ie] = H, P[G] = ce, G = ie;
        else break e;
      }
    }
    function r(P) {
      return P.length === 0 ? null : P[0];
    }
    function i(P) {
      if (P.length === 0) return null;
      var H = P[0], G = P.pop();
      if (G !== H) {
        P[0] = G;
        e: for (var ie = 0, ce = P.length, xe = ce >>> 1; ie < xe; ) {
          var Ce = 2 * (ie + 1) - 1, Be = P[Ce], Pe = Ce + 1, Fe = P[Pe];
          if (0 > u(Be, G))
            Pe < ce && 0 > u(Fe, Be) ? (P[ie] = Fe, P[Pe] = G, ie = Pe) : (P[ie] = Be, P[Ce] = G, ie = Ce);
          else if (Pe < ce && 0 > u(Fe, G))
            P[ie] = Fe, P[Pe] = G, ie = Pe;
          else break e;
        }
      }
      return H;
    }
    function u(P, H) {
      var G = P.sortIndex - H.sortIndex;
      return G !== 0 ? G : P.id - H.id;
    }
    if (a.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var d = performance;
      a.unstable_now = function() {
        return d.now();
      };
    } else {
      var g = Date, b = g.now();
      a.unstable_now = function() {
        return g.now() - b;
      };
    }
    var y = [], k = [], S = 1, A = null, x = 3, M = !1, D = !1, O = !1, T = typeof setTimeout == "function" ? setTimeout : null, L = typeof clearTimeout == "function" ? clearTimeout : null, U = typeof setImmediate < "u" ? setImmediate : null;
    function W(P) {
      for (var H = r(k); H !== null; ) {
        if (H.callback === null) i(k);
        else if (H.startTime <= P)
          i(k), H.sortIndex = H.expirationTime, e(y, H);
        else break;
        H = r(k);
      }
    }
    function Z(P) {
      if (O = !1, W(P), !D)
        if (r(y) !== null)
          D = !0, V();
        else {
          var H = r(k);
          H !== null && B(Z, H.startTime - P);
        }
    }
    var J = !1, Y = -1, X = 5, ee = -1;
    function j() {
      return !(a.unstable_now() - ee < X);
    }
    function ne() {
      if (J) {
        var P = a.unstable_now();
        ee = P;
        var H = !0;
        try {
          e: {
            D = !1, O && (O = !1, L(Y), Y = -1), M = !0;
            var G = x;
            try {
              t: {
                for (W(P), A = r(y); A !== null && !(A.expirationTime > P && j()); ) {
                  var ie = A.callback;
                  if (typeof ie == "function") {
                    A.callback = null, x = A.priorityLevel;
                    var ce = ie(
                      A.expirationTime <= P
                    );
                    if (P = a.unstable_now(), typeof ce == "function") {
                      A.callback = ce, W(P), H = !0;
                      break t;
                    }
                    A === r(y) && i(y), W(P);
                  } else i(y);
                  A = r(y);
                }
                if (A !== null) H = !0;
                else {
                  var xe = r(k);
                  xe !== null && B(
                    Z,
                    xe.startTime - P
                  ), H = !1;
                }
              }
              break e;
            } finally {
              A = null, x = G, M = !1;
            }
            H = void 0;
          }
        } finally {
          H ? ae() : J = !1;
        }
      }
    }
    var ae;
    if (typeof U == "function")
      ae = function() {
        U(ne);
      };
    else if (typeof MessageChannel < "u") {
      var he = new MessageChannel(), Ie = he.port2;
      he.port1.onmessage = ne, ae = function() {
        Ie.postMessage(null);
      };
    } else
      ae = function() {
        T(ne, 0);
      };
    function V() {
      J || (J = !0, ae());
    }
    function B(P, H) {
      Y = T(function() {
        P(a.unstable_now());
      }, H);
    }
    a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(P) {
      P.callback = null;
    }, a.unstable_continueExecution = function() {
      D || M || (D = !0, V());
    }, a.unstable_forceFrameRate = function(P) {
      0 > P || 125 < P ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : X = 0 < P ? Math.floor(1e3 / P) : 5;
    }, a.unstable_getCurrentPriorityLevel = function() {
      return x;
    }, a.unstable_getFirstCallbackNode = function() {
      return r(y);
    }, a.unstable_next = function(P) {
      switch (x) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = x;
      }
      var G = x;
      x = H;
      try {
        return P();
      } finally {
        x = G;
      }
    }, a.unstable_pauseExecution = function() {
    }, a.unstable_requestPaint = function() {
    }, a.unstable_runWithPriority = function(P, H) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var G = x;
      x = P;
      try {
        return H();
      } finally {
        x = G;
      }
    }, a.unstable_scheduleCallback = function(P, H, G) {
      var ie = a.unstable_now();
      switch (typeof G == "object" && G !== null ? (G = G.delay, G = typeof G == "number" && 0 < G ? ie + G : ie) : G = ie, P) {
        case 1:
          var ce = -1;
          break;
        case 2:
          ce = 250;
          break;
        case 5:
          ce = 1073741823;
          break;
        case 4:
          ce = 1e4;
          break;
        default:
          ce = 5e3;
      }
      return ce = G + ce, P = {
        id: S++,
        callback: H,
        priorityLevel: P,
        startTime: G,
        expirationTime: ce,
        sortIndex: -1
      }, G > ie ? (P.sortIndex = G, e(k, P), r(y) === null && P === r(k) && (O ? (L(Y), Y = -1) : O = !0, B(Z, G - ie))) : (P.sortIndex = ce, e(y, P), D || M || (D = !0, V())), P;
    }, a.unstable_shouldYield = j, a.unstable_wrapCallback = function(P) {
      var H = x;
      return function() {
        var G = x;
        x = H;
        try {
          return P.apply(this, arguments);
        } finally {
          x = G;
        }
      };
    };
  }(aA)), aA;
}
var iA = {}, sA;
function XP() {
  return sA || (sA = 1, function(a) {
    Gs.env.NODE_ENV !== "production" && function() {
      function e() {
        if (j) {
          var P = a.unstable_now();
          he = P;
          var H = !0;
          try {
            e: {
              Z = !1, J && (J = !1, X(ne), ne = -1), W = !0;
              var G = U;
              try {
                t: {
                  for (g(P), L = i(D); L !== null && !(L.expirationTime > P && y()); ) {
                    var ie = L.callback;
                    if (typeof ie == "function") {
                      L.callback = null, U = L.priorityLevel;
                      var ce = ie(
                        L.expirationTime <= P
                      );
                      if (P = a.unstable_now(), typeof ce == "function") {
                        L.callback = ce, g(P), H = !0;
                        break t;
                      }
                      L === i(D) && u(D), g(P);
                    } else u(D);
                    L = i(D);
                  }
                  if (L !== null) H = !0;
                  else {
                    var xe = i(O);
                    xe !== null && S(
                      b,
                      xe.startTime - P
                    ), H = !1;
                  }
                }
                break e;
              } finally {
                L = null, U = G, W = !1;
              }
              H = void 0;
            }
          } finally {
            H ? Ie() : j = !1;
          }
        }
      }
      function r(P, H) {
        var G = P.length;
        P.push(H);
        e: for (; 0 < G; ) {
          var ie = G - 1 >>> 1, ce = P[ie];
          if (0 < d(ce, H))
            P[ie] = H, P[G] = ce, G = ie;
          else break e;
        }
      }
      function i(P) {
        return P.length === 0 ? null : P[0];
      }
      function u(P) {
        if (P.length === 0) return null;
        var H = P[0], G = P.pop();
        if (G !== H) {
          P[0] = G;
          e: for (var ie = 0, ce = P.length, xe = ce >>> 1; ie < xe; ) {
            var Ce = 2 * (ie + 1) - 1, Be = P[Ce], Pe = Ce + 1, Fe = P[Pe];
            if (0 > d(Be, G))
              Pe < ce && 0 > d(Fe, Be) ? (P[ie] = Fe, P[Pe] = G, ie = Pe) : (P[ie] = Be, P[Ce] = G, ie = Ce);
            else if (Pe < ce && 0 > d(Fe, G))
              P[ie] = Fe, P[Pe] = G, ie = Pe;
            else break e;
          }
        }
        return H;
      }
      function d(P, H) {
        var G = P.sortIndex - H.sortIndex;
        return G !== 0 ? G : P.id - H.id;
      }
      function g(P) {
        for (var H = i(O); H !== null; ) {
          if (H.callback === null) u(O);
          else if (H.startTime <= P)
            u(O), H.sortIndex = H.expirationTime, r(D, H);
          else break;
          H = i(O);
        }
      }
      function b(P) {
        if (J = !1, g(P), !Z)
          if (i(D) !== null)
            Z = !0, k();
          else {
            var H = i(O);
            H !== null && S(
              b,
              H.startTime - P
            );
          }
      }
      function y() {
        return !(a.unstable_now() - he < ae);
      }
      function k() {
        j || (j = !0, Ie());
      }
      function S(P, H) {
        ne = Y(function() {
          P(a.unstable_now());
        }, H);
      }
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), a.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var A = performance;
        a.unstable_now = function() {
          return A.now();
        };
      } else {
        var x = Date, M = x.now();
        a.unstable_now = function() {
          return x.now() - M;
        };
      }
      var D = [], O = [], T = 1, L = null, U = 3, W = !1, Z = !1, J = !1, Y = typeof setTimeout == "function" ? setTimeout : null, X = typeof clearTimeout == "function" ? clearTimeout : null, ee = typeof setImmediate < "u" ? setImmediate : null, j = !1, ne = -1, ae = 5, he = -1;
      if (typeof ee == "function")
        var Ie = function() {
          ee(e);
        };
      else if (typeof MessageChannel < "u") {
        var V = new MessageChannel(), B = V.port2;
        V.port1.onmessage = e, Ie = function() {
          B.postMessage(null);
        };
      } else
        Ie = function() {
          Y(e, 0);
        };
      a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(P) {
        P.callback = null;
      }, a.unstable_continueExecution = function() {
        Z || W || (Z = !0, k());
      }, a.unstable_forceFrameRate = function(P) {
        0 > P || 125 < P ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : ae = 0 < P ? Math.floor(1e3 / P) : 5;
      }, a.unstable_getCurrentPriorityLevel = function() {
        return U;
      }, a.unstable_getFirstCallbackNode = function() {
        return i(D);
      }, a.unstable_next = function(P) {
        switch (U) {
          case 1:
          case 2:
          case 3:
            var H = 3;
            break;
          default:
            H = U;
        }
        var G = U;
        U = H;
        try {
          return P();
        } finally {
          U = G;
        }
      }, a.unstable_pauseExecution = function() {
      }, a.unstable_requestPaint = function() {
      }, a.unstable_runWithPriority = function(P, H) {
        switch (P) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            P = 3;
        }
        var G = U;
        U = P;
        try {
          return H();
        } finally {
          U = G;
        }
      }, a.unstable_scheduleCallback = function(P, H, G) {
        var ie = a.unstable_now();
        switch (typeof G == "object" && G !== null ? (G = G.delay, G = typeof G == "number" && 0 < G ? ie + G : ie) : G = ie, P) {
          case 1:
            var ce = -1;
            break;
          case 2:
            ce = 250;
            break;
          case 5:
            ce = 1073741823;
            break;
          case 4:
            ce = 1e4;
            break;
          default:
            ce = 5e3;
        }
        return ce = G + ce, P = {
          id: T++,
          callback: H,
          priorityLevel: P,
          startTime: G,
          expirationTime: ce,
          sortIndex: -1
        }, G > ie ? (P.sortIndex = G, r(O, P), i(D) === null && P === i(O) && (J ? (X(ne), ne = -1) : J = !0, S(b, G - ie))) : (P.sortIndex = ce, r(D, P), Z || W || (Z = !0, k())), P;
      }, a.unstable_shouldYield = y, a.unstable_wrapCallback = function(P) {
        var H = U;
        return function() {
          var G = U;
          U = H;
          try {
            return P.apply(this, arguments);
          } finally {
            U = G;
          }
        };
      }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(iA)), iA;
}
var lA;
function kx() {
  return lA || (lA = 1, Gs.env.NODE_ENV === "production" ? y8.exports = JP() : y8.exports = XP()), y8.exports;
}
var uA;
function eO() {
  if (uA) return M2;
  uA = 1;
  var a = kx(), e = dE, r = hx;
  function i(o) {
    var l = "https://react.dev/errors/" + o;
    if (1 < arguments.length) {
      l += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var c = 2; c < arguments.length; c++)
        l += "&args[]=" + encodeURIComponent(arguments[c]);
    }
    return "Minified React error #" + o + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function u(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
  }
  var d = Symbol.for("react.element"), g = Symbol.for("react.transitional.element"), b = Symbol.for("react.portal"), y = Symbol.for("react.fragment"), k = Symbol.for("react.strict_mode"), S = Symbol.for("react.profiler"), A = Symbol.for("react.provider"), x = Symbol.for("react.consumer"), M = Symbol.for("react.context"), D = Symbol.for("react.forward_ref"), O = Symbol.for("react.suspense"), T = Symbol.for("react.suspense_list"), L = Symbol.for("react.memo"), U = Symbol.for("react.lazy"), W = Symbol.for("react.offscreen"), Z = Symbol.for("react.memo_cache_sentinel"), J = Symbol.iterator;
  function Y(o) {
    return o === null || typeof o != "object" ? null : (o = J && o[J] || o["@@iterator"], typeof o == "function" ? o : null);
  }
  var X = Symbol.for("react.client.reference");
  function ee(o) {
    if (o == null) return null;
    if (typeof o == "function")
      return o.$$typeof === X ? null : o.displayName || o.name || null;
    if (typeof o == "string") return o;
    switch (o) {
      case y:
        return "Fragment";
      case b:
        return "Portal";
      case S:
        return "Profiler";
      case k:
        return "StrictMode";
      case O:
        return "Suspense";
      case T:
        return "SuspenseList";
    }
    if (typeof o == "object")
      switch (o.$$typeof) {
        case M:
          return (o.displayName || "Context") + ".Provider";
        case x:
          return (o._context.displayName || "Context") + ".Consumer";
        case D:
          var l = o.render;
          return o = o.displayName, o || (o = l.displayName || l.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
        case L:
          return l = o.displayName || null, l !== null ? l : ee(o.type) || "Memo";
        case U:
          l = o._payload, o = o._init;
          try {
            return ee(o(l));
          } catch {
          }
      }
    return null;
  }
  var j = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ne = Object.assign, ae, he;
  function Ie(o) {
    if (ae === void 0)
      try {
        throw Error();
      } catch (c) {
        var l = c.stack.trim().match(/\n( *(at )?)/);
        ae = l && l[1] || "", he = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + ae + o + he;
  }
  var V = !1;
  function B(o, l) {
    if (!o || V) return "";
    V = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var h = {
        DetermineComponentFrameRoot: function() {
          try {
            if (l) {
              var Ne = function() {
                throw Error();
              };
              if (Object.defineProperty(Ne.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(Ne, []);
                } catch (ve) {
                  var ge = ve;
                }
                Reflect.construct(o, [], Ne);
              } else {
                try {
                  Ne.call();
                } catch (ve) {
                  ge = ve;
                }
                o.call(Ne.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (ve) {
                ge = ve;
              }
              (Ne = o()) && typeof Ne.catch == "function" && Ne.catch(function() {
              });
            }
          } catch (ve) {
            if (ve && ge && typeof ve.stack == "string")
              return [ve.stack, ge.stack];
          }
          return [null, null];
        }
      };
      h.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var v = Object.getOwnPropertyDescriptor(
        h.DetermineComponentFrameRoot,
        "name"
      );
      v && v.configurable && Object.defineProperty(
        h.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var w = h.DetermineComponentFrameRoot(), N = w[0], _ = w[1];
      if (N && _) {
        var $ = N.split(`
`), oe = _.split(`
`);
        for (v = h = 0; h < $.length && !$[h].includes("DetermineComponentFrameRoot"); )
          h++;
        for (; v < oe.length && !oe[v].includes(
          "DetermineComponentFrameRoot"
        ); )
          v++;
        if (h === $.length || v === oe.length)
          for (h = $.length - 1, v = oe.length - 1; 1 <= h && 0 <= v && $[h] !== oe[v]; )
            v--;
        for (; 1 <= h && 0 <= v; h--, v--)
          if ($[h] !== oe[v]) {
            if (h !== 1 || v !== 1)
              do
                if (h--, v--, 0 > v || $[h] !== oe[v]) {
                  var ke = `
` + $[h].replace(" at new ", " at ");
                  return o.displayName && ke.includes("<anonymous>") && (ke = ke.replace("<anonymous>", o.displayName)), ke;
                }
              while (1 <= h && 0 <= v);
            break;
          }
      }
    } finally {
      V = !1, Error.prepareStackTrace = c;
    }
    return (c = o ? o.displayName || o.name : "") ? Ie(c) : "";
  }
  function P(o) {
    switch (o.tag) {
      case 26:
      case 27:
      case 5:
        return Ie(o.type);
      case 16:
        return Ie("Lazy");
      case 13:
        return Ie("Suspense");
      case 19:
        return Ie("SuspenseList");
      case 0:
      case 15:
        return o = B(o.type, !1), o;
      case 11:
        return o = B(o.type.render, !1), o;
      case 1:
        return o = B(o.type, !0), o;
      default:
        return "";
    }
  }
  function H(o) {
    try {
      var l = "";
      do
        l += P(o), o = o.return;
      while (o);
      return l;
    } catch (c) {
      return `
Error generating stack: ` + c.message + `
` + c.stack;
    }
  }
  function G(o) {
    var l = o, c = o;
    if (o.alternate) for (; l.return; ) l = l.return;
    else {
      o = l;
      do
        l = o, l.flags & 4098 && (c = l.return), o = l.return;
      while (o);
    }
    return l.tag === 3 ? c : null;
  }
  function ie(o) {
    if (o.tag === 13) {
      var l = o.memoizedState;
      if (l === null && (o = o.alternate, o !== null && (l = o.memoizedState)), l !== null) return l.dehydrated;
    }
    return null;
  }
  function ce(o) {
    if (G(o) !== o)
      throw Error(i(188));
  }
  function xe(o) {
    var l = o.alternate;
    if (!l) {
      if (l = G(o), l === null) throw Error(i(188));
      return l !== o ? null : o;
    }
    for (var c = o, h = l; ; ) {
      var v = c.return;
      if (v === null) break;
      var w = v.alternate;
      if (w === null) {
        if (h = v.return, h !== null) {
          c = h;
          continue;
        }
        break;
      }
      if (v.child === w.child) {
        for (w = v.child; w; ) {
          if (w === c) return ce(v), o;
          if (w === h) return ce(v), l;
          w = w.sibling;
        }
        throw Error(i(188));
      }
      if (c.return !== h.return) c = v, h = w;
      else {
        for (var N = !1, _ = v.child; _; ) {
          if (_ === c) {
            N = !0, c = v, h = w;
            break;
          }
          if (_ === h) {
            N = !0, h = v, c = w;
            break;
          }
          _ = _.sibling;
        }
        if (!N) {
          for (_ = w.child; _; ) {
            if (_ === c) {
              N = !0, c = w, h = v;
              break;
            }
            if (_ === h) {
              N = !0, h = w, c = v;
              break;
            }
            _ = _.sibling;
          }
          if (!N) throw Error(i(189));
        }
      }
      if (c.alternate !== h) throw Error(i(190));
    }
    if (c.tag !== 3) throw Error(i(188));
    return c.stateNode.current === c ? o : l;
  }
  function Ce(o) {
    var l = o.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return o;
    for (o = o.child; o !== null; ) {
      if (l = Ce(o), l !== null) return l;
      o = o.sibling;
    }
    return null;
  }
  var Be = Array.isArray, Pe = r.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Fe = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Xe = [], at = -1;
  function tt(o) {
    return { current: o };
  }
  function Ye(o) {
    0 > at || (o.current = Xe[at], Xe[at] = null, at--);
  }
  function Ve(o, l) {
    at++, Xe[at] = o.current, o.current = l;
  }
  var Je = tt(null), _e = tt(null), rt = tt(null), Gt = tt(null);
  function Er(o, l) {
    switch (Ve(rt, l), Ve(_e, o), Ve(Je, null), o = l.nodeType, o) {
      case 9:
      case 11:
        l = (l = l.documentElement) && (l = l.namespaceURI) ? u0(l) : 0;
        break;
      default:
        if (o = o === 8 ? l.parentNode : l, l = o.tagName, o = o.namespaceURI)
          o = u0(o), l = Wb(o, l);
        else
          switch (l) {
            case "svg":
              l = 1;
              break;
            case "math":
              l = 2;
              break;
            default:
              l = 0;
          }
    }
    Ye(Je), Ve(Je, l);
  }
  function Ga() {
    Ye(Je), Ye(_e), Ye(rt);
  }
  function jt(o) {
    o.memoizedState !== null && Ve(Gt, o);
    var l = Je.current, c = Wb(l, o.type);
    l !== c && (Ve(_e, o), Ve(Je, c));
  }
  function Og(o) {
    _e.current === o && (Ye(Je), Ye(_e)), Gt.current === o && (Ye(Gt), ca._currentValue = Fe);
  }
  var Rg = Object.prototype.hasOwnProperty, au = a.unstable_scheduleCallback, $s = a.unstable_cancelCallback, mw = a.unstable_shouldYield, yw = a.unstable_requestPaint, Xr = a.unstable_now, Zk = a.unstable_getCurrentPriorityLevel, bw = a.unstable_ImmediatePriority, Qs = a.unstable_UserBlockingPriority, ou = a.unstable_NormalPriority, Gd = a.unstable_LowPriority, vw = a.unstable_IdlePriority, ww = a.log, kw = a.unstable_setDisableYieldValue, iu = null, ur = null;
  function Yk(o) {
    if (ur && typeof ur.onCommitFiberRoot == "function")
      try {
        ur.onCommitFiberRoot(
          iu,
          o,
          void 0,
          (o.current.flags & 128) === 128
        );
      } catch {
      }
  }
  function zi(o) {
    if (typeof ww == "function" && kw(o), ur && typeof ur.setStrictMode == "function")
      try {
        ur.setStrictMode(iu, o);
      } catch {
      }
  }
  var ea = Math.clz32 ? Math.clz32 : Aw, Ew = Math.log, Sw = Math.LN2;
  function Aw(o) {
    return o >>>= 0, o === 0 ? 32 : 31 - (Ew(o) / Sw | 0) | 0;
  }
  var jd = 128, Lg = 4194304;
  function Hi(o) {
    var l = o & 42;
    if (l !== 0) return l;
    switch (o & -o) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o & 4194176;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return o & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return o;
    }
  }
  function zo(o, l) {
    var c = o.pendingLanes;
    if (c === 0) return 0;
    var h = 0, v = o.suspendedLanes, w = o.pingedLanes, N = o.warmLanes;
    o = o.finishedLanes !== 0;
    var _ = c & 134217727;
    return _ !== 0 ? (c = _ & ~v, c !== 0 ? h = Hi(c) : (w &= _, w !== 0 ? h = Hi(w) : o || (N = _ & ~N, N !== 0 && (h = Hi(N))))) : (_ = c & ~v, _ !== 0 ? h = Hi(_) : w !== 0 ? h = Hi(w) : o || (N = c & ~N, N !== 0 && (h = Hi(N)))), h === 0 ? 0 : l !== 0 && l !== h && !(l & v) && (v = h & -h, N = l & -l, v >= N || v === 32 && (N & 4194176) !== 0) ? l : h;
  }
  function fo(o, l) {
    return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & l) === 0;
  }
  function $d(o, l) {
    switch (o) {
      case 1:
      case 2:
      case 4:
      case 8:
        return l + 250;
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function su() {
    var o = jd;
    return jd <<= 1, !(jd & 4194176) && (jd = 128), o;
  }
  function Dn() {
    var o = Lg;
    return Lg <<= 1, !(Lg & 62914560) && (Lg = 4194304), o;
  }
  function Vi(o) {
    for (var l = [], c = 0; 31 > c; c++) l.push(o);
    return l;
  }
  function Ho(o, l) {
    o.pendingLanes |= l, l !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0);
  }
  function Vc(o, l, c, h, v, w) {
    var N = o.pendingLanes;
    o.pendingLanes = c, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= c, o.entangledLanes &= c, o.errorRecoveryDisabledLanes &= c, o.shellSuspendCounter = 0;
    var _ = o.entanglements, $ = o.expirationTimes, oe = o.hiddenUpdates;
    for (c = N & ~c; 0 < c; ) {
      var ke = 31 - ea(c), Ne = 1 << ke;
      _[ke] = 0, $[ke] = -1;
      var ge = oe[ke];
      if (ge !== null)
        for (oe[ke] = null, ke = 0; ke < ge.length; ke++) {
          var ve = ge[ke];
          ve !== null && (ve.lane &= -536870913);
        }
      c &= ~Ne;
    }
    h !== 0 && Dg(o, h, 0), w !== 0 && v === 0 && o.tag !== 0 && (o.suspendedLanes |= w & ~(N & ~l));
  }
  function Dg(o, l, c) {
    o.pendingLanes |= l, o.suspendedLanes &= ~l;
    var h = 31 - ea(l);
    o.entangledLanes |= l, o.entanglements[h] = o.entanglements[h] | 1073741824 | c & 4194218;
  }
  function s1(o, l) {
    var c = o.entangledLanes |= l;
    for (o = o.entanglements; c; ) {
      var h = 31 - ea(c), v = 1 << h;
      v & l | o[h] & l && (o[h] |= l), c &= ~v;
    }
  }
  function Qd(o) {
    return o &= -o, 2 < o ? 8 < o ? o & 134217727 ? 32 : 268435456 : 8 : 2;
  }
  function Zd() {
    var o = Pe.p;
    return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : S3(o.type));
  }
  function Wi(o, l) {
    var c = Pe.p;
    try {
      return Pe.p = o, l();
    } finally {
      Pe.p = c;
    }
  }
  var Bn = Math.random().toString(36).slice(2), cr = "__reactFiber$" + Bn, ta = "__reactProps$" + Bn, Gi = "__reactContainer$" + Bn, Bg = "__reactEvents$" + Bn, Mg = "__reactListeners$" + Bn, ho = "__reactHandles$" + Bn, l1 = "__reactResources$" + Bn, lu = "__reactMarker$" + Bn;
  function Fg(o) {
    delete o[cr], delete o[ta], delete o[Bg], delete o[Mg], delete o[ho];
  }
  function ji(o) {
    var l = o[cr];
    if (l) return l;
    for (var c = o.parentNode; c; ) {
      if (l = c[Gi] || c[cr]) {
        if (c = l.alternate, l.child !== null || c !== null && c.child !== null)
          for (o = ep(o); o !== null; ) {
            if (c = o[cr]) return c;
            o = ep(o);
          }
        return l;
      }
      o = c, c = o.parentNode;
    }
    return null;
  }
  function uu(o) {
    if (o = o[cr] || o[Gi]) {
      var l = o.tag;
      if (l === 5 || l === 6 || l === 13 || l === 26 || l === 27 || l === 3)
        return o;
    }
    return null;
  }
  function Wc(o) {
    var l = o.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return o.stateNode;
    throw Error(i(33));
  }
  function po(o) {
    var l = o[l1];
    return l || (l = o[l1] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), l;
  }
  function Mn(o) {
    o[lu] = !0;
  }
  var u1 = /* @__PURE__ */ new Set(), c1 = {};
  function Zs(o, l) {
    cu(o, l), cu(o + "Capture", l);
  }
  function cu(o, l) {
    for (c1[o] = l, o = 0; o < l.length; o++)
      u1.add(l[o]);
  }
  var wn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Gc = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Ys = {}, f1 = {};
  function Yd(o) {
    return Rg.call(f1, o) ? !0 : Rg.call(Ys, o) ? !1 : Gc.test(o) ? f1[o] = !0 : (Ys[o] = !0, !1);
  }
  function fu(o, l, c) {
    if (Yd(l))
      if (c === null) o.removeAttribute(l);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
            o.removeAttribute(l);
            return;
          case "boolean":
            var h = l.toLowerCase().slice(0, 5);
            if (h !== "data-" && h !== "aria-") {
              o.removeAttribute(l);
              return;
            }
        }
        o.setAttribute(l, "" + c);
      }
  }
  function jc(o, l, c) {
    if (c === null) o.removeAttribute(l);
    else {
      switch (typeof c) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(l);
          return;
      }
      o.setAttribute(l, "" + c);
    }
  }
  function ha(o, l, c, h) {
    if (h === null) o.removeAttribute(c);
    else {
      switch (typeof h) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(c);
          return;
      }
      o.setAttributeNS(l, c, "" + h);
    }
  }
  function fr(o) {
    switch (typeof o) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return o;
      case "object":
        return o;
      default:
        return "";
    }
  }
  function _g(o) {
    var l = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function qk(o) {
    var l = _g(o) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(
      o.constructor.prototype,
      l
    ), h = "" + o[l];
    if (!o.hasOwnProperty(l) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var v = c.get, w = c.set;
      return Object.defineProperty(o, l, {
        configurable: !0,
        get: function() {
          return v.call(this);
        },
        set: function(N) {
          h = "" + N, w.call(this, N);
        }
      }), Object.defineProperty(o, l, {
        enumerable: c.enumerable
      }), {
        getValue: function() {
          return h;
        },
        setValue: function(N) {
          h = "" + N;
        },
        stopTracking: function() {
          o._valueTracker = null, delete o[l];
        }
      };
    }
  }
  function Ug(o) {
    o._valueTracker || (o._valueTracker = qk(o));
  }
  function d1(o) {
    if (!o) return !1;
    var l = o._valueTracker;
    if (!l) return !0;
    var c = l.getValue(), h = "";
    return o && (h = _g(o) ? o.checked ? "true" : "false" : o.value), o = h, o !== c ? (l.setValue(o), !0) : !1;
  }
  function $c(o) {
    if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
    try {
      return o.activeElement || o.body;
    } catch {
      return o.body;
    }
  }
  var h1 = /[\n"\\]/g;
  function ja(o) {
    return o.replace(
      h1,
      function(l) {
        return "\\" + l.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function zg(o, l, c, h, v, w, N, _) {
    o.name = "", N != null && typeof N != "function" && typeof N != "symbol" && typeof N != "boolean" ? o.type = N : o.removeAttribute("type"), l != null ? N === "number" ? (l === 0 && o.value === "" || o.value != l) && (o.value = "" + fr(l)) : o.value !== "" + fr(l) && (o.value = "" + fr(l)) : N !== "submit" && N !== "reset" || o.removeAttribute("value"), l != null ? g1(o, N, fr(l)) : c != null ? g1(o, N, fr(c)) : h != null && o.removeAttribute("value"), v == null && w != null && (o.defaultChecked = !!w), v != null && (o.checked = v && typeof v != "function" && typeof v != "symbol"), _ != null && typeof _ != "function" && typeof _ != "symbol" && typeof _ != "boolean" ? o.name = "" + fr(_) : o.removeAttribute("name");
  }
  function p1(o, l, c, h, v, w, N, _) {
    if (w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" && (o.type = w), l != null || c != null) {
      if (!(w !== "submit" && w !== "reset" || l != null))
        return;
      c = c != null ? "" + fr(c) : "", l = l != null ? "" + fr(l) : c, _ || l === o.value || (o.value = l), o.defaultValue = l;
    }
    h = h ?? v, h = typeof h != "function" && typeof h != "symbol" && !!h, o.checked = _ ? o.checked : !!h, o.defaultChecked = !!h, N != null && typeof N != "function" && typeof N != "symbol" && typeof N != "boolean" && (o.name = N);
  }
  function g1(o, l, c) {
    l === "number" && $c(o.ownerDocument) === o || o.defaultValue === "" + c || (o.defaultValue = "" + c);
  }
  function du(o, l, c, h) {
    if (o = o.options, l) {
      l = {};
      for (var v = 0; v < c.length; v++)
        l["$" + c[v]] = !0;
      for (c = 0; c < o.length; c++)
        v = l.hasOwnProperty("$" + o[c].value), o[c].selected !== v && (o[c].selected = v), v && h && (o[c].defaultSelected = !0);
    } else {
      for (c = "" + fr(c), l = null, v = 0; v < o.length; v++) {
        if (o[v].value === c) {
          o[v].selected = !0, h && (o[v].defaultSelected = !0);
          return;
        }
        l !== null || o[v].disabled || (l = o[v]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function Hg(o, l, c) {
    if (l != null && (l = "" + fr(l), l !== o.value && (o.value = l), c == null)) {
      o.defaultValue !== l && (o.defaultValue = l);
      return;
    }
    o.defaultValue = c != null ? "" + fr(c) : "";
  }
  function qd(o, l, c, h) {
    if (l == null) {
      if (h != null) {
        if (c != null) throw Error(i(92));
        if (Be(h)) {
          if (1 < h.length) throw Error(i(93));
          h = h[0];
        }
        c = h;
      }
      c == null && (c = ""), l = c;
    }
    c = fr(l), o.defaultValue = c, h = o.textContent, h === c && h !== "" && h !== null && (o.value = h);
  }
  function Vo(o, l) {
    if (l) {
      var c = o.firstChild;
      if (c && c === o.lastChild && c.nodeType === 3) {
        c.nodeValue = l;
        return;
      }
    }
    o.textContent = l;
  }
  var Kk = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function m1(o, l, c) {
    var h = l.indexOf("--") === 0;
    c == null || typeof c == "boolean" || c === "" ? h ? o.setProperty(l, "") : l === "float" ? o.cssFloat = "" : o[l] = "" : h ? o.setProperty(l, c) : typeof c != "number" || c === 0 || Kk.has(l) ? l === "float" ? o.cssFloat = c : o[l] = ("" + c).trim() : o[l] = c + "px";
  }
  function y1(o, l, c) {
    if (l != null && typeof l != "object")
      throw Error(i(62));
    if (o = o.style, c != null) {
      for (var h in c)
        !c.hasOwnProperty(h) || l != null && l.hasOwnProperty(h) || (h.indexOf("--") === 0 ? o.setProperty(h, "") : h === "float" ? o.cssFloat = "" : o[h] = "");
      for (var v in l)
        h = l[v], l.hasOwnProperty(v) && c[v] !== h && m1(o, v, h);
    } else
      for (var w in l)
        l.hasOwnProperty(w) && m1(o, w, l[w]);
  }
  function hu(o) {
    if (o.indexOf("-") === -1) return !1;
    switch (o) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var xw = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Jk = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Vg(o) {
    return Jk.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o;
  }
  var b1 = null;
  function v1(o) {
    return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
  }
  var Wo = null, qs = null;
  function w1(o) {
    var l = uu(o);
    if (l && (o = l.stateNode)) {
      var c = o[ta] || null;
      e: switch (o = l.stateNode, l.type) {
        case "input":
          if (zg(
            o,
            c.value,
            c.defaultValue,
            c.defaultValue,
            c.checked,
            c.defaultChecked,
            c.type,
            c.name
          ), l = c.name, c.type === "radio" && l != null) {
            for (c = o; c.parentNode; ) c = c.parentNode;
            for (c = c.querySelectorAll(
              'input[name="' + ja(
                "" + l
              ) + '"][type="radio"]'
            ), l = 0; l < c.length; l++) {
              var h = c[l];
              if (h !== o && h.form === o.form) {
                var v = h[ta] || null;
                if (!v) throw Error(i(90));
                zg(
                  h,
                  v.value,
                  v.defaultValue,
                  v.defaultValue,
                  v.checked,
                  v.defaultChecked,
                  v.type,
                  v.name
                );
              }
            }
            for (l = 0; l < c.length; l++)
              h = c[l], h.form === o.form && d1(h);
          }
          break e;
        case "textarea":
          Hg(o, c.value, c.defaultValue);
          break e;
        case "select":
          l = c.value, l != null && du(o, !!c.multiple, l, !1);
      }
    }
  }
  var Wg = !1;
  function Qc(o, l, c) {
    if (Wg) return o(l, c);
    Wg = !0;
    try {
      var h = o(l);
      return h;
    } finally {
      if (Wg = !1, (Wo !== null || qs !== null) && (Yu(), Wo && (l = Wo, o = qs, qs = Wo = null, w1(l), o)))
        for (l = 0; l < o.length; l++) w1(o[l]);
    }
  }
  function Zc(o, l) {
    var c = o.stateNode;
    if (c === null) return null;
    var h = c[ta] || null;
    if (h === null) return null;
    c = h[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (h = !h.disabled) || (o = o.type, h = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !h;
        break e;
      default:
        o = !1;
    }
    if (o) return null;
    if (c && typeof c != "function")
      throw Error(
        i(231, l, typeof c)
      );
    return c;
  }
  var Yc = !1;
  if (wn)
    try {
      var Ks = {};
      Object.defineProperty(Ks, "passive", {
        get: function() {
          Yc = !0;
        }
      }), window.addEventListener("test", Ks, Ks), window.removeEventListener("test", Ks, Ks);
    } catch {
      Yc = !1;
    }
  var $i = null, Sr = null, Gg = null;
  function jg() {
    if (Gg) return Gg;
    var o, l = Sr, c = l.length, h, v = "value" in $i ? $i.value : $i.textContent, w = v.length;
    for (o = 0; o < c && l[o] === v[o]; o++) ;
    var N = c - o;
    for (h = 1; h <= N && l[c - h] === v[w - h]; h++) ;
    return Gg = v.slice(o, 1 < h ? 1 - h : void 0);
  }
  function Kd(o) {
    var l = o.keyCode;
    return "charCode" in o ? (o = o.charCode, o === 0 && l === 13 && (o = 13)) : o = l, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
  }
  function Jd() {
    return !0;
  }
  function Cw() {
    return !1;
  }
  function na(o) {
    function l(c, h, v, w, N) {
      this._reactName = c, this._targetInst = v, this.type = h, this.nativeEvent = w, this.target = N, this.currentTarget = null;
      for (var _ in o)
        o.hasOwnProperty(_) && (c = o[_], this[_] = c ? c(w) : w[_]);
      return this.isDefaultPrevented = (w.defaultPrevented != null ? w.defaultPrevented : w.returnValue === !1) ? Jd : Cw, this.isPropagationStopped = Cw, this;
    }
    return ne(l.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var c = this.nativeEvent;
        c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = Jd);
      },
      stopPropagation: function() {
        var c = this.nativeEvent;
        c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = Jd);
      },
      persist: function() {
      },
      isPersistent: Jd
    }), l;
  }
  var Js = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
      return o.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, $g = na(Js), qc = ne({}, Js, { view: 0, detail: 0 }), Xk = na(qc), Kc, Qg, Jc, Xd = ne({}, qc, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: pa,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
      return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
    },
    movementX: function(o) {
      return "movementX" in o ? o.movementX : (o !== Jc && (Jc && o.type === "mousemove" ? (Kc = o.screenX - Jc.screenX, Qg = o.screenY - Jc.screenY) : Qg = Kc = 0, Jc = o), Kc);
    },
    movementY: function(o) {
      return "movementY" in o ? o.movementY : Qg;
    }
  }), Tw = na(Xd), e6 = ne({}, Xd, { dataTransfer: 0 }), t6 = na(e6), n6 = ne({}, qc, { relatedTarget: 0 }), k1 = na(n6), eh = ne({}, Js, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Iw = na(eh), Nw = ne({}, Js, {
    clipboardData: function(o) {
      return "clipboardData" in o ? o.clipboardData : window.clipboardData;
    }
  }), Pw = na(Nw), Ow = ne({}, Js, { data: 0 }), Zg = na(Ow), r6 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Rw = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, pu = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function gu(o) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(o) : (o = pu[o]) ? !!l[o] : !1;
  }
  function pa() {
    return gu;
  }
  var Yg = ne({}, qc, {
    key: function(o) {
      if (o.key) {
        var l = r6[o.key] || o.key;
        if (l !== "Unidentified") return l;
      }
      return o.type === "keypress" ? (o = Kd(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? Rw[o.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: pa,
    charCode: function(o) {
      return o.type === "keypress" ? Kd(o) : 0;
    },
    keyCode: function(o) {
      return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    },
    which: function(o) {
      return o.type === "keypress" ? Kd(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    }
  }), qg = na(Yg), E1 = ne({}, Xd, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), dr = na(E1), Lw = ne({}, qc, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: pa
  }), Kg = na(Lw), mu = ne({}, Js, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), S1 = na(mu), Dw = ne({}, Xd, {
    deltaX: function(o) {
      return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
    },
    deltaY: function(o) {
      return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Bw = na(Dw), A1 = ne({}, Js, {
    newState: 0,
    oldState: 0
  }), Qi = na(A1), Jg = [9, 13, 27, 32], yu = wn && "CompositionEvent" in window, bu = null;
  wn && "documentMode" in document && (bu = document.documentMode);
  var x1 = wn && "TextEvent" in window && !bu, C1 = wn && (!yu || bu && 8 < bu && 11 >= bu), go = " ", mo = !1;
  function th(o, l) {
    switch (o) {
      case "keyup":
        return Jg.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function ra(o) {
    return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
  }
  var $a = !1;
  function Mw(o, l) {
    switch (o) {
      case "compositionend":
        return ra(l);
      case "keypress":
        return l.which !== 32 ? null : (mo = !0, go);
      case "textInput":
        return o = l.data, o === go && mo ? null : o;
      default:
        return null;
    }
  }
  function T1(o, l) {
    if ($a)
      return o === "compositionend" || !yu && th(o, l) ? (o = jg(), Gg = Sr = $i = null, $a = !1, o) : null;
    switch (o) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return C1 && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var I1 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Xs(o) {
    var l = o && o.nodeName && o.nodeName.toLowerCase();
    return l === "input" ? !!I1[o.type] : l === "textarea";
  }
  function el(o, l, c, h) {
    Wo ? qs ? qs.push(h) : qs = [h] : Wo = h, l = Nr(l, "onChange"), 0 < l.length && (c = new $g(
      "onChange",
      "change",
      null,
      c,
      h
    ), o.push({ event: c, listeners: l }));
  }
  var vu = null, yo = null;
  function Fw(o) {
    a0(o, 0);
  }
  function nh(o) {
    var l = Wc(o);
    if (d1(l)) return o;
  }
  function Xc(o, l) {
    if (o === "change") return l;
  }
  var ef = !1;
  if (wn) {
    var wu;
    if (wn) {
      var Xg = "oninput" in document;
      if (!Xg) {
        var N1 = document.createElement("div");
        N1.setAttribute("oninput", "return;"), Xg = typeof N1.oninput == "function";
      }
      wu = Xg;
    } else wu = !1;
    ef = wu && (!document.documentMode || 9 < document.documentMode);
  }
  function P1() {
    vu && (vu.detachEvent("onpropertychange", rh), yo = vu = null);
  }
  function rh(o) {
    if (o.propertyName === "value" && nh(yo)) {
      var l = [];
      el(
        l,
        yo,
        o,
        v1(o)
      ), Qc(Fw, l);
    }
  }
  function _w(o, l, c) {
    o === "focusin" ? (P1(), vu = l, yo = c, vu.attachEvent("onpropertychange", rh)) : o === "focusout" && P1();
  }
  function Uw(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
      return nh(yo);
  }
  function zw(o, l) {
    if (o === "click") return nh(l);
  }
  function hr(o, l) {
    if (o === "input" || o === "change")
      return nh(l);
  }
  function em(o, l) {
    return o === l && (o !== 0 || 1 / o === 1 / l) || o !== o && l !== l;
  }
  var Ar = typeof Object.is == "function" ? Object.is : em;
  function Zi(o, l) {
    if (Ar(o, l)) return !0;
    if (typeof o != "object" || o === null || typeof l != "object" || l === null)
      return !1;
    var c = Object.keys(o), h = Object.keys(l);
    if (c.length !== h.length) return !1;
    for (h = 0; h < c.length; h++) {
      var v = c[h];
      if (!Rg.call(l, v) || !Ar(o[v], l[v]))
        return !1;
    }
    return !0;
  }
  function ah(o) {
    for (; o && o.firstChild; ) o = o.firstChild;
    return o;
  }
  function oh(o, l) {
    var c = ah(o);
    o = 0;
    for (var h; c; ) {
      if (c.nodeType === 3) {
        if (h = o + c.textContent.length, o <= l && h >= l)
          return { node: c, offset: l - o };
        o = h;
      }
      e: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break e;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = ah(c);
    }
  }
  function ih(o, l) {
    return o && l ? o === l ? !0 : o && o.nodeType === 3 ? !1 : l && l.nodeType === 3 ? ih(o, l.parentNode) : "contains" in o ? o.contains(l) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function O1(o) {
    o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
    for (var l = $c(o.document); l instanceof o.HTMLIFrameElement; ) {
      try {
        var c = typeof l.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) o = l.contentWindow;
      else break;
      l = $c(o.document);
    }
    return l;
  }
  function tm(o) {
    var l = o && o.nodeName && o.nodeName.toLowerCase();
    return l && (l === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || l === "textarea" || o.contentEditable === "true");
  }
  function R1(o, l) {
    var c = O1(l);
    l = o.focusedElem;
    var h = o.selectionRange;
    if (c !== l && l && l.ownerDocument && ih(l.ownerDocument.documentElement, l)) {
      if (h !== null && tm(l)) {
        if (o = h.start, c = h.end, c === void 0 && (c = o), "selectionStart" in l)
          l.selectionStart = o, l.selectionEnd = Math.min(
            c,
            l.value.length
          );
        else if (c = (o = l.ownerDocument || document) && o.defaultView || window, c.getSelection) {
          c = c.getSelection();
          var v = l.textContent.length, w = Math.min(h.start, v);
          h = h.end === void 0 ? w : Math.min(h.end, v), !c.extend && w > h && (v = h, h = w, w = v), v = oh(l, w);
          var N = oh(
            l,
            h
          );
          v && N && (c.rangeCount !== 1 || c.anchorNode !== v.node || c.anchorOffset !== v.offset || c.focusNode !== N.node || c.focusOffset !== N.offset) && (o = o.createRange(), o.setStart(v.node, v.offset), c.removeAllRanges(), w > h ? (c.addRange(o), c.extend(N.node, N.offset)) : (o.setEnd(
            N.node,
            N.offset
          ), c.addRange(o)));
        }
      }
      for (o = [], c = l; c = c.parentNode; )
        c.nodeType === 1 && o.push({
          element: c,
          left: c.scrollLeft,
          top: c.scrollTop
        });
      for (typeof l.focus == "function" && l.focus(), l = 0; l < o.length; l++)
        c = o[l], c.element.scrollLeft = c.left, c.element.scrollTop = c.top;
    }
  }
  var L1 = wn && "documentMode" in document && 11 >= document.documentMode, ga = null, nm = null, Qa = null, bo = !1;
  function sh(o, l, c) {
    var h = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    bo || ga == null || ga !== $c(h) || (h = ga, "selectionStart" in h && tm(h) ? h = { start: h.selectionStart, end: h.selectionEnd } : (h = (h.ownerDocument && h.ownerDocument.defaultView || window).getSelection(), h = {
      anchorNode: h.anchorNode,
      anchorOffset: h.anchorOffset,
      focusNode: h.focusNode,
      focusOffset: h.focusOffset
    }), Qa && Zi(Qa, h) || (Qa = h, h = Nr(nm, "onSelect"), 0 < h.length && (l = new $g(
      "onSelect",
      "select",
      null,
      l,
      c
    ), o.push({ event: l, listeners: h }), l.target = ga)));
  }
  function Yi(o, l) {
    var c = {};
    return c[o.toLowerCase()] = l.toLowerCase(), c["Webkit" + o] = "webkit" + l, c["Moz" + o] = "moz" + l, c;
  }
  var Za = {
    animationend: Yi("Animation", "AnimationEnd"),
    animationiteration: Yi("Animation", "AnimationIteration"),
    animationstart: Yi("Animation", "AnimationStart"),
    transitionrun: Yi("Transition", "TransitionRun"),
    transitionstart: Yi("Transition", "TransitionStart"),
    transitioncancel: Yi("Transition", "TransitionCancel"),
    transitionend: Yi("Transition", "TransitionEnd")
  }, ku = {}, Hw = {};
  wn && (Hw = document.createElement("div").style, "AnimationEvent" in window || (delete Za.animationend.animation, delete Za.animationiteration.animation, delete Za.animationstart.animation), "TransitionEvent" in window || delete Za.transitionend.transition);
  function tl(o) {
    if (ku[o]) return ku[o];
    if (!Za[o]) return o;
    var l = Za[o], c;
    for (c in l)
      if (l.hasOwnProperty(c) && c in Hw)
        return ku[o] = l[c];
    return o;
  }
  var Vw = tl("animationend"), rm = tl("animationiteration"), lh = tl("animationstart"), Ww = tl("transitionrun"), ht = tl("transitionstart"), Le = tl("transitioncancel"), Eu = tl("transitionend"), uh = /* @__PURE__ */ new Map(), pn = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
    " "
  );
  function ma(o, l) {
    uh.set(o, l), Zs(l, [o]);
  }
  var aa = [], Su = 0, ch = 0;
  function am() {
    for (var o = Su, l = ch = Su = 0; l < o; ) {
      var c = aa[l];
      aa[l++] = null;
      var h = aa[l];
      aa[l++] = null;
      var v = aa[l];
      aa[l++] = null;
      var w = aa[l];
      if (aa[l++] = null, h !== null && v !== null) {
        var N = h.pending;
        N === null ? v.next = v : (v.next = N.next, N.next = v), h.pending = v;
      }
      w !== 0 && zr(c, v, w);
    }
  }
  function tf(o, l, c, h) {
    aa[Su++] = o, aa[Su++] = l, aa[Su++] = c, aa[Su++] = h, ch |= h, o.lanes |= h, o = o.alternate, o !== null && (o.lanes |= h);
  }
  function fh(o, l, c, h) {
    return tf(o, l, c, h), Nt(o);
  }
  function Go(o, l) {
    return tf(o, null, null, l), Nt(o);
  }
  function zr(o, l, c) {
    o.lanes |= c;
    var h = o.alternate;
    h !== null && (h.lanes |= c);
    for (var v = !1, w = o.return; w !== null; )
      w.childLanes |= c, h = w.alternate, h !== null && (h.childLanes |= c), w.tag === 22 && (o = w.stateNode, o === null || o._visibility & 1 || (v = !0)), o = w, w = w.return;
    v && l !== null && o.tag === 3 && (w = o.stateNode, v = 31 - ea(c), w = w.hiddenUpdates, o = w[v], o === null ? w[v] = [l] : o.push(l), l.lane = c | 536870912);
  }
  function Nt(o) {
    if (50 < Lf)
      throw Lf = 0, qm = null, Error(i(185));
    for (var l = o.return; l !== null; )
      o = l, l = o.return;
    return o.tag === 3 ? o.stateNode : null;
  }
  var jo = {}, qi = /* @__PURE__ */ new WeakMap();
  function Xn(o, l) {
    if (typeof o == "object" && o !== null) {
      var c = qi.get(o);
      return c !== void 0 ? c : (l = {
        value: o,
        source: l,
        stack: H(l)
      }, qi.set(o, l), l);
    }
    return {
      value: o,
      source: l,
      stack: H(l)
    };
  }
  var xr = [], nl = 0, Ki = null, nf = 0, Cr = [], oa = 0, $o = null, Qo = 1, Zo = "";
  function rl(o, l) {
    xr[nl++] = nf, xr[nl++] = Ki, Ki = o, nf = l;
  }
  function D1(o, l, c) {
    Cr[oa++] = Qo, Cr[oa++] = Zo, Cr[oa++] = $o, $o = o;
    var h = Qo;
    o = Zo;
    var v = 32 - ea(h) - 1;
    h &= ~(1 << v), c += 1;
    var w = 32 - ea(l) + v;
    if (30 < w) {
      var N = v - v % 5;
      w = (h & (1 << N) - 1).toString(32), h >>= N, v -= N, Qo = 1 << 32 - ea(l) + v | c << v | h, Zo = w + o;
    } else
      Qo = 1 << w | c << v | h, Zo = o;
  }
  function om(o) {
    o.return !== null && (rl(o, 1), D1(o, 1, 0));
  }
  function dh(o) {
    for (; o === Ki; )
      Ki = xr[--nl], xr[nl] = null, nf = xr[--nl], xr[nl] = null;
    for (; o === $o; )
      $o = Cr[--oa], Cr[oa] = null, Zo = Cr[--oa], Cr[oa] = null, Qo = Cr[--oa], Cr[oa] = null;
  }
  var pr = null, Fn = null, Tt = !1, Ya = null, vo = !1, B1 = Error(i(519));
  function al(o) {
    var l = Error(i(418, ""));
    throw af(Xn(l, o)), B1;
  }
  function M1(o) {
    var l = o.stateNode, c = o.type, h = o.memoizedProps;
    switch (l[cr] = o, l[ta] = h, c) {
      case "dialog":
        At("cancel", l), At("close", l);
        break;
      case "iframe":
      case "object":
      case "embed":
        At("load", l);
        break;
      case "video":
      case "audio":
        for (c = 0; c < pi.length; c++)
          At(pi[c], l);
        break;
      case "source":
        At("error", l);
        break;
      case "img":
      case "image":
      case "link":
        At("error", l), At("load", l);
        break;
      case "details":
        At("toggle", l);
        break;
      case "input":
        At("invalid", l), p1(
          l,
          h.value,
          h.defaultValue,
          h.checked,
          h.defaultChecked,
          h.type,
          h.name,
          !0
        ), Ug(l);
        break;
      case "select":
        At("invalid", l);
        break;
      case "textarea":
        At("invalid", l), qd(l, h.value, h.defaultValue, h.children), Ug(l);
    }
    c = h.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || l.textContent === "" + c || h.suppressHydrationWarning === !0 || st(l.textContent, c) ? (h.popover != null && (At("beforetoggle", l), At("toggle", l)), h.onScroll != null && At("scroll", l), h.onScrollEnd != null && At("scrollend", l), h.onClick != null && (l.onclick = xl), l = !0) : l = !1, l || al(o);
  }
  function F1(o) {
    for (pr = o.return; pr; )
      switch (pr.tag) {
        case 3:
        case 27:
          vo = !0;
          return;
        case 5:
        case 13:
          vo = !1;
          return;
        default:
          pr = pr.return;
      }
  }
  function Au(o) {
    if (o !== pr) return !1;
    if (!Tt) return F1(o), Tt = !0, !1;
    var l = !1, c;
    if ((c = o.tag !== 3 && o.tag !== 27) && ((c = o.tag === 5) && (c = o.type, c = !(c !== "form" && c !== "button") || qh(o.type, o.memoizedProps)), c = !c), c && (l = !0), l && Fn && al(o), F1(o), o.tag === 13) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(i(317));
      e: {
        for (o = o.nextSibling, l = 0; o; ) {
          if (o.nodeType === 8)
            if (c = o.data, c === "/$") {
              if (l === 0) {
                Fn = or(o.nextSibling);
                break e;
              }
              l--;
            } else
              c !== "$" && c !== "$!" && c !== "$?" || l++;
          o = o.nextSibling;
        }
        Fn = null;
      }
    } else
      Fn = pr ? or(o.stateNode.nextSibling) : null;
    return !0;
  }
  function rf() {
    Fn = pr = null, Tt = !1;
  }
  function af(o) {
    Ya === null ? Ya = [o] : Ya.push(o);
  }
  var Yo = Error(i(460)), hh = Error(i(474)), im = { then: function() {
  } };
  function Gw(o) {
    return o = o.status, o === "fulfilled" || o === "rejected";
  }
  function xu() {
  }
  function Cu(o, l, c) {
    switch (c = o[c], c === void 0 ? o.push(l) : c !== l && (l.then(xu, xu), l = c), l.status) {
      case "fulfilled":
        return l.value;
      case "rejected":
        throw o = l.reason, o === Yo ? Error(i(483)) : o;
      default:
        if (typeof l.status == "string") l.then(xu, xu);
        else {
          if (o = zt, o !== null && 100 < o.shellSuspendCounter)
            throw Error(i(482));
          o = l, o.status = "pending", o.then(
            function(h) {
              if (l.status === "pending") {
                var v = l;
                v.status = "fulfilled", v.value = h;
              }
            },
            function(h) {
              if (l.status === "pending") {
                var v = l;
                v.status = "rejected", v.reason = h;
              }
            }
          );
        }
        switch (l.status) {
          case "fulfilled":
            return l.value;
          case "rejected":
            throw o = l.reason, o === Yo ? Error(i(483)) : o;
        }
        throw Tu = l, Yo;
    }
  }
  var Tu = null;
  function ol() {
    if (Tu === null) throw Error(i(459));
    var o = Tu;
    return Tu = null, o;
  }
  var _n = null, il = 0;
  function of(o) {
    var l = il;
    return il += 1, _n === null && (_n = []), Cu(_n, o, l);
  }
  function sf(o, l) {
    l = l.props.ref, o.ref = l !== void 0 ? l : null;
  }
  function lf(o, l) {
    throw l.$$typeof === d ? Error(i(525)) : (o = Object.prototype.toString.call(l), Error(
      i(
        31,
        o === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : o
      )
    ));
  }
  function ph(o) {
    var l = o._init;
    return l(o._payload);
  }
  function sm(o) {
    function l(ue, re) {
      if (o) {
        var fe = ue.deletions;
        fe === null ? (ue.deletions = [re], ue.flags |= 16) : fe.push(re);
      }
    }
    function c(ue, re) {
      if (!o) return null;
      for (; re !== null; )
        l(ue, re), re = re.sibling;
      return null;
    }
    function h(ue) {
      for (var re = /* @__PURE__ */ new Map(); ue !== null; )
        ue.key !== null ? re.set(ue.key, ue) : re.set(ue.index, ue), ue = ue.sibling;
      return re;
    }
    function v(ue, re) {
      return ue = To(ue, re), ue.index = 0, ue.sibling = null, ue;
    }
    function w(ue, re, fe) {
      return ue.index = fe, o ? (fe = ue.alternate, fe !== null ? (fe = fe.index, fe < re ? (ue.flags |= 33554434, re) : fe) : (ue.flags |= 33554434, re)) : (ue.flags |= 1048576, re);
    }
    function N(ue) {
      return o && ue.alternate === null && (ue.flags |= 33554434), ue;
    }
    function _(ue, re, fe, Ae) {
      return re === null || re.tag !== 6 ? (re = jm(fe, ue.mode, Ae), re.return = ue, re) : (re = v(re, fe), re.return = ue, re);
    }
    function $(ue, re, fe, Ae) {
      var ze = fe.type;
      return ze === y ? ke(
        ue,
        re,
        fe.props.children,
        Ae,
        fe.key
      ) : re !== null && (re.elementType === ze || typeof ze == "object" && ze !== null && ze.$$typeof === U && ph(ze) === re.type) ? (re = v(re, fe.props), sf(re, fe), re.return = ue, re) : (re = Nf(
        fe.type,
        fe.key,
        fe.props,
        null,
        ue.mode,
        Ae
      ), sf(re, fe), re.return = ue, re);
    }
    function oe(ue, re, fe, Ae) {
      return re === null || re.tag !== 4 || re.stateNode.containerInfo !== fe.containerInfo || re.stateNode.implementation !== fe.implementation ? (re = Uh(fe, ue.mode, Ae), re.return = ue, re) : (re = v(re, fe.children || []), re.return = ue, re);
    }
    function ke(ue, re, fe, Ae, ze) {
      return re === null || re.tag !== 7 ? (re = cn(
        fe,
        ue.mode,
        Ae,
        ze
      ), re.return = ue, re) : (re = v(re, fe), re.return = ue, re);
    }
    function Ne(ue, re, fe) {
      if (typeof re == "string" && re !== "" || typeof re == "number" || typeof re == "bigint")
        return re = jm(
          "" + re,
          ue.mode,
          fe
        ), re.return = ue, re;
      if (typeof re == "object" && re !== null) {
        switch (re.$$typeof) {
          case g:
            return fe = Nf(
              re.type,
              re.key,
              re.props,
              null,
              ue.mode,
              fe
            ), sf(fe, re), fe.return = ue, fe;
          case b:
            return re = Uh(
              re,
              ue.mode,
              fe
            ), re.return = ue, re;
          case U:
            var Ae = re._init;
            return re = Ae(re._payload), Ne(ue, re, fe);
        }
        if (Be(re) || Y(re))
          return re = cn(
            re,
            ue.mode,
            fe,
            null
          ), re.return = ue, re;
        if (typeof re.then == "function")
          return Ne(ue, of(re), fe);
        if (re.$$typeof === M)
          return Ne(
            ue,
            Dm(ue, re),
            fe
          );
        lf(ue, re);
      }
      return null;
    }
    function ge(ue, re, fe, Ae) {
      var ze = re !== null ? re.key : null;
      if (typeof fe == "string" && fe !== "" || typeof fe == "number" || typeof fe == "bigint")
        return ze !== null ? null : _(ue, re, "" + fe, Ae);
      if (typeof fe == "object" && fe !== null) {
        switch (fe.$$typeof) {
          case g:
            return fe.key === ze ? $(ue, re, fe, Ae) : null;
          case b:
            return fe.key === ze ? oe(ue, re, fe, Ae) : null;
          case U:
            return ze = fe._init, fe = ze(fe._payload), ge(ue, re, fe, Ae);
        }
        if (Be(fe) || Y(fe))
          return ze !== null ? null : ke(ue, re, fe, Ae, null);
        if (typeof fe.then == "function")
          return ge(
            ue,
            re,
            of(fe),
            Ae
          );
        if (fe.$$typeof === M)
          return ge(
            ue,
            re,
            Dm(ue, fe),
            Ae
          );
        lf(ue, fe);
      }
      return null;
    }
    function ve(ue, re, fe, Ae, ze) {
      if (typeof Ae == "string" && Ae !== "" || typeof Ae == "number" || typeof Ae == "bigint")
        return ue = ue.get(fe) || null, _(re, ue, "" + Ae, ze);
      if (typeof Ae == "object" && Ae !== null) {
        switch (Ae.$$typeof) {
          case g:
            return ue = ue.get(
              Ae.key === null ? fe : Ae.key
            ) || null, $(re, ue, Ae, ze);
          case b:
            return ue = ue.get(
              Ae.key === null ? fe : Ae.key
            ) || null, oe(re, ue, Ae, ze);
          case U:
            var ut = Ae._init;
            return Ae = ut(Ae._payload), ve(
              ue,
              re,
              fe,
              Ae,
              ze
            );
        }
        if (Be(Ae) || Y(Ae))
          return ue = ue.get(fe) || null, ke(re, ue, Ae, ze, null);
        if (typeof Ae.then == "function")
          return ve(
            ue,
            re,
            fe,
            of(Ae),
            ze
          );
        if (Ae.$$typeof === M)
          return ve(
            ue,
            re,
            fe,
            Dm(re, Ae),
            ze
          );
        lf(re, Ae);
      }
      return null;
    }
    function Ue(ue, re, fe, Ae) {
      for (var ze = null, ut = null, $e = re, qe = re = 0, Wn = null; $e !== null && qe < fe.length; qe++) {
        $e.index > qe ? (Wn = $e, $e = null) : Wn = $e.sibling;
        var Pt = ge(
          ue,
          $e,
          fe[qe],
          Ae
        );
        if (Pt === null) {
          $e === null && ($e = Wn);
          break;
        }
        o && $e && Pt.alternate === null && l(ue, $e), re = w(Pt, re, qe), ut === null ? ze = Pt : ut.sibling = Pt, ut = Pt, $e = Wn;
      }
      if (qe === fe.length)
        return c(ue, $e), Tt && rl(ue, qe), ze;
      if ($e === null) {
        for (; qe < fe.length; qe++)
          $e = Ne(ue, fe[qe], Ae), $e !== null && (re = w(
            $e,
            re,
            qe
          ), ut === null ? ze = $e : ut.sibling = $e, ut = $e);
        return Tt && rl(ue, qe), ze;
      }
      for ($e = h($e); qe < fe.length; qe++)
        Wn = ve(
          $e,
          ue,
          qe,
          fe[qe],
          Ae
        ), Wn !== null && (o && Wn.alternate !== null && $e.delete(
          Wn.key === null ? qe : Wn.key
        ), re = w(
          Wn,
          re,
          qe
        ), ut === null ? ze = Wn : ut.sibling = Wn, ut = Wn);
      return o && $e.forEach(function(Bl) {
        return l(ue, Bl);
      }), Tt && rl(ue, qe), ze;
    }
    function et(ue, re, fe, Ae) {
      if (fe == null) throw Error(i(151));
      for (var ze = null, ut = null, $e = re, qe = re = 0, Wn = null, Pt = fe.next(); $e !== null && !Pt.done; qe++, Pt = fe.next()) {
        $e.index > qe ? (Wn = $e, $e = null) : Wn = $e.sibling;
        var Bl = ge(ue, $e, Pt.value, Ae);
        if (Bl === null) {
          $e === null && ($e = Wn);
          break;
        }
        o && $e && Bl.alternate === null && l(ue, $e), re = w(Bl, re, qe), ut === null ? ze = Bl : ut.sibling = Bl, ut = Bl, $e = Wn;
      }
      if (Pt.done)
        return c(ue, $e), Tt && rl(ue, qe), ze;
      if ($e === null) {
        for (; !Pt.done; qe++, Pt = fe.next())
          Pt = Ne(ue, Pt.value, Ae), Pt !== null && (re = w(Pt, re, qe), ut === null ? ze = Pt : ut.sibling = Pt, ut = Pt);
        return Tt && rl(ue, qe), ze;
      }
      for ($e = h($e); !Pt.done; qe++, Pt = fe.next())
        Pt = ve($e, ue, qe, Pt.value, Ae), Pt !== null && (o && Pt.alternate !== null && $e.delete(Pt.key === null ? qe : Pt.key), re = w(Pt, re, qe), ut === null ? ze = Pt : ut.sibling = Pt, ut = Pt);
      return o && $e.forEach(function(k6) {
        return l(ue, k6);
      }), Tt && rl(ue, qe), ze;
    }
    function Jt(ue, re, fe, Ae) {
      if (typeof fe == "object" && fe !== null && fe.type === y && fe.key === null && (fe = fe.props.children), typeof fe == "object" && fe !== null) {
        switch (fe.$$typeof) {
          case g:
            e: {
              for (var ze = fe.key; re !== null; ) {
                if (re.key === ze) {
                  if (ze = fe.type, ze === y) {
                    if (re.tag === 7) {
                      c(
                        ue,
                        re.sibling
                      ), Ae = v(
                        re,
                        fe.props.children
                      ), Ae.return = ue, ue = Ae;
                      break e;
                    }
                  } else if (re.elementType === ze || typeof ze == "object" && ze !== null && ze.$$typeof === U && ph(ze) === re.type) {
                    c(
                      ue,
                      re.sibling
                    ), Ae = v(re, fe.props), sf(Ae, fe), Ae.return = ue, ue = Ae;
                    break e;
                  }
                  c(ue, re);
                  break;
                } else l(ue, re);
                re = re.sibling;
              }
              fe.type === y ? (Ae = cn(
                fe.props.children,
                ue.mode,
                Ae,
                fe.key
              ), Ae.return = ue, ue = Ae) : (Ae = Nf(
                fe.type,
                fe.key,
                fe.props,
                null,
                ue.mode,
                Ae
              ), sf(Ae, fe), Ae.return = ue, ue = Ae);
            }
            return N(ue);
          case b:
            e: {
              for (ze = fe.key; re !== null; ) {
                if (re.key === ze)
                  if (re.tag === 4 && re.stateNode.containerInfo === fe.containerInfo && re.stateNode.implementation === fe.implementation) {
                    c(
                      ue,
                      re.sibling
                    ), Ae = v(re, fe.children || []), Ae.return = ue, ue = Ae;
                    break e;
                  } else {
                    c(ue, re);
                    break;
                  }
                else l(ue, re);
                re = re.sibling;
              }
              Ae = Uh(fe, ue.mode, Ae), Ae.return = ue, ue = Ae;
            }
            return N(ue);
          case U:
            return ze = fe._init, fe = ze(fe._payload), Jt(
              ue,
              re,
              fe,
              Ae
            );
        }
        if (Be(fe))
          return Ue(
            ue,
            re,
            fe,
            Ae
          );
        if (Y(fe)) {
          if (ze = Y(fe), typeof ze != "function") throw Error(i(150));
          return fe = ze.call(fe), et(
            ue,
            re,
            fe,
            Ae
          );
        }
        if (typeof fe.then == "function")
          return Jt(
            ue,
            re,
            of(fe),
            Ae
          );
        if (fe.$$typeof === M)
          return Jt(
            ue,
            re,
            Dm(ue, fe),
            Ae
          );
        lf(ue, fe);
      }
      return typeof fe == "string" && fe !== "" || typeof fe == "number" || typeof fe == "bigint" ? (fe = "" + fe, re !== null && re.tag === 6 ? (c(ue, re.sibling), Ae = v(re, fe), Ae.return = ue, ue = Ae) : (c(ue, re), Ae = jm(fe, ue.mode, Ae), Ae.return = ue, ue = Ae), N(ue)) : c(ue, re);
    }
    return function(ue, re, fe, Ae) {
      try {
        il = 0;
        var ze = Jt(
          ue,
          re,
          fe,
          Ae
        );
        return _n = null, ze;
      } catch ($e) {
        if ($e === Yo) throw $e;
        var ut = Hn(29, $e, null, ue.mode);
        return ut.lanes = Ae, ut.return = ue, ut;
      } finally {
      }
    };
  }
  var qo = sm(!0), lm = sm(!1), Ji = tt(null), uf = tt(0);
  function _1(o, l) {
    o = bs, Ve(uf, o), Ve(Ji, l), bs = o | l.baseLanes;
  }
  function um() {
    Ve(uf, bs), Ve(Ji, Ji.current);
  }
  function gh() {
    bs = uf.current, Ye(Ji), Ye(uf);
  }
  var ya = tt(null), Ko = null;
  function Jo(o) {
    var l = o.alternate;
    Ve(Cn, Cn.current & 1), Ve(ya, o), Ko === null && (l === null || Ji.current !== null || l.memoizedState !== null) && (Ko = o);
  }
  function U1(o) {
    if (o.tag === 22) {
      if (Ve(Cn, Cn.current), Ve(ya, o), Ko === null) {
        var l = o.alternate;
        l !== null && l.memoizedState !== null && (Ko = o);
      }
    } else Xi();
  }
  function Xi() {
    Ve(Cn, Cn.current), Ve(ya, ya.current);
  }
  function wo(o) {
    Ye(ya), Ko === o && (Ko = null), Ye(Cn);
  }
  var Cn = tt(0);
  function mh(o) {
    for (var l = o; l !== null; ) {
      if (l.tag === 13) {
        var c = l.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!"))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if (l.flags & 128) return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === o) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === o) return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  var Iu = typeof AbortController < "u" ? AbortController : function() {
    var o = [], l = this.signal = {
      aborted: !1,
      addEventListener: function(c, h) {
        o.push(h);
      }
    };
    this.abort = function() {
      l.aborted = !0, o.forEach(function(c) {
        return c();
      });
    };
  }, z1 = a.unstable_scheduleCallback, H1 = a.unstable_NormalPriority, Un = {
    $$typeof: M,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function V1() {
    return {
      controller: new Iu(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function cf(o) {
    o.refCount--, o.refCount === 0 && z1(H1, function() {
      o.controller.abort();
    });
  }
  var es = null, yh = 0, ts = 0, Nu = null;
  function jw(o, l) {
    if (es === null) {
      var c = es = [];
      yh = 0, ts = _f(), Nu = {
        status: "pending",
        value: void 0,
        then: function(h) {
          c.push(h);
        }
      };
    }
    return yh++, l.then(cm, cm), l;
  }
  function cm() {
    if (--yh === 0 && es !== null) {
      Nu !== null && (Nu.status = "fulfilled");
      var o = es;
      es = null, ts = 0, Nu = null;
      for (var l = 0; l < o.length; l++) (0, o[l])();
    }
  }
  function W1(o, l) {
    var c = [], h = {
      status: "pending",
      value: null,
      reason: null,
      then: function(v) {
        c.push(v);
      }
    };
    return o.then(
      function() {
        h.status = "fulfilled", h.value = l;
        for (var v = 0; v < c.length; v++) (0, c[v])(l);
      },
      function(v) {
        for (h.status = "rejected", h.reason = v, v = 0; v < c.length; v++)
          (0, c[v])(void 0);
      }
    ), h;
  }
  var G1 = j.S;
  j.S = function(o, l) {
    typeof l == "object" && l !== null && typeof l.then == "function" && jw(o, l), G1 !== null && G1(o, l);
  };
  var sl = tt(null);
  function ns() {
    var o = sl.current;
    return o !== null ? o : zt.pooledCache;
  }
  function bh(o, l) {
    l === null ? Ve(sl, sl.current) : Ve(sl, l.pool);
  }
  function j1() {
    var o = ns();
    return o === null ? null : { parent: Un._currentValue, pool: o };
  }
  var rs = 0, ot = null, Bt = null, gn = null, ff = !1, ll = !1, Pu = !1, Tn = 0, df = 0, Ou = null, $w = 0;
  function mn() {
    throw Error(i(321));
  }
  function fm(o, l) {
    if (l === null) return !1;
    for (var c = 0; c < l.length && c < o.length; c++)
      if (!Ar(o[c], l[c])) return !1;
    return !0;
  }
  function Ru(o, l, c, h, v, w) {
    return rs = w, ot = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, j.H = o === null || o.memoizedState === null ? fl : ls, Pu = !1, w = c(h, v), Pu = !1, ll && (w = $1(
      l,
      c,
      h,
      v
    )), dm(o), w;
  }
  function dm(o) {
    j.H = er;
    var l = Bt !== null && Bt.next !== null;
    if (rs = 0, gn = Bt = ot = null, ff = !1, df = 0, Ou = null, l) throw Error(i(300));
    o === null || un || (o = o.dependencies, o !== null && Lh(o) && (un = !0));
  }
  function $1(o, l, c, h) {
    ot = o;
    var v = 0;
    do {
      if (ll && (Ou = null), df = 0, ll = !1, 25 <= v) throw Error(i(301));
      if (v += 1, gn = Bt = null, o.updateQueue != null) {
        var w = o.updateQueue;
        w.lastEffect = null, w.events = null, w.stores = null, w.memoCache != null && (w.memoCache.index = 0);
      }
      j.H = Bu, w = l(c, h);
    } while (ll);
    return w;
  }
  function Qw() {
    var o = j.H, l = o.useState()[0];
    return l = typeof l.then == "function" ? Lu(l) : l, o = o.useState()[0], (Bt !== null ? Bt.memoizedState : null) !== o && (ot.flags |= 1024), l;
  }
  function hm() {
    var o = Tn !== 0;
    return Tn = 0, o;
  }
  function vh(o, l, c) {
    l.updateQueue = o.updateQueue, l.flags &= -2053, o.lanes &= ~c;
  }
  function wh(o) {
    if (ff) {
      for (o = o.memoizedState; o !== null; ) {
        var l = o.queue;
        l !== null && (l.pending = null), o = o.next;
      }
      ff = !1;
    }
    rs = 0, gn = Bt = ot = null, ll = !1, df = Tn = 0, Ou = null;
  }
  function Tr() {
    var o = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return gn === null ? ot.memoizedState = gn = o : gn = gn.next = o, gn;
  }
  function kn() {
    if (Bt === null) {
      var o = ot.alternate;
      o = o !== null ? o.memoizedState : null;
    } else o = Bt.next;
    var l = gn === null ? ot.memoizedState : gn.next;
    if (l !== null)
      gn = l, Bt = o;
    else {
      if (o === null)
        throw ot.alternate === null ? Error(i(467)) : Error(i(310));
      Bt = o, o = {
        memoizedState: Bt.memoizedState,
        baseState: Bt.baseState,
        baseQueue: Bt.baseQueue,
        queue: Bt.queue,
        next: null
      }, gn === null ? ot.memoizedState = gn = o : gn = gn.next = o;
    }
    return gn;
  }
  var hf;
  hf = function() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  };
  function Lu(o) {
    var l = df;
    return df += 1, Ou === null && (Ou = []), o = Cu(Ou, o, l), l = ot, (gn === null ? l.memoizedState : gn.next) === null && (l = l.alternate, j.H = l === null || l.memoizedState === null ? fl : ls), o;
  }
  function pf(o) {
    if (o !== null && typeof o == "object") {
      if (typeof o.then == "function") return Lu(o);
      if (o.$$typeof === M) return gr(o);
    }
    throw Error(i(438, String(o)));
  }
  function pm(o) {
    var l = null, c = ot.updateQueue;
    if (c !== null && (l = c.memoCache), l == null) {
      var h = ot.alternate;
      h !== null && (h = h.updateQueue, h !== null && (h = h.memoCache, h != null && (l = {
        data: h.data.map(function(v) {
          return v.slice();
        }),
        index: 0
      })));
    }
    if (l == null && (l = { data: [], index: 0 }), c === null && (c = hf(), ot.updateQueue = c), c.memoCache = l, c = l.data[l.index], c === void 0)
      for (c = l.data[l.index] = Array(o), h = 0; h < o; h++)
        c[h] = Z;
    return l.index++, c;
  }
  function Xo(o, l) {
    return typeof l == "function" ? l(o) : l;
  }
  function gf(o) {
    var l = kn();
    return gm(l, Bt, o);
  }
  function gm(o, l, c) {
    var h = o.queue;
    if (h === null) throw Error(i(311));
    h.lastRenderedReducer = c;
    var v = o.baseQueue, w = h.pending;
    if (w !== null) {
      if (v !== null) {
        var N = v.next;
        v.next = w.next, w.next = N;
      }
      l.baseQueue = v = w, h.pending = null;
    }
    if (w = o.baseState, v === null) o.memoizedState = w;
    else {
      l = v.next;
      var _ = N = null, $ = null, oe = l, ke = !1;
      do {
        var Ne = oe.lane & -536870913;
        if (Ne !== oe.lane ? (xt & Ne) === Ne : (rs & Ne) === Ne) {
          var ge = oe.revertLane;
          if (ge === 0)
            $ !== null && ($ = $.next = {
              lane: 0,
              revertLane: 0,
              action: oe.action,
              hasEagerState: oe.hasEagerState,
              eagerState: oe.eagerState,
              next: null
            }), Ne === ts && (ke = !0);
          else if ((rs & ge) === ge) {
            oe = oe.next, ge === ts && (ke = !0);
            continue;
          } else
            Ne = {
              lane: 0,
              revertLane: oe.revertLane,
              action: oe.action,
              hasEagerState: oe.hasEagerState,
              eagerState: oe.eagerState,
              next: null
            }, $ === null ? (_ = $ = Ne, N = w) : $ = $.next = Ne, ot.lanes |= ge, bl |= ge;
          Ne = oe.action, Pu && c(w, Ne), w = oe.hasEagerState ? oe.eagerState : c(w, Ne);
        } else
          ge = {
            lane: Ne,
            revertLane: oe.revertLane,
            action: oe.action,
            hasEagerState: oe.hasEagerState,
            eagerState: oe.eagerState,
            next: null
          }, $ === null ? (_ = $ = ge, N = w) : $ = $.next = ge, ot.lanes |= Ne, bl |= Ne;
        oe = oe.next;
      } while (oe !== null && oe !== l);
      if ($ === null ? N = w : $.next = _, !Ar(w, o.memoizedState) && (un = !0, ke && (c = Nu, c !== null)))
        throw c;
      o.memoizedState = w, o.baseState = N, o.baseQueue = $, h.lastRenderedState = w;
    }
    return v === null && (h.lanes = 0), [o.memoizedState, h.dispatch];
  }
  function ko(o) {
    var l = kn(), c = l.queue;
    if (c === null) throw Error(i(311));
    c.lastRenderedReducer = o;
    var h = c.dispatch, v = c.pending, w = l.memoizedState;
    if (v !== null) {
      c.pending = null;
      var N = v = v.next;
      do
        w = o(w, N.action), N = N.next;
      while (N !== v);
      Ar(w, l.memoizedState) || (un = !0), l.memoizedState = w, l.baseQueue === null && (l.baseState = w), c.lastRenderedState = w;
    }
    return [w, h];
  }
  function mm(o, l, c) {
    var h = ot, v = kn(), w = Tt;
    if (w) {
      if (c === void 0) throw Error(i(407));
      c = c();
    } else c = l();
    var N = !Ar(
      (Bt || v).memoizedState,
      c
    );
    if (N && (v.memoizedState = c, un = !0), v = v.queue, qa(kh.bind(null, h, v, o), [
      o
    ]), v.getSnapshot !== l || N || gn !== null && gn.memoizedState.tag & 1) {
      if (h.flags |= 2048, ti(
        9,
        ym.bind(
          null,
          h,
          v,
          c,
          l
        ),
        { destroy: void 0 },
        null
      ), zt === null) throw Error(i(349));
      w || rs & 60 || Zw(h, l, c);
    }
    return c;
  }
  function Zw(o, l, c) {
    o.flags |= 16384, o = { getSnapshot: l, value: c }, l = ot.updateQueue, l === null ? (l = hf(), ot.updateQueue = l, l.stores = [o]) : (c = l.stores, c === null ? l.stores = [o] : c.push(o));
  }
  function ym(o, l, c, h) {
    l.value = c, l.getSnapshot = h, as(l) && ei(o);
  }
  function kh(o, l, c) {
    return c(function() {
      as(l) && ei(o);
    });
  }
  function as(o) {
    var l = o.getSnapshot;
    o = o.value;
    try {
      var c = l();
      return !Ar(o, c);
    } catch {
      return !0;
    }
  }
  function ei(o) {
    var l = Go(o, 2);
    l !== null && Vn(l, o, 2);
  }
  function Eh(o) {
    var l = Tr();
    if (typeof o == "function") {
      var c = o;
      if (o = c(), Pu) {
        zi(!0);
        try {
          c();
        } finally {
          zi(!1);
        }
      }
    }
    return l.memoizedState = l.baseState = o, l.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Xo,
      lastRenderedState: o
    }, l;
  }
  function bm(o, l, c, h) {
    return o.baseState = c, gm(
      o,
      Bt,
      typeof h == "function" ? h : Xo
    );
  }
  function Sh(o, l, c, h, v) {
    if (Cm(o)) throw Error(i(485));
    if (o = l.action, o !== null) {
      var w = {
        payload: v,
        action: o,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(N) {
          w.listeners.push(N);
        }
      };
      j.T !== null ? c(!0) : w.isTransition = !1, h(w), c = l.pending, c === null ? (w.next = l.pending = w, Ah(l, w)) : (w.next = c.next, l.pending = c.next = w);
    }
  }
  function Ah(o, l) {
    var c = l.action, h = l.payload, v = o.state;
    if (l.isTransition) {
      var w = j.T, N = {};
      j.T = N;
      try {
        var _ = c(v, h), $ = j.S;
        $ !== null && $(N, _), ul(o, l, _);
      } catch (oe) {
        mf(o, l, oe);
      } finally {
        j.T = w;
      }
    } else
      try {
        w = c(v, h), ul(o, l, w);
      } catch (oe) {
        mf(o, l, oe);
      }
  }
  function ul(o, l, c) {
    c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(
      function(h) {
        qt(o, l, h);
      },
      function(h) {
        return mf(o, l, h);
      }
    ) : qt(o, l, c);
  }
  function qt(o, l, c) {
    l.status = "fulfilled", l.value = c, Q1(l), o.state = c, l = o.pending, l !== null && (c = l.next, c === l ? o.pending = null : (c = c.next, l.next = c, Ah(o, c)));
  }
  function mf(o, l, c) {
    var h = o.pending;
    if (o.pending = null, h !== null) {
      h = h.next;
      do
        l.status = "rejected", l.reason = c, Q1(l), l = l.next;
      while (l !== h);
    }
    o.action = null;
  }
  function Q1(o) {
    o = o.listeners;
    for (var l = 0; l < o.length; l++) (0, o[l])();
  }
  function vm(o, l) {
    return l;
  }
  function wm(o, l) {
    if (Tt) {
      var c = zt.formState;
      if (c !== null) {
        e: {
          var h = ot;
          if (Tt) {
            if (Fn) {
              t: {
                for (var v = Fn, w = vo; v.nodeType !== 8; ) {
                  if (!w) {
                    v = null;
                    break t;
                  }
                  if (v = or(
                    v.nextSibling
                  ), v === null) {
                    v = null;
                    break t;
                  }
                }
                w = v.data, v = w === "F!" || w === "F" ? v : null;
              }
              if (v) {
                Fn = or(
                  v.nextSibling
                ), h = v.data === "F!";
                break e;
              }
            }
            al(h);
          }
          h = !1;
        }
        h && (l = c[0]);
      }
    }
    return c = Tr(), c.memoizedState = c.baseState = l, h = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: vm,
      lastRenderedState: l
    }, c.queue = h, c = xm.bind(
      null,
      ot,
      h
    ), h.dispatch = c, h = Eh(!1), w = ab.bind(
      null,
      ot,
      !1,
      h.queue
    ), h = Tr(), v = {
      state: l,
      dispatch: null,
      action: o,
      pending: null
    }, h.queue = v, c = Sh.bind(
      null,
      ot,
      v,
      w,
      c
    ), v.dispatch = c, h.memoizedState = o, [l, c, !1];
  }
  function os(o) {
    var l = kn();
    return is(l, Bt, o);
  }
  function is(o, l, c) {
    l = gm(
      o,
      l,
      vm
    )[0], o = gf(Xo)[0], l = typeof l == "object" && l !== null && typeof l.then == "function" ? Lu(l) : l;
    var h = kn(), v = h.queue, w = v.dispatch;
    return c !== h.memoizedState && (ot.flags |= 2048, ti(
      9,
      xh.bind(null, v, c),
      { destroy: void 0 },
      null
    )), [l, w, o];
  }
  function xh(o, l) {
    o.action = l;
  }
  function Ch(o) {
    var l = kn(), c = Bt;
    if (c !== null)
      return is(l, c, o);
    kn(), l = l.memoizedState, c = kn();
    var h = c.queue.dispatch;
    return c.memoizedState = o, [l, h, !1];
  }
  function ti(o, l, c, h) {
    return o = { tag: o, create: l, inst: c, deps: h, next: null }, l = ot.updateQueue, l === null && (l = hf(), ot.updateQueue = l), c = l.lastEffect, c === null ? l.lastEffect = o.next = o : (h = c.next, c.next = o, o.next = h, l.lastEffect = o), o;
  }
  function yf() {
    return kn().memoizedState;
  }
  function Th(o, l, c, h) {
    var v = Tr();
    ot.flags |= o, v.memoizedState = ti(
      1 | l,
      c,
      { destroy: void 0 },
      h === void 0 ? null : h
    );
  }
  function km(o, l, c, h) {
    var v = kn();
    h = h === void 0 ? null : h;
    var w = v.memoizedState.inst;
    Bt !== null && h !== null && fm(h, Bt.memoizedState.deps) ? v.memoizedState = ti(l, c, w, h) : (ot.flags |= o, v.memoizedState = ti(1 | l, c, w, h));
  }
  function Z1(o, l) {
    Th(8390656, 8, o, l);
  }
  function qa(o, l) {
    km(2048, 8, o, l);
  }
  function Y1(o, l) {
    return km(4, 2, o, l);
  }
  function Em(o, l) {
    return km(4, 4, o, l);
  }
  function bf(o, l) {
    if (typeof l == "function") {
      o = o();
      var c = l(o);
      return function() {
        typeof c == "function" ? c() : l(null);
      };
    }
    if (l != null)
      return o = o(), l.current = o, function() {
        l.current = null;
      };
  }
  function Du(o, l, c) {
    c = c != null ? c.concat([o]) : null, km(4, 4, bf.bind(null, l, o), c);
  }
  function Sm() {
  }
  function Am(o, l) {
    var c = kn();
    l = l === void 0 ? null : l;
    var h = c.memoizedState;
    return l !== null && fm(l, h[1]) ? h[0] : (c.memoizedState = [o, l], o);
  }
  function q1(o, l) {
    var c = kn();
    l = l === void 0 ? null : l;
    var h = c.memoizedState;
    if (l !== null && fm(l, h[1]))
      return h[0];
    if (h = o(), Pu) {
      zi(!0);
      try {
        o();
      } finally {
        zi(!1);
      }
    }
    return c.memoizedState = [h, l], h;
  }
  function K1(o, l, c) {
    return c === void 0 || rs & 1073741824 ? o.memoizedState = l : (o.memoizedState = c, o = Qu(), ot.lanes |= o, bl |= o, c);
  }
  function Yw(o, l, c, h) {
    return Ar(c, l) ? c : Ji.current !== null ? (o = K1(o, c, h), Ar(o, l) || (un = !0), o) : rs & 42 ? (o = Qu(), ot.lanes |= o, bl |= o, l) : (un = !0, o.memoizedState = c);
  }
  function J1(o, l, c, h, v) {
    var w = Pe.p;
    Pe.p = w !== 0 && 8 > w ? w : 8;
    var N = j.T, _ = {};
    j.T = _, ab(o, !1, l, c);
    try {
      var $ = v(), oe = j.S;
      if (oe !== null && oe(_, $), $ !== null && typeof $ == "object" && typeof $.then == "function") {
        var ke = W1(
          $,
          h
        );
        cl(
          o,
          l,
          ke,
          Ir(o)
        );
      } else
        cl(
          o,
          l,
          h,
          Ir(o)
        );
    } catch (Ne) {
      cl(
        o,
        l,
        { then: function() {
        }, status: "rejected", reason: Ne },
        Ir()
      );
    } finally {
      Pe.p = w, j.T = N;
    }
  }
  function a6() {
  }
  function ss(o, l, c, h) {
    if (o.tag !== 5) throw Error(i(476));
    var v = ia(o).queue;
    J1(
      o,
      v,
      l,
      Fe,
      c === null ? a6 : function() {
        return X1(o), c(h);
      }
    );
  }
  function ia(o) {
    var l = o.memoizedState;
    if (l !== null) return l;
    l = {
      memoizedState: Fe,
      baseState: Fe,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Xo,
        lastRenderedState: Fe
      },
      next: null
    };
    var c = {};
    return l.next = {
      memoizedState: c,
      baseState: c,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Xo,
        lastRenderedState: c
      },
      next: null
    }, o.memoizedState = l, o = o.alternate, o !== null && (o.memoizedState = l), l;
  }
  function X1(o) {
    var l = ia(o).next.queue;
    cl(o, l, {}, Ir());
  }
  function eb() {
    return gr(ca);
  }
  function tb() {
    return kn().memoizedState;
  }
  function nb() {
    return kn().memoizedState;
  }
  function qw(o) {
    for (var l = o.return; l !== null; ) {
      switch (l.tag) {
        case 24:
        case 3:
          var c = Ir();
          o = ds(c);
          var h = hs(l, o, c);
          h !== null && (Vn(h, l, c), xf(h, l, c)), l = { cache: V1() }, o.payload = l;
          return;
      }
      l = l.return;
    }
  }
  function rb(o, l, c) {
    var h = Ir();
    c = {
      lane: h,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Cm(o) ? ob(l, c) : (c = fh(o, l, c, h), c !== null && (Vn(c, o, h), ib(c, l, h)));
  }
  function xm(o, l, c) {
    var h = Ir();
    cl(o, l, c, h);
  }
  function cl(o, l, c, h) {
    var v = {
      lane: h,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Cm(o)) ob(l, v);
    else {
      var w = o.alternate;
      if (o.lanes === 0 && (w === null || w.lanes === 0) && (w = l.lastRenderedReducer, w !== null))
        try {
          var N = l.lastRenderedState, _ = w(N, c);
          if (v.hasEagerState = !0, v.eagerState = _, Ar(_, N))
            return tf(o, l, v, 0), zt === null && am(), !1;
        } catch {
        } finally {
        }
      if (c = fh(o, l, v, h), c !== null)
        return Vn(c, o, h), ib(c, l, h), !0;
    }
    return !1;
  }
  function ab(o, l, c, h) {
    if (h = {
      lane: 2,
      revertLane: _f(),
      action: h,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Cm(o)) {
      if (l) throw Error(i(479));
    } else
      l = fh(
        o,
        c,
        h,
        2
      ), l !== null && Vn(l, o, 2);
  }
  function Cm(o) {
    var l = o.alternate;
    return o === ot || l !== null && l === ot;
  }
  function ob(o, l) {
    ll = ff = !0;
    var c = o.pending;
    c === null ? l.next = l : (l.next = c.next, c.next = l), o.pending = l;
  }
  function ib(o, l, c) {
    if (c & 4194176) {
      var h = l.lanes;
      h &= o.pendingLanes, c |= h, l.lanes = c, s1(o, c);
    }
  }
  var er = {
    readContext: gr,
    use: pf,
    useCallback: mn,
    useContext: mn,
    useEffect: mn,
    useImperativeHandle: mn,
    useLayoutEffect: mn,
    useInsertionEffect: mn,
    useMemo: mn,
    useReducer: mn,
    useRef: mn,
    useState: mn,
    useDebugValue: mn,
    useDeferredValue: mn,
    useTransition: mn,
    useSyncExternalStore: mn,
    useId: mn
  };
  er.useCacheRefresh = mn, er.useMemoCache = mn, er.useHostTransitionStatus = mn, er.useFormState = mn, er.useActionState = mn, er.useOptimistic = mn;
  var fl = {
    readContext: gr,
    use: pf,
    useCallback: function(o, l) {
      return Tr().memoizedState = [
        o,
        l === void 0 ? null : l
      ], o;
    },
    useContext: gr,
    useEffect: Z1,
    useImperativeHandle: function(o, l, c) {
      c = c != null ? c.concat([o]) : null, Th(
        4194308,
        4,
        bf.bind(null, l, o),
        c
      );
    },
    useLayoutEffect: function(o, l) {
      return Th(4194308, 4, o, l);
    },
    useInsertionEffect: function(o, l) {
      Th(4, 2, o, l);
    },
    useMemo: function(o, l) {
      var c = Tr();
      l = l === void 0 ? null : l;
      var h = o();
      if (Pu) {
        zi(!0);
        try {
          o();
        } finally {
          zi(!1);
        }
      }
      return c.memoizedState = [h, l], h;
    },
    useReducer: function(o, l, c) {
      var h = Tr();
      if (c !== void 0) {
        var v = c(l);
        if (Pu) {
          zi(!0);
          try {
            c(l);
          } finally {
            zi(!1);
          }
        }
      } else v = l;
      return h.memoizedState = h.baseState = v, o = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: v
      }, h.queue = o, o = o.dispatch = rb.bind(
        null,
        ot,
        o
      ), [h.memoizedState, o];
    },
    useRef: function(o) {
      var l = Tr();
      return o = { current: o }, l.memoizedState = o;
    },
    useState: function(o) {
      o = Eh(o);
      var l = o.queue, c = xm.bind(null, ot, l);
      return l.dispatch = c, [o.memoizedState, c];
    },
    useDebugValue: Sm,
    useDeferredValue: function(o, l) {
      var c = Tr();
      return K1(c, o, l);
    },
    useTransition: function() {
      var o = Eh(!1);
      return o = J1.bind(
        null,
        ot,
        o.queue,
        !0,
        !1
      ), Tr().memoizedState = o, [!1, o];
    },
    useSyncExternalStore: function(o, l, c) {
      var h = ot, v = Tr();
      if (Tt) {
        if (c === void 0)
          throw Error(i(407));
        c = c();
      } else {
        if (c = l(), zt === null) throw Error(i(349));
        xt & 60 || Zw(h, l, c);
      }
      v.memoizedState = c;
      var w = { value: c, getSnapshot: l };
      return v.queue = w, Z1(kh.bind(null, h, w, o), [
        o
      ]), h.flags |= 2048, ti(
        9,
        ym.bind(
          null,
          h,
          w,
          c,
          l
        ),
        { destroy: void 0 },
        null
      ), c;
    },
    useId: function() {
      var o = Tr(), l = zt.identifierPrefix;
      if (Tt) {
        var c = Zo, h = Qo;
        c = (h & ~(1 << 32 - ea(h) - 1)).toString(32) + c, l = ":" + l + "R" + c, c = Tn++, 0 < c && (l += "H" + c.toString(32)), l += ":";
      } else
        c = $w++, l = ":" + l + "r" + c.toString(32) + ":";
      return o.memoizedState = l;
    },
    useCacheRefresh: function() {
      return Tr().memoizedState = qw.bind(
        null,
        ot
      );
    }
  };
  fl.useMemoCache = pm, fl.useHostTransitionStatus = eb, fl.useFormState = wm, fl.useActionState = wm, fl.useOptimistic = function(o) {
    var l = Tr();
    l.memoizedState = l.baseState = o;
    var c = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: null,
      lastRenderedState: null
    };
    return l.queue = c, l = ab.bind(
      null,
      ot,
      !0,
      c
    ), c.dispatch = l, [o, l];
  };
  var ls = {
    readContext: gr,
    use: pf,
    useCallback: Am,
    useContext: gr,
    useEffect: qa,
    useImperativeHandle: Du,
    useInsertionEffect: Y1,
    useLayoutEffect: Em,
    useMemo: q1,
    useReducer: gf,
    useRef: yf,
    useState: function() {
      return gf(Xo);
    },
    useDebugValue: Sm,
    useDeferredValue: function(o, l) {
      var c = kn();
      return Yw(
        c,
        Bt.memoizedState,
        o,
        l
      );
    },
    useTransition: function() {
      var o = gf(Xo)[0], l = kn().memoizedState;
      return [
        typeof o == "boolean" ? o : Lu(o),
        l
      ];
    },
    useSyncExternalStore: mm,
    useId: tb
  };
  ls.useCacheRefresh = nb, ls.useMemoCache = pm, ls.useHostTransitionStatus = eb, ls.useFormState = os, ls.useActionState = os, ls.useOptimistic = function(o, l) {
    var c = kn();
    return bm(c, Bt, o, l);
  };
  var Bu = {
    readContext: gr,
    use: pf,
    useCallback: Am,
    useContext: gr,
    useEffect: qa,
    useImperativeHandle: Du,
    useInsertionEffect: Y1,
    useLayoutEffect: Em,
    useMemo: q1,
    useReducer: ko,
    useRef: yf,
    useState: function() {
      return ko(Xo);
    },
    useDebugValue: Sm,
    useDeferredValue: function(o, l) {
      var c = kn();
      return Bt === null ? K1(c, o, l) : Yw(
        c,
        Bt.memoizedState,
        o,
        l
      );
    },
    useTransition: function() {
      var o = ko(Xo)[0], l = kn().memoizedState;
      return [
        typeof o == "boolean" ? o : Lu(o),
        l
      ];
    },
    useSyncExternalStore: mm,
    useId: tb
  };
  Bu.useCacheRefresh = nb, Bu.useMemoCache = pm, Bu.useHostTransitionStatus = eb, Bu.useFormState = Ch, Bu.useActionState = Ch, Bu.useOptimistic = function(o, l) {
    var c = kn();
    return Bt !== null ? bm(c, Bt, o, l) : (c.baseState = o, [o, c.queue.dispatch]);
  };
  function Ih(o, l, c, h) {
    l = o.memoizedState, c = c(h, l), c = c == null ? l : ne({}, l, c), o.memoizedState = c, o.lanes === 0 && (o.updateQueue.baseState = c);
  }
  var sb = {
    isMounted: function(o) {
      return (o = o._reactInternals) ? G(o) === o : !1;
    },
    enqueueSetState: function(o, l, c) {
      o = o._reactInternals;
      var h = Ir(), v = ds(h);
      v.payload = l, c != null && (v.callback = c), l = hs(o, v, h), l !== null && (Vn(l, o, h), xf(l, o, h));
    },
    enqueueReplaceState: function(o, l, c) {
      o = o._reactInternals;
      var h = Ir(), v = ds(h);
      v.tag = 1, v.payload = l, c != null && (v.callback = c), l = hs(o, v, h), l !== null && (Vn(l, o, h), xf(l, o, h));
    },
    enqueueForceUpdate: function(o, l) {
      o = o._reactInternals;
      var c = Ir(), h = ds(c);
      h.tag = 2, l != null && (h.callback = l), l = hs(o, h, c), l !== null && (Vn(l, o, c), xf(l, o, c));
    }
  };
  function ba(o, l, c, h, v, w, N) {
    return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(h, w, N) : l.prototype && l.prototype.isPureReactComponent ? !Zi(c, h) || !Zi(v, w) : !0;
  }
  function lb(o, l, c, h) {
    o = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(c, h), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(c, h), l.state !== o && sb.enqueueReplaceState(l, l.state, null);
  }
  function tr(o, l) {
    var c = l;
    if ("ref" in l) {
      c = {};
      for (var h in l)
        h !== "ref" && (c[h] = l[h]);
    }
    if (o = o.defaultProps) {
      c === l && (c = ne({}, c));
      for (var v in o)
        c[v] === void 0 && (c[v] = o[v]);
    }
    return c;
  }
  var Nh = typeof reportError == "function" ? reportError : function(o) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var l = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
        error: o
      });
      if (!window.dispatchEvent(l)) return;
    } else if (typeof Gs == "object" && typeof Gs.emit == "function") {
      Gs.emit("uncaughtException", o);
      return;
    }
    console.error(o);
  };
  function Kw(o) {
    Nh(o);
  }
  function Eo(o) {
    console.error(o);
  }
  function ub(o) {
    Nh(o);
  }
  function us(o, l) {
    try {
      var c = o.onUncaughtError;
      c(l.value, { componentStack: l.stack });
    } catch (h) {
      setTimeout(function() {
        throw h;
      });
    }
  }
  function cb(o, l, c) {
    try {
      var h = o.onCaughtError;
      h(c.value, {
        componentStack: c.stack,
        errorBoundary: l.tag === 1 ? l.stateNode : null
      });
    } catch (v) {
      setTimeout(function() {
        throw v;
      });
    }
  }
  function So(o, l, c) {
    return c = ds(c), c.tag = 3, c.payload = { element: null }, c.callback = function() {
      us(o, l);
    }, c;
  }
  function Tm(o) {
    return o = ds(o), o.tag = 3, o;
  }
  function Im(o, l, c, h) {
    var v = c.type.getDerivedStateFromError;
    if (typeof v == "function") {
      var w = h.value;
      o.payload = function() {
        return v(w);
      }, o.callback = function() {
        cb(l, c, h);
      };
    }
    var N = c.stateNode;
    N !== null && typeof N.componentDidCatch == "function" && (o.callback = function() {
      cb(l, c, h), typeof v != "function" && (vs === null ? vs = /* @__PURE__ */ new Set([this]) : vs.add(this));
      var _ = h.stack;
      this.componentDidCatch(h.value, {
        componentStack: _ !== null ? _ : ""
      });
    });
  }
  function dl(o, l, c, h, v) {
    if (c.flags |= 32768, h !== null && typeof h == "object" && typeof h.then == "function") {
      if (l = c.alternate, l !== null && Vt(
        l,
        c,
        v,
        !0
      ), c = ya.current, c !== null) {
        switch (c.tag) {
          case 13:
            return Ko === null ? Km() : c.alternate === null && on === 0 && (on = 3), c.flags &= -257, c.flags |= 65536, c.lanes = v, h === im ? c.flags |= 16384 : (l = c.updateQueue, l === null ? c.updateQueue = /* @__PURE__ */ new Set([h]) : l.add(h), Lb(o, h, v)), !1;
          case 22:
            return c.flags |= 65536, h === im ? c.flags |= 16384 : (l = c.updateQueue, l === null ? (l = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([h])
            }, c.updateQueue = l) : (c = l.retryQueue, c === null ? l.retryQueue = /* @__PURE__ */ new Set([h]) : c.add(h)), Lb(o, h, v)), !1;
        }
        throw Error(i(435, c.tag));
      }
      return Lb(o, h, v), Km(), !1;
    }
    if (Tt)
      return l = ya.current, l !== null ? (!(l.flags & 65536) && (l.flags |= 256), l.flags |= 65536, l.lanes = v, h !== B1 && (o = Error(i(422), { cause: h }), af(Xn(o, c)))) : (h !== B1 && (l = Error(i(423), {
        cause: h
      }), af(
        Xn(l, c)
      )), o = o.current.alternate, o.flags |= 65536, v &= -v, o.lanes |= v, h = Xn(h, c), v = So(
        o.stateNode,
        h,
        v
      ), Bh(o, v), on !== 4 && (on = 2)), !1;
    var w = Error(i(520), { cause: h });
    if (w = Xn(w, c), Hh === null ? Hh = [w] : Hh.push(w), on !== 4 && (on = 2), l === null) return !0;
    h = Xn(h, c), c = l;
    do {
      switch (c.tag) {
        case 3:
          return c.flags |= 65536, o = v & -v, c.lanes |= o, o = So(c.stateNode, h, o), Bh(c, o), !1;
        case 1:
          if (l = c.type, w = c.stateNode, (c.flags & 128) === 0 && (typeof l.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (vs === null || !vs.has(w))))
            return c.flags |= 65536, v &= -v, c.lanes |= v, v = Tm(v), Im(
              v,
              o,
              c,
              h
            ), Bh(c, v), !1;
      }
      c = c.return;
    } while (c !== null);
    return !1;
  }
  var fb = Error(i(461)), un = !1;
  function nr(o, l, c, h) {
    l.child = o === null ? lm(l, null, c, h) : qo(
      l,
      o.child,
      c,
      h
    );
  }
  function vf(o, l, c, h, v) {
    c = c.render;
    var w = l.ref;
    if ("ref" in h) {
      var N = {};
      for (var _ in h)
        _ !== "ref" && (N[_] = h[_]);
    } else N = h;
    return fs(l), h = Ru(
      o,
      l,
      c,
      N,
      w,
      v
    ), _ = hm(), o !== null && !un ? (vh(o, l, v), ai(o, l, v)) : (Tt && _ && om(l), l.flags |= 1, nr(o, l, h, v), l.child);
  }
  function Mu(o, l, c, h, v) {
    if (o === null) {
      var w = c.type;
      return typeof w == "function" && !Gm(w) && w.defaultProps === void 0 && c.compare === null ? (l.tag = 15, l.type = w, db(
        o,
        l,
        w,
        h,
        v
      )) : (o = Nf(
        c.type,
        null,
        h,
        l,
        l.mode,
        v
      ), o.ref = l.ref, o.return = l, l.child = o);
    }
    if (w = o.child, !Af(o, v)) {
      var N = w.memoizedProps;
      if (c = c.compare, c = c !== null ? c : Zi, c(N, h) && o.ref === l.ref)
        return ai(o, l, v);
    }
    return l.flags |= 1, o = To(w, h), o.ref = l.ref, o.return = l, l.child = o;
  }
  function db(o, l, c, h, v) {
    if (o !== null) {
      var w = o.memoizedProps;
      if (Zi(w, h) && o.ref === l.ref)
        if (un = !1, l.pendingProps = h = w, Af(o, v))
          o.flags & 131072 && (un = !0);
        else
          return l.lanes = o.lanes, ai(o, l, v);
    }
    return Ef(
      o,
      l,
      c,
      h,
      v
    );
  }
  function hb(o, l, c) {
    var h = l.pendingProps, v = h.children, w = (l.stateNode._pendingVisibility & 2) !== 0, N = o !== null ? o.memoizedState : null;
    if (kf(o, l), h.mode === "hidden" || w) {
      if (l.flags & 128) {
        if (h = N !== null ? N.baseLanes | c : c, o !== null) {
          for (v = l.child = o.child, w = 0; v !== null; )
            w = w | v.lanes | v.childLanes, v = v.sibling;
          l.childLanes = w & ~h;
        } else l.childLanes = 0, l.child = null;
        return wf(
          o,
          l,
          h,
          c
        );
      }
      if (c & 536870912)
        l.memoizedState = { baseLanes: 0, cachePool: null }, o !== null && bh(
          l,
          N !== null ? N.cachePool : null
        ), N !== null ? _1(l, N) : um(), U1(l);
      else
        return l.lanes = l.childLanes = 536870912, wf(
          o,
          l,
          N !== null ? N.baseLanes | c : c,
          c
        );
    } else
      N !== null ? (bh(l, N.cachePool), _1(l, N), Xi(), l.memoizedState = null) : (o !== null && bh(l, null), um(), Xi());
    return nr(o, l, v, c), l.child;
  }
  function wf(o, l, c, h) {
    var v = ns();
    return v = v === null ? null : { parent: Un._currentValue, pool: v }, l.memoizedState = {
      baseLanes: c,
      cachePool: v
    }, o !== null && bh(l, null), um(), U1(l), o !== null && Vt(o, l, h, !0), null;
  }
  function kf(o, l) {
    var c = l.ref;
    if (c === null)
      o !== null && o.ref !== null && (l.flags |= 2097664);
    else {
      if (typeof c != "function" && typeof c != "object")
        throw Error(i(284));
      (o === null || o.ref !== c) && (l.flags |= 2097664);
    }
  }
  function Ef(o, l, c, h, v) {
    return fs(l), c = Ru(
      o,
      l,
      c,
      h,
      void 0,
      v
    ), h = hm(), o !== null && !un ? (vh(o, l, v), ai(o, l, v)) : (Tt && h && om(l), l.flags |= 1, nr(o, l, c, v), l.child);
  }
  function pb(o, l, c, h, v, w) {
    return fs(l), l.updateQueue = null, c = $1(
      l,
      h,
      c,
      v
    ), dm(o), h = hm(), o !== null && !un ? (vh(o, l, w), ai(o, l, w)) : (Tt && h && om(l), l.flags |= 1, nr(o, l, c, w), l.child);
  }
  function gb(o, l, c, h, v) {
    if (fs(l), l.stateNode === null) {
      var w = jo, N = c.contextType;
      typeof N == "object" && N !== null && (w = gr(N)), w = new c(h, w), l.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null, w.updater = sb, l.stateNode = w, w._reactInternals = l, w = l.stateNode, w.props = h, w.state = l.memoizedState, w.refs = {}, Dh(l), N = c.contextType, w.context = typeof N == "object" && N !== null ? gr(N) : jo, w.state = l.memoizedState, N = c.getDerivedStateFromProps, typeof N == "function" && (Ih(
        l,
        c,
        N,
        h
      ), w.state = l.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof w.getSnapshotBeforeUpdate == "function" || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (N = w.state, typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(), N !== w.state && sb.enqueueReplaceState(w, w.state, null), Fh(l, h, w, v), Cf(), w.state = l.memoizedState), typeof w.componentDidMount == "function" && (l.flags |= 4194308), h = !0;
    } else if (o === null) {
      w = l.stateNode;
      var _ = l.memoizedProps, $ = tr(c, _);
      w.props = $;
      var oe = w.context, ke = c.contextType;
      N = jo, typeof ke == "object" && ke !== null && (N = gr(ke));
      var Ne = c.getDerivedStateFromProps;
      ke = typeof Ne == "function" || typeof w.getSnapshotBeforeUpdate == "function", _ = l.pendingProps !== _, ke || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (_ || oe !== N) && lb(
        l,
        w,
        h,
        N
      ), va = !1;
      var ge = l.memoizedState;
      w.state = ge, Fh(l, h, w, v), Cf(), oe = l.memoizedState, _ || ge !== oe || va ? (typeof Ne == "function" && (Ih(
        l,
        c,
        Ne,
        h
      ), oe = l.memoizedState), ($ = va || ba(
        l,
        c,
        $,
        h,
        ge,
        oe,
        N
      )) ? (ke || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount()), typeof w.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof w.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = h, l.memoizedState = oe), w.props = h, w.state = oe, w.context = N, h = $) : (typeof w.componentDidMount == "function" && (l.flags |= 4194308), h = !1);
    } else {
      w = l.stateNode, pl(o, l), N = l.memoizedProps, ke = tr(c, N), w.props = ke, Ne = l.pendingProps, ge = w.context, oe = c.contextType, $ = jo, typeof oe == "object" && oe !== null && ($ = gr(oe)), _ = c.getDerivedStateFromProps, (oe = typeof _ == "function" || typeof w.getSnapshotBeforeUpdate == "function") || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (N !== Ne || ge !== $) && lb(
        l,
        w,
        h,
        $
      ), va = !1, ge = l.memoizedState, w.state = ge, Fh(l, h, w, v), Cf();
      var ve = l.memoizedState;
      N !== Ne || ge !== ve || va || o !== null && o.dependencies !== null && Lh(o.dependencies) ? (typeof _ == "function" && (Ih(
        l,
        c,
        _,
        h
      ), ve = l.memoizedState), (ke = va || ba(
        l,
        c,
        ke,
        h,
        ge,
        ve,
        $
      ) || o !== null && o.dependencies !== null && Lh(o.dependencies)) ? (oe || typeof w.UNSAFE_componentWillUpdate != "function" && typeof w.componentWillUpdate != "function" || (typeof w.componentWillUpdate == "function" && w.componentWillUpdate(h, ve, $), typeof w.UNSAFE_componentWillUpdate == "function" && w.UNSAFE_componentWillUpdate(
        h,
        ve,
        $
      )), typeof w.componentDidUpdate == "function" && (l.flags |= 4), typeof w.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof w.componentDidUpdate != "function" || N === o.memoizedProps && ge === o.memoizedState || (l.flags |= 4), typeof w.getSnapshotBeforeUpdate != "function" || N === o.memoizedProps && ge === o.memoizedState || (l.flags |= 1024), l.memoizedProps = h, l.memoizedState = ve), w.props = h, w.state = ve, w.context = $, h = ke) : (typeof w.componentDidUpdate != "function" || N === o.memoizedProps && ge === o.memoizedState || (l.flags |= 4), typeof w.getSnapshotBeforeUpdate != "function" || N === o.memoizedProps && ge === o.memoizedState || (l.flags |= 1024), h = !1);
    }
    return w = h, kf(o, l), h = (l.flags & 128) !== 0, w || h ? (w = l.stateNode, c = h && typeof c.getDerivedStateFromError != "function" ? null : w.render(), l.flags |= 1, o !== null && h ? (l.child = qo(
      l,
      o.child,
      null,
      v
    ), l.child = qo(
      l,
      null,
      c,
      v
    )) : nr(o, l, c, v), l.memoizedState = w.state, o = l.child) : o = ai(
      o,
      l,
      v
    ), o;
  }
  function Jw(o, l, c, h) {
    return rf(), l.flags |= 256, nr(o, l, c, h), l.child;
  }
  var Ph = { dehydrated: null, treeContext: null, retryLane: 0 };
  function ni(o) {
    return { baseLanes: o, cachePool: j1() };
  }
  function Nm(o, l, c) {
    return o = o !== null ? o.childLanes & ~c : 0, l && (o |= Ja), o;
  }
  function Pm(o, l, c) {
    var h = l.pendingProps, v = !1, w = (l.flags & 128) !== 0, N;
    if ((N = w) || (N = o !== null && o.memoizedState === null ? !1 : (Cn.current & 2) !== 0), N && (v = !0, l.flags &= -129), N = (l.flags & 32) !== 0, l.flags &= -33, o === null) {
      if (Tt) {
        if (v ? Jo(l) : Xi(), Tt) {
          var _ = Fn, $;
          if ($ = _) {
            e: {
              for ($ = _, _ = vo; $.nodeType !== 8; ) {
                if (!_) {
                  _ = null;
                  break e;
                }
                if ($ = or(
                  $.nextSibling
                ), $ === null) {
                  _ = null;
                  break e;
                }
              }
              _ = $;
            }
            _ !== null ? (l.memoizedState = {
              dehydrated: _,
              treeContext: $o !== null ? { id: Qo, overflow: Zo } : null,
              retryLane: 536870912
            }, $ = Hn(
              18,
              null,
              null,
              0
            ), $.stateNode = _, $.return = l, l.child = $, pr = l, Fn = null, $ = !0) : $ = !1;
          }
          $ || al(l);
        }
        if (_ = l.memoizedState, _ !== null && (_ = _.dehydrated, _ !== null))
          return _.data === "$!" ? l.lanes = 16 : l.lanes = 536870912, null;
        wo(l);
      }
      return _ = h.children, h = h.fallback, v ? (Xi(), v = l.mode, _ = cs(
        { mode: "hidden", children: _ },
        v
      ), h = cn(
        h,
        v,
        c,
        null
      ), _.return = l, h.return = l, _.sibling = h, l.child = _, v = l.child, v.memoizedState = ni(c), v.childLanes = Nm(
        o,
        N,
        c
      ), l.memoizedState = Ph, h) : (Jo(l), Sf(l, _));
    }
    if ($ = o.memoizedState, $ !== null && (_ = $.dehydrated, _ !== null)) {
      if (w)
        l.flags & 256 ? (Jo(l), l.flags &= -257, l = Om(
          o,
          l,
          c
        )) : l.memoizedState !== null ? (Xi(), l.child = o.child, l.flags |= 128, l = null) : (Xi(), v = h.fallback, _ = l.mode, h = cs(
          { mode: "visible", children: h.children },
          _
        ), v = cn(
          v,
          _,
          c,
          null
        ), v.flags |= 2, h.return = l, v.return = l, h.sibling = v, l.child = h, qo(
          l,
          o.child,
          null,
          c
        ), h = l.child, h.memoizedState = ni(c), h.childLanes = Nm(
          o,
          N,
          c
        ), l.memoizedState = Ph, l = v);
      else if (Jo(l), _.data === "$!") {
        if (N = _.nextSibling && _.nextSibling.dataset, N) var oe = N.dgst;
        N = oe, h = Error(i(419)), h.stack = "", h.digest = N, af({ value: h, source: null, stack: null }), l = Om(
          o,
          l,
          c
        );
      } else if (un || Vt(o, l, c, !1), N = (c & o.childLanes) !== 0, un || N) {
        if (N = zt, N !== null) {
          if (h = c & -c, h & 42) h = 1;
          else
            switch (h) {
              case 2:
                h = 1;
                break;
              case 8:
                h = 4;
                break;
              case 32:
                h = 16;
                break;
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                h = 64;
                break;
              case 268435456:
                h = 134217728;
                break;
              default:
                h = 0;
            }
          if (h = h & (N.suspendedLanes | c) ? 0 : h, h !== 0 && h !== $.retryLane)
            throw $.retryLane = h, Go(o, h), Vn(N, o, h), fb;
        }
        _.data === "$?" || Km(), l = Om(
          o,
          l,
          c
        );
      } else
        _.data === "$?" ? (l.flags |= 128, l.child = o.child, l = l6.bind(
          null,
          o
        ), _._reactRetry = l, l = null) : (o = $.treeContext, Fn = or(
          _.nextSibling
        ), pr = l, Tt = !0, Ya = null, vo = !1, o !== null && (Cr[oa++] = Qo, Cr[oa++] = Zo, Cr[oa++] = $o, Qo = o.id, Zo = o.overflow, $o = l), l = Sf(
          l,
          h.children
        ), l.flags |= 4096);
      return l;
    }
    return v ? (Xi(), v = h.fallback, _ = l.mode, $ = o.child, oe = $.sibling, h = To($, {
      mode: "hidden",
      children: h.children
    }), h.subtreeFlags = $.subtreeFlags & 31457280, oe !== null ? v = To(oe, v) : (v = cn(
      v,
      _,
      c,
      null
    ), v.flags |= 2), v.return = l, h.return = l, h.sibling = v, l.child = h, h = v, v = l.child, _ = o.child.memoizedState, _ === null ? _ = ni(c) : ($ = _.cachePool, $ !== null ? (oe = Un._currentValue, $ = $.parent !== oe ? { parent: oe, pool: oe } : $) : $ = j1(), _ = {
      baseLanes: _.baseLanes | c,
      cachePool: $
    }), v.memoizedState = _, v.childLanes = Nm(
      o,
      N,
      c
    ), l.memoizedState = Ph, h) : (Jo(l), c = o.child, o = c.sibling, c = To(c, {
      mode: "visible",
      children: h.children
    }), c.return = l, c.sibling = null, o !== null && (N = l.deletions, N === null ? (l.deletions = [o], l.flags |= 16) : N.push(o)), l.child = c, l.memoizedState = null, c);
  }
  function Sf(o, l) {
    return l = cs(
      { mode: "visible", children: l },
      o.mode
    ), l.return = o, o.child = l;
  }
  function cs(o, l) {
    return i3(o, l, 0, null);
  }
  function Om(o, l, c) {
    return qo(l, o.child, null, c), o = Sf(
      l,
      l.pendingProps.children
    ), o.flags |= 2, l.memoizedState = null, o;
  }
  function Rm(o, l, c) {
    o.lanes |= l;
    var h = o.alternate;
    h !== null && (h.lanes |= l), Hr(o.return, l, c);
  }
  function Oh(o, l, c, h, v) {
    var w = o.memoizedState;
    w === null ? o.memoizedState = {
      isBackwards: l,
      rendering: null,
      renderingStartTime: 0,
      last: h,
      tail: c,
      tailMode: v
    } : (w.isBackwards = l, w.rendering = null, w.renderingStartTime = 0, w.last = h, w.tail = c, w.tailMode = v);
  }
  function ri(o, l, c) {
    var h = l.pendingProps, v = h.revealOrder, w = h.tail;
    if (nr(o, l, h.children, c), h = Cn.current, h & 2)
      h = h & 1 | 2, l.flags |= 128;
    else {
      if (o !== null && o.flags & 128)
        e: for (o = l.child; o !== null; ) {
          if (o.tag === 13)
            o.memoizedState !== null && Rm(o, c, l);
          else if (o.tag === 19)
            Rm(o, c, l);
          else if (o.child !== null) {
            o.child.return = o, o = o.child;
            continue;
          }
          if (o === l) break e;
          for (; o.sibling === null; ) {
            if (o.return === null || o.return === l)
              break e;
            o = o.return;
          }
          o.sibling.return = o.return, o = o.sibling;
        }
      h &= 1;
    }
    switch (Ve(Cn, h), v) {
      case "forwards":
        for (c = l.child, v = null; c !== null; )
          o = c.alternate, o !== null && mh(o) === null && (v = c), c = c.sibling;
        c = v, c === null ? (v = l.child, l.child = null) : (v = c.sibling, c.sibling = null), Oh(
          l,
          !1,
          v,
          c,
          w
        );
        break;
      case "backwards":
        for (c = null, v = l.child, l.child = null; v !== null; ) {
          if (o = v.alternate, o !== null && mh(o) === null) {
            l.child = v;
            break;
          }
          o = v.sibling, v.sibling = c, c = v, v = o;
        }
        Oh(
          l,
          !0,
          c,
          null,
          w
        );
        break;
      case "together":
        Oh(l, !1, null, null, void 0);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function ai(o, l, c) {
    if (o !== null && (l.dependencies = o.dependencies), bl |= l.lanes, !(c & l.childLanes))
      if (o !== null) {
        if (Vt(
          o,
          l,
          c,
          !1
        ), (c & l.childLanes) === 0)
          return null;
      } else return null;
    if (o !== null && l.child !== o.child)
      throw Error(i(153));
    if (l.child !== null) {
      for (o = l.child, c = To(o, o.pendingProps), l.child = c, c.return = l; o.sibling !== null; )
        o = o.sibling, c = c.sibling = To(o, o.pendingProps), c.return = l;
      c.sibling = null;
    }
    return l.child;
  }
  function Af(o, l) {
    return o.lanes & l ? !0 : (o = o.dependencies, !!(o !== null && Lh(o)));
  }
  function Rh(o, l, c) {
    switch (l.tag) {
      case 3:
        Er(l, l.stateNode.containerInfo), hl(l, Un, o.memoizedState.cache), rf();
        break;
      case 27:
      case 5:
        jt(l);
        break;
      case 4:
        Er(l, l.stateNode.containerInfo);
        break;
      case 10:
        hl(
          l,
          l.type,
          l.memoizedProps.value
        );
        break;
      case 13:
        var h = l.memoizedState;
        if (h !== null)
          return h.dehydrated !== null ? (Jo(l), l.flags |= 128, null) : c & l.child.childLanes ? Pm(o, l, c) : (Jo(l), o = ai(
            o,
            l,
            c
          ), o !== null ? o.sibling : null);
        Jo(l);
        break;
      case 19:
        var v = (o.flags & 128) !== 0;
        if (h = (c & l.childLanes) !== 0, h || (Vt(
          o,
          l,
          c,
          !1
        ), h = (c & l.childLanes) !== 0), v) {
          if (h)
            return ri(
              o,
              l,
              c
            );
          l.flags |= 128;
        }
        if (v = l.memoizedState, v !== null && (v.rendering = null, v.tail = null, v.lastEffect = null), Ve(Cn, Cn.current), h) break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, hb(o, l, c);
      case 24:
        hl(l, Un, o.memoizedState.cache);
    }
    return ai(o, l, c);
  }
  function Kt(o, l, c) {
    if (o !== null)
      if (o.memoizedProps !== l.pendingProps)
        un = !0;
      else {
        if (!Af(o, c) && !(l.flags & 128))
          return un = !1, Rh(
            o,
            l,
            c
          );
        un = !!(o.flags & 131072);
      }
    else
      un = !1, Tt && l.flags & 1048576 && D1(l, nf, l.index);
    switch (l.lanes = 0, l.tag) {
      case 16:
        e: {
          o = l.pendingProps;
          var h = l.elementType, v = h._init;
          if (h = v(h._payload), l.type = h, typeof h == "function")
            Gm(h) ? (o = tr(h, o), l.tag = 1, l = gb(
              null,
              l,
              h,
              o,
              c
            )) : (l.tag = 0, l = Ef(
              null,
              l,
              h,
              o,
              c
            ));
          else {
            if (h != null) {
              if (v = h.$$typeof, v === D) {
                l.tag = 11, l = vf(
                  null,
                  l,
                  h,
                  o,
                  c
                );
                break e;
              } else if (v === L) {
                l.tag = 14, l = Mu(
                  null,
                  l,
                  h,
                  o,
                  c
                );
                break e;
              }
            }
            throw l = ee(h) || h, Error(i(306, l, ""));
          }
        }
        return l;
      case 0:
        return Ef(
          o,
          l,
          l.type,
          l.pendingProps,
          c
        );
      case 1:
        return h = l.type, v = tr(
          h,
          l.pendingProps
        ), gb(
          o,
          l,
          h,
          v,
          c
        );
      case 3:
        e: {
          if (Er(
            l,
            l.stateNode.containerInfo
          ), o === null) throw Error(i(387));
          var w = l.pendingProps;
          v = l.memoizedState, h = v.element, pl(o, l), Fh(l, w, null, c);
          var N = l.memoizedState;
          if (w = N.cache, hl(l, Un, w), w !== v.cache && Lm(
            l,
            [Un],
            c,
            !0
          ), Cf(), w = N.element, v.isDehydrated)
            if (v = {
              element: w,
              isDehydrated: !1,
              cache: N.cache
            }, l.updateQueue.baseState = v, l.memoizedState = v, l.flags & 256) {
              l = Jw(
                o,
                l,
                w,
                c
              );
              break e;
            } else if (w !== h) {
              h = Xn(
                Error(i(424)),
                l
              ), af(h), l = Jw(
                o,
                l,
                w,
                c
              );
              break e;
            } else
              for (Fn = or(
                l.stateNode.containerInfo.firstChild
              ), pr = l, Tt = !0, Ya = null, vo = !0, c = lm(
                l,
                null,
                w,
                c
              ), l.child = c; c; )
                c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            if (rf(), w === h) {
              l = ai(
                o,
                l,
                c
              );
              break e;
            }
            nr(o, l, w, c);
          }
          l = l.child;
        }
        return l;
      case 26:
        return kf(o, l), o === null ? (c = Me(
          l.type,
          null,
          l.pendingProps,
          null
        )) ? l.memoizedState = c : Tt || (c = l.type, o = l.pendingProps, h = Yh(
          rt.current
        ).createElement(c), h[cr] = l, h[ta] = o, ar(h, c, o), Mn(h), l.stateNode = h) : l.memoizedState = Me(
          l.type,
          o.memoizedProps,
          l.pendingProps,
          o.memoizedState
        ), null;
      case 27:
        return jt(l), o === null && Tt && (h = l.stateNode = gi(
          l.type,
          l.pendingProps,
          rt.current
        ), pr = l, vo = !0, Fn = or(
          h.firstChild
        )), h = l.pendingProps.children, o !== null || Tt ? nr(
          o,
          l,
          h,
          c
        ) : l.child = qo(
          l,
          null,
          h,
          c
        ), kf(o, l), l.child;
      case 5:
        return o === null && Tt && ((v = h = Fn) && (h = Cl(
          h,
          l.type,
          l.pendingProps,
          vo
        ), h !== null ? (l.stateNode = h, pr = l, Fn = or(
          h.firstChild
        ), vo = !1, v = !0) : v = !1), v || al(l)), jt(l), v = l.type, w = l.pendingProps, N = o !== null ? o.memoizedProps : null, h = w.children, qh(v, w) ? h = null : N !== null && qh(v, N) && (l.flags |= 32), l.memoizedState !== null && (v = Ru(
          o,
          l,
          Qw,
          null,
          null,
          c
        ), ca._currentValue = v), kf(o, l), nr(o, l, h, c), l.child;
      case 6:
        return o === null && Tt && ((o = c = Fn) && (c = Xh(
          c,
          l.pendingProps,
          vo
        ), c !== null ? (l.stateNode = c, pr = l, Fn = null, o = !0) : o = !1), o || al(l)), null;
      case 13:
        return Pm(o, l, c);
      case 4:
        return Er(
          l,
          l.stateNode.containerInfo
        ), h = l.pendingProps, o === null ? l.child = qo(
          l,
          null,
          h,
          c
        ) : nr(
          o,
          l,
          h,
          c
        ), l.child;
      case 11:
        return vf(
          o,
          l,
          l.type,
          l.pendingProps,
          c
        );
      case 7:
        return nr(
          o,
          l,
          l.pendingProps,
          c
        ), l.child;
      case 8:
        return nr(
          o,
          l,
          l.pendingProps.children,
          c
        ), l.child;
      case 12:
        return nr(
          o,
          l,
          l.pendingProps.children,
          c
        ), l.child;
      case 10:
        return h = l.pendingProps, hl(l, l.type, h.value), nr(
          o,
          l,
          h.children,
          c
        ), l.child;
      case 9:
        return v = l.type._context, h = l.pendingProps.children, fs(l), v = gr(v), h = h(v), l.flags |= 1, nr(o, l, h, c), l.child;
      case 14:
        return Mu(
          o,
          l,
          l.type,
          l.pendingProps,
          c
        );
      case 15:
        return db(
          o,
          l,
          l.type,
          l.pendingProps,
          c
        );
      case 19:
        return ri(o, l, c);
      case 22:
        return hb(o, l, c);
      case 24:
        return fs(l), h = gr(Un), o === null ? (v = ns(), v === null && (v = zt, w = V1(), v.pooledCache = w, w.refCount++, w !== null && (v.pooledCacheLanes |= c), v = w), l.memoizedState = {
          parent: h,
          cache: v
        }, Dh(l), hl(l, Un, v)) : (o.lanes & c && (pl(o, l), Fh(l, null, null, c), Cf()), v = o.memoizedState, w = l.memoizedState, v.parent !== h ? (v = { parent: h, cache: h }, l.memoizedState = v, l.lanes === 0 && (l.memoizedState = l.updateQueue.baseState = v), hl(l, Un, h)) : (h = w.cache, hl(l, Un, h), h !== v.cache && Lm(
          l,
          [Un],
          c,
          !0
        ))), nr(
          o,
          l,
          l.pendingProps.children,
          c
        ), l.child;
      case 29:
        throw l.pendingProps;
    }
    throw Error(i(156, l.tag));
  }
  var mb = tt(null), Fu = null, oi = null;
  function hl(o, l, c) {
    Ve(mb, l._currentValue), l._currentValue = c;
  }
  function ii(o) {
    o._currentValue = mb.current, Ye(mb);
  }
  function Hr(o, l, c) {
    for (; o !== null; ) {
      var h = o.alternate;
      if ((o.childLanes & l) !== l ? (o.childLanes |= l, h !== null && (h.childLanes |= l)) : h !== null && (h.childLanes & l) !== l && (h.childLanes |= l), o === c) break;
      o = o.return;
    }
  }
  function Lm(o, l, c, h) {
    var v = o.child;
    for (v !== null && (v.return = o); v !== null; ) {
      var w = v.dependencies;
      if (w !== null) {
        var N = v.child;
        w = w.firstContext;
        e: for (; w !== null; ) {
          var _ = w;
          w = v;
          for (var $ = 0; $ < l.length; $++)
            if (_.context === l[$]) {
              w.lanes |= c, _ = w.alternate, _ !== null && (_.lanes |= c), Hr(
                w.return,
                c,
                o
              ), h || (N = null);
              break e;
            }
          w = _.next;
        }
      } else if (v.tag === 18) {
        if (N = v.return, N === null) throw Error(i(341));
        N.lanes |= c, w = N.alternate, w !== null && (w.lanes |= c), Hr(N, c, o), N = null;
      } else N = v.child;
      if (N !== null) N.return = v;
      else
        for (N = v; N !== null; ) {
          if (N === o) {
            N = null;
            break;
          }
          if (v = N.sibling, v !== null) {
            v.return = N.return, N = v;
            break;
          }
          N = N.return;
        }
      v = N;
    }
  }
  function Vt(o, l, c, h) {
    o = null;
    for (var v = l, w = !1; v !== null; ) {
      if (!w) {
        if (v.flags & 524288) w = !0;
        else if (v.flags & 262144) break;
      }
      if (v.tag === 10) {
        var N = v.alternate;
        if (N === null) throw Error(i(387));
        if (N = N.memoizedProps, N !== null) {
          var _ = v.type;
          Ar(v.pendingProps.value, N.value) || (o !== null ? o.push(_) : o = [_]);
        }
      } else if (v === Gt.current) {
        if (N = v.alternate, N === null) throw Error(i(387));
        N.memoizedState.memoizedState !== v.memoizedState.memoizedState && (o !== null ? o.push(ca) : o = [ca]);
      }
      v = v.return;
    }
    o !== null && Lm(
      l,
      o,
      c,
      h
    ), l.flags |= 262144;
  }
  function Lh(o) {
    for (o = o.firstContext; o !== null; ) {
      if (!Ar(
        o.context._currentValue,
        o.memoizedValue
      ))
        return !0;
      o = o.next;
    }
    return !1;
  }
  function fs(o) {
    Fu = o, oi = null, o = o.dependencies, o !== null && (o.firstContext = null);
  }
  function gr(o) {
    return si(Fu, o);
  }
  function Dm(o, l) {
    return Fu === null && fs(o), si(o, l);
  }
  function si(o, l) {
    var c = l._currentValue;
    if (l = { context: l, memoizedValue: c, next: null }, oi === null) {
      if (o === null) throw Error(i(308));
      oi = l, o.dependencies = { lanes: 0, firstContext: l }, o.flags |= 524288;
    } else oi = oi.next = l;
    return c;
  }
  var va = !1;
  function Dh(o) {
    o.updateQueue = {
      baseState: o.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function pl(o, l) {
    o = o.updateQueue, l.updateQueue === o && (l.updateQueue = {
      baseState: o.baseState,
      firstBaseUpdate: o.firstBaseUpdate,
      lastBaseUpdate: o.lastBaseUpdate,
      shared: o.shared,
      callbacks: null
    });
  }
  function ds(o) {
    return { lane: o, tag: 0, payload: null, callback: null, next: null };
  }
  function hs(o, l, c) {
    var h = o.updateQueue;
    if (h === null) return null;
    if (h = h.shared, an & 2) {
      var v = h.pending;
      return v === null ? l.next = l : (l.next = v.next, v.next = l), h.pending = l, l = Nt(o), zr(o, null, c), l;
    }
    return tf(o, h, l, c), Nt(o);
  }
  function xf(o, l, c) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (c & 4194176) !== 0)) {
      var h = l.lanes;
      h &= o.pendingLanes, c |= h, l.lanes = c, s1(o, c);
    }
  }
  function Bh(o, l) {
    var c = o.updateQueue, h = o.alternate;
    if (h !== null && (h = h.updateQueue, c === h)) {
      var v = null, w = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var N = {
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: null,
            next: null
          };
          w === null ? v = w = N : w = w.next = N, c = c.next;
        } while (c !== null);
        w === null ? v = w = l : w = w.next = l;
      } else v = w = l;
      c = {
        baseState: h.baseState,
        firstBaseUpdate: v,
        lastBaseUpdate: w,
        shared: h.shared,
        callbacks: h.callbacks
      }, o.updateQueue = c;
      return;
    }
    o = c.lastBaseUpdate, o === null ? c.firstBaseUpdate = l : o.next = l, c.lastBaseUpdate = l;
  }
  var Mh = !1;
  function Cf() {
    if (Mh) {
      var o = Nu;
      if (o !== null) throw o;
    }
  }
  function Fh(o, l, c, h) {
    Mh = !1;
    var v = o.updateQueue;
    va = !1;
    var w = v.firstBaseUpdate, N = v.lastBaseUpdate, _ = v.shared.pending;
    if (_ !== null) {
      v.shared.pending = null;
      var $ = _, oe = $.next;
      $.next = null, N === null ? w = oe : N.next = oe, N = $;
      var ke = o.alternate;
      ke !== null && (ke = ke.updateQueue, _ = ke.lastBaseUpdate, _ !== N && (_ === null ? ke.firstBaseUpdate = oe : _.next = oe, ke.lastBaseUpdate = $));
    }
    if (w !== null) {
      var Ne = v.baseState;
      N = 0, ke = oe = $ = null, _ = w;
      do {
        var ge = _.lane & -536870913, ve = ge !== _.lane;
        if (ve ? (xt & ge) === ge : (h & ge) === ge) {
          ge !== 0 && ge === ts && (Mh = !0), ke !== null && (ke = ke.next = {
            lane: 0,
            tag: _.tag,
            payload: _.payload,
            callback: null,
            next: null
          });
          e: {
            var Ue = o, et = _;
            ge = l;
            var Jt = c;
            switch (et.tag) {
              case 1:
                if (Ue = et.payload, typeof Ue == "function") {
                  Ne = Ue.call(Jt, Ne, ge);
                  break e;
                }
                Ne = Ue;
                break e;
              case 3:
                Ue.flags = Ue.flags & -65537 | 128;
              case 0:
                if (Ue = et.payload, ge = typeof Ue == "function" ? Ue.call(Jt, Ne, ge) : Ue, ge == null) break e;
                Ne = ne({}, Ne, ge);
                break e;
              case 2:
                va = !0;
            }
          }
          ge = _.callback, ge !== null && (o.flags |= 64, ve && (o.flags |= 8192), ve = v.callbacks, ve === null ? v.callbacks = [ge] : ve.push(ge));
        } else
          ve = {
            lane: ge,
            tag: _.tag,
            payload: _.payload,
            callback: _.callback,
            next: null
          }, ke === null ? (oe = ke = ve, $ = Ne) : ke = ke.next = ve, N |= ge;
        if (_ = _.next, _ === null) {
          if (_ = v.shared.pending, _ === null)
            break;
          ve = _, _ = ve.next, ve.next = null, v.lastBaseUpdate = ve, v.shared.pending = null;
        }
      } while (!0);
      ke === null && ($ = Ne), v.baseState = $, v.firstBaseUpdate = oe, v.lastBaseUpdate = ke, w === null && (v.shared.lanes = 0), bl |= N, o.lanes = N, o.memoizedState = Ne;
    }
  }
  function Xw(o, l) {
    if (typeof o != "function")
      throw Error(i(191, o));
    o.call(l);
  }
  function yb(o, l) {
    var c = o.callbacks;
    if (c !== null)
      for (o.callbacks = null, o = 0; o < c.length; o++)
        Xw(c[o], l);
  }
  function Tf(o, l) {
    try {
      var c = l.updateQueue, h = c !== null ? c.lastEffect : null;
      if (h !== null) {
        var v = h.next;
        c = v;
        do {
          if ((c.tag & o) === o) {
            h = void 0;
            var w = c.create, N = c.inst;
            h = w(), N.destroy = h;
          }
          c = c.next;
        } while (c !== v);
      }
    } catch (_) {
      Ht(l, l.return, _);
    }
  }
  function gl(o, l, c) {
    try {
      var h = l.updateQueue, v = h !== null ? h.lastEffect : null;
      if (v !== null) {
        var w = v.next;
        h = w;
        do {
          if ((h.tag & o) === o) {
            var N = h.inst, _ = N.destroy;
            if (_ !== void 0) {
              N.destroy = void 0, v = l;
              var $ = c;
              try {
                _();
              } catch (oe) {
                Ht(
                  v,
                  $,
                  oe
                );
              }
            }
          }
          h = h.next;
        } while (h !== w);
      }
    } catch (oe) {
      Ht(l, l.return, oe);
    }
  }
  function _u(o) {
    var l = o.updateQueue;
    if (l !== null) {
      var c = o.stateNode;
      try {
        yb(l, c);
      } catch (h) {
        Ht(o, o.return, h);
      }
    }
  }
  function _h(o, l, c) {
    c.props = tr(
      o.type,
      o.memoizedProps
    ), c.state = o.memoizedState;
    try {
      c.componentWillUnmount();
    } catch (h) {
      Ht(o, l, h);
    }
  }
  function ml(o, l) {
    try {
      var c = o.ref;
      if (c !== null) {
        var h = o.stateNode;
        switch (o.tag) {
          case 26:
          case 27:
          case 5:
            var v = h;
            break;
          default:
            v = h;
        }
        typeof c == "function" ? o.refCleanup = c(v) : c.current = v;
      }
    } catch (w) {
      Ht(o, l, w);
    }
  }
  function Vr(o, l) {
    var c = o.ref, h = o.refCleanup;
    if (c !== null)
      if (typeof h == "function")
        try {
          h();
        } catch (v) {
          Ht(o, l, v);
        } finally {
          o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null);
        }
      else if (typeof c == "function")
        try {
          c(null);
        } catch (v) {
          Ht(o, l, v);
        }
      else c.current = null;
  }
  function e3(o) {
    var l = o.type, c = o.memoizedProps, h = o.stateNode;
    try {
      e: switch (l) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && h.focus();
          break e;
        case "img":
          c.src ? h.src = c.src : c.srcSet && (h.srcset = c.srcSet);
      }
    } catch (v) {
      Ht(o, o.return, v);
    }
  }
  function t3(o, l, c) {
    try {
      var h = o.stateNode;
      m3(h, o.type, c, l), h[ta] = l;
    } catch (v) {
      Ht(o, o.return, v);
    }
  }
  function bb(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 || o.tag === 4;
  }
  function ps(o) {
    e: for (; ; ) {
      for (; o.sibling === null; ) {
        if (o.return === null || bb(o.return)) return null;
        o = o.return;
      }
      for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 27 && o.tag !== 18; ) {
        if (o.flags & 2 || o.child === null || o.tag === 4) continue e;
        o.child.return = o, o = o.child;
      }
      if (!(o.flags & 2)) return o.stateNode;
    }
  }
  function Bm(o, l, c) {
    var h = o.tag;
    if (h === 5 || h === 6)
      o = o.stateNode, l ? c.nodeType === 8 ? c.parentNode.insertBefore(o, l) : c.insertBefore(o, l) : (c.nodeType === 8 ? (l = c.parentNode, l.insertBefore(o, c)) : (l = c, l.appendChild(o)), c = c._reactRootContainer, c != null || l.onclick !== null || (l.onclick = xl));
    else if (h !== 4 && h !== 27 && (o = o.child, o !== null))
      for (Bm(o, l, c), o = o.sibling; o !== null; )
        Bm(o, l, c), o = o.sibling;
  }
  function Rt(o, l, c) {
    var h = o.tag;
    if (h === 5 || h === 6)
      o = o.stateNode, l ? c.insertBefore(o, l) : c.appendChild(o);
    else if (h !== 4 && h !== 27 && (o = o.child, o !== null))
      for (Rt(o, l, c), o = o.sibling; o !== null; )
        Rt(o, l, c), o = o.sibling;
  }
  var Ao = !1, yn = !1, Mm = !1, n3 = typeof WeakSet == "function" ? WeakSet : Set, rr = null, Fm = !1;
  function r3(o, l) {
    if (o = o.containerInfo, s0 = rp, o = O1(o), tm(o)) {
      if ("selectionStart" in o)
        var c = {
          start: o.selectionStart,
          end: o.selectionEnd
        };
      else
        e: {
          c = (c = o.ownerDocument) && c.defaultView || window;
          var h = c.getSelection && c.getSelection();
          if (h && h.rangeCount !== 0) {
            c = h.anchorNode;
            var v = h.anchorOffset, w = h.focusNode;
            h = h.focusOffset;
            try {
              c.nodeType, w.nodeType;
            } catch {
              c = null;
              break e;
            }
            var N = 0, _ = -1, $ = -1, oe = 0, ke = 0, Ne = o, ge = null;
            t: for (; ; ) {
              for (var ve; Ne !== c || v !== 0 && Ne.nodeType !== 3 || (_ = N + v), Ne !== w || h !== 0 && Ne.nodeType !== 3 || ($ = N + h), Ne.nodeType === 3 && (N += Ne.nodeValue.length), (ve = Ne.firstChild) !== null; )
                ge = Ne, Ne = ve;
              for (; ; ) {
                if (Ne === o) break t;
                if (ge === c && ++oe === v && (_ = N), ge === w && ++ke === h && ($ = N), (ve = Ne.nextSibling) !== null) break;
                Ne = ge, ge = Ne.parentNode;
              }
              Ne = ve;
            }
            c = _ === -1 || $ === -1 ? null : { start: _, end: $ };
          } else c = null;
        }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (l0 = { focusedElem: o, selectionRange: c }, rp = !1, rr = l; rr !== null; )
      if (l = rr, o = l.child, (l.subtreeFlags & 1028) !== 0 && o !== null)
        o.return = l, rr = o;
      else
        for (; rr !== null; ) {
          switch (l = rr, w = l.alternate, o = l.flags, l.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if (o & 1024 && w !== null) {
                o = void 0, c = l, v = w.memoizedProps, w = w.memoizedState, h = c.stateNode;
                try {
                  var Ue = tr(
                    c.type,
                    v,
                    c.elementType === c.type
                  );
                  o = h.getSnapshotBeforeUpdate(
                    Ue,
                    w
                  ), h.__reactInternalSnapshotBeforeUpdate = o;
                } catch (et) {
                  Ht(
                    c,
                    c.return,
                    et
                  );
                }
              }
              break;
            case 3:
              if (o & 1024) {
                if (o = l.stateNode.containerInfo, c = o.nodeType, c === 9)
                  Io(o);
                else if (c === 1)
                  switch (o.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Io(o);
                      break;
                    default:
                      o.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if (o & 1024) throw Error(i(163));
          }
          if (o = l.sibling, o !== null) {
            o.return = l.return, rr = o;
            break;
          }
          rr = l.return;
        }
    return Ue = Fm, Fm = !1, Ue;
  }
  function vb(o, l, c) {
    var h = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
        li(o, c), h & 4 && Tf(5, c);
        break;
      case 1:
        if (li(o, c), h & 4)
          if (o = c.stateNode, l === null)
            try {
              o.componentDidMount();
            } catch (_) {
              Ht(c, c.return, _);
            }
          else {
            var v = tr(
              c.type,
              l.memoizedProps
            );
            l = l.memoizedState;
            try {
              o.componentDidUpdate(
                v,
                l,
                o.__reactInternalSnapshotBeforeUpdate
              );
            } catch (_) {
              Ht(
                c,
                c.return,
                _
              );
            }
          }
        h & 64 && _u(c), h & 512 && ml(c, c.return);
        break;
      case 3:
        if (li(o, c), h & 64 && (h = c.updateQueue, h !== null)) {
          if (o = null, c.child !== null)
            switch (c.child.tag) {
              case 27:
              case 5:
                o = c.child.stateNode;
                break;
              case 1:
                o = c.child.stateNode;
            }
          try {
            yb(h, o);
          } catch (_) {
            Ht(c, c.return, _);
          }
        }
        break;
      case 26:
        li(o, c), h & 512 && ml(c, c.return);
        break;
      case 27:
      case 5:
        li(o, c), l === null && h & 4 && e3(c), h & 512 && ml(c, c.return);
        break;
      case 12:
        li(o, c);
        break;
      case 13:
        li(o, c), h & 4 && If(o, c);
        break;
      case 22:
        if (v = c.memoizedState !== null || Ao, !v) {
          l = l !== null && l.memoizedState !== null || yn;
          var w = Ao, N = yn;
          Ao = v, (yn = l) && !N ? yl(
            o,
            c,
            (c.subtreeFlags & 8772) !== 0
          ) : li(o, c), Ao = w, yn = N;
        }
        h & 512 && (c.memoizedProps.mode === "manual" ? ml(c, c.return) : Vr(c, c.return));
        break;
      default:
        li(o, c);
    }
  }
  function wb(o) {
    var l = o.alternate;
    l !== null && (o.alternate = null, wb(l)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (l = o.stateNode, l !== null && Fg(l)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
  }
  var nn = null, wa = !1;
  function gs(o, l, c) {
    for (c = c.child; c !== null; )
      xo(o, l, c), c = c.sibling;
  }
  function xo(o, l, c) {
    if (ur && typeof ur.onCommitFiberUnmount == "function")
      try {
        ur.onCommitFiberUnmount(iu, c);
      } catch {
      }
    switch (c.tag) {
      case 26:
        yn || Vr(c, l), gs(
          o,
          l,
          c
        ), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
        break;
      case 27:
        yn || Vr(c, l);
        var h = nn, v = wa;
        for (nn = c.stateNode, gs(
          o,
          l,
          c
        ), c = c.stateNode, l = c.attributes; l.length; )
          c.removeAttributeNode(l[0]);
        Fg(c), nn = h, wa = v;
        break;
      case 5:
        yn || Vr(c, l);
      case 6:
        v = nn;
        var w = wa;
        if (nn = null, gs(
          o,
          l,
          c
        ), nn = v, wa = w, nn !== null)
          if (wa)
            try {
              o = nn, h = c.stateNode, o.nodeType === 8 ? o.parentNode.removeChild(h) : o.removeChild(h);
            } catch (N) {
              Ht(
                c,
                l,
                N
              );
            }
          else
            try {
              nn.removeChild(c.stateNode);
            } catch (N) {
              Ht(
                c,
                l,
                N
              );
            }
        break;
      case 18:
        nn !== null && (wa ? (l = nn, c = c.stateNode, l.nodeType === 8 ? Jh(
          l.parentNode,
          c
        ) : l.nodeType === 1 && Jh(l, c), $f(l)) : Jh(nn, c.stateNode));
        break;
      case 4:
        h = nn, v = wa, nn = c.stateNode.containerInfo, wa = !0, gs(
          o,
          l,
          c
        ), nn = h, wa = v;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        yn || gl(2, c, l), yn || gl(4, c, l), gs(
          o,
          l,
          c
        );
        break;
      case 1:
        yn || (Vr(c, l), h = c.stateNode, typeof h.componentWillUnmount == "function" && _h(
          c,
          l,
          h
        )), gs(
          o,
          l,
          c
        );
        break;
      case 21:
        gs(
          o,
          l,
          c
        );
        break;
      case 22:
        yn || Vr(c, l), yn = (h = yn) || c.memoizedState !== null, gs(
          o,
          l,
          c
        ), yn = h;
        break;
      default:
        gs(
          o,
          l,
          c
        );
    }
  }
  function If(o, l) {
    if (l.memoizedState === null && (o = l.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null))))
      try {
        $f(o);
      } catch (c) {
        Ht(l, l.return, c);
      }
  }
  function a3(o) {
    switch (o.tag) {
      case 13:
      case 19:
        var l = o.stateNode;
        return l === null && (l = o.stateNode = new n3()), l;
      case 22:
        return o = o.stateNode, l = o._retryCache, l === null && (l = o._retryCache = new n3()), l;
      default:
        throw Error(i(435, o.tag));
    }
  }
  function _m(o, l) {
    var c = a3(o);
    l.forEach(function(h) {
      var v = Db.bind(null, o, h);
      c.has(h) || (c.add(h), h.then(v, v));
    });
  }
  function ka(o, l) {
    var c = l.deletions;
    if (c !== null)
      for (var h = 0; h < c.length; h++) {
        var v = c[h], w = o, N = l, _ = N;
        e: for (; _ !== null; ) {
          switch (_.tag) {
            case 27:
            case 5:
              nn = _.stateNode, wa = !1;
              break e;
            case 3:
              nn = _.stateNode.containerInfo, wa = !0;
              break e;
            case 4:
              nn = _.stateNode.containerInfo, wa = !0;
              break e;
          }
          _ = _.return;
        }
        if (nn === null) throw Error(i(160));
        xo(w, N, v), nn = null, wa = !1, w = v.alternate, w !== null && (w.return = null), v.return = null;
      }
    if (l.subtreeFlags & 13878)
      for (l = l.child; l !== null; )
        Um(l, o), l = l.sibling;
  }
  var Ka = null;
  function Um(o, l) {
    var c = o.alternate, h = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ka(l, o), Ea(o), h & 4 && (gl(3, o, o.return), Tf(3, o), gl(5, o, o.return));
        break;
      case 1:
        ka(l, o), Ea(o), h & 512 && (yn || c === null || Vr(c, c.return)), h & 64 && Ao && (o = o.updateQueue, o !== null && (h = o.callbacks, h !== null && (c = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = c === null ? h : c.concat(h))));
        break;
      case 26:
        var v = Ka;
        if (ka(l, o), Ea(o), h & 512 && (yn || c === null || Vr(c, c.return)), h & 4) {
          var w = c !== null ? c.memoizedState : null;
          if (h = o.memoizedState, c === null)
            if (h === null)
              if (o.stateNode === null) {
                e: {
                  h = o.type, c = o.memoizedProps, v = v.ownerDocument || v;
                  t: switch (h) {
                    case "title":
                      w = v.getElementsByTagName("title")[0], (!w || w[lu] || w[cr] || w.namespaceURI === "http://www.w3.org/2000/svg" || w.hasAttribute("itemprop")) && (w = v.createElement(h), v.head.insertBefore(
                        w,
                        v.querySelector("head > title")
                      )), ar(w, h, c), w[cr] = o, Mn(w), h = w;
                      break e;
                    case "link":
                      var N = ks(
                        "link",
                        "href",
                        v
                      ).get(h + (c.href || ""));
                      if (N) {
                        for (var _ = 0; _ < N.length; _++)
                          if (w = N[_], w.getAttribute("href") === (c.href == null ? null : c.href) && w.getAttribute("rel") === (c.rel == null ? null : c.rel) && w.getAttribute("title") === (c.title == null ? null : c.title) && w.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                            N.splice(_, 1);
                            break t;
                          }
                      }
                      w = v.createElement(h), ar(w, h, c), v.head.appendChild(w);
                      break;
                    case "meta":
                      if (N = ks(
                        "meta",
                        "content",
                        v
                      ).get(h + (c.content || ""))) {
                        for (_ = 0; _ < N.length; _++)
                          if (w = N[_], w.getAttribute("content") === (c.content == null ? null : "" + c.content) && w.getAttribute("name") === (c.name == null ? null : c.name) && w.getAttribute("property") === (c.property == null ? null : c.property) && w.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && w.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                            N.splice(_, 1);
                            break t;
                          }
                      }
                      w = v.createElement(h), ar(w, h, c), v.head.appendChild(w);
                      break;
                    default:
                      throw Error(i(468, h));
                  }
                  w[cr] = o, Mn(w), h = w;
                }
                o.stateNode = h;
              } else
                yr(
                  v,
                  o.type,
                  o.stateNode
                );
            else
              o.stateNode = tp(
                v,
                h,
                o.memoizedProps
              );
          else
            w !== h ? (w === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : w.count--, h === null ? yr(
              v,
              o.type,
              o.stateNode
            ) : tp(
              v,
              h,
              o.memoizedProps
            )) : h === null && o.stateNode !== null && t3(
              o,
              o.memoizedProps,
              c.memoizedProps
            );
        }
        break;
      case 27:
        if (h & 4 && o.alternate === null) {
          v = o.stateNode, w = o.memoizedProps;
          try {
            for (var $ = v.firstChild; $; ) {
              var oe = $.nextSibling, ke = $.nodeName;
              $[lu] || ke === "HEAD" || ke === "BODY" || ke === "SCRIPT" || ke === "STYLE" || ke === "LINK" && $.rel.toLowerCase() === "stylesheet" || v.removeChild($), $ = oe;
            }
            for (var Ne = o.type, ge = v.attributes; ge.length; )
              v.removeAttributeNode(ge[0]);
            ar(v, Ne, w), v[cr] = o, v[ta] = w;
          } catch (Ue) {
            Ht(o, o.return, Ue);
          }
        }
      case 5:
        if (ka(l, o), Ea(o), h & 512 && (yn || c === null || Vr(c, c.return)), o.flags & 32) {
          v = o.stateNode;
          try {
            Vo(v, "");
          } catch (Ue) {
            Ht(o, o.return, Ue);
          }
        }
        h & 4 && o.stateNode != null && (v = o.memoizedProps, t3(
          o,
          v,
          c !== null ? c.memoizedProps : v
        )), h & 1024 && (Mm = !0);
        break;
      case 6:
        if (ka(l, o), Ea(o), h & 4) {
          if (o.stateNode === null)
            throw Error(i(162));
          h = o.memoizedProps, c = o.stateNode;
          try {
            c.nodeValue = h;
          } catch (Ue) {
            Ht(o, o.return, Ue);
          }
        }
        break;
      case 3:
        if (ec = null, v = Ka, Ka = c0(l.containerInfo), ka(l, o), Ka = v, Ea(o), h & 4 && c !== null && c.memoizedState.isDehydrated)
          try {
            $f(l.containerInfo);
          } catch (Ue) {
            Ht(o, o.return, Ue);
          }
        Mm && (Mm = !1, zm(o));
        break;
      case 4:
        h = Ka, Ka = c0(
          o.stateNode.containerInfo
        ), ka(l, o), Ea(o), Ka = h;
        break;
      case 12:
        ka(l, o), Ea(o);
        break;
      case 13:
        ka(l, o), Ea(o), o.child.flags & 8192 && o.memoizedState !== null != (c !== null && c.memoizedState !== null) && (Zm = Xr()), h & 4 && (h = o.updateQueue, h !== null && (o.updateQueue = null, _m(o, h)));
        break;
      case 22:
        if (h & 512 && (yn || c === null || Vr(c, c.return)), $ = o.memoizedState !== null, oe = c !== null && c.memoizedState !== null, ke = Ao, Ne = yn, Ao = ke || $, yn = Ne || oe, ka(l, o), yn = Ne, Ao = ke, Ea(o), l = o.stateNode, l._current = o, l._visibility &= -3, l._visibility |= l._pendingVisibility & 2, h & 8192 && (l._visibility = $ ? l._visibility & -2 : l._visibility | 1, $ && (l = Ao || yn, c === null || oe || l || Uu(o)), o.memoizedProps === null || o.memoizedProps.mode !== "manual"))
          e: for (c = null, l = o; ; ) {
            if (l.tag === 5 || l.tag === 26 || l.tag === 27) {
              if (c === null) {
                oe = c = l;
                try {
                  if (v = oe.stateNode, $)
                    w = v.style, typeof w.setProperty == "function" ? w.setProperty(
                      "display",
                      "none",
                      "important"
                    ) : w.display = "none";
                  else {
                    N = oe.stateNode, _ = oe.memoizedProps.style;
                    var ve = _ != null && _.hasOwnProperty("display") ? _.display : null;
                    N.style.display = ve == null || typeof ve == "boolean" ? "" : ("" + ve).trim();
                  }
                } catch (Ue) {
                  Ht(oe, oe.return, Ue);
                }
              }
            } else if (l.tag === 6) {
              if (c === null) {
                oe = l;
                try {
                  oe.stateNode.nodeValue = $ ? "" : oe.memoizedProps;
                } catch (Ue) {
                  Ht(oe, oe.return, Ue);
                }
              }
            } else if ((l.tag !== 22 && l.tag !== 23 || l.memoizedState === null || l === o) && l.child !== null) {
              l.child.return = l, l = l.child;
              continue;
            }
            if (l === o) break e;
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === o) break e;
              c === l && (c = null), l = l.return;
            }
            c === l && (c = null), l.sibling.return = l.return, l = l.sibling;
          }
        h & 4 && (h = o.updateQueue, h !== null && (c = h.retryQueue, c !== null && (h.retryQueue = null, _m(o, c))));
        break;
      case 19:
        ka(l, o), Ea(o), h & 4 && (h = o.updateQueue, h !== null && (o.updateQueue = null, _m(o, h)));
        break;
      case 21:
        break;
      default:
        ka(l, o), Ea(o);
    }
  }
  function Ea(o) {
    var l = o.flags;
    if (l & 2) {
      try {
        if (o.tag !== 27) {
          e: {
            for (var c = o.return; c !== null; ) {
              if (bb(c)) {
                var h = c;
                break e;
              }
              c = c.return;
            }
            throw Error(i(160));
          }
          switch (h.tag) {
            case 27:
              var v = h.stateNode, w = ps(o);
              Rt(o, w, v);
              break;
            case 5:
              var N = h.stateNode;
              h.flags & 32 && (Vo(N, ""), h.flags &= -33);
              var _ = ps(o);
              Rt(o, _, N);
              break;
            case 3:
            case 4:
              var $ = h.stateNode.containerInfo, oe = ps(o);
              Bm(
                o,
                oe,
                $
              );
              break;
            default:
              throw Error(i(161));
          }
        }
      } catch (ke) {
        Ht(o, o.return, ke);
      }
      o.flags &= -3;
    }
    l & 4096 && (o.flags &= -4097);
  }
  function zm(o) {
    if (o.subtreeFlags & 1024)
      for (o = o.child; o !== null; ) {
        var l = o;
        zm(l), l.tag === 5 && l.flags & 1024 && l.stateNode.reset(), o = o.sibling;
      }
  }
  function li(o, l) {
    if (l.subtreeFlags & 8772)
      for (l = l.child; l !== null; )
        vb(o, l.alternate, l), l = l.sibling;
  }
  function Uu(o) {
    for (o = o.child; o !== null; ) {
      var l = o;
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          gl(4, l, l.return), Uu(l);
          break;
        case 1:
          Vr(l, l.return);
          var c = l.stateNode;
          typeof c.componentWillUnmount == "function" && _h(
            l,
            l.return,
            c
          ), Uu(l);
          break;
        case 26:
        case 27:
        case 5:
          Vr(l, l.return), Uu(l);
          break;
        case 22:
          Vr(l, l.return), l.memoizedState === null && Uu(l);
          break;
        default:
          Uu(l);
      }
      o = o.sibling;
    }
  }
  function yl(o, l, c) {
    for (c = c && (l.subtreeFlags & 8772) !== 0, l = l.child; l !== null; ) {
      var h = l.alternate, v = o, w = l, N = w.flags;
      switch (w.tag) {
        case 0:
        case 11:
        case 15:
          yl(
            v,
            w,
            c
          ), Tf(4, w);
          break;
        case 1:
          if (yl(
            v,
            w,
            c
          ), h = w, v = h.stateNode, typeof v.componentDidMount == "function")
            try {
              v.componentDidMount();
            } catch (oe) {
              Ht(h, h.return, oe);
            }
          if (h = w, v = h.updateQueue, v !== null) {
            var _ = h.stateNode;
            try {
              var $ = v.shared.hiddenCallbacks;
              if ($ !== null)
                for (v.shared.hiddenCallbacks = null, v = 0; v < $.length; v++)
                  Xw($[v], _);
            } catch (oe) {
              Ht(h, h.return, oe);
            }
          }
          c && N & 64 && _u(w), ml(w, w.return);
          break;
        case 26:
        case 27:
        case 5:
          yl(
            v,
            w,
            c
          ), c && h === null && N & 4 && e3(w), ml(w, w.return);
          break;
        case 12:
          yl(
            v,
            w,
            c
          );
          break;
        case 13:
          yl(
            v,
            w,
            c
          ), c && N & 4 && If(v, w);
          break;
        case 22:
          w.memoizedState === null && yl(
            v,
            w,
            c
          ), ml(w, w.return);
          break;
        default:
          yl(
            v,
            w,
            c
          );
      }
      l = l.sibling;
    }
  }
  function Hm(o, l) {
    var c = null;
    o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (c = o.memoizedState.cachePool.pool), o = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (o = l.memoizedState.cachePool.pool), o !== c && (o != null && o.refCount++, c != null && cf(c));
  }
  function vt(o, l) {
    o = null, l.alternate !== null && (o = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== o && (l.refCount++, o != null && cf(o));
  }
  function ui(o, l, c, h) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        Vm(
          o,
          l,
          c,
          h
        ), l = l.sibling;
  }
  function Vm(o, l, c, h) {
    var v = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        ui(
          o,
          l,
          c,
          h
        ), v & 2048 && Tf(9, l);
        break;
      case 3:
        ui(
          o,
          l,
          c,
          h
        ), v & 2048 && (o = null, l.alternate !== null && (o = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== o && (l.refCount++, o != null && cf(o)));
        break;
      case 12:
        if (v & 2048) {
          ui(
            o,
            l,
            c,
            h
          ), o = l.stateNode;
          try {
            var w = l.memoizedProps, N = w.id, _ = w.onPostCommit;
            typeof _ == "function" && _(
              N,
              l.alternate === null ? "mount" : "update",
              o.passiveEffectDuration,
              -0
            );
          } catch ($) {
            Ht(l, l.return, $);
          }
        } else
          ui(
            o,
            l,
            c,
            h
          );
        break;
      case 23:
        break;
      case 22:
        w = l.stateNode, l.memoizedState !== null ? w._visibility & 4 ? ui(
          o,
          l,
          c,
          h
        ) : Hu(o, l) : w._visibility & 4 ? ui(
          o,
          l,
          c,
          h
        ) : (w._visibility |= 4, zu(
          o,
          l,
          c,
          h,
          (l.subtreeFlags & 10256) !== 0
        )), v & 2048 && Hm(
          l.alternate,
          l
        );
        break;
      case 24:
        ui(
          o,
          l,
          c,
          h
        ), v & 2048 && vt(l.alternate, l);
        break;
      default:
        ui(
          o,
          l,
          c,
          h
        );
    }
  }
  function zu(o, l, c, h, v) {
    for (v = v && (l.subtreeFlags & 10256) !== 0, l = l.child; l !== null; ) {
      var w = o, N = l, _ = c, $ = h, oe = N.flags;
      switch (N.tag) {
        case 0:
        case 11:
        case 15:
          zu(
            w,
            N,
            _,
            $,
            v
          ), Tf(8, N);
          break;
        case 23:
          break;
        case 22:
          var ke = N.stateNode;
          N.memoizedState !== null ? ke._visibility & 4 ? zu(
            w,
            N,
            _,
            $,
            v
          ) : Hu(
            w,
            N
          ) : (ke._visibility |= 4, zu(
            w,
            N,
            _,
            $,
            v
          )), v && oe & 2048 && Hm(
            N.alternate,
            N
          );
          break;
        case 24:
          zu(
            w,
            N,
            _,
            $,
            v
          ), v && oe & 2048 && vt(N.alternate, N);
          break;
        default:
          zu(
            w,
            N,
            _,
            $,
            v
          );
      }
      l = l.sibling;
    }
  }
  function Hu(o, l) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; ) {
        var c = o, h = l, v = h.flags;
        switch (h.tag) {
          case 22:
            Hu(c, h), v & 2048 && Hm(
              h.alternate,
              h
            );
            break;
          case 24:
            Hu(c, h), v & 2048 && vt(h.alternate, h);
            break;
          default:
            Hu(c, h);
        }
        l = l.sibling;
      }
  }
  var ms = 8192;
  function ys(o) {
    if (o.subtreeFlags & ms)
      for (o = o.child; o !== null; )
        Vu(o), o = o.sibling;
  }
  function Vu(o) {
    switch (o.tag) {
      case 26:
        ys(o), o.flags & ms && o.memoizedState !== null && b6(
          Ka,
          o.memoizedState,
          o.memoizedProps
        );
        break;
      case 5:
        ys(o);
        break;
      case 3:
      case 4:
        var l = Ka;
        Ka = c0(o.stateNode.containerInfo), ys(o), Ka = l;
        break;
      case 22:
        o.memoizedState === null && (l = o.alternate, l !== null && l.memoizedState !== null ? (l = ms, ms = 16777216, ys(o), ms = l) : ys(o));
        break;
      default:
        ys(o);
    }
  }
  function kb(o) {
    var l = o.alternate;
    if (l !== null && (o = l.child, o !== null)) {
      l.child = null;
      do
        l = o.sibling, o.sibling = null, o = l;
      while (o !== null);
    }
  }
  function Wu(o) {
    var l = o.deletions;
    if (o.flags & 16) {
      if (l !== null)
        for (var c = 0; c < l.length; c++) {
          var h = l[c];
          rr = h, Co(
            h,
            o
          );
        }
      kb(o);
    }
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        zn(o), o = o.sibling;
  }
  function zn(o) {
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        Wu(o), o.flags & 2048 && gl(9, o, o.return);
        break;
      case 3:
        Wu(o);
        break;
      case 12:
        Wu(o);
        break;
      case 22:
        var l = o.stateNode;
        o.memoizedState !== null && l._visibility & 4 && (o.return === null || o.return.tag !== 13) ? (l._visibility &= -5, Wm(o)) : Wu(o);
        break;
      default:
        Wu(o);
    }
  }
  function Wm(o) {
    var l = o.deletions;
    if (o.flags & 16) {
      if (l !== null)
        for (var c = 0; c < l.length; c++) {
          var h = l[c];
          rr = h, Co(
            h,
            o
          );
        }
      kb(o);
    }
    for (o = o.child; o !== null; ) {
      switch (l = o, l.tag) {
        case 0:
        case 11:
        case 15:
          gl(8, l, l.return), Wm(l);
          break;
        case 22:
          c = l.stateNode, c._visibility & 4 && (c._visibility &= -5, Wm(l));
          break;
        default:
          Wm(l);
      }
      o = o.sibling;
    }
  }
  function Co(o, l) {
    for (; rr !== null; ) {
      var c = rr;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          gl(8, c, l);
          break;
        case 23:
        case 22:
          if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
            var h = c.memoizedState.cachePool.pool;
            h != null && h.refCount++;
          }
          break;
        case 24:
          cf(c.memoizedState.cache);
      }
      if (h = c.child, h !== null) h.return = c, rr = h;
      else
        e: for (c = o; rr !== null; ) {
          h = rr;
          var v = h.sibling, w = h.return;
          if (wb(h), h === c) {
            rr = null;
            break e;
          }
          if (v !== null) {
            v.return = w, rr = v;
            break e;
          }
          rr = w;
        }
    }
  }
  function o3(o, l, c, h) {
    this.tag = o, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = h, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Hn(o, l, c, h) {
    return new o3(o, l, c, h);
  }
  function Gm(o) {
    return o = o.prototype, !(!o || !o.isReactComponent);
  }
  function To(o, l) {
    var c = o.alternate;
    return c === null ? (c = Hn(
      o.tag,
      l,
      o.key,
      o.mode
    ), c.elementType = o.elementType, c.type = o.type, c.stateNode = o.stateNode, c.alternate = o, o.alternate = c) : (c.pendingProps = l, c.type = o.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = o.flags & 31457280, c.childLanes = o.childLanes, c.lanes = o.lanes, c.child = o.child, c.memoizedProps = o.memoizedProps, c.memoizedState = o.memoizedState, c.updateQueue = o.updateQueue, l = o.dependencies, c.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, c.sibling = o.sibling, c.index = o.index, c.ref = o.ref, c.refCleanup = o.refCleanup, c;
  }
  function Mt(o, l) {
    o.flags &= 31457282;
    var c = o.alternate;
    return c === null ? (o.childLanes = 0, o.lanes = l, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = c.childLanes, o.lanes = c.lanes, o.child = c.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = c.memoizedProps, o.memoizedState = c.memoizedState, o.updateQueue = c.updateQueue, o.type = c.type, l = c.dependencies, o.dependencies = l === null ? null : {
      lanes: l.lanes,
      firstContext: l.firstContext
    }), o;
  }
  function Nf(o, l, c, h, v, w) {
    var N = 0;
    if (h = o, typeof o == "function") Gm(o) && (N = 1);
    else if (typeof o == "string")
      N = ua(
        o,
        c,
        Je.current
      ) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
    else
      e: switch (o) {
        case y:
          return cn(c.children, v, w, l);
        case k:
          N = 8, v |= 24;
          break;
        case S:
          return o = Hn(12, c, l, v | 2), o.elementType = S, o.lanes = w, o;
        case O:
          return o = Hn(13, c, l, v), o.elementType = O, o.lanes = w, o;
        case T:
          return o = Hn(19, c, l, v), o.elementType = T, o.lanes = w, o;
        case W:
          return i3(c, v, w, l);
        default:
          if (typeof o == "object" && o !== null)
            switch (o.$$typeof) {
              case A:
              case M:
                N = 10;
                break e;
              case x:
                N = 9;
                break e;
              case D:
                N = 11;
                break e;
              case L:
                N = 14;
                break e;
              case U:
                N = 16, h = null;
                break e;
            }
          N = 29, c = Error(
            i(130, o === null ? "null" : typeof o, "")
          ), h = null;
      }
    return l = Hn(N, c, l, v), l.elementType = o, l.type = h, l.lanes = w, l;
  }
  function cn(o, l, c, h) {
    return o = Hn(7, o, h, l), o.lanes = c, o;
  }
  function i3(o, l, c, h) {
    o = Hn(22, o, h, l), o.elementType = W, o.lanes = c;
    var v = {
      _visibility: 1,
      _pendingVisibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null,
      _current: null,
      detach: function() {
        var w = v._current;
        if (w === null) throw Error(i(456));
        if (!(v._pendingVisibility & 2)) {
          var N = Go(w, 2);
          N !== null && (v._pendingVisibility |= 2, Vn(N, w, 2));
        }
      },
      attach: function() {
        var w = v._current;
        if (w === null) throw Error(i(456));
        if (v._pendingVisibility & 2) {
          var N = Go(w, 2);
          N !== null && (v._pendingVisibility &= -3, Vn(N, w, 2));
        }
      }
    };
    return o.stateNode = v, o;
  }
  function jm(o, l, c) {
    return o = Hn(6, o, null, l), o.lanes = c, o;
  }
  function Uh(o, l, c) {
    return l = Hn(
      4,
      o.children !== null ? o.children : [],
      o.key,
      l
    ), l.lanes = c, l.stateNode = {
      containerInfo: o.containerInfo,
      pendingChildren: null,
      implementation: o.implementation
    }, l;
  }
  function ci(o) {
    o.flags |= 4;
  }
  function Sa(o, l) {
    if (l.type !== "stylesheet" || l.state.loading & 4)
      o.flags &= -16777217;
    else if (o.flags |= 16777216, !Nl(l)) {
      if (l = ya.current, l !== null && ((xt & 4194176) === xt ? Ko !== null : (xt & 62914560) !== xt && !(xt & 536870912) || l !== Ko))
        throw Tu = im, hh;
      o.flags |= 8192;
    }
  }
  function zh(o, l) {
    l !== null && (o.flags |= 4), o.flags & 16384 && (l = o.tag !== 22 ? Dn() : 536870912, o.lanes |= l, vl |= l);
  }
  function Gu(o, l) {
    if (!Tt)
      switch (o.tailMode) {
        case "hidden":
          l = o.tail;
          for (var c = null; l !== null; )
            l.alternate !== null && (c = l), l = l.sibling;
          c === null ? o.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = o.tail;
          for (var h = null; c !== null; )
            c.alternate !== null && (h = c), c = c.sibling;
          h === null ? l || o.tail === null ? o.tail = null : o.tail.sibling = null : h.sibling = null;
      }
  }
  function rn(o) {
    var l = o.alternate !== null && o.alternate.child === o.child, c = 0, h = 0;
    if (l)
      for (var v = o.child; v !== null; )
        c |= v.lanes | v.childLanes, h |= v.subtreeFlags & 31457280, h |= v.flags & 31457280, v.return = o, v = v.sibling;
    else
      for (v = o.child; v !== null; )
        c |= v.lanes | v.childLanes, h |= v.subtreeFlags, h |= v.flags, v.return = o, v = v.sibling;
    return o.subtreeFlags |= h, o.childLanes = c, l;
  }
  function $m(o, l, c) {
    var h = l.pendingProps;
    switch (dh(l), l.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return rn(l), null;
      case 1:
        return rn(l), null;
      case 3:
        return c = l.stateNode, h = null, o !== null && (h = o.memoizedState.cache), l.memoizedState.cache !== h && (l.flags |= 2048), ii(Un), Ga(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (o === null || o.child === null) && (Au(l) ? ci(l) : o === null || o.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, Ya !== null && (Cb(Ya), Ya = null))), rn(l), null;
      case 26:
        return c = l.memoizedState, o === null ? (ci(l), c !== null ? (rn(l), Sa(l, c)) : (rn(l), l.flags &= -16777217)) : c ? c !== o.memoizedState ? (ci(l), rn(l), Sa(l, c)) : (rn(l), l.flags &= -16777217) : (o.memoizedProps !== h && ci(l), rn(l), l.flags &= -16777217), null;
      case 27:
        Og(l), c = rt.current;
        var v = l.type;
        if (o !== null && l.stateNode != null)
          o.memoizedProps !== h && ci(l);
        else {
          if (!h) {
            if (l.stateNode === null)
              throw Error(i(166));
            return rn(l), null;
          }
          o = Je.current, Au(l) ? M1(l) : (o = gi(v, h, c), l.stateNode = o, ci(l));
        }
        return rn(l), null;
      case 5:
        if (Og(l), c = l.type, o !== null && l.stateNode != null)
          o.memoizedProps !== h && ci(l);
        else {
          if (!h) {
            if (l.stateNode === null)
              throw Error(i(166));
            return rn(l), null;
          }
          if (o = Je.current, Au(l))
            M1(l);
          else {
            switch (v = Yh(
              rt.current
            ), o) {
              case 1:
                o = v.createElementNS(
                  "http://www.w3.org/2000/svg",
                  c
                );
                break;
              case 2:
                o = v.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  c
                );
                break;
              default:
                switch (c) {
                  case "svg":
                    o = v.createElementNS(
                      "http://www.w3.org/2000/svg",
                      c
                    );
                    break;
                  case "math":
                    o = v.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      c
                    );
                    break;
                  case "script":
                    o = v.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild);
                    break;
                  case "select":
                    o = typeof h.is == "string" ? v.createElement("select", { is: h.is }) : v.createElement("select"), h.multiple ? o.multiple = !0 : h.size && (o.size = h.size);
                    break;
                  default:
                    o = typeof h.is == "string" ? v.createElement(c, { is: h.is }) : v.createElement(c);
                }
            }
            o[cr] = l, o[ta] = h;
            e: for (v = l.child; v !== null; ) {
              if (v.tag === 5 || v.tag === 6)
                o.appendChild(v.stateNode);
              else if (v.tag !== 4 && v.tag !== 27 && v.child !== null) {
                v.child.return = v, v = v.child;
                continue;
              }
              if (v === l) break e;
              for (; v.sibling === null; ) {
                if (v.return === null || v.return === l)
                  break e;
                v = v.return;
              }
              v.sibling.return = v.return, v = v.sibling;
            }
            l.stateNode = o;
            e: switch (ar(o, c, h), c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                o = !!h.autoFocus;
                break e;
              case "img":
                o = !0;
                break e;
              default:
                o = !1;
            }
            o && ci(l);
          }
        }
        return rn(l), l.flags &= -16777217, null;
      case 6:
        if (o && l.stateNode != null)
          o.memoizedProps !== h && ci(l);
        else {
          if (typeof h != "string" && l.stateNode === null)
            throw Error(i(166));
          if (o = rt.current, Au(l)) {
            if (o = l.stateNode, c = l.memoizedProps, h = null, v = pr, v !== null)
              switch (v.tag) {
                case 27:
                case 5:
                  h = v.memoizedProps;
              }
            o[cr] = l, o = !!(o.nodeValue === c || h !== null && h.suppressHydrationWarning === !0 || st(o.nodeValue, c)), o || al(l);
          } else
            o = Yh(o).createTextNode(
              h
            ), o[cr] = l, l.stateNode = o;
        }
        return rn(l), null;
      case 13:
        if (h = l.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
          if (v = Au(l), h !== null && h.dehydrated !== null) {
            if (o === null) {
              if (!v) throw Error(i(318));
              if (v = l.memoizedState, v = v !== null ? v.dehydrated : null, !v) throw Error(i(317));
              v[cr] = l;
            } else
              rf(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            rn(l), v = !1;
          } else
            Ya !== null && (Cb(Ya), Ya = null), v = !0;
          if (!v)
            return l.flags & 256 ? (wo(l), l) : (wo(l), null);
        }
        if (wo(l), l.flags & 128)
          return l.lanes = c, l;
        if (c = h !== null, o = o !== null && o.memoizedState !== null, c) {
          h = l.child, v = null, h.alternate !== null && h.alternate.memoizedState !== null && h.alternate.memoizedState.cachePool !== null && (v = h.alternate.memoizedState.cachePool.pool);
          var w = null;
          h.memoizedState !== null && h.memoizedState.cachePool !== null && (w = h.memoizedState.cachePool.pool), w !== v && (h.flags |= 2048);
        }
        return c !== o && c && (l.child.flags |= 8192), zh(l, l.updateQueue), rn(l), null;
      case 4:
        return Ga(), o === null && Ju(l.stateNode.containerInfo), rn(l), null;
      case 10:
        return ii(l.type), rn(l), null;
      case 19:
        if (Ye(Cn), v = l.memoizedState, v === null) return rn(l), null;
        if (h = (l.flags & 128) !== 0, w = v.rendering, w === null)
          if (h) Gu(v, !1);
          else {
            if (on !== 0 || o !== null && o.flags & 128)
              for (o = l.child; o !== null; ) {
                if (w = mh(o), w !== null) {
                  for (l.flags |= 128, Gu(v, !1), o = w.updateQueue, l.updateQueue = o, zh(l, o), l.subtreeFlags = 0, o = c, c = l.child; c !== null; )
                    Mt(c, o), c = c.sibling;
                  return Ve(
                    Cn,
                    Cn.current & 1 | 2
                  ), l.child;
                }
                o = o.sibling;
              }
            v.tail !== null && Xr() > Vh && (l.flags |= 128, h = !0, Gu(v, !1), l.lanes = 4194304);
          }
        else {
          if (!h)
            if (o = mh(w), o !== null) {
              if (l.flags |= 128, h = !0, o = o.updateQueue, l.updateQueue = o, zh(l, o), Gu(v, !0), v.tail === null && v.tailMode === "hidden" && !w.alternate && !Tt)
                return rn(l), null;
            } else
              2 * Xr() - v.renderingStartTime > Vh && c !== 536870912 && (l.flags |= 128, h = !0, Gu(v, !1), l.lanes = 4194304);
          v.isBackwards ? (w.sibling = l.child, l.child = w) : (o = v.last, o !== null ? o.sibling = w : l.child = w, v.last = w);
        }
        return v.tail !== null ? (l = v.tail, v.rendering = l, v.tail = l.sibling, v.renderingStartTime = Xr(), l.sibling = null, o = Cn.current, Ve(Cn, h ? o & 1 | 2 : o & 1), l) : (rn(l), null);
      case 22:
      case 23:
        return wo(l), gh(), h = l.memoizedState !== null, o !== null ? o.memoizedState !== null !== h && (l.flags |= 8192) : h && (l.flags |= 8192), h ? c & 536870912 && !(l.flags & 128) && (rn(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : rn(l), c = l.updateQueue, c !== null && zh(l, c.retryQueue), c = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (c = o.memoizedState.cachePool.pool), h = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (h = l.memoizedState.cachePool.pool), h !== c && (l.flags |= 2048), o !== null && Ye(sl), null;
      case 24:
        return c = null, o !== null && (c = o.memoizedState.cache), l.memoizedState.cache !== c && (l.flags |= 2048), ii(Un), rn(l), null;
      case 25:
        return null;
    }
    throw Error(i(156, l.tag));
  }
  function s3(o, l) {
    switch (dh(l), l.tag) {
      case 1:
        return o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null;
      case 3:
        return ii(Un), Ga(), o = l.flags, o & 65536 && !(o & 128) ? (l.flags = o & -65537 | 128, l) : null;
      case 26:
      case 27:
      case 5:
        return Og(l), null;
      case 13:
        if (wo(l), o = l.memoizedState, o !== null && o.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(i(340));
          rf();
        }
        return o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null;
      case 19:
        return Ye(Cn), null;
      case 4:
        return Ga(), null;
      case 10:
        return ii(l.type), null;
      case 22:
      case 23:
        return wo(l), gh(), o !== null && Ye(sl), o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null;
      case 24:
        return ii(Un), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function l3(o, l) {
    switch (dh(l), l.tag) {
      case 3:
        ii(Un), Ga();
        break;
      case 26:
      case 27:
      case 5:
        Og(l);
        break;
      case 4:
        Ga();
        break;
      case 13:
        wo(l);
        break;
      case 19:
        Ye(Cn);
        break;
      case 10:
        ii(l.type);
        break;
      case 22:
      case 23:
        wo(l), gh(), o !== null && Ye(sl);
        break;
      case 24:
        ii(Un);
    }
  }
  var Qm = {
    getCacheForType: function(o) {
      var l = gr(Un), c = l.data.get(o);
      return c === void 0 && (c = o(), l.data.set(o, c)), c;
    }
  }, u3 = typeof WeakMap == "function" ? WeakMap : Map, an = 0, zt = null, wt = null, xt = 0, $t = 0, Aa = null, fi = !1, Pf = !1, Eb = !1, bs = 0, on = 0, bl = 0, ju = 0, Sb = 0, Ja = 0, vl = 0, Hh = null, di = null, sa = !1, Zm = 0, Vh = 1 / 0, Wh = null, vs = null, Ym = !1, $u = null, Of = 0, Ab = 0, Rf = null, Lf = 0, qm = null;
  function Ir() {
    if (an & 2 && xt !== 0)
      return xt & -xt;
    if (j.T !== null) {
      var o = ts;
      return o !== 0 ? o : _f();
    }
    return Zd();
  }
  function Qu() {
    Ja === 0 && (Ja = !(xt & 536870912) || Tt ? su() : 536870912);
    var o = ya.current;
    return o !== null && (o.flags |= 32), Ja;
  }
  function Vn(o, l, c) {
    (o === zt && $t === 2 || o.cancelPendingCommit !== null) && (wl(o, 0), hi(
      o,
      xt,
      Ja,
      !1
    )), Ho(o, c), (!(an & 2) || o !== zt) && (o === zt && (!(an & 2) && (ju |= c), on === 4 && hi(
      o,
      xt,
      Ja,
      !1
    )), xa(o));
  }
  function xb(o, l, c) {
    if (an & 6) throw Error(i(327));
    var h = !c && (l & 60) === 0 && (l & o.expiredLanes) === 0 || fo(o, l), v = h ? i6(o, l) : Nb(o, l, !0), w = h;
    do {
      if (v === 0) {
        Pf && !h && hi(o, l, 0, !1);
        break;
      } else if (v === 6)
        hi(
          o,
          l,
          0,
          !fi
        );
      else {
        if (c = o.current.alternate, w && !Gh(c)) {
          v = Nb(o, l, !1), w = !1;
          continue;
        }
        if (v === 2) {
          if (w = l, o.errorRecoveryDisabledLanes & w)
            var N = 0;
          else
            N = o.pendingLanes & -536870913, N = N !== 0 ? N : N & 536870912 ? 536870912 : 0;
          if (N !== 0) {
            l = N;
            e: {
              var _ = o;
              v = Hh;
              var $ = _.current.memoizedState.isDehydrated;
              if ($ && (wl(_, N).flags |= 256), N = Nb(
                _,
                N,
                !1
              ), N !== 2) {
                if (Eb && !$) {
                  _.errorRecoveryDisabledLanes |= w, ju |= w, v = 4;
                  break e;
                }
                w = di, di = v, w !== null && Cb(w);
              }
              v = N;
            }
            if (w = !1, v !== 2) continue;
          }
        }
        if (v === 1) {
          wl(o, 0), hi(o, l, 0, !0);
          break;
        }
        e: {
          switch (h = o, v) {
            case 0:
            case 1:
              throw Error(i(345));
            case 4:
              if ((l & 4194176) === l) {
                hi(
                  h,
                  l,
                  Ja,
                  !fi
                );
                break e;
              }
              break;
            case 2:
              di = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(i(329));
          }
          if (h.finishedWork = c, h.finishedLanes = l, (l & 62914560) === l && (w = Zm + 300 - Xr(), 10 < w)) {
            if (hi(
              h,
              l,
              Ja,
              !fi
            ), zo(h, 0) !== 0) break e;
            h.timeoutHandle = Ta(
              Zu.bind(
                null,
                h,
                c,
                di,
                Wh,
                sa,
                l,
                Ja,
                ju,
                vl,
                fi,
                2,
                -0,
                0
              ),
              w
            );
            break e;
          }
          Zu(
            h,
            c,
            di,
            Wh,
            sa,
            l,
            Ja,
            ju,
            vl,
            fi,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    xa(o);
  }
  function Cb(o) {
    di === null ? di = o : di.push.apply(
      di,
      o
    );
  }
  function Zu(o, l, c, h, v, w, N, _, $, oe, ke, Ne, ge) {
    var ve = l.subtreeFlags;
    if ((ve & 8192 || (ve & 16785408) === 16785408) && (tc = { stylesheets: null, count: 0, unsuspend: y6 }, Vu(l), l = b3(), l !== null)) {
      o.cancelPendingCommit = l(
        Ob.bind(
          null,
          o,
          c,
          h,
          v,
          N,
          _,
          $,
          1,
          Ne,
          ge
        )
      ), hi(o, w, N, !oe);
      return;
    }
    Ob(
      o,
      c,
      h,
      v,
      N,
      _,
      $,
      ke,
      Ne,
      ge
    );
  }
  function Gh(o) {
    for (var l = o; ; ) {
      var c = l.tag;
      if ((c === 0 || c === 11 || c === 15) && l.flags & 16384 && (c = l.updateQueue, c !== null && (c = c.stores, c !== null)))
        for (var h = 0; h < c.length; h++) {
          var v = c[h], w = v.getSnapshot;
          v = v.value;
          try {
            if (!Ar(w(), v)) return !1;
          } catch {
            return !1;
          }
        }
      if (c = l.child, l.subtreeFlags & 16384 && c !== null)
        c.return = l, l = c;
      else {
        if (l === o) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === o) return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function hi(o, l, c, h) {
    l &= ~Sb, l &= ~ju, o.suspendedLanes |= l, o.pingedLanes &= ~l, h && (o.warmLanes |= l), h = o.expirationTimes;
    for (var v = l; 0 < v; ) {
      var w = 31 - ea(v), N = 1 << w;
      h[w] = -1, v &= ~N;
    }
    c !== 0 && Dg(o, c, l);
  }
  function Yu() {
    return an & 6 ? !0 : (Mf(0), !1);
  }
  function jh() {
    if (wt !== null) {
      if ($t === 0)
        var o = wt.return;
      else
        o = wt, oi = Fu = null, wh(o), _n = null, il = 0, o = wt;
      for (; o !== null; )
        l3(o.alternate, o), o = o.return;
      wt = null;
    }
  }
  function wl(o, l) {
    o.finishedWork = null, o.finishedLanes = 0;
    var c = o.timeoutHandle;
    c !== -1 && (o.timeoutHandle = -1, mr(c)), c = o.cancelPendingCommit, c !== null && (o.cancelPendingCommit = null, c()), jh(), zt = o, wt = c = To(o.current, null), xt = l, $t = 0, Aa = null, fi = !1, Pf = fo(o, l), Eb = !1, vl = Ja = Sb = ju = bl = on = 0, di = Hh = null, sa = !1, l & 8 && (l |= l & 32);
    var h = o.entangledLanes;
    if (h !== 0)
      for (o = o.entanglements, h &= l; 0 < h; ) {
        var v = 31 - ea(h), w = 1 << v;
        l |= o[v], h &= ~w;
      }
    return bs = l, am(), c;
  }
  function Tb(o, l) {
    ot = null, j.H = er, l === Yo ? (l = ol(), $t = 3) : l === hh ? (l = ol(), $t = 4) : $t = l === fb ? 8 : l !== null && typeof l == "object" && typeof l.then == "function" ? 6 : 1, Aa = l, wt === null && (on = 1, us(
      o,
      Xn(l, o.current)
    ));
  }
  function Ib() {
    var o = j.H;
    return j.H = er, o === null ? er : o;
  }
  function c3() {
    var o = j.A;
    return j.A = Qm, o;
  }
  function Km() {
    on = 4, fi || (xt & 4194176) !== xt && ya.current !== null || (Pf = !0), !(bl & 134217727) && !(ju & 134217727) || zt === null || hi(
      zt,
      xt,
      Ja,
      !1
    );
  }
  function Nb(o, l, c) {
    var h = an;
    an |= 2;
    var v = Ib(), w = c3();
    (zt !== o || xt !== l) && (Wh = null, wl(o, l)), l = !1;
    var N = on;
    e: do
      try {
        if ($t !== 0 && wt !== null) {
          var _ = wt, $ = Aa;
          switch ($t) {
            case 8:
              jh(), N = 6;
              break e;
            case 3:
            case 2:
            case 6:
              ya.current === null && (l = !0);
              var oe = $t;
              if ($t = 0, Aa = null, Df(o, _, $, oe), c && Pf) {
                N = 0;
                break e;
              }
              break;
            default:
              oe = $t, $t = 0, Aa = null, Df(o, _, $, oe);
          }
        }
        o6(), N = on;
        break;
      } catch (ke) {
        Tb(o, ke);
      }
    while (!0);
    return l && o.shellSuspendCounter++, oi = Fu = null, an = h, j.H = v, j.A = w, wt === null && (zt = null, xt = 0, am()), N;
  }
  function o6() {
    for (; wt !== null; ) Xm(wt);
  }
  function i6(o, l) {
    var c = an;
    an |= 2;
    var h = Ib(), v = c3();
    zt !== o || xt !== l ? (Wh = null, Vh = Xr() + 500, wl(o, l)) : Pf = fo(
      o,
      l
    );
    e: do
      try {
        if ($t !== 0 && wt !== null) {
          l = wt;
          var w = Aa;
          t: switch ($t) {
            case 1:
              $t = 0, Aa = null, Df(o, l, w, 1);
              break;
            case 2:
              if (Gw(w)) {
                $t = 0, Aa = null, f3(l);
                break;
              }
              l = function() {
                $t === 2 && zt === o && ($t = 7), xa(o);
              }, w.then(l, l);
              break e;
            case 3:
              $t = 7;
              break e;
            case 4:
              $t = 5;
              break e;
            case 7:
              Gw(w) ? ($t = 0, Aa = null, f3(l)) : ($t = 0, Aa = null, Df(o, l, w, 7));
              break;
            case 5:
              var N = null;
              switch (wt.tag) {
                case 26:
                  N = wt.memoizedState;
                case 5:
                case 27:
                  var _ = wt;
                  if (!N || Nl(N)) {
                    $t = 0, Aa = null;
                    var $ = _.sibling;
                    if ($ !== null) wt = $;
                    else {
                      var oe = _.return;
                      oe !== null ? (wt = oe, e0(oe)) : wt = null;
                    }
                    break t;
                  }
              }
              $t = 0, Aa = null, Df(o, l, w, 5);
              break;
            case 6:
              $t = 0, Aa = null, Df(o, l, w, 6);
              break;
            case 8:
              jh(), on = 6;
              break e;
            default:
              throw Error(i(462));
          }
        }
        Jm();
        break;
      } catch (ke) {
        Tb(o, ke);
      }
    while (!0);
    return oi = Fu = null, j.H = h, j.A = v, an = c, wt !== null ? 0 : (zt = null, xt = 0, am(), on);
  }
  function Jm() {
    for (; wt !== null && !mw(); )
      Xm(wt);
  }
  function Xm(o) {
    var l = Kt(o.alternate, o, bs);
    o.memoizedProps = o.pendingProps, l === null ? e0(o) : wt = l;
  }
  function f3(o) {
    var l = o, c = l.alternate;
    switch (l.tag) {
      case 15:
      case 0:
        l = pb(
          c,
          l,
          l.pendingProps,
          l.type,
          void 0,
          xt
        );
        break;
      case 11:
        l = pb(
          c,
          l,
          l.pendingProps,
          l.type.render,
          l.ref,
          xt
        );
        break;
      case 5:
        wh(l);
      default:
        l3(c, l), l = wt = Mt(l, bs), l = Kt(c, l, bs);
    }
    o.memoizedProps = o.pendingProps, l === null ? e0(o) : wt = l;
  }
  function Df(o, l, c, h) {
    oi = Fu = null, wh(l), _n = null, il = 0;
    var v = l.return;
    try {
      if (dl(
        o,
        v,
        l,
        c,
        xt
      )) {
        on = 1, us(
          o,
          Xn(c, o.current)
        ), wt = null;
        return;
      }
    } catch (w) {
      if (v !== null) throw wt = v, w;
      on = 1, us(
        o,
        Xn(c, o.current)
      ), wt = null;
      return;
    }
    l.flags & 32768 ? (Tt || h === 1 ? o = !0 : Pf || xt & 536870912 ? o = !1 : (fi = o = !0, (h === 2 || h === 3 || h === 6) && (h = ya.current, h !== null && h.tag === 13 && (h.flags |= 16384))), Pb(l, o)) : e0(l);
  }
  function e0(o) {
    var l = o;
    do {
      if (l.flags & 32768) {
        Pb(
          l,
          fi
        );
        return;
      }
      o = l.return;
      var c = $m(
        l.alternate,
        l,
        bs
      );
      if (c !== null) {
        wt = c;
        return;
      }
      if (l = l.sibling, l !== null) {
        wt = l;
        return;
      }
      wt = l = o;
    } while (l !== null);
    on === 0 && (on = 5);
  }
  function Pb(o, l) {
    do {
      var c = s3(o.alternate, o);
      if (c !== null) {
        c.flags &= 32767, wt = c;
        return;
      }
      if (c = o.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !l && (o = o.sibling, o !== null)) {
        wt = o;
        return;
      }
      wt = o = c;
    } while (o !== null);
    on = 6, wt = null;
  }
  function Ob(o, l, c, h, v, w, N, _, $, oe) {
    var ke = j.T, Ne = Pe.p;
    try {
      Pe.p = 2, j.T = null, d3(
        o,
        l,
        c,
        h,
        Ne,
        v,
        w,
        N,
        _,
        $,
        oe
      );
    } finally {
      j.T = ke, Pe.p = Ne;
    }
  }
  function d3(o, l, c, h, v, w, N, _) {
    do
      qu();
    while ($u !== null);
    if (an & 6) throw Error(i(327));
    var $ = o.finishedWork;
    if (h = o.finishedLanes, $ === null) return null;
    if (o.finishedWork = null, o.finishedLanes = 0, $ === o.current) throw Error(i(177));
    o.callbackNode = null, o.callbackPriority = 0, o.cancelPendingCommit = null;
    var oe = $.lanes | $.childLanes;
    if (oe |= ch, Vc(
      o,
      h,
      oe,
      w,
      N,
      _
    ), o === zt && (wt = zt = null, xt = 0), !($.subtreeFlags & 10256) && !($.flags & 10256) || Ym || (Ym = !0, Ab = oe, Rf = c, Bb(ou, function() {
      return qu(), null;
    })), c = ($.flags & 15990) !== 0, $.subtreeFlags & 15990 || c ? (c = j.T, j.T = null, w = Pe.p, Pe.p = 2, N = an, an |= 4, r3(o, $), Um($, o), R1(l0, o.containerInfo), rp = !!s0, l0 = s0 = null, o.current = $, vb(o, $.alternate, $), yw(), an = N, Pe.p = w, j.T = c) : o.current = $, Ym ? (Ym = !1, $u = o, Of = h) : Rb(o, oe), oe = o.pendingLanes, oe === 0 && (vs = null), Yk($.stateNode), xa(o), l !== null)
      for (v = o.onRecoverableError, $ = 0; $ < l.length; $++)
        oe = l[$], v(oe.value, {
          componentStack: oe.stack
        });
    return Of & 3 && qu(), oe = o.pendingLanes, h & 4194218 && oe & 42 ? o === qm ? Lf++ : (Lf = 0, qm = o) : Lf = 0, Mf(0), null;
  }
  function Rb(o, l) {
    (o.pooledCacheLanes &= l) === 0 && (l = o.pooledCache, l != null && (o.pooledCache = null, cf(l)));
  }
  function qu() {
    if ($u !== null) {
      var o = $u, l = Ab;
      Ab = 0;
      var c = Qd(Of), h = j.T, v = Pe.p;
      try {
        if (Pe.p = 32 > c ? 32 : c, j.T = null, $u === null)
          var w = !1;
        else {
          c = Rf, Rf = null;
          var N = $u, _ = Of;
          if ($u = null, Of = 0, an & 6)
            throw Error(i(331));
          var $ = an;
          if (an |= 4, zn(N.current), Vm(N, N.current, _, c), an = $, Mf(0, !1), ur && typeof ur.onPostCommitFiberRoot == "function")
            try {
              ur.onPostCommitFiberRoot(iu, N);
            } catch {
            }
          w = !0;
        }
        return w;
      } finally {
        Pe.p = v, j.T = h, Rb(o, l);
      }
    }
    return !1;
  }
  function t0(o, l, c) {
    l = Xn(c, l), l = So(o.stateNode, l, 2), o = hs(o, l, 2), o !== null && (Ho(o, 2), xa(o));
  }
  function Ht(o, l, c) {
    if (o.tag === 3)
      t0(o, o, c);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          t0(
            l,
            o,
            c
          );
          break;
        } else if (l.tag === 1) {
          var h = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof h.componentDidCatch == "function" && (vs === null || !vs.has(h))) {
            o = Xn(c, o), c = Tm(2), h = hs(l, c, 2), h !== null && (Im(
              c,
              h,
              l,
              o
            ), Ho(h, 2), xa(h));
            break;
          }
        }
        l = l.return;
      }
  }
  function Lb(o, l, c) {
    var h = o.pingCache;
    if (h === null) {
      h = o.pingCache = new u3();
      var v = /* @__PURE__ */ new Set();
      h.set(l, v);
    } else
      v = h.get(l), v === void 0 && (v = /* @__PURE__ */ new Set(), h.set(l, v));
    v.has(c) || (Eb = !0, v.add(c), o = s6.bind(null, o, l, c), l.then(o, o));
  }
  function s6(o, l, c) {
    var h = o.pingCache;
    h !== null && h.delete(l), o.pingedLanes |= o.suspendedLanes & c, o.warmLanes &= ~c, zt === o && (xt & c) === c && (on === 4 || on === 3 && (xt & 62914560) === xt && 300 > Xr() - Zm ? !(an & 2) && wl(o, 0) : Sb |= c, vl === xt && (vl = 0)), xa(o);
  }
  function h3(o, l) {
    l === 0 && (l = Dn()), o = Go(o, l), o !== null && (Ho(o, l), xa(o));
  }
  function l6(o) {
    var l = o.memoizedState, c = 0;
    l !== null && (c = l.retryLane), h3(o, c);
  }
  function Db(o, l) {
    var c = 0;
    switch (o.tag) {
      case 13:
        var h = o.stateNode, v = o.memoizedState;
        v !== null && (c = v.retryLane);
        break;
      case 19:
        h = o.stateNode;
        break;
      case 22:
        h = o.stateNode._retryCache;
        break;
      default:
        throw Error(i(314));
    }
    h !== null && h.delete(l), h3(o, c);
  }
  function Bb(o, l) {
    return au(o, l);
  }
  var Bf = null, Ku = null, n0 = !1, kl = !1, Mb = !1, El = 0;
  function xa(o) {
    o !== Ku && o.next === null && (Ku === null ? Bf = Ku = o : Ku = Ku.next = o), kl = !0, n0 || (n0 = !0, _b(u6));
  }
  function Mf(o, l) {
    if (!Mb && kl) {
      Mb = !0;
      do
        for (var c = !1, h = Bf; h !== null; ) {
          if (o !== 0) {
            var v = h.pendingLanes;
            if (v === 0) var w = 0;
            else {
              var N = h.suspendedLanes, _ = h.pingedLanes;
              w = (1 << 31 - ea(42 | o) + 1) - 1, w &= v & ~(N & ~_), w = w & 201326677 ? w & 201326677 | 1 : w ? w | 2 : 0;
            }
            w !== 0 && (c = !0, Ff(h, w));
          } else
            w = xt, w = zo(
              h,
              h === zt ? w : 0
            ), !(w & 3) || fo(h, w) || (c = !0, Ff(h, w));
          h = h.next;
        }
      while (c);
      Mb = !1;
    }
  }
  function u6() {
    kl = n0 = !1;
    var o = 0;
    El !== 0 && (Pr() && (o = El), El = 0);
    for (var l = Xr(), c = null, h = Bf; h !== null; ) {
      var v = h.next, w = $h(h, l);
      w === 0 ? (h.next = null, c === null ? Bf = v : c.next = v, v === null && (Ku = c)) : (c = h, (o !== 0 || w & 3) && (kl = !0)), h = v;
    }
    Mf(o);
  }
  function $h(o, l) {
    for (var c = o.suspendedLanes, h = o.pingedLanes, v = o.expirationTimes, w = o.pendingLanes & -62914561; 0 < w; ) {
      var N = 31 - ea(w), _ = 1 << N, $ = v[N];
      $ === -1 ? (!(_ & c) || _ & h) && (v[N] = $d(_, l)) : $ <= l && (o.expiredLanes |= _), w &= ~_;
    }
    if (l = zt, c = xt, c = zo(
      o,
      o === l ? c : 0
    ), h = o.callbackNode, c === 0 || o === l && $t === 2 || o.cancelPendingCommit !== null)
      return h !== null && h !== null && $s(h), o.callbackNode = null, o.callbackPriority = 0;
    if (!(c & 3) || fo(o, c)) {
      if (l = c & -c, l === o.callbackPriority) return l;
      switch (h !== null && $s(h), Qd(c)) {
        case 2:
        case 8:
          c = Qs;
          break;
        case 32:
          c = ou;
          break;
        case 268435456:
          c = vw;
          break;
        default:
          c = ou;
      }
      return h = Fb.bind(null, o), c = au(c, h), o.callbackPriority = l, o.callbackNode = c, l;
    }
    return h !== null && h !== null && $s(h), o.callbackPriority = 2, o.callbackNode = null, 2;
  }
  function Fb(o, l) {
    var c = o.callbackNode;
    if (qu() && o.callbackNode !== c)
      return null;
    var h = xt;
    return h = zo(
      o,
      o === zt ? h : 0
    ), h === 0 ? null : (xb(o, h, l), $h(o, Xr()), o.callbackNode != null && o.callbackNode === c ? Fb.bind(null, o) : null);
  }
  function Ff(o, l) {
    if (qu()) return null;
    xb(o, l, !0);
  }
  function _b(o) {
    f6(function() {
      an & 6 ? au(bw, o) : o();
    });
  }
  function _f() {
    return El === 0 && (El = su()), El;
  }
  function Ub(o) {
    return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : Vg("" + o);
  }
  function En(o, l) {
    var c = l.ownerDocument.createElement("input");
    return c.name = l.name, c.value = l.value, o.id && c.setAttribute("form", o.id), l.parentNode.insertBefore(c, l), o = new FormData(o), c.parentNode.removeChild(c), o;
  }
  function zb(o, l, c, h, v) {
    if (l === "submit" && c && c.stateNode === v) {
      var w = Ub(
        (v[ta] || null).action
      ), N = h.submitter;
      N && (l = (l = N[ta] || null) ? Ub(l.formAction) : N.getAttribute("formAction"), l !== null && (w = l, N = null));
      var _ = new $g(
        "action",
        "action",
        null,
        h,
        v
      );
      o.push({
        event: _,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (h.defaultPrevented) {
                if (El !== 0) {
                  var $ = N ? En(v, N) : new FormData(v);
                  ss(
                    c,
                    {
                      pending: !0,
                      data: $,
                      method: v.method,
                      action: w
                    },
                    null,
                    $
                  );
                }
              } else
                typeof w == "function" && (_.preventDefault(), $ = N ? En(v, N) : new FormData(v), ss(
                  c,
                  {
                    pending: !0,
                    data: $,
                    method: v.method,
                    action: w
                  },
                  w,
                  $
                ));
            },
            currentTarget: v
          }
        ]
      });
    }
  }
  for (var Hb = 0; Hb < pn.length; Hb++) {
    var Vb = pn[Hb], Sl = Vb.toLowerCase(), Uf = Vb[0].toUpperCase() + Vb.slice(1);
    ma(
      Sl,
      "on" + Uf
    );
  }
  ma(Vw, "onAnimationEnd"), ma(rm, "onAnimationIteration"), ma(lh, "onAnimationStart"), ma("dblclick", "onDoubleClick"), ma("focusin", "onFocus"), ma("focusout", "onBlur"), ma(Ww, "onTransitionRun"), ma(ht, "onTransitionStart"), ma(Le, "onTransitionCancel"), ma(Eu, "onTransitionEnd"), cu("onMouseEnter", ["mouseout", "mouseover"]), cu("onMouseLeave", ["mouseout", "mouseover"]), cu("onPointerEnter", ["pointerout", "pointerover"]), cu("onPointerLeave", ["pointerout", "pointerover"]), Zs(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Zs(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Zs("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Zs(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Zs(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Zs(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var pi = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), r0 = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(pi)
  );
  function a0(o, l) {
    l = (l & 4) !== 0;
    for (var c = 0; c < o.length; c++) {
      var h = o[c], v = h.event;
      h = h.listeners;
      e: {
        var w = void 0;
        if (l)
          for (var N = h.length - 1; 0 <= N; N--) {
            var _ = h[N], $ = _.instance, oe = _.currentTarget;
            if (_ = _.listener, $ !== w && v.isPropagationStopped())
              break e;
            w = _, v.currentTarget = oe;
            try {
              w(v);
            } catch (ke) {
              Nh(ke);
            }
            v.currentTarget = null, w = $;
          }
        else
          for (N = 0; N < h.length; N++) {
            if (_ = h[N], $ = _.instance, oe = _.currentTarget, _ = _.listener, $ !== w && v.isPropagationStopped())
              break e;
            w = _, v.currentTarget = oe;
            try {
              w(v);
            } catch (ke) {
              Nh(ke);
            }
            v.currentTarget = null, w = $;
          }
      }
    }
  }
  function At(o, l) {
    var c = l[Bg];
    c === void 0 && (c = l[Bg] = /* @__PURE__ */ new Set());
    var h = o + "__bubble";
    c.has(h) || (o0(l, o, 2, !1), c.add(h));
  }
  function Qh(o, l, c) {
    var h = 0;
    l && (h |= 4), o0(
      c,
      o,
      h,
      l
    );
  }
  var Ca = "_reactListening" + Math.random().toString(36).slice(2);
  function Ju(o) {
    if (!o[Ca]) {
      o[Ca] = !0, u1.forEach(function(c) {
        c !== "selectionchange" && (r0.has(c) || Qh(c, !1, o), Qh(c, !0, o));
      });
      var l = o.nodeType === 9 ? o : o.ownerDocument;
      l === null || l[Ca] || (l[Ca] = !0, Qh("selectionchange", !1, l));
    }
  }
  function o0(o, l, c, h) {
    switch (S3(l)) {
      case 2:
        var v = k3;
        break;
      case 8:
        v = E3;
        break;
      default:
        v = h0;
    }
    c = v.bind(
      null,
      l,
      c,
      o
    ), v = void 0, !Yc || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (v = !0), h ? v !== void 0 ? o.addEventListener(l, c, {
      capture: !0,
      passive: v
    }) : o.addEventListener(l, c, !0) : v !== void 0 ? o.addEventListener(l, c, {
      passive: v
    }) : o.addEventListener(l, c, !1);
  }
  function Zh(o, l, c, h, v) {
    var w = h;
    if (!(l & 1) && !(l & 2) && h !== null)
      e: for (; ; ) {
        if (h === null) return;
        var N = h.tag;
        if (N === 3 || N === 4) {
          var _ = h.stateNode.containerInfo;
          if (_ === v || _.nodeType === 8 && _.parentNode === v)
            break;
          if (N === 4)
            for (N = h.return; N !== null; ) {
              var $ = N.tag;
              if (($ === 3 || $ === 4) && ($ = N.stateNode.containerInfo, $ === v || $.nodeType === 8 && $.parentNode === v))
                return;
              N = N.return;
            }
          for (; _ !== null; ) {
            if (N = ji(_), N === null) return;
            if ($ = N.tag, $ === 5 || $ === 6 || $ === 26 || $ === 27) {
              h = w = N;
              continue e;
            }
            _ = _.parentNode;
          }
        }
        h = h.return;
      }
    Qc(function() {
      var oe = w, ke = v1(c), Ne = [];
      e: {
        var ge = uh.get(o);
        if (ge !== void 0) {
          var ve = $g, Ue = o;
          switch (o) {
            case "keypress":
              if (Kd(c) === 0) break e;
            case "keydown":
            case "keyup":
              ve = qg;
              break;
            case "focusin":
              Ue = "focus", ve = k1;
              break;
            case "focusout":
              Ue = "blur", ve = k1;
              break;
            case "beforeblur":
            case "afterblur":
              ve = k1;
              break;
            case "click":
              if (c.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              ve = Tw;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              ve = t6;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              ve = Kg;
              break;
            case Vw:
            case rm:
            case lh:
              ve = Iw;
              break;
            case Eu:
              ve = S1;
              break;
            case "scroll":
            case "scrollend":
              ve = Xk;
              break;
            case "wheel":
              ve = Bw;
              break;
            case "copy":
            case "cut":
            case "paste":
              ve = Pw;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              ve = dr;
              break;
            case "toggle":
            case "beforetoggle":
              ve = Qi;
          }
          var et = (l & 4) !== 0, Jt = !et && (o === "scroll" || o === "scrollend"), ue = et ? ge !== null ? ge + "Capture" : null : ge;
          et = [];
          for (var re = oe, fe; re !== null; ) {
            var Ae = re;
            if (fe = Ae.stateNode, Ae = Ae.tag, Ae !== 5 && Ae !== 26 && Ae !== 27 || fe === null || ue === null || (Ae = Zc(re, ue), Ae != null && et.push(
              Al(re, Ae, fe)
            )), Jt) break;
            re = re.return;
          }
          0 < et.length && (ge = new ve(
            ge,
            Ue,
            null,
            c,
            ke
          ), Ne.push({ event: ge, listeners: et }));
        }
      }
      if (!(l & 7)) {
        e: {
          if (ge = o === "mouseover" || o === "pointerover", ve = o === "mouseout" || o === "pointerout", ge && c !== b1 && (Ue = c.relatedTarget || c.fromElement) && (ji(Ue) || Ue[Gi]))
            break e;
          if ((ve || ge) && (ge = ke.window === ke ? ke : (ge = ke.ownerDocument) ? ge.defaultView || ge.parentWindow : window, ve ? (Ue = c.relatedTarget || c.toElement, ve = oe, Ue = Ue ? ji(Ue) : null, Ue !== null && (Jt = G(Ue), et = Ue.tag, Ue !== Jt || et !== 5 && et !== 27 && et !== 6) && (Ue = null)) : (ve = null, Ue = oe), ve !== Ue)) {
            if (et = Tw, Ae = "onMouseLeave", ue = "onMouseEnter", re = "mouse", (o === "pointerout" || o === "pointerover") && (et = dr, Ae = "onPointerLeave", ue = "onPointerEnter", re = "pointer"), Jt = ve == null ? ge : Wc(ve), fe = Ue == null ? ge : Wc(Ue), ge = new et(
              Ae,
              re + "leave",
              ve,
              c,
              ke
            ), ge.target = Jt, ge.relatedTarget = fe, Ae = null, ji(ke) === oe && (et = new et(
              ue,
              re + "enter",
              Ue,
              c,
              ke
            ), et.target = fe, et.relatedTarget = Jt, Ae = et), Jt = Ae, ve && Ue)
              t: {
                for (et = ve, ue = Ue, re = 0, fe = et; fe; fe = Xu(fe))
                  re++;
                for (fe = 0, Ae = ue; Ae; Ae = Xu(Ae))
                  fe++;
                for (; 0 < re - fe; )
                  et = Xu(et), re--;
                for (; 0 < fe - re; )
                  ue = Xu(ue), fe--;
                for (; re--; ) {
                  if (et === ue || ue !== null && et === ue.alternate)
                    break t;
                  et = Xu(et), ue = Xu(ue);
                }
                et = null;
              }
            else et = null;
            ve !== null && p3(
              Ne,
              ge,
              ve,
              et,
              !1
            ), Ue !== null && Jt !== null && p3(
              Ne,
              Jt,
              Ue,
              et,
              !0
            );
          }
        }
        e: {
          if (ge = oe ? Wc(oe) : window, ve = ge.nodeName && ge.nodeName.toLowerCase(), ve === "select" || ve === "input" && ge.type === "file")
            var ze = Xc;
          else if (Xs(ge))
            if (ef)
              ze = hr;
            else {
              ze = Uw;
              var ut = _w;
            }
          else
            ve = ge.nodeName, !ve || ve.toLowerCase() !== "input" || ge.type !== "checkbox" && ge.type !== "radio" ? oe && hu(oe.elementType) && (ze = Xc) : ze = zw;
          if (ze && (ze = ze(o, oe))) {
            el(
              Ne,
              ze,
              c,
              ke
            );
            break e;
          }
          ut && ut(o, ge, oe), o === "focusout" && oe && ge.type === "number" && oe.memoizedProps.value != null && g1(ge, "number", ge.value);
        }
        switch (ut = oe ? Wc(oe) : window, o) {
          case "focusin":
            (Xs(ut) || ut.contentEditable === "true") && (ga = ut, nm = oe, Qa = null);
            break;
          case "focusout":
            Qa = nm = ga = null;
            break;
          case "mousedown":
            bo = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            bo = !1, sh(Ne, c, ke);
            break;
          case "selectionchange":
            if (L1) break;
          case "keydown":
          case "keyup":
            sh(Ne, c, ke);
        }
        var $e;
        if (yu)
          e: {
            switch (o) {
              case "compositionstart":
                var qe = "onCompositionStart";
                break e;
              case "compositionend":
                qe = "onCompositionEnd";
                break e;
              case "compositionupdate":
                qe = "onCompositionUpdate";
                break e;
            }
            qe = void 0;
          }
        else
          $a ? th(o, c) && (qe = "onCompositionEnd") : o === "keydown" && c.keyCode === 229 && (qe = "onCompositionStart");
        qe && (C1 && c.locale !== "ko" && ($a || qe !== "onCompositionStart" ? qe === "onCompositionEnd" && $a && ($e = jg()) : ($i = ke, Sr = "value" in $i ? $i.value : $i.textContent, $a = !0)), ut = Nr(oe, qe), 0 < ut.length && (qe = new Zg(
          qe,
          o,
          null,
          c,
          ke
        ), Ne.push({ event: qe, listeners: ut }), $e ? qe.data = $e : ($e = ra(c), $e !== null && (qe.data = $e)))), ($e = x1 ? Mw(o, c) : T1(o, c)) && (qe = Nr(oe, "onBeforeInput"), 0 < qe.length && (ut = new Zg(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          ke
        ), Ne.push({
          event: ut,
          listeners: qe
        }), ut.data = $e)), zb(
          Ne,
          o,
          oe,
          c,
          ke
        );
      }
      a0(Ne, l);
    });
  }
  function Al(o, l, c) {
    return {
      instance: o,
      listener: l,
      currentTarget: c
    };
  }
  function Nr(o, l) {
    for (var c = l + "Capture", h = []; o !== null; ) {
      var v = o, w = v.stateNode;
      v = v.tag, v !== 5 && v !== 26 && v !== 27 || w === null || (v = Zc(o, c), v != null && h.unshift(
        Al(o, v, w)
      ), v = Zc(o, l), v != null && h.push(
        Al(o, v, w)
      )), o = o.return;
    }
    return h;
  }
  function Xu(o) {
    if (o === null) return null;
    do
      o = o.return;
    while (o && o.tag !== 5 && o.tag !== 27);
    return o || null;
  }
  function p3(o, l, c, h, v) {
    for (var w = l._reactName, N = []; c !== null && c !== h; ) {
      var _ = c, $ = _.alternate, oe = _.stateNode;
      if (_ = _.tag, $ !== null && $ === h) break;
      _ !== 5 && _ !== 26 && _ !== 27 || oe === null || ($ = oe, v ? (oe = Zc(c, w), oe != null && N.unshift(
        Al(c, oe, $)
      )) : v || (oe = Zc(c, w), oe != null && N.push(
        Al(c, oe, $)
      ))), c = c.return;
    }
    N.length !== 0 && o.push({ event: l, listeners: N });
  }
  var g3 = /\r\n?/g, c6 = /\u0000|\uFFFD/g;
  function me(o) {
    return (typeof o == "string" ? o : "" + o).replace(g3, `
`).replace(c6, "");
  }
  function st(o, l) {
    return l = me(l), me(o) === l;
  }
  function xl() {
  }
  function Ft(o, l, c, h, v, w) {
    switch (c) {
      case "children":
        typeof h == "string" ? l === "body" || l === "textarea" && h === "" || Vo(o, h) : (typeof h == "number" || typeof h == "bigint") && l !== "body" && Vo(o, "" + h);
        break;
      case "className":
        jc(o, "class", h);
        break;
      case "tabIndex":
        jc(o, "tabindex", h);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        jc(o, c, h);
        break;
      case "style":
        y1(o, h, w);
        break;
      case "data":
        if (l !== "object") {
          jc(o, "data", h);
          break;
        }
      case "src":
      case "href":
        if (h === "" && (l !== "a" || c !== "href")) {
          o.removeAttribute(c);
          break;
        }
        if (h == null || typeof h == "function" || typeof h == "symbol" || typeof h == "boolean") {
          o.removeAttribute(c);
          break;
        }
        h = Vg("" + h), o.setAttribute(c, h);
        break;
      case "action":
      case "formAction":
        if (typeof h == "function") {
          o.setAttribute(
            c,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof w == "function" && (c === "formAction" ? (l !== "input" && Ft(o, l, "name", v.name, v, null), Ft(
            o,
            l,
            "formEncType",
            v.formEncType,
            v,
            null
          ), Ft(
            o,
            l,
            "formMethod",
            v.formMethod,
            v,
            null
          ), Ft(
            o,
            l,
            "formTarget",
            v.formTarget,
            v,
            null
          )) : (Ft(o, l, "encType", v.encType, v, null), Ft(o, l, "method", v.method, v, null), Ft(o, l, "target", v.target, v, null)));
        if (h == null || typeof h == "symbol" || typeof h == "boolean") {
          o.removeAttribute(c);
          break;
        }
        h = Vg("" + h), o.setAttribute(c, h);
        break;
      case "onClick":
        h != null && (o.onclick = xl);
        break;
      case "onScroll":
        h != null && At("scroll", o);
        break;
      case "onScrollEnd":
        h != null && At("scrollend", o);
        break;
      case "dangerouslySetInnerHTML":
        if (h != null) {
          if (typeof h != "object" || !("__html" in h))
            throw Error(i(61));
          if (c = h.__html, c != null) {
            if (v.children != null) throw Error(i(60));
            o.innerHTML = c;
          }
        }
        break;
      case "multiple":
        o.multiple = h && typeof h != "function" && typeof h != "symbol";
        break;
      case "muted":
        o.muted = h && typeof h != "function" && typeof h != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (h == null || typeof h == "function" || typeof h == "boolean" || typeof h == "symbol") {
          o.removeAttribute("xlink:href");
          break;
        }
        c = Vg("" + h), o.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          c
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        h != null && typeof h != "function" && typeof h != "symbol" ? o.setAttribute(c, "" + h) : o.removeAttribute(c);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        h && typeof h != "function" && typeof h != "symbol" ? o.setAttribute(c, "") : o.removeAttribute(c);
        break;
      case "capture":
      case "download":
        h === !0 ? o.setAttribute(c, "") : h !== !1 && h != null && typeof h != "function" && typeof h != "symbol" ? o.setAttribute(c, h) : o.removeAttribute(c);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        h != null && typeof h != "function" && typeof h != "symbol" && !isNaN(h) && 1 <= h ? o.setAttribute(c, h) : o.removeAttribute(c);
        break;
      case "rowSpan":
      case "start":
        h == null || typeof h == "function" || typeof h == "symbol" || isNaN(h) ? o.removeAttribute(c) : o.setAttribute(c, h);
        break;
      case "popover":
        At("beforetoggle", o), At("toggle", o), fu(o, "popover", h);
        break;
      case "xlinkActuate":
        ha(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          h
        );
        break;
      case "xlinkArcrole":
        ha(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          h
        );
        break;
      case "xlinkRole":
        ha(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          h
        );
        break;
      case "xlinkShow":
        ha(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          h
        );
        break;
      case "xlinkTitle":
        ha(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          h
        );
        break;
      case "xlinkType":
        ha(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          h
        );
        break;
      case "xmlBase":
        ha(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          h
        );
        break;
      case "xmlLang":
        ha(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          h
        );
        break;
      case "xmlSpace":
        ha(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          h
        );
        break;
      case "is":
        fu(o, "is", h);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = xw.get(c) || c, fu(o, c, h));
    }
  }
  function i0(o, l, c, h, v, w) {
    switch (c) {
      case "style":
        y1(o, h, w);
        break;
      case "dangerouslySetInnerHTML":
        if (h != null) {
          if (typeof h != "object" || !("__html" in h))
            throw Error(i(61));
          if (c = h.__html, c != null) {
            if (v.children != null) throw Error(i(60));
            o.innerHTML = c;
          }
        }
        break;
      case "children":
        typeof h == "string" ? Vo(o, h) : (typeof h == "number" || typeof h == "bigint") && Vo(o, "" + h);
        break;
      case "onScroll":
        h != null && At("scroll", o);
        break;
      case "onScrollEnd":
        h != null && At("scrollend", o);
        break;
      case "onClick":
        h != null && (o.onclick = xl);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!c1.hasOwnProperty(c))
          e: {
            if (c[0] === "o" && c[1] === "n" && (v = c.endsWith("Capture"), l = c.slice(2, v ? c.length - 7 : void 0), w = o[ta] || null, w = w != null ? w[c] : null, typeof w == "function" && o.removeEventListener(l, w, v), typeof h == "function")) {
              typeof w != "function" && w !== null && (c in o ? o[c] = null : o.hasAttribute(c) && o.removeAttribute(c)), o.addEventListener(l, h, v);
              break e;
            }
            c in o ? o[c] = h : h === !0 ? o.setAttribute(c, "") : fu(o, c, h);
          }
    }
  }
  function ar(o, l, c) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        At("error", o), At("load", o);
        var h = !1, v = !1, w;
        for (w in c)
          if (c.hasOwnProperty(w)) {
            var N = c[w];
            if (N != null)
              switch (w) {
                case "src":
                  h = !0;
                  break;
                case "srcSet":
                  v = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(i(137, l));
                default:
                  Ft(o, l, w, N, c, null);
              }
          }
        v && Ft(o, l, "srcSet", c.srcSet, c, null), h && Ft(o, l, "src", c.src, c, null);
        return;
      case "input":
        At("invalid", o);
        var _ = w = N = v = null, $ = null, oe = null;
        for (h in c)
          if (c.hasOwnProperty(h)) {
            var ke = c[h];
            if (ke != null)
              switch (h) {
                case "name":
                  v = ke;
                  break;
                case "type":
                  N = ke;
                  break;
                case "checked":
                  $ = ke;
                  break;
                case "defaultChecked":
                  oe = ke;
                  break;
                case "value":
                  w = ke;
                  break;
                case "defaultValue":
                  _ = ke;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ke != null)
                    throw Error(i(137, l));
                  break;
                default:
                  Ft(o, l, h, ke, c, null);
              }
          }
        p1(
          o,
          w,
          _,
          $,
          oe,
          N,
          v,
          !1
        ), Ug(o);
        return;
      case "select":
        At("invalid", o), h = N = w = null;
        for (v in c)
          if (c.hasOwnProperty(v) && (_ = c[v], _ != null))
            switch (v) {
              case "value":
                w = _;
                break;
              case "defaultValue":
                N = _;
                break;
              case "multiple":
                h = _;
              default:
                Ft(o, l, v, _, c, null);
            }
        l = w, c = N, o.multiple = !!h, l != null ? du(o, !!h, l, !1) : c != null && du(o, !!h, c, !0);
        return;
      case "textarea":
        At("invalid", o), w = v = h = null;
        for (N in c)
          if (c.hasOwnProperty(N) && (_ = c[N], _ != null))
            switch (N) {
              case "value":
                h = _;
                break;
              case "defaultValue":
                v = _;
                break;
              case "children":
                w = _;
                break;
              case "dangerouslySetInnerHTML":
                if (_ != null) throw Error(i(91));
                break;
              default:
                Ft(o, l, N, _, c, null);
            }
        qd(o, h, v, w), Ug(o);
        return;
      case "option":
        for ($ in c)
          if (c.hasOwnProperty($) && (h = c[$], h != null))
            switch ($) {
              case "selected":
                o.selected = h && typeof h != "function" && typeof h != "symbol";
                break;
              default:
                Ft(o, l, $, h, c, null);
            }
        return;
      case "dialog":
        At("cancel", o), At("close", o);
        break;
      case "iframe":
      case "object":
        At("load", o);
        break;
      case "video":
      case "audio":
        for (h = 0; h < pi.length; h++)
          At(pi[h], o);
        break;
      case "image":
        At("error", o), At("load", o);
        break;
      case "details":
        At("toggle", o);
        break;
      case "embed":
      case "source":
      case "link":
        At("error", o), At("load", o);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (oe in c)
          if (c.hasOwnProperty(oe) && (h = c[oe], h != null))
            switch (oe) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(i(137, l));
              default:
                Ft(o, l, oe, h, c, null);
            }
        return;
      default:
        if (hu(l)) {
          for (ke in c)
            c.hasOwnProperty(ke) && (h = c[ke], h !== void 0 && i0(
              o,
              l,
              ke,
              h,
              c,
              void 0
            ));
          return;
        }
    }
    for (_ in c)
      c.hasOwnProperty(_) && (h = c[_], h != null && Ft(o, l, _, h, c, null));
  }
  function m3(o, l, c, h) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var v = null, w = null, N = null, _ = null, $ = null, oe = null, ke = null;
        for (ve in c) {
          var Ne = c[ve];
          if (c.hasOwnProperty(ve) && Ne != null)
            switch (ve) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                $ = Ne;
              default:
                h.hasOwnProperty(ve) || Ft(o, l, ve, null, h, Ne);
            }
        }
        for (var ge in h) {
          var ve = h[ge];
          if (Ne = c[ge], h.hasOwnProperty(ge) && (ve != null || Ne != null))
            switch (ge) {
              case "type":
                w = ve;
                break;
              case "name":
                v = ve;
                break;
              case "checked":
                oe = ve;
                break;
              case "defaultChecked":
                ke = ve;
                break;
              case "value":
                N = ve;
                break;
              case "defaultValue":
                _ = ve;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (ve != null)
                  throw Error(i(137, l));
                break;
              default:
                ve !== Ne && Ft(
                  o,
                  l,
                  ge,
                  ve,
                  h,
                  Ne
                );
            }
        }
        zg(
          o,
          N,
          _,
          $,
          oe,
          ke,
          w,
          v
        );
        return;
      case "select":
        ve = N = _ = ge = null;
        for (w in c)
          if ($ = c[w], c.hasOwnProperty(w) && $ != null)
            switch (w) {
              case "value":
                break;
              case "multiple":
                ve = $;
              default:
                h.hasOwnProperty(w) || Ft(
                  o,
                  l,
                  w,
                  null,
                  h,
                  $
                );
            }
        for (v in h)
          if (w = h[v], $ = c[v], h.hasOwnProperty(v) && (w != null || $ != null))
            switch (v) {
              case "value":
                ge = w;
                break;
              case "defaultValue":
                _ = w;
                break;
              case "multiple":
                N = w;
              default:
                w !== $ && Ft(
                  o,
                  l,
                  v,
                  w,
                  h,
                  $
                );
            }
        l = _, c = N, h = ve, ge != null ? du(o, !!c, ge, !1) : !!h != !!c && (l != null ? du(o, !!c, l, !0) : du(o, !!c, c ? [] : "", !1));
        return;
      case "textarea":
        ve = ge = null;
        for (_ in c)
          if (v = c[_], c.hasOwnProperty(_) && v != null && !h.hasOwnProperty(_))
            switch (_) {
              case "value":
                break;
              case "children":
                break;
              default:
                Ft(o, l, _, null, h, v);
            }
        for (N in h)
          if (v = h[N], w = c[N], h.hasOwnProperty(N) && (v != null || w != null))
            switch (N) {
              case "value":
                ge = v;
                break;
              case "defaultValue":
                ve = v;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (v != null) throw Error(i(91));
                break;
              default:
                v !== w && Ft(o, l, N, v, h, w);
            }
        Hg(o, ge, ve);
        return;
      case "option":
        for (var Ue in c)
          if (ge = c[Ue], c.hasOwnProperty(Ue) && ge != null && !h.hasOwnProperty(Ue))
            switch (Ue) {
              case "selected":
                o.selected = !1;
                break;
              default:
                Ft(
                  o,
                  l,
                  Ue,
                  null,
                  h,
                  ge
                );
            }
        for ($ in h)
          if (ge = h[$], ve = c[$], h.hasOwnProperty($) && ge !== ve && (ge != null || ve != null))
            switch ($) {
              case "selected":
                o.selected = ge && typeof ge != "function" && typeof ge != "symbol";
                break;
              default:
                Ft(
                  o,
                  l,
                  $,
                  ge,
                  h,
                  ve
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var et in c)
          ge = c[et], c.hasOwnProperty(et) && ge != null && !h.hasOwnProperty(et) && Ft(o, l, et, null, h, ge);
        for (oe in h)
          if (ge = h[oe], ve = c[oe], h.hasOwnProperty(oe) && ge !== ve && (ge != null || ve != null))
            switch (oe) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ge != null)
                  throw Error(i(137, l));
                break;
              default:
                Ft(
                  o,
                  l,
                  oe,
                  ge,
                  h,
                  ve
                );
            }
        return;
      default:
        if (hu(l)) {
          for (var Jt in c)
            ge = c[Jt], c.hasOwnProperty(Jt) && ge !== void 0 && !h.hasOwnProperty(Jt) && i0(
              o,
              l,
              Jt,
              void 0,
              h,
              ge
            );
          for (ke in h)
            ge = h[ke], ve = c[ke], !h.hasOwnProperty(ke) || ge === ve || ge === void 0 && ve === void 0 || i0(
              o,
              l,
              ke,
              ge,
              h,
              ve
            );
          return;
        }
    }
    for (var ue in c)
      ge = c[ue], c.hasOwnProperty(ue) && ge != null && !h.hasOwnProperty(ue) && Ft(o, l, ue, null, h, ge);
    for (Ne in h)
      ge = h[Ne], ve = c[Ne], !h.hasOwnProperty(Ne) || ge === ve || ge == null && ve == null || Ft(o, l, Ne, ge, h, ve);
  }
  var s0 = null, l0 = null;
  function Yh(o) {
    return o.nodeType === 9 ? o : o.ownerDocument;
  }
  function u0(o) {
    switch (o) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function Wb(o, l) {
    if (o === 0)
      switch (l) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return o === 1 && l === "foreignObject" ? 0 : o;
  }
  function qh(o, l) {
    return o === "textarea" || o === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.children == "bigint" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var Kh = null;
  function Pr() {
    var o = window.event;
    return o && o.type === "popstate" ? o === Kh ? !1 : (Kh = o, !0) : (Kh = null, !1);
  }
  var Ta = typeof setTimeout == "function" ? setTimeout : void 0, mr = typeof clearTimeout == "function" ? clearTimeout : void 0, Qt = typeof Promise == "function" ? Promise : void 0, f6 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Qt < "u" ? function(o) {
    return Qt.resolve(null).then(o).catch(Gb);
  } : Ta;
  function Gb(o) {
    setTimeout(function() {
      throw o;
    });
  }
  function Jh(o, l) {
    var c = l, h = 0;
    do {
      var v = c.nextSibling;
      if (o.removeChild(c), v && v.nodeType === 8)
        if (c = v.data, c === "/$") {
          if (h === 0) {
            o.removeChild(v), $f(l);
            return;
          }
          h--;
        } else c !== "$" && c !== "$?" && c !== "$!" || h++;
      c = v;
    } while (c);
    $f(l);
  }
  function Io(o) {
    var l = o.firstChild;
    for (l && l.nodeType === 10 && (l = l.nextSibling); l; ) {
      var c = l;
      switch (l = l.nextSibling, c.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Io(c), Fg(c);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (c.rel.toLowerCase() === "stylesheet") continue;
      }
      o.removeChild(c);
    }
  }
  function Cl(o, l, c, h) {
    for (; o.nodeType === 1; ) {
      var v = c;
      if (o.nodeName.toLowerCase() !== l.toLowerCase()) {
        if (!h && (o.nodeName !== "INPUT" || o.type !== "hidden"))
          break;
      } else if (h) {
        if (!o[lu])
          switch (l) {
            case "meta":
              if (!o.hasAttribute("itemprop")) break;
              return o;
            case "link":
              if (w = o.getAttribute("rel"), w === "stylesheet" && o.hasAttribute("data-precedence") || w !== v.rel || o.getAttribute("href") !== (v.href == null ? null : v.href) || o.getAttribute("crossorigin") !== (v.crossOrigin == null ? null : v.crossOrigin) || o.getAttribute("title") !== (v.title == null ? null : v.title))
                break;
              return o;
            case "style":
              if (o.hasAttribute("data-precedence")) break;
              return o;
            case "script":
              if (w = o.getAttribute("src"), (w !== (v.src == null ? null : v.src) || o.getAttribute("type") !== (v.type == null ? null : v.type) || o.getAttribute("crossorigin") !== (v.crossOrigin == null ? null : v.crossOrigin)) && w && o.hasAttribute("async") && !o.hasAttribute("itemprop"))
                break;
              return o;
            default:
              return o;
          }
      } else if (l === "input" && o.type === "hidden") {
        var w = v.name == null ? null : "" + v.name;
        if (v.type === "hidden" && o.getAttribute("name") === w)
          return o;
      } else return o;
      if (o = or(o.nextSibling), o === null) break;
    }
    return null;
  }
  function Xh(o, l, c) {
    if (l === "") return null;
    for (; o.nodeType !== 3; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !c || (o = or(o.nextSibling), o === null)) return null;
    return o;
  }
  function or(o) {
    for (; o != null; o = o.nextSibling) {
      var l = o.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (l = o.data, l === "$" || l === "$!" || l === "$?" || l === "F!" || l === "F")
          break;
        if (l === "/$") return null;
      }
    }
    return o;
  }
  function ep(o) {
    o = o.previousSibling;
    for (var l = 0; o; ) {
      if (o.nodeType === 8) {
        var c = o.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (l === 0) return o;
          l--;
        } else c === "/$" && l++;
      }
      o = o.previousSibling;
    }
    return null;
  }
  function gi(o, l, c) {
    switch (l = Yh(c), o) {
      case "html":
        if (o = l.documentElement, !o) throw Error(i(452));
        return o;
      case "head":
        if (o = l.head, !o) throw Error(i(453));
        return o;
      case "body":
        if (o = l.body, !o) throw Error(i(454));
        return o;
      default:
        throw Error(i(451));
    }
  }
  var la = /* @__PURE__ */ new Map(), y3 = /* @__PURE__ */ new Set();
  function c0(o) {
    return typeof o.getRootNode == "function" ? o.getRootNode() : o.ownerDocument;
  }
  var ws = Pe.d;
  Pe.d = {
    f: mi,
    r: d6,
    D: zf,
    C: h6,
    L: jb,
    m: p6,
    X: Hf,
    S: g6,
    M: Or
  };
  function mi() {
    var o = ws.f(), l = Yu();
    return o || l;
  }
  function d6(o) {
    var l = uu(o);
    l !== null && l.tag === 5 && l.type === "form" ? X1(l) : ws.r(o);
  }
  var Tl = typeof document > "u" ? null : document;
  function f0(o, l, c) {
    var h = Tl;
    if (h && typeof l == "string" && l) {
      var v = ja(l);
      v = 'link[rel="' + o + '"][href="' + v + '"]', typeof c == "string" && (v += '[crossorigin="' + c + '"]'), y3.has(v) || (y3.add(v), o = { rel: o, crossOrigin: c, href: l }, h.querySelector(v) === null && (l = h.createElement("link"), ar(l, "link", o), Mn(l), h.head.appendChild(l)));
    }
  }
  function zf(o) {
    ws.D(o), f0("dns-prefetch", o, null);
  }
  function h6(o, l) {
    ws.C(o, l), f0("preconnect", o, l);
  }
  function jb(o, l, c) {
    ws.L(o, l, c);
    var h = Tl;
    if (h && o && l) {
      var v = 'link[rel="preload"][as="' + ja(l) + '"]';
      l === "image" && c && c.imageSrcSet ? (v += '[imagesrcset="' + ja(
        c.imageSrcSet
      ) + '"]', typeof c.imageSizes == "string" && (v += '[imagesizes="' + ja(
        c.imageSizes
      ) + '"]')) : v += '[href="' + ja(o) + '"]';
      var w = v;
      switch (l) {
        case "style":
          w = Wr(o);
          break;
        case "script":
          w = Vf(o);
      }
      la.has(w) || (o = ne(
        {
          rel: "preload",
          href: l === "image" && c && c.imageSrcSet ? void 0 : o,
          as: l
        },
        c
      ), la.set(w, o), h.querySelector(v) !== null || l === "style" && h.querySelector(Gr(w)) || l === "script" && h.querySelector(Il(w)) || (l = h.createElement("link"), ar(l, "link", o), Mn(l), h.head.appendChild(l)));
    }
  }
  function p6(o, l) {
    ws.m(o, l);
    var c = Tl;
    if (c && o) {
      var h = l && typeof l.as == "string" ? l.as : "script", v = 'link[rel="modulepreload"][as="' + ja(h) + '"][href="' + ja(o) + '"]', w = v;
      switch (h) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          w = Vf(o);
      }
      if (!la.has(w) && (o = ne({ rel: "modulepreload", href: o }, l), la.set(w, o), c.querySelector(v) === null)) {
        switch (h) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (c.querySelector(Il(w)))
              return;
        }
        h = c.createElement("link"), ar(h, "link", o), Mn(h), c.head.appendChild(h);
      }
    }
  }
  function g6(o, l, c) {
    ws.S(o, l, c);
    var h = Tl;
    if (h && o) {
      var v = po(h).hoistableStyles, w = Wr(o);
      l = l || "default";
      var N = v.get(w);
      if (!N) {
        var _ = { loading: 0, preload: null };
        if (N = h.querySelector(
          Gr(w)
        ))
          _.loading = 5;
        else {
          o = ne(
            { rel: "stylesheet", href: o, "data-precedence": l },
            c
          ), (c = la.get(w)) && Xa(o, c);
          var $ = N = h.createElement("link");
          Mn($), ar($, "link", o), $._p = new Promise(function(oe, ke) {
            $.onload = oe, $.onerror = ke;
          }), $.addEventListener("load", function() {
            _.loading |= 1;
          }), $.addEventListener("error", function() {
            _.loading |= 2;
          }), _.loading |= 4, Ia(N, l, h);
        }
        N = {
          type: "stylesheet",
          instance: N,
          count: 1,
          state: _
        }, v.set(w, N);
      }
    }
  }
  function Hf(o, l) {
    ws.X(o, l);
    var c = Tl;
    if (c && o) {
      var h = po(c).hoistableScripts, v = Vf(o), w = h.get(v);
      w || (w = c.querySelector(Il(v)), w || (o = ne({ src: o, async: !0 }, l), (l = la.get(v)) && No(o, l), w = c.createElement("script"), Mn(w), ar(w, "link", o), c.head.appendChild(w)), w = {
        type: "script",
        instance: w,
        count: 1,
        state: null
      }, h.set(v, w));
    }
  }
  function Or(o, l) {
    ws.M(o, l);
    var c = Tl;
    if (c && o) {
      var h = po(c).hoistableScripts, v = Vf(o), w = h.get(v);
      w || (w = c.querySelector(Il(v)), w || (o = ne({ src: o, async: !0, type: "module" }, l), (l = la.get(v)) && No(o, l), w = c.createElement("script"), Mn(w), ar(w, "link", o), c.head.appendChild(w)), w = {
        type: "script",
        instance: w,
        count: 1,
        state: null
      }, h.set(v, w));
    }
  }
  function Me(o, l, c, h) {
    var v = (v = rt.current) ? c0(v) : null;
    if (!v) throw Error(i(446));
    switch (o) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof c.precedence == "string" && typeof c.href == "string" ? (l = Wr(c.href), c = po(
          v
        ).hoistableStyles, h = c.get(l), h || (h = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, c.set(l, h)), h) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
          o = Wr(c.href);
          var w = po(
            v
          ).hoistableStyles, N = w.get(o);
          if (N || (v = v.ownerDocument || v, N = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, w.set(o, N), (w = v.querySelector(
            Gr(o)
          )) && !w._p && (N.instance = w, N.state.loading = 5), la.has(o) || (c = {
            rel: "preload",
            as: "style",
            href: c.href,
            crossOrigin: c.crossOrigin,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
          }, la.set(o, c), w || m6(
            v,
            o,
            c,
            N.state
          ))), l && h === null)
            throw Error(i(528, ""));
          return N;
        }
        if (l && h !== null)
          throw Error(i(529, ""));
        return null;
      case "script":
        return l = c.async, c = c.src, typeof c == "string" && l && typeof l != "function" && typeof l != "symbol" ? (l = Vf(c), c = po(
          v
        ).hoistableScripts, h = c.get(l), h || (h = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, c.set(l, h)), h) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(i(444, o));
    }
  }
  function Wr(o) {
    return 'href="' + ja(o) + '"';
  }
  function Gr(o) {
    return 'link[rel="stylesheet"][' + o + "]";
  }
  function Rr(o) {
    return ne({}, o, {
      "data-precedence": o.precedence,
      precedence: null
    });
  }
  function m6(o, l, c, h) {
    o.querySelector('link[rel="preload"][as="style"][' + l + "]") ? h.loading = 1 : (l = o.createElement("link"), h.preload = l, l.addEventListener("load", function() {
      return h.loading |= 1;
    }), l.addEventListener("error", function() {
      return h.loading |= 2;
    }), ar(l, "link", c), Mn(l), o.head.appendChild(l));
  }
  function Vf(o) {
    return '[src="' + ja(o) + '"]';
  }
  function Il(o) {
    return "script[async]" + o;
  }
  function tp(o, l, c) {
    if (l.count++, l.instance === null)
      switch (l.type) {
        case "style":
          var h = o.querySelector(
            'style[data-href~="' + ja(c.href) + '"]'
          );
          if (h)
            return l.instance = h, Mn(h), h;
          var v = ne({}, c, {
            "data-href": c.href,
            "data-precedence": c.precedence,
            href: null,
            precedence: null
          });
          return h = (o.ownerDocument || o).createElement(
            "style"
          ), Mn(h), ar(h, "style", v), Ia(h, c.precedence, o), l.instance = h;
        case "stylesheet":
          v = Wr(c.href);
          var w = o.querySelector(
            Gr(v)
          );
          if (w)
            return l.state.loading |= 4, l.instance = w, Mn(w), w;
          h = Rr(c), (v = la.get(v)) && Xa(h, v), w = (o.ownerDocument || o).createElement("link"), Mn(w);
          var N = w;
          return N._p = new Promise(function(_, $) {
            N.onload = _, N.onerror = $;
          }), ar(w, "link", h), l.state.loading |= 4, Ia(w, c.precedence, o), l.instance = w;
        case "script":
          return w = Vf(c.src), (v = o.querySelector(
            Il(w)
          )) ? (l.instance = v, Mn(v), v) : (h = c, (v = la.get(w)) && (h = ne({}, c), No(h, v)), o = o.ownerDocument || o, v = o.createElement("script"), Mn(v), ar(v, "link", h), o.head.appendChild(v), l.instance = v);
        case "void":
          return null;
        default:
          throw Error(i(443, l.type));
      }
    else
      l.type === "stylesheet" && !(l.state.loading & 4) && (h = l.instance, l.state.loading |= 4, Ia(h, c.precedence, o));
    return l.instance;
  }
  function Ia(o, l, c) {
    for (var h = c.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), v = h.length ? h[h.length - 1] : null, w = v, N = 0; N < h.length; N++) {
      var _ = h[N];
      if (_.dataset.precedence === l) w = _;
      else if (w !== v) break;
    }
    w ? w.parentNode.insertBefore(o, w.nextSibling) : (l = c.nodeType === 9 ? c.head : c, l.insertBefore(o, l.firstChild));
  }
  function Xa(o, l) {
    o.crossOrigin == null && (o.crossOrigin = l.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = l.referrerPolicy), o.title == null && (o.title = l.title);
  }
  function No(o, l) {
    o.crossOrigin == null && (o.crossOrigin = l.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = l.referrerPolicy), o.integrity == null && (o.integrity = l.integrity);
  }
  var ec = null;
  function ks(o, l, c) {
    if (ec === null) {
      var h = /* @__PURE__ */ new Map(), v = ec = /* @__PURE__ */ new Map();
      v.set(c, h);
    } else
      v = ec, h = v.get(c), h || (h = /* @__PURE__ */ new Map(), v.set(c, h));
    if (h.has(o)) return h;
    for (h.set(o, null), c = c.getElementsByTagName(o), v = 0; v < c.length; v++) {
      var w = c[v];
      if (!(w[lu] || w[cr] || o === "link" && w.getAttribute("rel") === "stylesheet") && w.namespaceURI !== "http://www.w3.org/2000/svg") {
        var N = w.getAttribute(l) || "";
        N = o + N;
        var _ = h.get(N);
        _ ? _.push(w) : h.set(N, [w]);
      }
    }
    return h;
  }
  function yr(o, l, c) {
    o = o.ownerDocument || o, o.head.insertBefore(
      c,
      l === "title" ? o.querySelector("head > title") : null
    );
  }
  function ua(o, l, c) {
    if (c === 1 || l.itemProp != null) return !1;
    switch (o) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof l.precedence != "string" || typeof l.href != "string" || l.href === "")
          break;
        return !0;
      case "link":
        if (typeof l.rel != "string" || typeof l.href != "string" || l.href === "" || l.onLoad || l.onError)
          break;
        switch (l.rel) {
          case "stylesheet":
            return o = l.disabled, typeof l.precedence == "string" && o == null;
          default:
            return !0;
        }
      case "script":
        if (l.async && typeof l.async != "function" && typeof l.async != "symbol" && !l.onLoad && !l.onError && l.src && typeof l.src == "string")
          return !0;
    }
    return !1;
  }
  function Nl(o) {
    return !(o.type === "stylesheet" && !(o.state.loading & 3));
  }
  var tc = null;
  function y6() {
  }
  function b6(o, l, c) {
    if (tc === null) throw Error(i(475));
    var h = tc;
    if (l.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && !(l.state.loading & 4)) {
      if (l.instance === null) {
        var v = Wr(c.href), w = o.querySelector(
          Gr(v)
        );
        if (w) {
          o = w._p, o !== null && typeof o == "object" && typeof o.then == "function" && (h.count++, h = Pl.bind(h), o.then(h, h)), l.state.loading |= 4, l.instance = w, Mn(w);
          return;
        }
        w = o.ownerDocument || o, c = Rr(c), (v = la.get(v)) && Xa(c, v), w = w.createElement("link"), Mn(w);
        var N = w;
        N._p = new Promise(function(_, $) {
          N.onload = _, N.onerror = $;
        }), ar(w, "link", c), l.instance = w;
      }
      h.stylesheets === null && (h.stylesheets = /* @__PURE__ */ new Map()), h.stylesheets.set(l, o), (o = l.state.preload) && !(l.state.loading & 3) && (h.count++, l = Pl.bind(h), o.addEventListener("load", l), o.addEventListener("error", l));
    }
  }
  function b3() {
    if (tc === null) throw Error(i(475));
    var o = tc;
    return o.stylesheets && o.count === 0 && Es(o, o.stylesheets), 0 < o.count ? function(l) {
      var c = setTimeout(function() {
        if (o.stylesheets && Es(o, o.stylesheets), o.unsuspend) {
          var h = o.unsuspend;
          o.unsuspend = null, h();
        }
      }, 6e4);
      return o.unsuspend = l, function() {
        o.unsuspend = null, clearTimeout(c);
      };
    } : null;
  }
  function Pl() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) Es(this, this.stylesheets);
      else if (this.unsuspend) {
        var o = this.unsuspend;
        this.unsuspend = null, o();
      }
    }
  }
  var np = null;
  function Es(o, l) {
    o.stylesheets = null, o.unsuspend !== null && (o.count++, np = /* @__PURE__ */ new Map(), l.forEach($b, o), np = null, Pl.call(o));
  }
  function $b(o, l) {
    if (!(l.state.loading & 4)) {
      var c = np.get(o);
      if (c) var h = c.get(null);
      else {
        c = /* @__PURE__ */ new Map(), np.set(o, c);
        for (var v = o.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), w = 0; w < v.length; w++) {
          var N = v[w];
          (N.nodeName === "LINK" || N.getAttribute("media") !== "not all") && (c.set(N.dataset.precedence, N), h = N);
        }
        h && c.set(null, h);
      }
      v = l.instance, N = v.getAttribute("data-precedence"), w = c.get(N) || h, w === h && c.set(null, v), c.set(N, v), this.count++, h = Pl.bind(this), v.addEventListener("load", h), v.addEventListener("error", h), w ? w.parentNode.insertBefore(v, w.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(v, o.firstChild)), l.state.loading |= 4;
    }
  }
  var ca = {
    $$typeof: M,
    Provider: null,
    Consumer: null,
    _currentValue: Fe,
    _currentValue2: Fe,
    _threadCount: 0
  };
  function v6(o, l, c, h, v, w, N, _) {
    this.tag = 1, this.containerInfo = o, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Vi(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Vi(0), this.hiddenUpdates = Vi(null), this.identifierPrefix = h, this.onUncaughtError = v, this.onCaughtError = w, this.onRecoverableError = N, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = _, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function v3(o, l, c, h, v, w, N, _, $, oe, ke, Ne) {
    return o = new v6(
      o,
      l,
      c,
      N,
      _,
      $,
      oe,
      Ne
    ), l = 1, w === !0 && (l |= 24), w = Hn(3, null, null, l), o.current = w, w.stateNode = o, l = V1(), l.refCount++, o.pooledCache = l, l.refCount++, w.memoizedState = {
      element: h,
      isDehydrated: c,
      cache: l
    }, Dh(w), o;
  }
  function Qb(o) {
    return o ? (o = jo, o) : jo;
  }
  function Zb(o, l, c, h, v, w) {
    v = Qb(v), h.context === null ? h.context = v : h.pendingContext = v, h = ds(l), h.payload = { element: c }, w = w === void 0 ? null : w, w !== null && (h.callback = w), c = hs(o, h, l), c !== null && (Vn(c, o, l), xf(c, o, l));
  }
  function w3(o, l) {
    if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
      var c = o.retryLane;
      o.retryLane = c !== 0 && c < l ? c : l;
    }
  }
  function d0(o, l) {
    w3(o, l), (o = o.alternate) && w3(o, l);
  }
  function Yb(o) {
    if (o.tag === 13) {
      var l = Go(o, 67108864);
      l !== null && Vn(l, o, 67108864), d0(o, 67108864);
    }
  }
  var rp = !0;
  function k3(o, l, c, h) {
    var v = j.T;
    j.T = null;
    var w = Pe.p;
    try {
      Pe.p = 2, h0(o, l, c, h);
    } finally {
      Pe.p = w, j.T = v;
    }
  }
  function E3(o, l, c, h) {
    var v = j.T;
    j.T = null;
    var w = Pe.p;
    try {
      Pe.p = 8, h0(o, l, c, h);
    } finally {
      Pe.p = w, j.T = v;
    }
  }
  function h0(o, l, c, h) {
    if (rp) {
      var v = p0(h);
      if (v === null)
        Zh(
          o,
          l,
          h,
          ap,
          c
        ), Kb(o, h);
      else if (w6(
        v,
        o,
        l,
        c,
        h
      ))
        h.stopPropagation();
      else if (Kb(o, h), l & 4 && -1 < qb.indexOf(o)) {
        for (; v !== null; ) {
          var w = uu(v);
          if (w !== null)
            switch (w.tag) {
              case 3:
                if (w = w.stateNode, w.current.memoizedState.isDehydrated) {
                  var N = Hi(w.pendingLanes);
                  if (N !== 0) {
                    var _ = w;
                    for (_.pendingLanes |= 2, _.entangledLanes |= 2; N; ) {
                      var $ = 1 << 31 - ea(N);
                      _.entanglements[1] |= $, N &= ~$;
                    }
                    xa(w), !(an & 6) && (Vh = Xr() + 500, Mf(0));
                  }
                }
                break;
              case 13:
                _ = Go(w, 2), _ !== null && Vn(_, w, 2), Yu(), d0(w, 2);
            }
          if (w = p0(h), w === null && Zh(
            o,
            l,
            h,
            ap,
            c
          ), w === v) break;
          v = w;
        }
        v !== null && h.stopPropagation();
      } else
        Zh(
          o,
          l,
          h,
          null,
          c
        );
    }
  }
  function p0(o) {
    return o = v1(o), g0(o);
  }
  var ap = null;
  function g0(o) {
    if (ap = null, o = ji(o), o !== null) {
      var l = G(o);
      if (l === null) o = null;
      else {
        var c = l.tag;
        if (c === 13) {
          if (o = ie(l), o !== null) return o;
          o = null;
        } else if (c === 3) {
          if (l.stateNode.current.memoizedState.isDehydrated)
            return l.tag === 3 ? l.stateNode.containerInfo : null;
          o = null;
        } else l !== o && (o = null);
      }
    }
    return ap = o, null;
  }
  function S3(o) {
    switch (o) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Zk()) {
          case bw:
            return 2;
          case Qs:
            return 8;
          case ou:
          case Gd:
            return 32;
          case vw:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var m0 = !1, Ol = null, Rl = null, Ss = null, Ll = /* @__PURE__ */ new Map(), Dl = /* @__PURE__ */ new Map(), Na = [], qb = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Kb(o, l) {
    switch (o) {
      case "focusin":
      case "focusout":
        Ol = null;
        break;
      case "dragenter":
      case "dragleave":
        Rl = null;
        break;
      case "mouseover":
      case "mouseout":
        Ss = null;
        break;
      case "pointerover":
      case "pointerout":
        Ll.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Dl.delete(l.pointerId);
    }
  }
  function Wf(o, l, c, h, v, w) {
    return o === null || o.nativeEvent !== w ? (o = {
      blockedOn: l,
      domEventName: c,
      eventSystemFlags: h,
      nativeEvent: w,
      targetContainers: [v]
    }, l !== null && (l = uu(l), l !== null && Yb(l)), o) : (o.eventSystemFlags |= h, l = o.targetContainers, v !== null && l.indexOf(v) === -1 && l.push(v), o);
  }
  function w6(o, l, c, h, v) {
    switch (l) {
      case "focusin":
        return Ol = Wf(
          Ol,
          o,
          l,
          c,
          h,
          v
        ), !0;
      case "dragenter":
        return Rl = Wf(
          Rl,
          o,
          l,
          c,
          h,
          v
        ), !0;
      case "mouseover":
        return Ss = Wf(
          Ss,
          o,
          l,
          c,
          h,
          v
        ), !0;
      case "pointerover":
        var w = v.pointerId;
        return Ll.set(
          w,
          Wf(
            Ll.get(w) || null,
            o,
            l,
            c,
            h,
            v
          )
        ), !0;
      case "gotpointercapture":
        return w = v.pointerId, Dl.set(
          w,
          Wf(
            Dl.get(w) || null,
            o,
            l,
            c,
            h,
            v
          )
        ), !0;
    }
    return !1;
  }
  function A3(o) {
    var l = ji(o.target);
    if (l !== null) {
      var c = G(l);
      if (c !== null) {
        if (l = c.tag, l === 13) {
          if (l = ie(c), l !== null) {
            o.blockedOn = l, Wi(o.priority, function() {
              if (c.tag === 13) {
                var h = Ir(), v = Go(c, h);
                v !== null && Vn(v, c, h), d0(c, h);
              }
            });
            return;
          }
        } else if (l === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          o.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    o.blockedOn = null;
  }
  function y0(o) {
    if (o.blockedOn !== null) return !1;
    for (var l = o.targetContainers; 0 < l.length; ) {
      var c = p0(o.nativeEvent);
      if (c === null) {
        c = o.nativeEvent;
        var h = new c.constructor(
          c.type,
          c
        );
        b1 = h, c.target.dispatchEvent(h), b1 = null;
      } else
        return l = uu(c), l !== null && Yb(l), o.blockedOn = c, !1;
      l.shift();
    }
    return !0;
  }
  function Jb(o, l, c) {
    y0(o) && c.delete(l);
  }
  function Gf() {
    m0 = !1, Ol !== null && y0(Ol) && (Ol = null), Rl !== null && y0(Rl) && (Rl = null), Ss !== null && y0(Ss) && (Ss = null), Ll.forEach(Jb), Dl.forEach(Jb);
  }
  function jf(o, l) {
    o.blockedOn === l && (o.blockedOn = null, m0 || (m0 = !0, a.unstable_scheduleCallback(
      a.unstable_NormalPriority,
      Gf
    )));
  }
  var op = null;
  function Xb(o) {
    op !== o && (op = o, a.unstable_scheduleCallback(
      a.unstable_NormalPriority,
      function() {
        op === o && (op = null);
        for (var l = 0; l < o.length; l += 3) {
          var c = o[l], h = o[l + 1], v = o[l + 2];
          if (typeof h != "function") {
            if (g0(h || c) === null)
              continue;
            break;
          }
          var w = uu(c);
          w !== null && (o.splice(l, 3), l -= 3, ss(
            w,
            {
              pending: !0,
              data: v,
              method: c.method,
              action: h
            },
            h,
            v
          ));
        }
      }
    ));
  }
  function $f(o) {
    function l($) {
      return jf($, o);
    }
    Ol !== null && jf(Ol, o), Rl !== null && jf(Rl, o), Ss !== null && jf(Ss, o), Ll.forEach(l), Dl.forEach(l);
    for (var c = 0; c < Na.length; c++) {
      var h = Na[c];
      h.blockedOn === o && (h.blockedOn = null);
    }
    for (; 0 < Na.length && (c = Na[0], c.blockedOn === null); )
      A3(c), c.blockedOn === null && Na.shift();
    if (c = (o.ownerDocument || o).$$reactFormReplay, c != null)
      for (h = 0; h < c.length; h += 3) {
        var v = c[h], w = c[h + 1], N = v[ta] || null;
        if (typeof w == "function")
          N || Xb(c);
        else if (N) {
          var _ = null;
          if (w && w.hasAttribute("formAction")) {
            if (v = w, N = w[ta] || null)
              _ = N.formAction;
            else if (g0(v) !== null) continue;
          } else _ = N.action;
          typeof _ == "function" ? c[h + 1] = _ : (c.splice(h, 3), h -= 3), Xb(c);
        }
      }
  }
  function e2(o) {
    this._internalRoot = o;
  }
  nc.prototype.render = e2.prototype.render = function(o) {
    var l = this._internalRoot;
    if (l === null) throw Error(i(409));
    var c = l.current, h = Ir();
    Zb(c, h, o, l, null, null);
  }, nc.prototype.unmount = e2.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
      this._internalRoot = null;
      var l = o.containerInfo;
      o.tag === 0 && qu(), Zb(o.current, 2, null, o, null, null), Yu(), l[Gi] = null;
    }
  };
  function nc(o) {
    this._internalRoot = o;
  }
  nc.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
      var l = Zd();
      o = { blockedOn: null, target: o, priority: l };
      for (var c = 0; c < Na.length && l !== 0 && l < Na[c].priority; c++) ;
      Na.splice(c, 0, o), c === 0 && A3(o);
    }
  };
  var t2 = e.version;
  if (t2 !== "19.0.0")
    throw Error(
      i(
        527,
        t2,
        "19.0.0"
      )
    );
  Pe.findDOMNode = function(o) {
    var l = o._reactInternals;
    if (l === void 0)
      throw typeof o.render == "function" ? Error(i(188)) : (o = Object.keys(o).join(","), Error(i(268, o)));
    return o = xe(l), o = o !== null ? Ce(o) : null, o = o === null ? null : o.stateNode, o;
  };
  var Qf = {
    bundleType: 0,
    version: "19.0.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: j,
    findFiberByHostInstance: ji,
    reconcilerVersion: "19.0.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var b0 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!b0.isDisabled && b0.supportsFiber)
      try {
        iu = b0.inject(
          Qf
        ), ur = b0;
      } catch {
      }
  }
  return M2.createRoot = function(o, l) {
    if (!u(o)) throw Error(i(299));
    var c = !1, h = "", v = Kw, w = Eo, N = ub, _ = null;
    return l != null && (l.unstable_strictMode === !0 && (c = !0), l.identifierPrefix !== void 0 && (h = l.identifierPrefix), l.onUncaughtError !== void 0 && (v = l.onUncaughtError), l.onCaughtError !== void 0 && (w = l.onCaughtError), l.onRecoverableError !== void 0 && (N = l.onRecoverableError), l.unstable_transitionCallbacks !== void 0 && (_ = l.unstable_transitionCallbacks)), l = v3(
      o,
      1,
      !1,
      null,
      null,
      c,
      h,
      v,
      w,
      N,
      _,
      null
    ), o[Gi] = l.current, Ju(
      o.nodeType === 8 ? o.parentNode : o
    ), new e2(l);
  }, M2.hydrateRoot = function(o, l, c) {
    if (!u(o)) throw Error(i(299));
    var h = !1, v = "", w = Kw, N = Eo, _ = ub, $ = null, oe = null;
    return c != null && (c.unstable_strictMode === !0 && (h = !0), c.identifierPrefix !== void 0 && (v = c.identifierPrefix), c.onUncaughtError !== void 0 && (w = c.onUncaughtError), c.onCaughtError !== void 0 && (N = c.onCaughtError), c.onRecoverableError !== void 0 && (_ = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && ($ = c.unstable_transitionCallbacks), c.formState !== void 0 && (oe = c.formState)), l = v3(
      o,
      1,
      !0,
      l,
      c ?? null,
      h,
      v,
      w,
      N,
      _,
      $,
      oe
    ), l.context = Qb(null), c = l.current, h = Ir(), v = ds(h), v.callback = null, hs(c, v, h), l.current.lanes = h, Ho(l, h), xa(l), o[Gi] = l.current, Ju(o), new nc(l);
  }, M2.version = "19.0.0", M2;
}
var l4 = {}, cA;
function tO() {
  return cA || (cA = 1, Gs.env.NODE_ENV !== "production" && function() {
    function a(t, n) {
      for (t = t.memoizedState; t !== null && 0 < n; )
        t = t.next, n--;
      return t;
    }
    function e(t, n, s, f) {
      if (s >= n.length) return f;
      var p = n[s], m = mr(t) ? t.slice() : st({}, t);
      return m[p] = e(t[p], n, s + 1, f), m;
    }
    function r(t, n, s) {
      if (n.length !== s.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var f = 0; f < s.length - 1; f++)
          if (n[f] !== s[f]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return i(t, n, s, 0);
      }
    }
    function i(t, n, s, f) {
      var p = n[f], m = mr(t) ? t.slice() : st({}, t);
      return f + 1 === n.length ? (m[s[f]] = m[p], mr(m) ? m.splice(p, 1) : delete m[p]) : m[p] = i(
        t[p],
        n,
        s,
        f + 1
      ), m;
    }
    function u(t, n, s) {
      var f = n[s], p = mr(t) ? t.slice() : st({}, t);
      return s + 1 === n.length ? (mr(p) ? p.splice(f, 1) : delete p[f], p) : (p[f] = u(t[f], n, s + 1), p);
    }
    function d() {
      return !1;
    }
    function g() {
      return null;
    }
    function b(t, n, s, f) {
      return new Jw(t, n, s, f);
    }
    function y() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function k() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function S() {
    }
    function A() {
    }
    function x(t) {
      var n = [];
      return t.forEach(function(s) {
        n.push(s);
      }), n.sort().join(", ");
    }
    function M(t, n) {
      t.context === Zf && (d3(n, t, null, null), va());
    }
    function D(t, n) {
      if (bi !== null) {
        var s = n.staleFamilies;
        n = n.updatedFamilies, ps(), A1(
          t.current,
          n,
          s
        ), va();
      }
    }
    function O(t) {
      bi = t;
    }
    function T(t) {
      return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
    }
    function L(t) {
      return t === null || typeof t != "object" ? null : (t = g3 && t[g3] || t["@@iterator"], typeof t == "function" ? t : null);
    }
    function U(t) {
      if (t == null) return null;
      if (typeof t == "function")
        return t.$$typeof === c6 ? null : t.displayName || t.name || null;
      if (typeof t == "string") return t;
      switch (t) {
        case pi:
          return "Fragment";
        case Uf:
          return "Portal";
        case a0:
          return "Profiler";
        case r0:
          return "StrictMode";
        case o0:
          return "Suspense";
        case Zh:
          return "SuspenseList";
      }
      if (typeof t == "object")
        switch (typeof t.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), t.$$typeof) {
          case Ca:
            return (t.displayName || "Context") + ".Provider";
          case Qh:
            return (t._context.displayName || "Context") + ".Consumer";
          case Ju:
            var n = t.render;
            return t = t.displayName, t || (t = n.displayName || n.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
          case Al:
            return n = t.displayName || null, n !== null ? n : U(t.type) || "Memo";
          case Nr:
            n = t._payload, t = t._init;
            try {
              return U(t(n));
            } catch {
            }
        }
      return null;
    }
    function W(t) {
      return typeof t.tag == "number" ? Z(t) : typeof t.name == "string" ? t.name : null;
    }
    function Z(t) {
      var n = t.type;
      switch (t.tag) {
        case 24:
          return "Cache";
        case 9:
          return (n._context.displayName || "Context") + ".Consumer";
        case 10:
          return (n.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return t = n.render, t = t.displayName || t.name || "", n.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return n;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return U(n);
        case 8:
          return n === r0 ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof n == "function")
            return n.displayName || n.name || null;
          if (typeof n == "string") return n;
          break;
        case 29:
          if (n = t._debugInfo, n != null) {
            for (var s = n.length - 1; 0 <= s; s--)
              if (typeof n[s].name == "string") return n[s].name;
          }
          if (t.return !== null)
            return Z(t.return);
      }
      return null;
    }
    function J() {
    }
    function Y() {
      if (xl === 0) {
        Ft = console.log, i0 = console.info, ar = console.warn, m3 = console.error, s0 = console.group, l0 = console.groupCollapsed, Yh = console.groupEnd;
        var t = {
          configurable: !0,
          enumerable: !0,
          value: J,
          writable: !0
        };
        Object.defineProperties(console, {
          info: t,
          log: t,
          warn: t,
          error: t,
          group: t,
          groupCollapsed: t,
          groupEnd: t
        });
      }
      xl++;
    }
    function X() {
      if (xl--, xl === 0) {
        var t = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: st({}, t, { value: Ft }),
          info: st({}, t, { value: i0 }),
          warn: st({}, t, { value: ar }),
          error: st({}, t, { value: m3 }),
          group: st({}, t, { value: s0 }),
          groupCollapsed: st({}, t, { value: l0 }),
          groupEnd: st({}, t, { value: Yh })
        });
      }
      0 > xl && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function ee(t) {
      if (u0 === void 0)
        try {
          throw Error();
        } catch (s) {
          var n = s.stack.trim().match(/\n( *(at )?)/);
          u0 = n && n[1] || "", Wb = -1 < s.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < s.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + u0 + t + Wb;
    }
    function j(t, n) {
      if (!t || qh) return "";
      var s = Kh.get(t);
      if (s !== void 0) return s;
      qh = !0, s = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var f = null;
      f = me.H, me.H = null, Y();
      try {
        var p = {
          DetermineComponentFrameRoot: function() {
            try {
              if (n) {
                var pe = function() {
                  throw Error();
                };
                if (Object.defineProperty(pe.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(pe, []);
                  } catch (Ze) {
                    var Se = Ze;
                  }
                  Reflect.construct(t, [], pe);
                } else {
                  try {
                    pe.call();
                  } catch (Ze) {
                    Se = Ze;
                  }
                  t.call(pe.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Ze) {
                  Se = Ze;
                }
                (pe = t()) && typeof pe.catch == "function" && pe.catch(function() {
                });
              }
            } catch (Ze) {
              if (Ze && Se && typeof Ze.stack == "string")
                return [Ze.stack, Se.stack];
            }
            return [null, null];
          }
        };
        p.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var m = Object.getOwnPropertyDescriptor(
          p.DetermineComponentFrameRoot,
          "name"
        );
        m && m.configurable && Object.defineProperty(
          p.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var E = p.DetermineComponentFrameRoot(), I = E[0], F = E[1];
        if (I && F) {
          var z = I.split(`
`), de = F.split(`
`);
          for (E = m = 0; m < z.length && !z[m].includes(
            "DetermineComponentFrameRoot"
          ); )
            m++;
          for (; E < de.length && !de[E].includes(
            "DetermineComponentFrameRoot"
          ); )
            E++;
          if (m === z.length || E === de.length)
            for (m = z.length - 1, E = de.length - 1; 1 <= m && 0 <= E && z[m] !== de[E]; )
              E--;
          for (; 1 <= m && 0 <= E; m--, E--)
            if (z[m] !== de[E]) {
              if (m !== 1 || E !== 1)
                do
                  if (m--, E--, 0 > E || z[m] !== de[E]) {
                    var Ee = `
` + z[m].replace(
                      " at new ",
                      " at "
                    );
                    return t.displayName && Ee.includes("<anonymous>") && (Ee = Ee.replace("<anonymous>", t.displayName)), typeof t == "function" && Kh.set(t, Ee), Ee;
                  }
                while (1 <= m && 0 <= E);
              break;
            }
        }
      } finally {
        qh = !1, me.H = f, X(), Error.prepareStackTrace = s;
      }
      return z = (z = t ? t.displayName || t.name : "") ? ee(z) : "", typeof t == "function" && Kh.set(t, z), z;
    }
    function ne(t) {
      switch (t.tag) {
        case 26:
        case 27:
        case 5:
          return ee(t.type);
        case 16:
          return ee("Lazy");
        case 13:
          return ee("Suspense");
        case 19:
          return ee("SuspenseList");
        case 0:
        case 15:
          return t = j(t.type, !1), t;
        case 11:
          return t = j(t.type.render, !1), t;
        case 1:
          return t = j(t.type, !0), t;
        default:
          return "";
      }
    }
    function ae(t) {
      try {
        var n = "";
        do {
          n += ne(t);
          var s = t._debugInfo;
          if (s)
            for (var f = s.length - 1; 0 <= f; f--) {
              var p = s[f];
              if (typeof p.name == "string") {
                var m = n, E = p.env, I = ee(
                  p.name + (E ? " [" + E + "]" : "")
                );
                n = m + I;
              }
            }
          t = t.return;
        } while (t);
        return n;
      } catch (F) {
        return `
Error generating stack: ` + F.message + `
` + F.stack;
      }
    }
    function he() {
      if (Pr === null) return null;
      var t = Pr._debugOwner;
      return t != null ? W(t) : null;
    }
    function Ie() {
      return Pr === null ? "" : ae(Pr);
    }
    function V(t, n, s, f, p, m, E) {
      var I = Pr;
      me.getCurrentStack = t === null ? null : Ie, Ta = !1, Pr = t;
      try {
        return n(s, f, p, m, E);
      } finally {
        Pr = I;
      }
      throw Error(
        "runWithFiberInDEV should never be called in production. This is a bug in React."
      );
    }
    function B(t) {
      var n = t, s = t;
      if (t.alternate) for (; n.return; ) n = n.return;
      else {
        t = n;
        do
          n = t, n.flags & 4098 && (s = n.return), t = n.return;
        while (t);
      }
      return n.tag === 3 ? s : null;
    }
    function P(t) {
      if (t.tag === 13) {
        var n = t.memoizedState;
        if (n === null && (t = t.alternate, t !== null && (n = t.memoizedState)), n !== null) return n.dehydrated;
      }
      return null;
    }
    function H(t) {
      if (B(t) !== t)
        throw Error("Unable to find node on an unmounted component.");
    }
    function G(t) {
      var n = t.alternate;
      if (!n) {
        if (n = B(t), n === null)
          throw Error("Unable to find node on an unmounted component.");
        return n !== t ? null : t;
      }
      for (var s = t, f = n; ; ) {
        var p = s.return;
        if (p === null) break;
        var m = p.alternate;
        if (m === null) {
          if (f = p.return, f !== null) {
            s = f;
            continue;
          }
          break;
        }
        if (p.child === m.child) {
          for (m = p.child; m; ) {
            if (m === s) return H(p), t;
            if (m === f) return H(p), n;
            m = m.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (s.return !== f.return) s = p, f = m;
        else {
          for (var E = !1, I = p.child; I; ) {
            if (I === s) {
              E = !0, s = p, f = m;
              break;
            }
            if (I === f) {
              E = !0, f = p, s = m;
              break;
            }
            I = I.sibling;
          }
          if (!E) {
            for (I = m.child; I; ) {
              if (I === s) {
                E = !0, s = m, f = p;
                break;
              }
              if (I === f) {
                E = !0, f = m, s = p;
                break;
              }
              I = I.sibling;
            }
            if (!E)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (s.alternate !== f)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (s.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return s.stateNode.current === s ? t : n;
    }
    function ie(t) {
      var n = t.tag;
      if (n === 5 || n === 26 || n === 27 || n === 6) return t;
      for (t = t.child; t !== null; ) {
        if (n = ie(t), n !== null) return n;
        t = t.sibling;
      }
      return null;
    }
    function ce(t) {
      return { current: t };
    }
    function xe(t, n) {
      0 > Io ? console.error("Unexpected pop.") : (n !== Jh[Io] && console.error("Unexpected Fiber popped."), t.current = Gb[Io], Gb[Io] = null, Jh[Io] = null, Io--);
    }
    function Ce(t, n, s) {
      Io++, Gb[Io] = t.current, Jh[Io] = s, t.current = n;
    }
    function Be(t) {
      return t === null && console.error(
        "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
      ), t;
    }
    function Pe(t, n) {
      Ce(or, n, t), Ce(Xh, t, t), Ce(Cl, null, t);
      var s = n.nodeType;
      switch (s) {
        case 9:
        case 11:
          s = s === 9 ? "#document" : "#fragment", n = (n = n.documentElement) && (n = n.namespaceURI) ? u3(n) : ad;
          break;
        default:
          if (n = s === 8 ? n.parentNode : n, s = n.tagName, n = n.namespaceURI)
            n = u3(n), n = an(
              n,
              s
            );
          else
            switch (s) {
              case "svg":
                n = G0;
                break;
              case "math":
                n = e4;
                break;
              default:
                n = ad;
            }
      }
      s = s.toLowerCase(), s = zg(null, s), s = {
        context: n,
        ancestorInfo: s
      }, xe(Cl, t), Ce(Cl, s, t);
    }
    function Fe(t) {
      xe(Cl, t), xe(Xh, t), xe(or, t);
    }
    function Xe() {
      return Be(Cl.current);
    }
    function at(t) {
      t.memoizedState !== null && Ce(ep, t, t);
      var n = Be(Cl.current), s = t.type, f = an(n.context, s);
      s = zg(n.ancestorInfo, s), f = { context: f, ancestorInfo: s }, n !== f && (Ce(Xh, t, t), Ce(Cl, f, t));
    }
    function tt(t) {
      Xh.current === t && (xe(Cl, t), xe(Xh, t)), ep.current === t && (xe(ep, t), L2._currentValue = Cp);
    }
    function Ye(t) {
      return typeof Symbol == "function" && Symbol.toStringTag && t[Symbol.toStringTag] || t.constructor.name || "Object";
    }
    function Ve(t) {
      try {
        return Je(t), !1;
      } catch {
        return !0;
      }
    }
    function Je(t) {
      return "" + t;
    }
    function _e(t, n) {
      if (Ve(t))
        return console.error(
          "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
          n,
          Ye(t)
        ), Je(t);
    }
    function rt(t, n) {
      if (Ve(t))
        return console.error(
          "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
          n,
          Ye(t)
        ), Je(t);
    }
    function Gt(t) {
      if (Ve(t))
        return console.error(
          "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
          Ye(t)
        ), Je(t);
    }
    function Er(t) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
      var n = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (n.isDisabled) return !0;
      if (!n.supportsFiber)
        return console.error(
          "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
        ), !0;
      try {
        Hf = n.inject(t), Or = n;
      } catch (s) {
        console.error("React instrumentation encountered an error: %s.", s);
      }
      return !!n.checkDCE;
    }
    function Ga(t, n) {
      if (Or && typeof Or.onCommitFiberRoot == "function")
        try {
          var s = (t.current.flags & 128) === 128;
          switch (n) {
            case Ia:
              var f = Tl;
              break;
            case Xa:
              f = f0;
              break;
            case No:
              f = zf;
              break;
            case ec:
              f = jb;
              break;
            default:
              f = zf;
          }
          Or.onCommitFiberRoot(
            Hf,
            t,
            f,
            s
          );
        } catch (p) {
          Wr || (Wr = !0, console.error(
            "React instrumentation encountered an error: %s",
            p
          ));
        }
    }
    function jt(t) {
      if (typeof p6 == "function" && g6(t), Or && typeof Or.setStrictMode == "function")
        try {
          Or.setStrictMode(Hf, t);
        } catch (n) {
          Wr || (Wr = !0, console.error(
            "React instrumentation encountered an error: %s",
            n
          ));
        }
    }
    function Og(t) {
      Me = t;
    }
    function Rg() {
      Me !== null && typeof Me.markCommitStopped == "function" && Me.markCommitStopped();
    }
    function au(t) {
      Me !== null && typeof Me.markComponentRenderStarted == "function" && Me.markComponentRenderStarted(t);
    }
    function $s() {
      Me !== null && typeof Me.markComponentRenderStopped == "function" && Me.markComponentRenderStopped();
    }
    function mw(t) {
      Me !== null && typeof Me.markRenderStarted == "function" && Me.markRenderStarted(t);
    }
    function yw() {
      Me !== null && typeof Me.markRenderStopped == "function" && Me.markRenderStopped();
    }
    function Xr(t, n) {
      Me !== null && typeof Me.markStateUpdateScheduled == "function" && Me.markStateUpdateScheduled(t, n);
    }
    function Zk(t) {
      return t >>>= 0, t === 0 ? 32 : 31 - (m6(t) / Vf | 0) | 0;
    }
    function bw(t) {
      if (t & 1) return "SyncHydrationLane";
      if (t & 2) return "Sync";
      if (t & 4) return "InputContinuousHydration";
      if (t & 8) return "InputContinuous";
      if (t & 16) return "DefaultHydration";
      if (t & 32) return "Default";
      if (t & 64) return "TransitionHydration";
      if (t & 4194176) return "Transition";
      if (t & 62914560) return "Retry";
      if (t & 67108864) return "SelectiveHydration";
      if (t & 134217728) return "IdleHydration";
      if (t & 268435456) return "Idle";
      if (t & 536870912) return "Offscreen";
      if (t & 1073741824) return "Deferred";
    }
    function Qs(t) {
      var n = t & 42;
      if (n !== 0) return n;
      switch (t & -t) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return t & 4194176;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return t & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), t;
      }
    }
    function ou(t, n) {
      var s = t.pendingLanes;
      if (s === 0) return 0;
      var f = 0, p = t.suspendedLanes, m = t.pingedLanes, E = t.warmLanes;
      t = t.finishedLanes !== 0;
      var I = s & 134217727;
      return I !== 0 ? (s = I & ~p, s !== 0 ? f = Qs(s) : (m &= I, m !== 0 ? f = Qs(m) : t || (E = I & ~E, E !== 0 && (f = Qs(E))))) : (I = s & ~p, I !== 0 ? f = Qs(I) : m !== 0 ? f = Qs(m) : t || (E = s & ~E, E !== 0 && (f = Qs(E)))), f === 0 ? 0 : n !== 0 && n !== f && !(n & p) && (p = f & -f, E = n & -n, p >= E || p === 32 && (E & 4194176) !== 0) ? n : f;
    }
    function Gd(t, n) {
      return (t.pendingLanes & ~(t.suspendedLanes & ~t.pingedLanes) & n) === 0;
    }
    function vw(t, n) {
      switch (t) {
        case 1:
        case 2:
        case 4:
        case 8:
          return n + 250;
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return n + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), -1;
      }
    }
    function ww() {
      var t = Il;
      return Il <<= 1, !(Il & 4194176) && (Il = 128), t;
    }
    function kw() {
      var t = tp;
      return tp <<= 1, !(tp & 62914560) && (tp = 4194304), t;
    }
    function iu(t) {
      for (var n = [], s = 0; 31 > s; s++) n.push(t);
      return n;
    }
    function ur(t, n) {
      t.pendingLanes |= n, n !== 268435456 && (t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0);
    }
    function Yk(t, n, s, f, p, m) {
      var E = t.pendingLanes;
      t.pendingLanes = s, t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0, t.expiredLanes &= s, t.entangledLanes &= s, t.errorRecoveryDisabledLanes &= s, t.shellSuspendCounter = 0;
      var I = t.entanglements, F = t.expirationTimes, z = t.hiddenUpdates;
      for (s = E & ~s; 0 < s; ) {
        var de = 31 - Rr(s), Ee = 1 << de;
        I[de] = 0, F[de] = -1;
        var pe = z[de];
        if (pe !== null)
          for (z[de] = null, de = 0; de < pe.length; de++) {
            var Se = pe[de];
            Se !== null && (Se.lane &= -536870913);
          }
        s &= ~Ee;
      }
      f !== 0 && zi(t, f, 0), m !== 0 && p === 0 && t.tag !== 0 && (t.suspendedLanes |= m & ~(E & ~n));
    }
    function zi(t, n, s) {
      t.pendingLanes |= n, t.suspendedLanes &= ~n;
      var f = 31 - Rr(n);
      t.entangledLanes |= n, t.entanglements[f] = t.entanglements[f] | 1073741824 | s & 4194218;
    }
    function ea(t, n) {
      var s = t.entangledLanes |= n;
      for (t = t.entanglements; s; ) {
        var f = 31 - Rr(s), p = 1 << f;
        p & n | t[f] & n && (t[f] |= n), s &= ~p;
      }
    }
    function Ew(t, n, s) {
      if (Gr)
        for (t = t.pendingUpdatersLaneMap; 0 < s; ) {
          var f = 31 - Rr(s), p = 1 << f;
          t[f].add(n), s &= ~p;
        }
    }
    function Sw(t, n) {
      if (Gr)
        for (var s = t.pendingUpdatersLaneMap, f = t.memoizedUpdaters; 0 < n; ) {
          var p = 31 - Rr(n);
          t = 1 << p, p = s[p], 0 < p.size && (p.forEach(function(m) {
            var E = m.alternate;
            E !== null && f.has(E) || f.add(m);
          }), p.clear()), n &= ~t;
        }
    }
    function Aw(t) {
      return t &= -t, Ia < t ? Xa < t ? t & 134217727 ? No : ec : Xa : Ia;
    }
    function jd() {
      var t = Qt.p;
      return t !== 0 ? t : (t = window.event, t === void 0 ? No : Ku(t.type));
    }
    function Lg(t, n) {
      var s = Qt.p;
      try {
        return Qt.p = t, n();
      } finally {
        Qt.p = s;
      }
    }
    function Hi(t) {
      delete t[yr], delete t[ua], delete t[tc], delete t[y6], delete t[b6];
    }
    function zo(t) {
      var n = t[yr];
      if (n) return n;
      for (var s = t.parentNode; s; ) {
        if (n = s[Nl] || s[yr]) {
          if (s = n.alternate, n.child !== null || s !== null && s.child !== null)
            for (t = vs(t); t !== null; ) {
              if (s = t[yr])
                return s;
              t = vs(t);
            }
          return n;
        }
        t = s, s = t.parentNode;
      }
      return null;
    }
    function fo(t) {
      if (t = t[yr] || t[Nl]) {
        var n = t.tag;
        if (n === 5 || n === 6 || n === 13 || n === 26 || n === 27 || n === 3)
          return t;
      }
      return null;
    }
    function $d(t) {
      var n = t.tag;
      if (n === 5 || n === 26 || n === 27 || n === 6)
        return t.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function su(t) {
      var n = t[b3];
      return n || (n = t[b3] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), n;
    }
    function Dn(t) {
      t[Pl] = !0;
    }
    function Vi(t, n) {
      Ho(t, n), Ho(t + "Capture", n);
    }
    function Ho(t, n) {
      Es[t] && console.error(
        "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
        t
      ), Es[t] = n;
      var s = t.toLowerCase();
      for ($b[s] = t, t === "onDoubleClick" && ($b.ondblclick = t), t = 0; t < n.length; t++)
        np.add(n[t]);
    }
    function Vc(t, n) {
      v6[n.type] || n.onChange || n.onInput || n.readOnly || n.disabled || n.value == null || console.error(
        t === "select" ? "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`." : "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
      ), n.onChange || n.readOnly || n.disabled || n.checked == null || console.error(
        "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
      );
    }
    function Dg(t) {
      return gi.call(Zb, t) ? !0 : gi.call(Qb, t) ? !1 : v3.test(t) ? Zb[t] = !0 : (Qb[t] = !0, console.error("Invalid attribute name: `%s`", t), !1);
    }
    function s1(t, n, s) {
      if (Dg(n)) {
        if (!t.hasAttribute(n)) {
          switch (typeof s) {
            case "symbol":
            case "object":
              return s;
            case "function":
              return s;
            case "boolean":
              if (s === !1) return s;
          }
          return s === void 0 ? void 0 : null;
        }
        return t = t.getAttribute(n), t === "" && s === !0 ? !0 : (_e(s, n), t === "" + s ? s : t);
      }
    }
    function Qd(t, n, s) {
      if (Dg(n))
        if (s === null) t.removeAttribute(n);
        else {
          switch (typeof s) {
            case "undefined":
            case "function":
            case "symbol":
              t.removeAttribute(n);
              return;
            case "boolean":
              var f = n.toLowerCase().slice(0, 5);
              if (f !== "data-" && f !== "aria-") {
                t.removeAttribute(n);
                return;
              }
          }
          _e(s, n), t.setAttribute(n, "" + s);
        }
    }
    function Zd(t, n, s) {
      if (s === null) t.removeAttribute(n);
      else {
        switch (typeof s) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            t.removeAttribute(n);
            return;
        }
        _e(s, n), t.setAttribute(n, "" + s);
      }
    }
    function Wi(t, n, s, f) {
      if (f === null) t.removeAttribute(s);
      else {
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            t.removeAttribute(s);
            return;
        }
        _e(f, s), t.setAttributeNS(n, s, "" + f);
      }
    }
    function Bn(t) {
      switch (typeof t) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return t;
        case "object":
          return Gt(t), t;
        default:
          return "";
      }
    }
    function cr(t) {
      var n = t.type;
      return (t = t.nodeName) && t.toLowerCase() === "input" && (n === "checkbox" || n === "radio");
    }
    function ta(t) {
      var n = cr(t) ? "checked" : "value", s = Object.getOwnPropertyDescriptor(
        t.constructor.prototype,
        n
      );
      Gt(t[n]);
      var f = "" + t[n];
      if (!t.hasOwnProperty(n) && typeof s < "u" && typeof s.get == "function" && typeof s.set == "function") {
        var p = s.get, m = s.set;
        return Object.defineProperty(t, n, {
          configurable: !0,
          get: function() {
            return p.call(this);
          },
          set: function(E) {
            Gt(E), f = "" + E, m.call(this, E);
          }
        }), Object.defineProperty(t, n, {
          enumerable: s.enumerable
        }), {
          getValue: function() {
            return f;
          },
          setValue: function(E) {
            Gt(E), f = "" + E;
          },
          stopTracking: function() {
            t._valueTracker = null, delete t[n];
          }
        };
      }
    }
    function Gi(t) {
      t._valueTracker || (t._valueTracker = ta(t));
    }
    function Bg(t) {
      if (!t) return !1;
      var n = t._valueTracker;
      if (!n) return !0;
      var s = n.getValue(), f = "";
      return t && (f = cr(t) ? t.checked ? "true" : "false" : t.value), t = f, t !== s ? (n.setValue(t), !0) : !1;
    }
    function Mg(t) {
      if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
      try {
        return t.activeElement || t.body;
      } catch {
        return t.body;
      }
    }
    function ho(t) {
      return t.replace(
        w3,
        function(n) {
          return "\\" + n.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function l1(t, n) {
      n.checked === void 0 || n.defaultChecked === void 0 || Yb || (console.error(
        "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        he() || "A component",
        n.type
      ), Yb = !0), n.value === void 0 || n.defaultValue === void 0 || d0 || (console.error(
        "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        he() || "A component",
        n.type
      ), d0 = !0);
    }
    function lu(t, n, s, f, p, m, E, I) {
      t.name = "", E != null && typeof E != "function" && typeof E != "symbol" && typeof E != "boolean" ? (_e(E, "type"), t.type = E) : t.removeAttribute("type"), n != null ? E === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + Bn(n)) : t.value !== "" + Bn(n) && (t.value = "" + Bn(n)) : E !== "submit" && E !== "reset" || t.removeAttribute("value"), n != null ? ji(t, E, Bn(n)) : s != null ? ji(t, E, Bn(s)) : f != null && t.removeAttribute("value"), p == null && m != null && (t.defaultChecked = !!m), p != null && (t.checked = p && typeof p != "function" && typeof p != "symbol"), I != null && typeof I != "function" && typeof I != "symbol" && typeof I != "boolean" ? (_e(I, "name"), t.name = "" + Bn(I)) : t.removeAttribute("name");
    }
    function Fg(t, n, s, f, p, m, E, I) {
      if (m != null && typeof m != "function" && typeof m != "symbol" && typeof m != "boolean" && (_e(m, "type"), t.type = m), n != null || s != null) {
        if (!(m !== "submit" && m !== "reset" || n != null))
          return;
        s = s != null ? "" + Bn(s) : "", n = n != null ? "" + Bn(n) : s, I || n === t.value || (t.value = n), t.defaultValue = n;
      }
      f = f ?? p, f = typeof f != "function" && typeof f != "symbol" && !!f, t.checked = I ? t.checked : !!f, t.defaultChecked = !!f, E != null && typeof E != "function" && typeof E != "symbol" && typeof E != "boolean" && (_e(E, "name"), t.name = E);
    }
    function ji(t, n, s) {
      n === "number" && Mg(t.ownerDocument) === t || t.defaultValue === "" + s || (t.defaultValue = "" + s);
    }
    function uu(t, n) {
      n.value == null && (typeof n.children == "object" && n.children !== null ? zb.Children.forEach(n.children, function(s) {
        s == null || typeof s == "string" || typeof s == "number" || typeof s == "bigint" || k3 || (k3 = !0, console.error(
          "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
        ));
      }) : n.dangerouslySetInnerHTML == null || E3 || (E3 = !0, console.error(
        "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
      ))), n.selected == null || rp || (console.error(
        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
      ), rp = !0);
    }
    function Wc() {
      var t = he();
      return t ? `

Check the render method of \`` + t + "`." : "";
    }
    function po(t, n, s, f) {
      if (t = t.options, n) {
        n = {};
        for (var p = 0; p < s.length; p++)
          n["$" + s[p]] = !0;
        for (s = 0; s < t.length; s++)
          p = n.hasOwnProperty("$" + t[s].value), t[s].selected !== p && (t[s].selected = p), p && f && (t[s].defaultSelected = !0);
      } else {
        for (s = "" + Bn(s), n = null, p = 0; p < t.length; p++) {
          if (t[p].value === s) {
            t[p].selected = !0, f && (t[p].defaultSelected = !0);
            return;
          }
          n !== null || t[p].disabled || (n = t[p]);
        }
        n !== null && (n.selected = !0);
      }
    }
    function Mn(t, n) {
      for (t = 0; t < p0.length; t++) {
        var s = p0[t];
        if (n[s] != null) {
          var f = mr(n[s]);
          n.multiple && !f ? console.error(
            "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
            s,
            Wc()
          ) : !n.multiple && f && console.error(
            "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
            s,
            Wc()
          );
        }
      }
      n.value === void 0 || n.defaultValue === void 0 || h0 || (console.error(
        "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
      ), h0 = !0);
    }
    function u1(t, n) {
      n.value === void 0 || n.defaultValue === void 0 || ap || (console.error(
        "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
        he() || "A component"
      ), ap = !0), n.children != null && n.value == null && console.error(
        "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
      );
    }
    function c1(t, n, s) {
      if (n != null && (n = "" + Bn(n), n !== t.value && (t.value = n), s == null)) {
        t.defaultValue !== n && (t.defaultValue = n);
        return;
      }
      t.defaultValue = s != null ? "" + Bn(s) : "";
    }
    function Zs(t, n, s, f) {
      if (n == null) {
        if (f != null) {
          if (s != null)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (mr(f)) {
            if (1 < f.length)
              throw Error("<textarea> can only have at most one child.");
            f = f[0];
          }
          s = f;
        }
        s == null && (s = ""), n = s;
      }
      s = Bn(n), t.defaultValue = s, f = t.textContent, f === s && f !== "" && f !== null && (t.value = f);
    }
    function cu(t, n) {
      return t.serverProps === void 0 && t.serverTail.length === 0 && t.children.length === 1 && 3 < t.distanceFromLeaf && t.distanceFromLeaf > 15 - n ? cu(t.children[0], n) : t;
    }
    function wn(t) {
      return "  " + "  ".repeat(t);
    }
    function Gc(t) {
      return "+ " + "  ".repeat(t);
    }
    function Ys(t) {
      return "- " + "  ".repeat(t);
    }
    function f1(t) {
      switch (t.tag) {
        case 26:
        case 27:
        case 5:
          return t.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return t = t.type, t.displayName || t.name || null;
        case 11:
          return t = t.type.render, t.displayName || t.name || null;
        case 1:
          return t = t.type, t.displayName || t.name || null;
        default:
          return null;
      }
    }
    function Yd(t, n) {
      return g0.test(t) ? (t = JSON.stringify(t), t.length > n - 2 ? 8 > n ? '{"..."}' : "{" + t.slice(0, n - 7) + '..."}' : "{" + t + "}") : t.length > n ? 5 > n ? '{"..."}' : t.slice(0, n - 3) + "..." : t;
    }
    function fu(t, n, s) {
      var f = 120 - 2 * s;
      if (n === null)
        return Gc(s) + Yd(t, f) + `
`;
      if (typeof n == "string") {
        for (var p = 0; p < n.length && p < t.length && n.charCodeAt(p) === t.charCodeAt(p); p++) ;
        return p > f - 8 && 10 < p && (t = "..." + t.slice(p - 8), n = "..." + n.slice(p - 8)), Gc(s) + Yd(t, f) + `
` + Ys(s) + Yd(n, f) + `
`;
      }
      return wn(s) + Yd(t, f) + `
`;
    }
    function jc(t) {
      return Object.prototype.toString.call(t).replace(/^\[object (.*)\]$/, function(n, s) {
        return s;
      });
    }
    function ha(t, n) {
      switch (typeof t) {
        case "string":
          return t = JSON.stringify(t), t.length > n ? 5 > n ? '"..."' : t.slice(0, n - 4) + '..."' : t;
        case "object":
          if (t === null) return "null";
          if (mr(t)) return "[...]";
          if (t.$$typeof === Sl)
            return (n = U(t.type)) ? "<" + n + ">" : "<...>";
          var s = jc(t);
          if (s === "Object") {
            s = "", n -= 2;
            for (var f in t)
              if (t.hasOwnProperty(f)) {
                var p = JSON.stringify(f);
                if (p !== '"' + f + '"' && (f = p), n -= f.length - 2, p = ha(
                  t[f],
                  15 > n ? n : 15
                ), n -= p.length, 0 > n) {
                  s += s === "" ? "..." : ", ...";
                  break;
                }
                s += (s === "" ? "" : ",") + f + ":" + p;
              }
            return "{" + s + "}";
          }
          return s;
        case "function":
          return (n = t.displayName || t.name) ? "function " + n : "function";
        default:
          return String(t);
      }
    }
    function fr(t, n) {
      return typeof t != "string" || g0.test(t) ? "{" + ha(t, n - 2) + "}" : t.length > n - 2 ? 5 > n ? '"..."' : '"' + t.slice(0, n - 5) + '..."' : '"' + t + '"';
    }
    function _g(t, n, s) {
      var f = 120 - s.length - t.length, p = [], m;
      for (m in n)
        if (n.hasOwnProperty(m) && m !== "children") {
          var E = fr(
            n[m],
            120 - s.length - m.length - 1
          );
          f -= m.length + E.length + 2, p.push(m + "=" + E);
        }
      return p.length === 0 ? s + "<" + t + `>
` : 0 < f ? s + "<" + t + " " + p.join(" ") + `>
` : s + "<" + t + `
` + s + "  " + p.join(`
` + s + "  ") + `
` + s + `>
`;
    }
    function qk(t, n, s) {
      var f = "", p = st({}, n), m;
      for (m in t)
        if (t.hasOwnProperty(m)) {
          delete p[m];
          var E = 120 - 2 * s - m.length - 2, I = ha(t[m], E);
          n.hasOwnProperty(m) ? (E = ha(n[m], E), f += Gc(s) + m + ": " + I + `
`, f += Ys(s) + m + ": " + E + `
`) : f += Gc(s) + m + ": " + I + `
`;
        }
      for (var F in p)
        p.hasOwnProperty(F) && (t = ha(
          p[F],
          120 - 2 * s - F.length - 2
        ), f += Ys(s) + F + ": " + t + `
`);
      return f;
    }
    function Ug(t, n, s, f) {
      var p = "", m = /* @__PURE__ */ new Map();
      for (z in s)
        s.hasOwnProperty(z) && m.set(
          z.toLowerCase(),
          z
        );
      if (m.size === 1 && m.has("children"))
        p += _g(
          t,
          n,
          wn(f)
        );
      else {
        for (var E in n)
          if (n.hasOwnProperty(E) && E !== "children") {
            var I = 120 - 2 * (f + 1) - E.length - 1, F = m.get(E.toLowerCase());
            if (F !== void 0) {
              m.delete(E.toLowerCase());
              var z = n[E];
              F = s[F];
              var de = fr(
                z,
                I
              );
              I = fr(
                F,
                I
              ), typeof z == "object" && z !== null && typeof F == "object" && F !== null && jc(z) === "Object" && jc(F) === "Object" && (2 < Object.keys(z).length || 2 < Object.keys(F).length || -1 < de.indexOf("...") || -1 < I.indexOf("...")) ? p += wn(f + 1) + E + `={{
` + qk(
                z,
                F,
                f + 2
              ) + wn(f + 1) + `}}
` : (p += Gc(f + 1) + E + "=" + de + `
`, p += Ys(f + 1) + E + "=" + I + `
`);
            } else
              p += wn(f + 1) + E + "=" + fr(n[E], I) + `
`;
          }
        m.forEach(function(Ee) {
          if (Ee !== "children") {
            var pe = 120 - 2 * (f + 1) - Ee.length - 1;
            p += Ys(f + 1) + Ee + "=" + fr(s[Ee], pe) + `
`;
          }
        }), p = p === "" ? wn(f) + "<" + t + `>
` : wn(f) + "<" + t + `
` + p + wn(f) + `>
`;
      }
      return t = s.children, n = n.children, typeof t == "string" || typeof t == "number" || typeof t == "bigint" ? (m = "", (typeof n == "string" || typeof n == "number" || typeof n == "bigint") && (m = "" + n), p += fu(m, "" + t, f + 1)) : (typeof n == "string" || typeof n == "number" || typeof n == "bigint") && (p = t == null ? p + fu("" + n, null, f + 1) : p + fu("" + n, void 0, f + 1)), p;
    }
    function d1(t, n) {
      var s = f1(t);
      if (s === null) {
        for (s = "", t = t.child; t; )
          s += d1(t, n), t = t.sibling;
        return s;
      }
      return wn(n) + "<" + s + `>
`;
    }
    function $c(t, n) {
      var s = cu(t, n);
      if (s !== t && (t.children.length !== 1 || t.children[0] !== s))
        return wn(n) + `...
` + $c(s, n + 1);
      s = "";
      var f = t.fiber._debugInfo;
      if (f)
        for (var p = 0; p < f.length; p++) {
          var m = f[p].name;
          typeof m == "string" && (s += wn(n) + "<" + m + `>
`, n++);
        }
      if (f = "", p = t.fiber.pendingProps, t.fiber.tag === 6)
        f = fu(p, t.serverProps, n), n++;
      else if (m = f1(t.fiber), m !== null)
        if (t.serverProps === void 0) {
          f = n;
          var E = 120 - 2 * f - m.length - 2, I = "";
          for (z in p)
            if (p.hasOwnProperty(z) && z !== "children") {
              var F = fr(p[z], 15);
              if (E -= z.length + F.length + 2, 0 > E) {
                I += " ...";
                break;
              }
              I += " " + z + "=" + F;
            }
          f = wn(f) + "<" + m + I + `>
`, n++;
        } else
          t.serverProps === null ? (f = _g(
            m,
            p,
            Gc(n)
          ), n++) : typeof t.serverProps == "string" ? console.error(
            "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
          ) : (f = Ug(
            m,
            p,
            t.serverProps,
            n
          ), n++);
      var z = "";
      for (p = t.fiber.child, m = 0; p && m < t.children.length; )
        E = t.children[m], E.fiber === p ? (z += $c(E, n), m++) : z += d1(p, n), p = p.sibling;
      for (p && 0 < t.children.length && (z += wn(n) + `...
`), p = t.serverTail, t.serverProps === null && n--, t = 0; t < p.length; t++)
        m = p[t], z = typeof m == "string" ? z + (Ys(n) + Yd(m, 120 - 2 * n) + `
`) : z + _g(
          m.type,
          m.props,
          Ys(n)
        );
      return s + f + z;
    }
    function h1(t) {
      try {
        return `

` + $c(t, 0);
      } catch {
        return "";
      }
    }
    function ja(t, n, s) {
      for (var f = n, p = null, m = 0; f; )
        f === t && (m = 0), p = {
          fiber: f,
          children: p !== null ? [p] : [],
          serverProps: f === n ? s : f === t ? null : void 0,
          serverTail: [],
          distanceFromLeaf: m
        }, m++, f = f.return;
      return p !== null ? h1(p).replaceAll(/^[+-]/gm, ">") : "";
    }
    function zg(t, n) {
      t = st({}, t || Ss);
      var s = { tag: n };
      return m0.indexOf(n) !== -1 && (t.aTagInScope = null, t.buttonTagInScope = null, t.nobrTagInScope = null), Ol.indexOf(n) !== -1 && (t.pTagInButtonScope = null), S3.indexOf(n) !== -1 && n !== "address" && n !== "div" && n !== "p" && (t.listItemTagAutoclosing = null, t.dlItemTagAutoclosing = null), t.current = s, n === "form" && (t.formTag = s), n === "a" && (t.aTagInScope = s), n === "button" && (t.buttonTagInScope = s), n === "nobr" && (t.nobrTagInScope = s), n === "p" && (t.pTagInButtonScope = s), n === "li" && (t.listItemTagAutoclosing = s), (n === "dd" || n === "dt") && (t.dlItemTagAutoclosing = s), n === "#document" || n === "html" ? t.containerTagInScope = null : t.containerTagInScope || (t.containerTagInScope = s), t;
    }
    function p1(t, n) {
      switch (n) {
        case "select":
          return t === "hr" || t === "option" || t === "optgroup" || t === "#text";
        case "optgroup":
          return t === "option" || t === "#text";
        case "option":
          return t === "#text";
        case "tr":
          return t === "th" || t === "td" || t === "style" || t === "script" || t === "template";
        case "tbody":
        case "thead":
        case "tfoot":
          return t === "tr" || t === "style" || t === "script" || t === "template";
        case "colgroup":
          return t === "col" || t === "template";
        case "table":
          return t === "caption" || t === "colgroup" || t === "tbody" || t === "tfoot" || t === "thead" || t === "style" || t === "script" || t === "template";
        case "head":
          return t === "base" || t === "basefont" || t === "bgsound" || t === "link" || t === "meta" || t === "title" || t === "noscript" || t === "noframes" || t === "style" || t === "script" || t === "template";
        case "html":
          return t === "head" || t === "body" || t === "frameset";
        case "frameset":
          return t === "frame";
        case "#document":
          return t === "html";
      }
      switch (t) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return n !== "h1" && n !== "h2" && n !== "h3" && n !== "h4" && n !== "h5" && n !== "h6";
        case "rp":
        case "rt":
          return Rl.indexOf(n) === -1;
        case "body":
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "head":
        case "html":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return n == null;
      }
      return !0;
    }
    function g1(t, n) {
      switch (t) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return n.pTagInButtonScope;
        case "form":
          return n.formTag || n.pTagInButtonScope;
        case "li":
          return n.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return n.dlItemTagAutoclosing;
        case "button":
          return n.buttonTagInScope;
        case "a":
          return n.aTagInScope;
        case "nobr":
          return n.nobrTagInScope;
      }
      return null;
    }
    function du(t, n) {
      for (; t; ) {
        switch (t.tag) {
          case 5:
          case 26:
          case 27:
            if (t.type === n) return t;
        }
        t = t.return;
      }
      return null;
    }
    function Hg(t, n) {
      n = n || Ss;
      var s = n.current;
      if (n = (s = p1(
        t,
        s && s.tag
      ) ? null : s) ? null : g1(t, n), n = s || n, !n) return !0;
      n = n.tag;
      var f = String(!!s) + "|" + t + "|" + n;
      if (Ll[f]) return !1;
      Ll[f] = !0;
      var p = (f = Pr) ? du(f.return, n) : null;
      return f = f !== null && p !== null ? ja(p, f, null) : "", p = "<" + t + ">", s ? (s = "", n === "table" && t === "tr" && (s += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
        `In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`,
        p,
        n,
        s,
        f
      )) : console.error(
        `In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`,
        p,
        n,
        f
      ), !1;
    }
    function qd(t, n) {
      if (p1("#text", n)) return !0;
      var s = "#text|" + n;
      if (Ll[s]) return !1;
      Ll[s] = !0;
      var f = (s = Pr) ? du(s, n) : null;
      return s = s !== null && f !== null ? ja(
        f,
        s,
        s.tag !== 6 ? { children: null } : null
      ) : "", /\S/.test(t) ? console.error(
        `In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`,
        n,
        s
      ) : console.error(
        `In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`,
        n,
        s
      ), !1;
    }
    function Vo(t, n) {
      if (n) {
        var s = t.firstChild;
        if (s && s === t.lastChild && s.nodeType === 3) {
          s.nodeValue = n;
          return;
        }
      }
      t.textContent = n;
    }
    function Kk(t) {
      return t.replace(y0, function(n, s) {
        return s.toUpperCase();
      });
    }
    function m1(t, n, s) {
      var f = n.indexOf("--") === 0;
      f || (-1 < n.indexOf("-") ? Gf.hasOwnProperty(n) && Gf[n] || (Gf[n] = !0, console.error(
        "Unsupported style property %s. Did you mean %s?",
        n,
        Kk(n.replace(A3, "ms-"))
      )) : w6.test(n) ? Gf.hasOwnProperty(n) && Gf[n] || (Gf[n] = !0, console.error(
        "Unsupported vendor-prefixed style property %s. Did you mean %s?",
        n,
        n.charAt(0).toUpperCase() + n.slice(1)
      )) : !Jb.test(s) || jf.hasOwnProperty(s) && jf[s] || (jf[s] = !0, console.error(
        `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
        n,
        s.replace(Jb, "")
      )), typeof s == "number" && (isNaN(s) ? op || (op = !0, console.error(
        "`NaN` is an invalid value for the `%s` css style property.",
        n
      )) : isFinite(s) || Xb || (Xb = !0, console.error(
        "`Infinity` is an invalid value for the `%s` css style property.",
        n
      )))), s == null || typeof s == "boolean" || s === "" ? f ? t.setProperty(n, "") : n === "float" ? t.cssFloat = "" : t[n] = "" : f ? t.setProperty(n, s) : typeof s != "number" || s === 0 || $f.has(n) ? n === "float" ? t.cssFloat = s : (rt(s, n), t[n] = ("" + s).trim()) : t[n] = s + "px";
    }
    function y1(t, n, s) {
      if (n != null && typeof n != "object")
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      if (n && Object.freeze(n), t = t.style, s != null) {
        if (n) {
          var f = {};
          if (s) {
            for (var p in s)
              if (s.hasOwnProperty(p) && !n.hasOwnProperty(p))
                for (var m = qb[p] || [p], E = 0; E < m.length; E++)
                  f[m[E]] = p;
          }
          for (var I in n)
            if (n.hasOwnProperty(I) && (!s || s[I] !== n[I]))
              for (p = qb[I] || [I], m = 0; m < p.length; m++)
                f[p[m]] = I;
          I = {};
          for (var F in n)
            for (p = qb[F] || [F], m = 0; m < p.length; m++)
              I[p[m]] = F;
          F = {};
          for (var z in f)
            if (p = f[z], (m = I[z]) && p !== m && (E = p + "," + m, !F[E])) {
              F[E] = !0, E = console;
              var de = n[p];
              E.error.call(
                E,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                de == null || typeof de == "boolean" || de === "" ? "Removing" : "Updating",
                p,
                m
              );
            }
        }
        for (var Ee in s)
          !s.hasOwnProperty(Ee) || n != null && n.hasOwnProperty(Ee) || (Ee.indexOf("--") === 0 ? t.setProperty(Ee, "") : Ee === "float" ? t.cssFloat = "" : t[Ee] = "");
        for (var pe in n)
          z = n[pe], n.hasOwnProperty(pe) && s[pe] !== z && m1(t, pe, z);
      } else
        for (f in n)
          n.hasOwnProperty(f) && m1(t, f, n[f]);
    }
    function hu(t) {
      if (t.indexOf("-") === -1) return !1;
      switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function xw(t) {
      return e2.get(t) || t;
    }
    function Jk(t, n) {
      if (gi.call(Qf, n) && Qf[n])
        return !0;
      if (o.test(n)) {
        if (t = "aria-" + n.slice(4).toLowerCase(), t = t2.hasOwnProperty(t) ? t : null, t == null)
          return console.error(
            "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
            n
          ), Qf[n] = !0;
        if (n !== t)
          return console.error(
            "Invalid ARIA attribute `%s`. Did you mean `%s`?",
            n,
            t
          ), Qf[n] = !0;
      }
      if (b0.test(n)) {
        if (t = n.toLowerCase(), t = t2.hasOwnProperty(t) ? t : null, t == null) return Qf[n] = !0, !1;
        n !== t && (console.error(
          "Unknown ARIA attribute `%s`. Did you mean `%s`?",
          n,
          t
        ), Qf[n] = !0);
      }
      return !0;
    }
    function Vg(t, n) {
      var s = [], f;
      for (f in n)
        Jk(t, f) || s.push(f);
      n = s.map(function(p) {
        return "`" + p + "`";
      }).join(", "), s.length === 1 ? console.error(
        "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        n,
        t
      ) : 1 < s.length && console.error(
        "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        n,
        t
      );
    }
    function b1(t, n, s, f) {
      if (gi.call(c, n) && c[n])
        return !0;
      var p = n.toLowerCase();
      if (p === "onfocusin" || p === "onfocusout")
        return console.error(
          "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
        ), c[n] = !0;
      if (typeof s == "function" && (t === "form" && n === "action" || t === "input" && n === "formAction" || t === "button" && n === "formAction"))
        return !0;
      if (f != null) {
        if (t = f.possibleRegistrationNames, f.registrationNameDependencies.hasOwnProperty(n))
          return !0;
        if (f = t.hasOwnProperty(p) ? t[p] : null, f != null)
          return console.error(
            "Invalid event handler property `%s`. Did you mean `%s`?",
            n,
            f
          ), c[n] = !0;
        if (h.test(n))
          return console.error(
            "Unknown event handler property `%s`. It will be ignored.",
            n
          ), c[n] = !0;
      } else if (h.test(n))
        return v.test(n) && console.error(
          "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
          n
        ), c[n] = !0;
      if (w.test(n) || N.test(n)) return !0;
      if (p === "innerhtml")
        return console.error(
          "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
        ), c[n] = !0;
      if (p === "aria")
        return console.error(
          "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
        ), c[n] = !0;
      if (p === "is" && s !== null && s !== void 0 && typeof s != "string")
        return console.error(
          "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
          typeof s
        ), c[n] = !0;
      if (typeof s == "number" && isNaN(s))
        return console.error(
          "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
          n
        ), c[n] = !0;
      if (nc.hasOwnProperty(p)) {
        if (p = nc[p], p !== n)
          return console.error(
            "Invalid DOM property `%s`. Did you mean `%s`?",
            n,
            p
          ), c[n] = !0;
      } else if (n !== p)
        return console.error(
          "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
          n,
          p
        ), c[n] = !0;
      switch (n) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof s) {
        case "boolean":
          switch (n) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              return p = n.toLowerCase().slice(0, 5), p === "data-" || p === "aria-" ? !0 : (s ? console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                s,
                n,
                n,
                s,
                n
              ) : console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                s,
                n,
                n,
                s,
                n,
                n,
                n
              ), c[n] = !0);
          }
        case "function":
        case "symbol":
          return c[n] = !0, !1;
        case "string":
          if (s === "false" || s === "true") {
            switch (n) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              s,
              n,
              s === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
              n,
              s
            ), c[n] = !0;
          }
      }
      return !0;
    }
    function v1(t, n, s) {
      var f = [], p;
      for (p in n)
        b1(t, p, n[p], s) || f.push(p);
      n = f.map(function(m) {
        return "`" + m + "`";
      }).join(", "), f.length === 1 ? console.error(
        "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        n,
        t
      ) : 1 < f.length && console.error(
        "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        n,
        t
      );
    }
    function Wo(t) {
      return _.test("" + t) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : t;
    }
    function qs(t) {
      return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
    }
    function w1(t) {
      var n = fo(t);
      if (n && (t = n.stateNode)) {
        var s = t[ua] || null;
        e: switch (t = n.stateNode, n.type) {
          case "input":
            if (lu(
              t,
              s.value,
              s.defaultValue,
              s.defaultValue,
              s.checked,
              s.defaultChecked,
              s.type,
              s.name
            ), n = s.name, s.type === "radio" && n != null) {
              for (s = t; s.parentNode; ) s = s.parentNode;
              for (_e(n, "name"), s = s.querySelectorAll(
                'input[name="' + ho(
                  "" + n
                ) + '"][type="radio"]'
              ), n = 0; n < s.length; n++) {
                var f = s[n];
                if (f !== t && f.form === t.form) {
                  var p = f[ua] || null;
                  if (!p)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  lu(
                    f,
                    p.value,
                    p.defaultValue,
                    p.defaultValue,
                    p.checked,
                    p.defaultChecked,
                    p.type,
                    p.name
                  );
                }
              }
              for (n = 0; n < s.length; n++)
                f = s[n], f.form === t.form && Bg(f);
            }
            break e;
          case "textarea":
            c1(t, s.value, s.defaultValue);
            break e;
          case "select":
            n = s.value, n != null && po(t, !!s.multiple, n, !1);
        }
      }
    }
    function Wg(t, n, s) {
      if (Ne) return t(n, s);
      Ne = !0;
      try {
        var f = t(n);
        return f;
      } finally {
        if (Ne = !1, (oe !== null || ke !== null) && (va(), oe && (n = oe, t = ke, ke = oe = null, w1(n), t)))
          for (n = 0; n < t.length; n++) w1(t[n]);
      }
    }
    function Qc(t, n) {
      var s = t.stateNode;
      if (s === null) return null;
      var f = s[ua] || null;
      if (f === null) return null;
      s = f[n];
      e: switch (n) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (f = !f.disabled) || (t = t.type, f = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !f;
          break e;
        default:
          t = !1;
      }
      if (t) return null;
      if (s && typeof s != "function")
        throw Error(
          "Expected `" + n + "` listener to be a function, instead got a value of `" + typeof s + "` type."
        );
      return s;
    }
    function Zc() {
      if (Jt) return Jt;
      var t, n = et, s = n.length, f, p = "value" in Ue ? Ue.value : Ue.textContent, m = p.length;
      for (t = 0; t < s && n[t] === p[t]; t++) ;
      var E = s - t;
      for (f = 1; f <= E && n[s - f] === p[m - f]; f++) ;
      return Jt = p.slice(t, 1 < f ? 1 - f : void 0);
    }
    function Yc(t) {
      var n = t.keyCode;
      return "charCode" in t ? (t = t.charCode, t === 0 && n === 13 && (t = 13)) : t = n, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
    }
    function Ks() {
      return !0;
    }
    function $i() {
      return !1;
    }
    function Sr(t) {
      function n(s, f, p, m, E) {
        this._reactName = s, this._targetInst = p, this.type = f, this.nativeEvent = m, this.target = E, this.currentTarget = null;
        for (var I in t)
          t.hasOwnProperty(I) && (s = t[I], this[I] = s ? s(m) : m[I]);
        return this.isDefaultPrevented = (m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1) ? Ks : $i, this.isPropagationStopped = $i, this;
      }
      return st(n.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var s = this.nativeEvent;
          s && (s.preventDefault ? s.preventDefault() : typeof s.returnValue != "unknown" && (s.returnValue = !1), this.isDefaultPrevented = Ks);
        },
        stopPropagation: function() {
          var s = this.nativeEvent;
          s && (s.stopPropagation ? s.stopPropagation() : typeof s.cancelBubble != "unknown" && (s.cancelBubble = !0), this.isPropagationStopped = Ks);
        },
        persist: function() {
        },
        isPersistent: Ks
      }), n;
    }
    function Gg(t) {
      var n = this.nativeEvent;
      return n.getModifierState ? n.getModifierState(t) : (t = _N[t]) ? !!n[t] : !1;
    }
    function jg() {
      return Gg;
    }
    function Kd(t, n) {
      switch (t) {
        case "keyup":
          return qN.indexOf(n.keyCode) !== -1;
        case "keydown":
          return n.keyCode !== h7;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Jd(t) {
      return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
    }
    function Cw(t, n) {
      switch (t) {
        case "compositionend":
          return Jd(n);
        case "keypress":
          return n.which !== g7 ? null : (y7 = !0, m7);
        case "textInput":
          return t = n.data, t === m7 && y7 ? null : t;
        default:
          return null;
      }
    }
    function na(t, n) {
      if (v0)
        return t === "compositionend" || !S6 && Kd(t, n) ? (t = Zc(), Jt = et = Ue = null, v0 = !1, t) : null;
      switch (t) {
        case "paste":
          return null;
        case "keypress":
          if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) {
            if (n.char && 1 < n.char.length)
              return n.char;
            if (n.which)
              return String.fromCharCode(n.which);
          }
          return null;
        case "compositionend":
          return p7 && n.locale !== "ko" ? null : n.data;
        default:
          return null;
      }
    }
    function Js(t) {
      var n = t && t.nodeName && t.nodeName.toLowerCase();
      return n === "input" ? !!JN[t.type] : n === "textarea";
    }
    function $g(t) {
      if (!ca) return !1;
      t = "on" + t;
      var n = t in document;
      return n || (n = document.createElement("div"), n.setAttribute(t, "return;"), n = typeof n[t] == "function"), n;
    }
    function qc(t, n, s, f) {
      oe ? ke ? ke.push(f) : ke = [f] : oe = f, n = ys(n, "onChange"), 0 < n.length && (s = new re(
        "onChange",
        "change",
        null,
        s,
        f
      ), t.push({ event: s, listeners: n }));
    }
    function Xk(t) {
      Hm(t, 0);
    }
    function Kc(t) {
      var n = $d(t);
      if (Bg(n)) return t;
    }
    function Qg(t, n) {
      if (t === "change") return n;
    }
    function Jc() {
      r2 && (r2.detachEvent("onpropertychange", Xd), a2 = r2 = null);
    }
    function Xd(t) {
      if (t.propertyName === "value" && Kc(a2)) {
        var n = [];
        qc(
          n,
          a2,
          t,
          qs(t)
        ), Wg(Xk, n);
      }
    }
    function Tw(t, n, s) {
      t === "focusin" ? (Jc(), r2 = n, a2 = s, r2.attachEvent("onpropertychange", Xd)) : t === "focusout" && Jc();
    }
    function e6(t) {
      if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return Kc(a2);
    }
    function t6(t, n) {
      if (t === "click") return Kc(n);
    }
    function n6(t, n) {
      if (t === "input" || t === "change")
        return Kc(n);
    }
    function k1(t, n) {
      return t === n && (t !== 0 || 1 / t === 1 / n) || t !== t && n !== n;
    }
    function eh(t, n) {
      if (Pa(t, n)) return !0;
      if (typeof t != "object" || t === null || typeof n != "object" || n === null)
        return !1;
      var s = Object.keys(t), f = Object.keys(n);
      if (s.length !== f.length) return !1;
      for (f = 0; f < s.length; f++) {
        var p = s[f];
        if (!gi.call(n, p) || !Pa(t[p], n[p]))
          return !1;
      }
      return !0;
    }
    function Iw(t) {
      for (; t && t.firstChild; ) t = t.firstChild;
      return t;
    }
    function Nw(t, n) {
      var s = Iw(t);
      t = 0;
      for (var f; s; ) {
        if (s.nodeType === 3) {
          if (f = t + s.textContent.length, t <= n && f >= n)
            return { node: s, offset: n - t };
          t = f;
        }
        e: {
          for (; s; ) {
            if (s.nextSibling) {
              s = s.nextSibling;
              break e;
            }
            s = s.parentNode;
          }
          s = void 0;
        }
        s = Iw(s);
      }
    }
    function Pw(t, n) {
      return t && n ? t === n ? !0 : t && t.nodeType === 3 ? !1 : n && n.nodeType === 3 ? Pw(t, n.parentNode) : "contains" in t ? t.contains(n) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(n) & 16) : !1 : !1;
    }
    function Ow(t) {
      t = t != null && t.ownerDocument != null && t.ownerDocument.defaultView != null ? t.ownerDocument.defaultView : window;
      for (var n = Mg(t.document); n instanceof t.HTMLIFrameElement; ) {
        try {
          var s = typeof n.contentWindow.location.href == "string";
        } catch {
          s = !1;
        }
        if (s) t = n.contentWindow;
        else break;
        n = Mg(t.document);
      }
      return n;
    }
    function Zg(t) {
      var n = t && t.nodeName && t.nodeName.toLowerCase();
      return n && (n === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || n === "textarea" || t.contentEditable === "true");
    }
    function r6(t, n) {
      var s = Ow(n);
      n = t.focusedElem;
      var f = t.selectionRange;
      if (s !== n && n && n.ownerDocument && Pw(n.ownerDocument.documentElement, n)) {
        if (f !== null && Zg(n)) {
          if (t = f.start, s = f.end, s === void 0 && (s = t), "selectionStart" in n)
            n.selectionStart = t, n.selectionEnd = Math.min(
              s,
              n.value.length
            );
          else if (s = (t = n.ownerDocument || document) && t.defaultView || window, s.getSelection) {
            s = s.getSelection();
            var p = n.textContent.length, m = Math.min(f.start, p);
            f = f.end === void 0 ? m : Math.min(f.end, p), !s.extend && m > f && (p = f, f = m, m = p), p = Nw(n, m);
            var E = Nw(
              n,
              f
            );
            p && E && (s.rangeCount !== 1 || s.anchorNode !== p.node || s.anchorOffset !== p.offset || s.focusNode !== E.node || s.focusOffset !== E.offset) && (t = t.createRange(), t.setStart(p.node, p.offset), s.removeAllRanges(), m > f ? (s.addRange(t), s.extend(E.node, E.offset)) : (t.setEnd(
              E.node,
              E.offset
            ), s.addRange(t)));
          }
        }
        for (t = [], s = n; s = s.parentNode; )
          s.nodeType === 1 && t.push({
            element: s,
            left: s.scrollLeft,
            top: s.scrollTop
          });
        for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)
          s = t[n], s.element.scrollLeft = s.left, s.element.scrollTop = s.top;
      }
    }
    function Rw(t, n, s) {
      var f = s.window === s ? s.document : s.nodeType === 9 ? s : s.ownerDocument;
      x6 || w0 == null || w0 !== Mg(f) || (f = w0, "selectionStart" in f && Zg(f) ? f = { start: f.selectionStart, end: f.selectionEnd } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
        anchorNode: f.anchorNode,
        anchorOffset: f.anchorOffset,
        focusNode: f.focusNode,
        focusOffset: f.focusOffset
      }), o2 && eh(o2, f) || (o2 = f, f = ys(A6, "onSelect"), 0 < f.length && (n = new re(
        "onSelect",
        "select",
        null,
        n,
        s
      ), t.push({ event: n, listeners: f }), n.target = w0)));
    }
    function pu(t, n) {
      var s = {};
      return s[t.toLowerCase()] = n.toLowerCase(), s["Webkit" + t] = "webkit" + n, s["Moz" + t] = "moz" + n, s;
    }
    function gu(t) {
      if (C6[t]) return C6[t];
      if (!k0[t]) return t;
      var n = k0[t], s;
      for (s in n)
        if (n.hasOwnProperty(s) && s in v7)
          return C6[t] = n[s];
      return t;
    }
    function pa(t, n) {
      A7.set(t, n), Vi(n, [t]);
    }
    function Yg() {
      for (var t = E0, n = T6 = E0 = 0; n < t; ) {
        var s = yi[n];
        yi[n++] = null;
        var f = yi[n];
        yi[n++] = null;
        var p = yi[n];
        yi[n++] = null;
        var m = yi[n];
        if (yi[n++] = null, f !== null && p !== null) {
          var E = f.pending;
          E === null ? p.next = p : (p.next = E.next, E.next = p), f.pending = p;
        }
        m !== 0 && Lw(s, p, m);
      }
    }
    function qg(t, n, s, f) {
      yi[E0++] = t, yi[E0++] = n, yi[E0++] = s, yi[E0++] = f, T6 |= f, t.lanes |= f, t = t.alternate, t !== null && (t.lanes |= f);
    }
    function E1(t, n, s, f) {
      return qg(t, n, s, f), Kg(t);
    }
    function dr(t, n) {
      return qg(t, null, null, n), Kg(t);
    }
    function Lw(t, n, s) {
      t.lanes |= s;
      var f = t.alternate;
      f !== null && (f.lanes |= s);
      for (var p = !1, m = t.return; m !== null; )
        m.childLanes |= s, f = m.alternate, f !== null && (f.childLanes |= s), m.tag === 22 && (t = m.stateNode, t === null || t._visibility & x3 || (p = !0)), t = m, m = m.return;
      p && n !== null && t.tag === 3 && (m = t.stateNode, p = 31 - Rr(s), m = m.hiddenUpdates, t = m[p], t === null ? m[p] = [n] : t.push(n), n.lane = s | 536870912);
    }
    function Kg(t) {
      if (I2 > gP)
        throw wp = I2 = 0, N2 = n8 = null, Error(
          "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
        );
      wp > mP && (wp = 0, N2 = null, console.error(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      )), t.alternate === null && t.flags & 4098 && wb(t);
      for (var n = t, s = n.return; s !== null; )
        n.alternate === null && n.flags & 4098 && wb(t), n = s, s = n.return;
      return n.tag === 3 ? n.stateNode : null;
    }
    function mu(t) {
      if (bi === null) return t;
      var n = bi(t);
      return n === void 0 ? t : n.current;
    }
    function S1(t) {
      if (bi === null) return t;
      var n = bi(t);
      return n === void 0 ? t != null && typeof t.render == "function" && (n = mu(t.render), t.render !== n) ? (n = { $$typeof: Ju, render: n }, t.displayName !== void 0 && (n.displayName = t.displayName), n) : t : n.current;
    }
    function Dw(t, n) {
      if (bi === null) return !1;
      var s = t.elementType;
      n = n.type;
      var f = !1, p = typeof n == "object" && n !== null ? n.$$typeof : null;
      switch (t.tag) {
        case 1:
          typeof n == "function" && (f = !0);
          break;
        case 0:
          (typeof n == "function" || p === Nr) && (f = !0);
          break;
        case 11:
          (p === Ju || p === Nr) && (f = !0);
          break;
        case 14:
        case 15:
          (p === Al || p === Nr) && (f = !0);
          break;
        default:
          return !1;
      }
      return !!(f && (t = bi(s), t !== void 0 && t === bi(n)));
    }
    function Bw(t) {
      bi !== null && typeof WeakSet == "function" && (S0 === null && (S0 = /* @__PURE__ */ new WeakSet()), S0.add(t));
    }
    function A1(t, n, s) {
      var f = t.alternate, p = t.child, m = t.sibling, E = t.tag, I = t.type, F = null;
      switch (E) {
        case 0:
        case 15:
        case 1:
          F = I;
          break;
        case 11:
          F = I.render;
      }
      if (bi === null)
        throw Error("Expected resolveFamily to be set during hot reload.");
      var z = !1;
      I = !1, F !== null && (F = bi(F), F !== void 0 && (s.has(F) ? I = !0 : n.has(F) && (E === 1 ? I = !0 : z = !0))), S0 !== null && (S0.has(t) || f !== null && S0.has(f)) && (I = !0), I && (t._debugNeedsRemount = !0), (I || z) && (f = dr(t, 2), f !== null && Vt(f, t, 2)), p === null || I || A1(
        p,
        n,
        s
      ), m !== null && A1(
        m,
        n,
        s
      );
    }
    function Qi() {
      var t = sp;
      return sp = 0, t;
    }
    function Jg(t) {
      var n = sp;
      return sp = t, n;
    }
    function yu(t) {
      var n = sp;
      return sp += t, n;
    }
    function bu(t) {
      eo = A0(), 0 > t.actualStartTime && (t.actualStartTime = eo);
    }
    function x1(t) {
      if (0 <= eo) {
        var n = A0() - eo;
        t.actualDuration += n, t.selfBaseDuration = n, eo = -1;
      }
    }
    function C1(t) {
      if (0 <= eo) {
        var n = A0() - eo;
        t.actualDuration += n, eo = -1;
      }
    }
    function go() {
      if (0 <= eo) {
        var t = A0() - eo;
        eo = -1, sp += t;
      }
    }
    function mo() {
      eo = A0();
    }
    function th(t) {
      for (var n = t.child; n; )
        t.actualDuration += n.actualDuration, n = n.sibling;
    }
    function ra(t, n) {
      if (typeof t == "object" && t !== null) {
        var s = N6.get(t);
        return s !== void 0 ? s : (n = {
          value: t,
          source: n,
          stack: ae(n)
        }, N6.set(t, n), n);
      }
      return {
        value: t,
        source: n,
        stack: ae(n)
      };
    }
    function $a(t, n) {
      Xs(), x0[C0++] = O3, x0[C0++] = P3, P3 = t, O3 = n;
    }
    function Mw(t, n, s) {
      Xs(), vi[wi++] = rc, vi[wi++] = ac, vi[wi++] = up, up = t;
      var f = rc;
      t = ac;
      var p = 32 - Rr(f) - 1;
      f &= ~(1 << p), s += 1;
      var m = 32 - Rr(n) + p;
      if (30 < m) {
        var E = p - p % 5;
        m = (f & (1 << E) - 1).toString(32), f >>= E, p -= E, rc = 1 << 32 - Rr(n) + p | s << p | f, ac = m + t;
      } else
        rc = 1 << m | s << p | f, ac = t;
    }
    function T1(t) {
      Xs(), t.return !== null && ($a(t, 1), Mw(t, 1, 0));
    }
    function I1(t) {
      for (; t === P3; )
        P3 = x0[--C0], x0[C0] = null, O3 = x0[--C0], x0[C0] = null;
      for (; t === up; )
        up = vi[--wi], vi[wi] = null, ac = vi[--wi], vi[wi] = null, rc = vi[--wi], vi[wi] = null;
    }
    function Xs() {
      It || console.error(
        "Expected to be hydrating. This is a bug in React. Please file an issue."
      );
    }
    function el(t, n) {
      if (t.return === null) {
        if (ki === null)
          ki = {
            fiber: t,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: n
          };
        else {
          if (ki.fiber !== t)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          ki.distanceFromLeaf > n && (ki.distanceFromLeaf = n);
        }
        return ki;
      }
      var s = el(
        t.return,
        n + 1
      ).children;
      return 0 < s.length && s[s.length - 1].fiber === t ? (s = s[s.length - 1], s.distanceFromLeaf > n && (s.distanceFromLeaf = n), s) : (n = {
        fiber: t,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: n
      }, s.push(n), n);
    }
    function vu(t, n) {
      oc || (t = el(t, 0), t.serverProps = null, n !== null && (n = Zm(n), t.serverTail.push(n)));
    }
    function yo(t) {
      var n = "", s = ki;
      throw s !== null && (ki = null, n = h1(s)), wu(
        ra(
          Error(
            `Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + n
          ),
          t
        )
      ), P6;
    }
    function Fw(t) {
      var n = t.stateNode, s = t.type, f = t.memoizedProps;
      switch (n[yr] = t, n[ua] = f, Wu(s, f), s) {
        case "dialog":
          vt("cancel", n), vt("close", n);
          break;
        case "iframe":
        case "object":
        case "embed":
          vt("load", n);
          break;
        case "video":
        case "audio":
          for (s = 0; s < P2.length; s++)
            vt(P2[s], n);
          break;
        case "source":
          vt("error", n);
          break;
        case "img":
        case "image":
        case "link":
          vt("error", n), vt("load", n);
          break;
        case "details":
          vt("toggle", n);
          break;
        case "input":
          Vc("input", f), vt("invalid", n), l1(n, f), Fg(
            n,
            f.value,
            f.defaultValue,
            f.checked,
            f.defaultChecked,
            f.type,
            f.name,
            !0
          ), Gi(n);
          break;
        case "option":
          uu(n, f);
          break;
        case "select":
          Vc("select", f), vt("invalid", n), Mn(n, f);
          break;
        case "textarea":
          Vc("textarea", f), vt("invalid", n), u1(n, f), Zs(
            n,
            f.value,
            f.defaultValue,
            f.children
          ), Gi(n);
      }
      s = f.children, typeof s != "string" && typeof s != "number" && typeof s != "bigint" || n.textContent === "" + s || f.suppressHydrationWarning === !0 || Gm(n.textContent, s) ? (f.popover != null && (vt("beforetoggle", n), vt("toggle", n)), f.onScroll != null && vt("scroll", n), f.onScrollEnd != null && vt("scrollend", n), f.onClick != null && (n.onclick = To), n = !0) : n = !1, n || yo(t);
    }
    function nh(t) {
      for (Oa = t.return; Oa; )
        switch (Oa.tag) {
          case 3:
          case 27:
            Ml = !0;
            return;
          case 5:
          case 13:
            Ml = !1;
            return;
          default:
            Oa = Oa.return;
        }
    }
    function Xc(t) {
      if (t !== Oa) return !1;
      if (!It)
        return nh(t), It = !0, !1;
      var n = !1, s;
      if ((s = t.tag !== 3 && t.tag !== 27) && ((s = t.tag === 5) && (s = t.type, s = !(s !== "form" && s !== "button") || zt(t.type, t.memoizedProps)), s = !s), s && (n = !0), n && $r) {
        for (n = $r; n; ) {
          s = el(t, 0);
          var f = Zm(n);
          s.serverTail.push(f), n = f.type === "Suspense" ? Wh(n) : sa(n.nextSibling);
        }
        yo(t);
      }
      if (nh(t), t.tag === 13) {
        if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        $r = Wh(t);
      } else
        $r = Oa ? sa(t.stateNode.nextSibling) : null;
      return !0;
    }
    function ef() {
      $r = Oa = null, oc = It = !1;
    }
    function wu(t) {
      Cs === null ? Cs = [t] : Cs.push(t);
    }
    function Xg() {
      var t = ki;
      t !== null && (ki = null, t = h1(t), console.error(
        `A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`,
        "https://react.dev/link/hydration-mismatch",
        t
      ));
    }
    function N1() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function P1(t) {
      return t = t.status, t === "fulfilled" || t === "rejected";
    }
    function rh() {
    }
    function _w(t, n, s) {
      me.actQueue !== null && (me.didUsePromise = !0);
      var f = t.thenables;
      switch (s = f[s], s === void 0 ? f.push(n) : s !== n && (t.didWarnAboutUncachedPromise || (t.didWarnAboutUncachedPromise = !0, console.error(
        "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
      )), n.then(rh, rh), n = s), n.status) {
        case "fulfilled":
          return n.value;
        case "rejected":
          throw t = n.reason, zw(t), t;
        default:
          if (typeof n.status == "string")
            n.then(rh, rh);
          else {
            if (t = Xt, t !== null && 100 < t.shellSuspendCounter)
              throw Error(
                "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            t = n, t.status = "pending", t.then(
              function(p) {
                if (n.status === "pending") {
                  var m = n;
                  m.status = "fulfilled", m.value = p;
                }
              },
              function(p) {
                if (n.status === "pending") {
                  var m = n;
                  m.status = "rejected", m.reason = p;
                }
              }
            );
          }
          switch (n.status) {
            case "fulfilled":
              return n.value;
            case "rejected":
              throw t = n.reason, zw(t), t;
          }
          throw h2 = n, L3 = !0, R3;
      }
    }
    function Uw() {
      if (h2 === null)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var t = h2;
      return h2 = null, L3 = !1, t;
    }
    function zw(t) {
      if (t === R3)
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function hr(t) {
      var n = dt;
      return t != null && (dt = n === null ? t : n.concat(t)), n;
    }
    function em(t, n, s) {
      for (var f = Object.keys(t.props), p = 0; p < f.length; p++) {
        var m = f[p];
        if (m !== "children" && m !== "key") {
          n === null && (n = Sf(t, s.mode, 0), n._debugInfo = dt, n.return = s), V(
            n,
            function(E) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                E
              );
            },
            m
          );
          break;
        }
      }
    }
    function Ar(t) {
      var n = p2;
      return p2 += 1, T0 === null && (T0 = N1()), _w(T0, t, n);
    }
    function Zi(t, n) {
      n = n.props.ref, t.ref = n !== void 0 ? n : null;
    }
    function ah(t, n) {
      throw n.$$typeof === Vb ? Error(
        `A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`
      ) : (t = Object.prototype.toString.call(n), Error(
        "Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."
      ));
    }
    function oh(t, n) {
      var s = Z(t) || "Component";
      W7[s] || (W7[s] = !0, n = n.displayName || n.name || "Component", t.tag === 3 ? console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`,
        n,
        n,
        n
      ) : console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`,
        n,
        n,
        s,
        n,
        s
      ));
    }
    function ih(t, n) {
      var s = Z(t) || "Component";
      G7[s] || (G7[s] = !0, n = String(n), t.tag === 3 ? console.error(
        `Symbols are not valid as a React child.
  root.render(%s)`,
        n
      ) : console.error(
        `Symbols are not valid as a React child.
  <%s>%s</%s>`,
        s,
        n,
        s
      ));
    }
    function O1(t) {
      function n(K, q) {
        if (t) {
          var te = K.deletions;
          te === null ? (K.deletions = [q], K.flags |= 16) : te.push(q);
        }
      }
      function s(K, q) {
        if (!t) return null;
        for (; q !== null; )
          n(K, q), q = q.sibling;
        return null;
      }
      function f(K) {
        for (var q = /* @__PURE__ */ new Map(); K !== null; )
          K.key !== null ? q.set(K.key, K) : q.set(K.index, K), K = K.sibling;
        return q;
      }
      function p(K, q) {
        return K = ni(K, q), K.index = 0, K.sibling = null, K;
      }
      function m(K, q, te) {
        return K.index = te, t ? (te = K.alternate, te !== null ? (te = te.index, te < q ? (K.flags |= 33554434, q) : te) : (K.flags |= 33554434, q)) : (K.flags |= 1048576, q);
      }
      function E(K) {
        return t && K.alternate === null && (K.flags |= 33554434), K;
      }
      function I(K, q, te, we) {
        return q === null || q.tag !== 6 ? (q = Rm(
          te,
          K.mode,
          we
        ), q.return = K, q._debugOwner = K, q._debugInfo = dt, q) : (q = p(q, te), q.return = K, q._debugInfo = dt, q);
      }
      function F(K, q, te, we) {
        var De = te.type;
        return De === pi ? (q = de(
          K,
          q,
          te.props.children,
          we,
          te.key
        ), em(te, q, K), q) : q !== null && (q.elementType === De || Dw(q, te) || typeof De == "object" && De !== null && De.$$typeof === Nr && Yf(De) === q.type) ? (q = p(q, te.props), Zi(q, te), q.return = K, q._debugOwner = te._owner, q._debugInfo = dt, q) : (q = Sf(te, K.mode, we), Zi(q, te), q.return = K, q._debugInfo = dt, q);
      }
      function z(K, q, te, we) {
        return q === null || q.tag !== 4 || q.stateNode.containerInfo !== te.containerInfo || q.stateNode.implementation !== te.implementation ? (q = Oh(te, K.mode, we), q.return = K, q._debugInfo = dt, q) : (q = p(q, te.children || []), q.return = K, q._debugInfo = dt, q);
      }
      function de(K, q, te, we, De) {
        return q === null || q.tag !== 7 ? (q = cs(
          te,
          K.mode,
          we,
          De
        ), q.return = K, q._debugOwner = K, q._debugInfo = dt, q) : (q = p(q, te), q.return = K, q._debugInfo = dt, q);
      }
      function Ee(K, q, te) {
        if (typeof q == "string" && q !== "" || typeof q == "number" || typeof q == "bigint")
          return q = Rm(
            "" + q,
            K.mode,
            te
          ), q.return = K, q._debugOwner = K, q._debugInfo = dt, q;
        if (typeof q == "object" && q !== null) {
          switch (q.$$typeof) {
            case Sl:
              return te = Sf(
                q,
                K.mode,
                te
              ), Zi(te, q), te.return = K, K = hr(q._debugInfo), te._debugInfo = dt, dt = K, te;
            case Uf:
              return q = Oh(
                q,
                K.mode,
                te
              ), q.return = K, q._debugInfo = dt, q;
            case Nr:
              var we = hr(q._debugInfo);
              return q = Yf(q), K = Ee(K, q, te), dt = we, K;
          }
          if (mr(q) || L(q))
            return te = cs(
              q,
              K.mode,
              te,
              null
            ), te.return = K, te._debugOwner = K, K = hr(q._debugInfo), te._debugInfo = dt, dt = K, te;
          if (typeof q.then == "function")
            return we = hr(q._debugInfo), K = Ee(
              K,
              Ar(q),
              te
            ), dt = we, K;
          if (q.$$typeof === Ca)
            return Ee(
              K,
              mf(K, q),
              te
            );
          ah(K, q);
        }
        return typeof q == "function" && oh(K, q), typeof q == "symbol" && ih(K, q), null;
      }
      function pe(K, q, te, we) {
        var De = q !== null ? q.key : null;
        if (typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint")
          return De !== null ? null : I(K, q, "" + te, we);
        if (typeof te == "object" && te !== null) {
          switch (te.$$typeof) {
            case Sl:
              return te.key === De ? (De = hr(te._debugInfo), K = F(
                K,
                q,
                te,
                we
              ), dt = De, K) : null;
            case Uf:
              return te.key === De ? z(K, q, te, we) : null;
            case Nr:
              return De = hr(te._debugInfo), te = Yf(te), K = pe(
                K,
                q,
                te,
                we
              ), dt = De, K;
          }
          if (mr(te) || L(te))
            return De !== null ? null : (De = hr(te._debugInfo), K = de(
              K,
              q,
              te,
              we,
              null
            ), dt = De, K);
          if (typeof te.then == "function")
            return De = hr(te._debugInfo), K = pe(
              K,
              q,
              Ar(te),
              we
            ), dt = De, K;
          if (te.$$typeof === Ca)
            return pe(
              K,
              q,
              mf(K, te),
              we
            );
          ah(K, te);
        }
        return typeof te == "function" && oh(K, te), typeof te == "symbol" && ih(K, te), null;
      }
      function Se(K, q, te, we, De) {
        if (typeof we == "string" && we !== "" || typeof we == "number" || typeof we == "bigint")
          return K = K.get(te) || null, I(q, K, "" + we, De);
        if (typeof we == "object" && we !== null) {
          switch (we.$$typeof) {
            case Sl:
              return te = K.get(
                we.key === null ? te : we.key
              ) || null, K = hr(we._debugInfo), q = F(
                q,
                te,
                we,
                De
              ), dt = K, q;
            case Uf:
              return K = K.get(
                we.key === null ? te : we.key
              ) || null, z(q, K, we, De);
            case Nr:
              var it = hr(we._debugInfo);
              return we = Yf(we), q = Se(
                K,
                q,
                te,
                we,
                De
              ), dt = it, q;
          }
          if (mr(we) || L(we))
            return te = K.get(te) || null, K = hr(we._debugInfo), q = de(
              q,
              te,
              we,
              De,
              null
            ), dt = K, q;
          if (typeof we.then == "function")
            return it = hr(we._debugInfo), q = Se(
              K,
              q,
              te,
              Ar(we),
              De
            ), dt = it, q;
          if (we.$$typeof === Ca)
            return Se(
              K,
              q,
              te,
              mf(q, we),
              De
            );
          ah(q, we);
        }
        return typeof we == "function" && oh(q, we), typeof we == "symbol" && ih(q, we), null;
      }
      function Ze(K, q, te, we) {
        if (typeof te != "object" || te === null) return we;
        switch (te.$$typeof) {
          case Sl:
          case Uf:
            A(K, q, te);
            var De = te.key;
            if (typeof De != "string") break;
            if (we === null) {
              we = /* @__PURE__ */ new Set(), we.add(De);
              break;
            }
            if (!we.has(De)) {
              we.add(De);
              break;
            }
            V(q, function() {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.",
                De
              );
            });
            break;
          case Nr:
            te = Yf(te), Ze(K, q, te, we);
        }
        return we;
      }
      function ct(K, q, te, we) {
        for (var De = null, it = null, je = null, lt = q, ft = q = 0, dn = null; lt !== null && ft < te.length; ft++) {
          lt.index > ft ? (dn = lt, lt = null) : dn = lt.sibling;
          var jn = pe(
            K,
            lt,
            te[ft],
            we
          );
          if (jn === null) {
            lt === null && (lt = dn);
            break;
          }
          De = Ze(
            K,
            jn,
            te[ft],
            De
          ), t && lt && jn.alternate === null && n(K, lt), q = m(jn, q, ft), je === null ? it = jn : je.sibling = jn, je = jn, lt = dn;
        }
        if (ft === te.length)
          return s(K, lt), It && $a(K, ft), it;
        if (lt === null) {
          for (; ft < te.length; ft++)
            lt = Ee(K, te[ft], we), lt !== null && (De = Ze(
              K,
              lt,
              te[ft],
              De
            ), q = m(
              lt,
              q,
              ft
            ), je === null ? it = lt : je.sibling = lt, je = lt);
          return It && $a(K, ft), it;
        }
        for (lt = f(lt); ft < te.length; ft++)
          dn = Se(
            lt,
            K,
            ft,
            te[ft],
            we
          ), dn !== null && (De = Ze(
            K,
            dn,
            te[ft],
            De
          ), t && dn.alternate !== null && lt.delete(
            dn.key === null ? ft : dn.key
          ), q = m(
            dn,
            q,
            ft
          ), je === null ? it = dn : je.sibling = dn, je = dn);
        return t && lt.forEach(function(pc) {
          return n(K, pc);
        }), It && $a(K, ft), it;
      }
      function Gn(K, q, te, we) {
        if (te == null)
          throw Error("An iterable object provided no iterator.");
        for (var De = null, it = null, je = q, lt = q = 0, ft = null, dn = null, jn = te.next(); je !== null && !jn.done; lt++, jn = te.next()) {
          je.index > lt ? (ft = je, je = null) : ft = je.sibling;
          var pc = pe(K, je, jn.value, we);
          if (pc === null) {
            je === null && (je = ft);
            break;
          }
          dn = Ze(
            K,
            pc,
            jn.value,
            dn
          ), t && je && pc.alternate === null && n(K, je), q = m(pc, q, lt), it === null ? De = pc : it.sibling = pc, it = pc, je = ft;
        }
        if (jn.done)
          return s(K, je), It && $a(K, lt), De;
        if (je === null) {
          for (; !jn.done; lt++, jn = te.next())
            je = Ee(K, jn.value, we), je !== null && (dn = Ze(
              K,
              je,
              jn.value,
              dn
            ), q = m(
              je,
              q,
              lt
            ), it === null ? De = je : it.sibling = je, it = je);
          return It && $a(K, lt), De;
        }
        for (je = f(je); !jn.done; lt++, jn = te.next())
          ft = Se(
            je,
            K,
            lt,
            jn.value,
            we
          ), ft !== null && (dn = Ze(
            K,
            ft,
            jn.value,
            dn
          ), t && ft.alternate !== null && je.delete(
            ft.key === null ? lt : ft.key
          ), q = m(
            ft,
            q,
            lt
          ), it === null ? De = ft : it.sibling = ft, it = ft);
        return t && je.forEach(function(IP) {
          return n(K, IP);
        }), It && $a(K, lt), De;
      }
      function _t(K, q, te, we) {
        if (typeof te == "object" && te !== null && te.type === pi && te.key === null && (em(te, null, K), te = te.props.children), typeof te == "object" && te !== null) {
          switch (te.$$typeof) {
            case Sl:
              var De = hr(te._debugInfo);
              e: {
                for (var it = te.key; q !== null; ) {
                  if (q.key === it) {
                    if (it = te.type, it === pi) {
                      if (q.tag === 7) {
                        s(
                          K,
                          q.sibling
                        ), we = p(
                          q,
                          te.props.children
                        ), we.return = K, we._debugOwner = te._owner, we._debugInfo = dt, em(te, we, K), K = we;
                        break e;
                      }
                    } else if (q.elementType === it || Dw(
                      q,
                      te
                    ) || typeof it == "object" && it !== null && it.$$typeof === Nr && Yf(it) === q.type) {
                      s(
                        K,
                        q.sibling
                      ), we = p(q, te.props), Zi(we, te), we.return = K, we._debugOwner = te._owner, we._debugInfo = dt, K = we;
                      break e;
                    }
                    s(K, q);
                    break;
                  } else n(K, q);
                  q = q.sibling;
                }
                te.type === pi ? (we = cs(
                  te.props.children,
                  K.mode,
                  we,
                  te.key
                ), we.return = K, we._debugOwner = K, we._debugInfo = dt, em(te, we, K), K = we) : (we = Sf(
                  te,
                  K.mode,
                  we
                ), Zi(we, te), we.return = K, we._debugInfo = dt, K = we);
              }
              return K = E(K), dt = De, K;
            case Uf:
              e: {
                for (De = te, te = De.key; q !== null; ) {
                  if (q.key === te)
                    if (q.tag === 4 && q.stateNode.containerInfo === De.containerInfo && q.stateNode.implementation === De.implementation) {
                      s(
                        K,
                        q.sibling
                      ), we = p(
                        q,
                        De.children || []
                      ), we.return = K, K = we;
                      break e;
                    } else {
                      s(K, q);
                      break;
                    }
                  else n(K, q);
                  q = q.sibling;
                }
                we = Oh(
                  De,
                  K.mode,
                  we
                ), we.return = K, K = we;
              }
              return E(K);
            case Nr:
              return De = hr(te._debugInfo), te = Yf(te), K = _t(
                K,
                q,
                te,
                we
              ), dt = De, K;
          }
          if (mr(te))
            return De = hr(te._debugInfo), K = ct(
              K,
              q,
              te,
              we
            ), dt = De, K;
          if (L(te)) {
            if (De = hr(te._debugInfo), it = L(te), typeof it != "function")
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var je = it.call(te);
            return je === te ? (K.tag !== 0 || Object.prototype.toString.call(K.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(je) !== "[object Generator]") && (H7 || console.error(
              "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
            ), H7 = !0) : te.entries !== it || D6 || (console.error(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), D6 = !0), K = Gn(
              K,
              q,
              je,
              we
            ), dt = De, K;
          }
          if (typeof te.then == "function")
            return De = hr(te._debugInfo), K = _t(
              K,
              q,
              Ar(te),
              we
            ), dt = De, K;
          if (te.$$typeof === Ca)
            return _t(
              K,
              q,
              mf(K, te),
              we
            );
          ah(K, te);
        }
        return typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint" ? (De = "" + te, q !== null && q.tag === 6 ? (s(
          K,
          q.sibling
        ), we = p(q, De), we.return = K, K = we) : (s(K, q), we = Rm(
          De,
          K.mode,
          we
        ), we.return = K, we._debugOwner = K, we._debugInfo = dt, K = we), E(K)) : (typeof te == "function" && oh(K, te), typeof te == "symbol" && ih(K, te), s(K, q));
      }
      return function(K, q, te, we) {
        var De = dt;
        dt = null;
        try {
          p2 = 0;
          var it = _t(
            K,
            q,
            te,
            we
          );
          return T0 = null, it;
        } catch (dn) {
          if (dn === R3) throw dn;
          var je = b(29, dn, null, K.mode);
          je.lanes = we, je.return = K;
          var lt = je._debugInfo = dt;
          if (je._debugOwner = K._debugOwner, lt != null) {
            for (var ft = lt.length - 1; 0 <= ft; ft--)
              if (typeof lt[ft].stack == "string") {
                je._debugOwner = lt[ft];
                break;
              }
          }
          return je;
        } finally {
          dt = De;
        }
      };
    }
    function tm(t, n) {
      var s = _l;
      Ce(D3, s, t), Ce(I0, n, t), _l = s | n.baseLanes;
    }
    function R1(t) {
      Ce(D3, _l, t), Ce(
        I0,
        I0.current,
        t
      );
    }
    function L1(t) {
      _l = D3.current, xe(I0, t), xe(D3, t);
    }
    function ga(t) {
      var n = t.alternate;
      Ce(
        br,
        br.current & N0,
        t
      ), Ce(Ei, t, t), ic === null && (n === null || I0.current !== null || n.memoizedState !== null) && (ic = t);
    }
    function nm(t) {
      if (t.tag === 22) {
        if (Ce(br, br.current, t), Ce(Ei, t, t), ic === null) {
          var n = t.alternate;
          n !== null && n.memoizedState !== null && (ic = t);
        }
      } else Qa(t);
    }
    function Qa(t) {
      Ce(br, br.current, t), Ce(
        Ei,
        Ei.current,
        t
      );
    }
    function bo(t) {
      xe(Ei, t), ic === t && (ic = null), xe(br, t);
    }
    function sh(t) {
      for (var n = t; n !== null; ) {
        if (n.tag === 13) {
          var s = n.memoizedState;
          if (s !== null && (s = s.dehydrated, s === null || s.data === Sp || s.data === Ap))
            return n;
        } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) {
          if (n.flags & 128) return n;
        } else if (n.child !== null) {
          n.child.return = n, n = n.child;
          continue;
        }
        if (n === t) break;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === t) return null;
          n = n.return;
        }
        n.sibling.return = n.return, n = n.sibling;
      }
      return null;
    }
    function Yi() {
      return {
        controller: new sP(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function Za(t) {
      t.controller.signal.aborted && console.warn(
        "A cache instance was retained after it was already freed. This likely indicates a bug in React."
      ), t.refCount++;
    }
    function ku(t) {
      t.refCount--, 0 > t.refCount && console.warn(
        "A cache instance was released after it was already freed. This likely indicates a bug in React."
      ), t.refCount === 0 && lP(uP, function() {
        t.controller.abort();
      });
    }
    function Hw(t, n) {
      if (m2 === null) {
        var s = m2 = [];
        B6 = 0, fp = zm(), P0 = {
          status: "pending",
          value: void 0,
          then: function(f) {
            s.push(f);
          }
        };
      }
      return B6++, n.then(tl, tl), n;
    }
    function tl() {
      if (--B6 === 0 && m2 !== null) {
        P0 !== null && (P0.status = "fulfilled");
        var t = m2;
        m2 = null, fp = 0, P0 = null;
        for (var n = 0; n < t.length; n++) (0, t[n])();
      }
    }
    function Vw(t, n) {
      var s = [], f = {
        status: "pending",
        value: null,
        reason: null,
        then: function(p) {
          s.push(p);
        }
      };
      return t.then(
        function() {
          f.status = "fulfilled", f.value = n;
          for (var p = 0; p < s.length; p++) (0, s[p])(n);
        },
        function(p) {
          for (f.status = "rejected", f.reason = p, p = 0; p < s.length; p++)
            (0, s[p])(void 0);
        }
      ), f;
    }
    function rm() {
      var t = dp.current;
      return t !== null ? t : Xt.pooledCache;
    }
    function lh(t, n) {
      n === null ? Ce(dp, dp.current, t) : Ce(dp, n.pool, t);
    }
    function Ww() {
      var t = rm();
      return t === null ? null : { parent: wr._currentValue, pool: t };
    }
    function ht() {
      var t = be;
      xi === null ? xi = [t] : xi.push(t);
    }
    function Le() {
      var t = be;
      if (xi !== null && (lc++, xi[lc] !== t)) {
        var n = Z(
          nt
        );
        if (!Q7.has(n) && (Q7.add(n), xi !== null)) {
          for (var s = "", f = 0; f <= lc; f++) {
            var p = xi[f], m = f === lc ? t : p;
            for (p = f + 1 + ". " + p; 30 > p.length; )
              p += " ";
            p += m + `
`, s += p;
          }
          console.error(
            `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
            n,
            s
          );
        }
      }
    }
    function Eu(t) {
      t == null || mr(t) || console.error(
        "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
        be,
        typeof t
      );
    }
    function uh() {
      var t = Z(nt);
      Y7.has(t) || (Y7.add(t), console.error(
        "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
        t
      ));
    }
    function pn() {
      throw Error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      );
    }
    function ma(t, n) {
      if (b2) return !1;
      if (n === null)
        return console.error(
          "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
          be
        ), !1;
      t.length !== n.length && console.error(
        `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
        be,
        "[" + n.join(", ") + "]",
        "[" + t.join(", ") + "]"
      );
      for (var s = 0; s < n.length && s < t.length; s++)
        if (!Pa(t[s], n[s])) return !1;
      return !0;
    }
    function aa(t, n, s, f, p, m) {
      qf = m, nt = n, xi = t !== null ? t._debugHookTypes : null, lc = -1, b2 = t !== null && t.type !== n.type, (Object.prototype.toString.call(s) === "[object AsyncFunction]" || Object.prototype.toString.call(s) === "[object AsyncGeneratorFunction]") && (m = Z(
        nt
      ), M6.has(m) || (M6.add(m), console.error(
        "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
      ))), n.memoizedState = null, n.updateQueue = null, n.lanes = 0, me.H = t !== null && t.memoizedState !== null ? Jf : xi !== null ? pp : Kf, hp = m = (n.mode & fa) !== sn;
      var E = R6(s, f, p);
      if (hp = !1, R0 && (E = ch(
        n,
        s,
        f,
        p
      )), m) {
        jt(!0);
        try {
          E = ch(
            n,
            s,
            f,
            p
          );
        } finally {
          jt(!1);
        }
      }
      return Su(t, n), E;
    }
    function Su(t, n) {
      n._debugHookTypes = xi, n.dependencies === null ? sc !== null && (n.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: sc
      }) : n.dependencies._debugThenableState = sc, me.H = Fl;
      var s = Zt !== null && Zt.next !== null;
      if (qf = 0, xi = be = ir = Zt = nt = null, lc = -1, t !== null && (t.flags & 31457280) !== (n.flags & 31457280) && console.error(
        "Internal React error: Expected static flag was missing. Please notify the React team."
      ), B3 = !1, y2 = 0, sc = null, s)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      t === null || Lr || (t = t.dependencies, t !== null && Ah(t) && (Lr = !0)), L3 ? (L3 = !1, t = !0) : t = !1, t && (n = Z(n) || "Unknown", Z7.has(n) || M6.has(n) || (Z7.add(n), console.error(
        "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
      )));
    }
    function ch(t, n, s, f) {
      nt = t;
      var p = 0;
      do {
        if (R0 && (sc = null), y2 = 0, R0 = !1, p >= fP)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (p += 1, b2 = !1, ir = Zt = null, t.updateQueue != null) {
          var m = t.updateQueue;
          m.lastEffect = null, m.events = null, m.stores = null, m.memoCache != null && (m.memoCache.index = 0);
        }
        lc = -1, me.H = gp, m = R6(n, s, f);
      } while (R0);
      return m;
    }
    function am() {
      var t = me.H, n = t.useState()[0];
      return n = typeof n.then == "function" ? jo(n) : n, t = t.useState()[0], (Zt !== null ? Zt.memoizedState : null) !== t && (nt.flags |= 1024), n;
    }
    function tf() {
      var t = M3 !== 0;
      return M3 = 0, t;
    }
    function fh(t, n, s) {
      n.updateQueue = t.updateQueue, n.flags = (n.mode & As) !== sn ? n.flags & -201328645 : n.flags & -2053, t.lanes &= ~s;
    }
    function Go(t) {
      if (B3) {
        for (t = t.memoizedState; t !== null; ) {
          var n = t.queue;
          n !== null && (n.pending = null), t = t.next;
        }
        B3 = !1;
      }
      qf = 0, xi = ir = Zt = nt = null, lc = -1, be = null, R0 = !1, y2 = M3 = 0, sc = null;
    }
    function zr() {
      var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return ir === null ? nt.memoizedState = ir = t : ir = ir.next = t, ir;
    }
    function Nt() {
      if (Zt === null) {
        var t = nt.alternate;
        t = t !== null ? t.memoizedState : null;
      } else t = Zt.next;
      var n = ir === null ? nt.memoizedState : ir.next;
      if (n !== null)
        ir = n, Zt = t;
      else {
        if (t === null)
          throw nt.alternate === null ? Error(
            "Update hook called on initial render. This is likely a bug in React. Please file an issue."
          ) : Error("Rendered more hooks than during the previous render.");
        Zt = t, t = {
          memoizedState: Zt.memoizedState,
          baseState: Zt.baseState,
          baseQueue: Zt.baseQueue,
          queue: Zt.queue,
          next: null
        }, ir === null ? nt.memoizedState = ir = t : ir = ir.next = t;
      }
      return ir;
    }
    function jo(t) {
      var n = y2;
      return y2 += 1, sc === null && (sc = N1()), t = _w(sc, t, n), n = nt, (ir === null ? n.memoizedState : ir.next) === null && (n = n.alternate, me.H = n !== null && n.memoizedState !== null ? Jf : Kf), t;
    }
    function qi(t) {
      if (t !== null && typeof t == "object") {
        if (typeof t.then == "function") return jo(t);
        if (t.$$typeof === Ca) return qt(t);
      }
      throw Error("An unsupported type was passed to use(): " + String(t));
    }
    function Xn(t) {
      var n = null, s = nt.updateQueue;
      if (s !== null && (n = s.memoCache), n == null) {
        var f = nt.alternate;
        f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (n = {
          data: f.data.map(function(p) {
            return p.slice();
          }),
          index: 0
        })));
      }
      if (n == null && (n = { data: [], index: 0 }), s === null && (s = F6(), nt.updateQueue = s), s.memoCache = n, s = n.data[n.index], s === void 0 || b2)
        for (s = n.data[n.index] = Array(t), f = 0; f < t; f++)
          s[f] = p3;
      else
        s.length !== t && console.error(
          "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
          s.length,
          t
        );
      return n.index++, s;
    }
    function xr(t, n) {
      return typeof n == "function" ? n(t) : n;
    }
    function nl(t, n, s) {
      var f = zr();
      if (s !== void 0) {
        var p = s(n);
        if (hp) {
          jt(!0);
          try {
            s(n);
          } finally {
            jt(!1);
          }
        }
      } else p = n;
      return f.memoizedState = f.baseState = p, t = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: p
      }, f.queue = t, t = t.dispatch = V1.bind(
        null,
        nt,
        t
      ), [f.memoizedState, t];
    }
    function Ki(t) {
      var n = Nt();
      return nf(n, Zt, t);
    }
    function nf(t, n, s) {
      var f = t.queue;
      if (f === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      f.lastRenderedReducer = s;
      var p = t.baseQueue, m = f.pending;
      if (m !== null) {
        if (p !== null) {
          var E = p.next;
          p.next = m.next, m.next = E;
        }
        n.baseQueue !== p && console.error(
          "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
        ), n.baseQueue = p = m, f.pending = null;
      }
      if (m = t.baseState, p === null) t.memoizedState = m;
      else {
        n = p.next;
        var I = E = null, F = null, z = n, de = !1;
        do {
          var Ee = z.lane & -536870913;
          if (Ee !== z.lane ? (St & Ee) === Ee : (qf & Ee) === Ee) {
            var pe = z.revertLane;
            if (pe === 0)
              F !== null && (F = F.next = {
                lane: 0,
                revertLane: 0,
                action: z.action,
                hasEagerState: z.hasEagerState,
                eagerState: z.eagerState,
                next: null
              }), Ee === fp && (de = !0);
            else if ((qf & pe) === pe) {
              z = z.next, pe === fp && (de = !0);
              continue;
            } else
              Ee = {
                lane: 0,
                revertLane: z.revertLane,
                action: z.action,
                hasEagerState: z.hasEagerState,
                eagerState: z.eagerState,
                next: null
              }, F === null ? (I = F = Ee, E = m) : F = F.next = Ee, nt.lanes |= pe, td |= pe;
            Ee = z.action, hp && s(m, Ee), m = z.hasEagerState ? z.eagerState : s(m, Ee);
          } else
            pe = {
              lane: Ee,
              revertLane: z.revertLane,
              action: z.action,
              hasEagerState: z.hasEagerState,
              eagerState: z.eagerState,
              next: null
            }, F === null ? (I = F = pe, E = m) : F = F.next = pe, nt.lanes |= Ee, td |= Ee;
          z = z.next;
        } while (z !== null && z !== n);
        if (F === null ? E = m : F.next = I, !Pa(m, t.memoizedState) && (Lr = !0, de && (s = P0, s !== null)))
          throw s;
        t.memoizedState = m, t.baseState = E, t.baseQueue = F, f.lastRenderedState = m;
      }
      return p === null && (f.lanes = 0), [t.memoizedState, f.dispatch];
    }
    function Cr(t) {
      var n = Nt(), s = n.queue;
      if (s === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      s.lastRenderedReducer = t;
      var f = s.dispatch, p = s.pending, m = n.memoizedState;
      if (p !== null) {
        s.pending = null;
        var E = p = p.next;
        do
          m = t(m, E.action), E = E.next;
        while (E !== p);
        Pa(m, n.memoizedState) || (Lr = !0), n.memoizedState = m, n.baseQueue === null && (n.baseState = m), s.lastRenderedState = m;
      }
      return [m, f];
    }
    function oa(t, n, s) {
      var f = nt, p = zr();
      if (It) {
        if (s === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var m = s();
        O0 || m === s() || (console.error(
          "The result of getServerSnapshot should be cached to avoid an infinite loop"
        ), O0 = !0);
      } else {
        if (m = n(), O0 || (s = n(), Pa(m, s) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), O0 = !0)), Xt === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        St & 60 || Qo(f, n, m);
      }
      return p.memoizedState = m, s = { value: m, getSnapshot: n }, p.queue = s, il(
        rl.bind(null, f, s, t),
        [t]
      ), f.flags |= 2048, Cu(
        Ai | vr,
        Zo.bind(
          null,
          f,
          s,
          m,
          n
        ),
        { destroy: void 0 },
        null
      ), m;
    }
    function $o(t, n, s) {
      var f = nt, p = Nt(), m = It;
      if (m) {
        if (s === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        s = s();
      } else if (s = n(), !O0) {
        var E = n();
        Pa(s, E) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), O0 = !0);
      }
      (E = !Pa(
        (Zt || p).memoizedState,
        s
      )) && (p.memoizedState = s, Lr = !0), p = p.queue;
      var I = rl.bind(null, f, p, t);
      if (_n(2048, vr, I, [t]), p.getSnapshot !== n || E || ir !== null && ir.memoizedState.tag & Ai) {
        if (f.flags |= 2048, Cu(
          Ai | vr,
          Zo.bind(
            null,
            f,
            p,
            s,
            n
          ),
          { destroy: void 0 },
          null
        ), Xt === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        m || qf & 60 || Qo(f, n, s);
      }
      return s;
    }
    function Qo(t, n, s) {
      t.flags |= 16384, t = { getSnapshot: n, value: s }, n = nt.updateQueue, n === null ? (n = F6(), nt.updateQueue = n, n.stores = [t]) : (s = n.stores, s === null ? n.stores = [t] : s.push(t));
    }
    function Zo(t, n, s, f) {
      n.value = s, n.getSnapshot = f, D1(n) && om(t);
    }
    function rl(t, n, s) {
      return s(function() {
        D1(n) && om(t);
      });
    }
    function D1(t) {
      var n = t.getSnapshot;
      t = t.value;
      try {
        var s = n();
        return !Pa(t, s);
      } catch {
        return !0;
      }
    }
    function om(t) {
      var n = dr(t, 2);
      n !== null && Vt(n, t, 2);
    }
    function dh(t) {
      var n = zr();
      if (typeof t == "function") {
        var s = t;
        if (t = s(), hp) {
          jt(!0);
          try {
            s();
          } finally {
            jt(!1);
          }
        }
      }
      return n.memoizedState = n.baseState = t, n.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: xr,
        lastRenderedState: t
      }, n;
    }
    function pr(t) {
      t = dh(t);
      var n = t.queue, s = cf.bind(
        null,
        nt,
        n
      );
      return n.dispatch = s, [t.memoizedState, s];
    }
    function Fn(t) {
      var n = zr();
      n.memoizedState = n.baseState = t;
      var s = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return n.queue = s, n = yh.bind(
        null,
        nt,
        !0,
        s
      ), s.dispatch = n, [t, n];
    }
    function Tt(t, n) {
      var s = Nt();
      return Ya(s, Zt, t, n);
    }
    function Ya(t, n, s, f) {
      return t.baseState = s, nf(
        t,
        Zt,
        typeof f == "function" ? f : xr
      );
    }
    function vo(t, n) {
      var s = Nt();
      return Zt !== null ? Ya(s, Zt, t, n) : (s.baseState = t, [t, s.queue.dispatch]);
    }
    function B1(t, n, s, f, p) {
      if (ts(t))
        throw Error("Cannot update form state while rendering.");
      if (t = n.action, t !== null) {
        var m = {
          payload: p,
          action: t,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(E) {
            m.listeners.push(E);
          }
        };
        me.T !== null ? s(!0) : m.isTransition = !1, f(m), s = n.pending, s === null ? (m.next = n.pending = m, al(n, m)) : (m.next = s.next, n.pending = s.next = m);
      }
    }
    function al(t, n) {
      var s = n.action, f = n.payload, p = t.state;
      if (n.isTransition) {
        var m = me.T, E = {};
        me.T = E, me.T._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var I = s(p, f), F = me.S;
          F !== null && F(E, I), M1(t, n, I);
        } catch (z) {
          Au(t, n, z);
        } finally {
          me.T = m, m === null && E._updatedFibers && (t = E._updatedFibers.size, E._updatedFibers.clear(), 10 < t && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      } else
        try {
          E = s(p, f), M1(t, n, E);
        } catch (z) {
          Au(t, n, z);
        }
    }
    function M1(t, n, s) {
      s !== null && typeof s == "object" && typeof s.then == "function" ? (s.then(
        function(f) {
          F1(t, n, f);
        },
        function(f) {
          return Au(t, n, f);
        }
      ), n.isTransition || console.error(
        "An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`"
      )) : F1(t, n, s);
    }
    function F1(t, n, s) {
      n.status = "fulfilled", n.value = s, rf(n), t.state = s, n = t.pending, n !== null && (s = n.next, s === n ? t.pending = null : (s = s.next, n.next = s, al(t, s)));
    }
    function Au(t, n, s) {
      var f = t.pending;
      if (t.pending = null, f !== null) {
        f = f.next;
        do
          n.status = "rejected", n.reason = s, rf(n), n = n.next;
        while (n !== f);
      }
      t.action = null;
    }
    function rf(t) {
      t = t.listeners;
      for (var n = 0; n < t.length; n++) (0, t[n])();
    }
    function af(t, n) {
      return n;
    }
    function Yo(t, n) {
      if (It) {
        var s = Xt.formState;
        if (s !== null) {
          e: {
            var f = nt;
            if (It) {
              if ($r) {
                t: {
                  for (var p = $r, m = Ml; p.nodeType !== 8; ) {
                    if (!m) {
                      p = null;
                      break t;
                    }
                    if (p = sa(
                      p.nextSibling
                    ), p === null) {
                      p = null;
                      break t;
                    }
                  }
                  m = p.data, p = m === c8 || m === DS ? p : null;
                }
                if (p) {
                  $r = sa(
                    p.nextSibling
                  ), f = p.data === c8;
                  break e;
                }
              }
              yo(f);
            }
            f = !1;
          }
          f && (n = s[0]);
        }
      }
      return s = zr(), s.memoizedState = s.baseState = n, f = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: af,
        lastRenderedState: n
      }, s.queue = f, s = cf.bind(
        null,
        nt,
        f
      ), f.dispatch = s, f = dh(!1), m = yh.bind(
        null,
        nt,
        !1,
        f.queue
      ), f = zr(), p = {
        state: n,
        dispatch: null,
        action: t,
        pending: null
      }, f.queue = p, s = B1.bind(
        null,
        nt,
        p,
        m,
        s
      ), p.dispatch = s, f.memoizedState = t, [n, s, !1];
    }
    function hh(t) {
      var n = Nt();
      return im(n, Zt, t);
    }
    function im(t, n, s) {
      n = nf(
        t,
        n,
        af
      )[0], t = Ki(xr)[0], n = typeof n == "object" && n !== null && typeof n.then == "function" ? jo(n) : n;
      var f = Nt(), p = f.queue, m = p.dispatch;
      return s !== f.memoizedState && (nt.flags |= 2048, Cu(
        Ai | vr,
        Gw.bind(null, p, s),
        { destroy: void 0 },
        null
      )), [n, m, t];
    }
    function Gw(t, n) {
      t.action = n;
    }
    function xu(t) {
      var n = Nt(), s = Zt;
      if (s !== null)
        return im(n, s, t);
      Nt(), n = n.memoizedState, s = Nt();
      var f = s.queue.dispatch;
      return s.memoizedState = t, [n, f, !1];
    }
    function Cu(t, n, s, f) {
      return t = { tag: t, create: n, inst: s, deps: f, next: null }, n = nt.updateQueue, n === null && (n = F6(), nt.updateQueue = n), s = n.lastEffect, s === null ? n.lastEffect = t.next = t : (f = s.next, s.next = t, t.next = f, n.lastEffect = t), t;
    }
    function Tu(t) {
      var n = zr();
      return t = { current: t }, n.memoizedState = t;
    }
    function ol(t, n, s, f) {
      var p = zr();
      nt.flags |= t, p.memoizedState = Cu(
        Ai | n,
        s,
        { destroy: void 0 },
        f === void 0 ? null : f
      );
    }
    function _n(t, n, s, f) {
      var p = Nt();
      f = f === void 0 ? null : f;
      var m = p.memoizedState.inst;
      Zt !== null && f !== null && ma(f, Zt.memoizedState.deps) ? p.memoizedState = Cu(n, s, m, f) : (nt.flags |= t, p.memoizedState = Cu(
        Ai | n,
        s,
        m,
        f
      ));
    }
    function il(t, n) {
      (nt.mode & As) !== sn && (nt.mode & C7) === sn ? ol(142608384, vr, t, n) : ol(8390656, vr, t, n);
    }
    function of(t, n) {
      var s = 4194308;
      return (nt.mode & As) !== sn && (s |= 67108864), ol(s, Qr, t, n);
    }
    function sf(t, n) {
      if (typeof n == "function") {
        t = t();
        var s = n(t);
        return function() {
          typeof s == "function" ? s() : n(null);
        };
      }
      if (n != null)
        return n.hasOwnProperty("current") || console.error(
          "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
          "an object with keys {" + Object.keys(n).join(", ") + "}"
        ), t = t(), n.current = t, function() {
          n.current = null;
        };
    }
    function lf(t, n, s) {
      typeof n != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        n !== null ? typeof n : "null"
      ), s = s != null ? s.concat([t]) : null;
      var f = 4194308;
      (nt.mode & As) !== sn && (f |= 67108864), ol(
        f,
        Qr,
        sf.bind(null, n, t),
        s
      );
    }
    function ph(t, n, s) {
      typeof n != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        n !== null ? typeof n : "null"
      ), s = s != null ? s.concat([t]) : null, _n(
        4,
        Qr,
        sf.bind(null, n, t),
        s
      );
    }
    function sm(t, n) {
      return zr().memoizedState = [
        t,
        n === void 0 ? null : n
      ], t;
    }
    function qo(t, n) {
      var s = Nt();
      n = n === void 0 ? null : n;
      var f = s.memoizedState;
      return n !== null && ma(n, f[1]) ? f[0] : (s.memoizedState = [t, n], t);
    }
    function lm(t, n) {
      var s = zr();
      n = n === void 0 ? null : n;
      var f = t();
      if (hp) {
        jt(!0);
        try {
          t();
        } finally {
          jt(!1);
        }
      }
      return s.memoizedState = [f, n], f;
    }
    function Ji(t, n) {
      var s = Nt();
      n = n === void 0 ? null : n;
      var f = s.memoizedState;
      if (n !== null && ma(n, f[1]))
        return f[0];
      if (f = t(), hp) {
        jt(!0);
        try {
          t();
        } finally {
          jt(!1);
        }
      }
      return s.memoizedState = [f, n], f;
    }
    function uf(t, n) {
      var s = zr();
      return gh(s, t, n);
    }
    function _1(t, n) {
      var s = Nt();
      return ya(
        s,
        Zt.memoizedState,
        t,
        n
      );
    }
    function um(t, n) {
      var s = Nt();
      return Zt === null ? gh(s, t, n) : ya(
        s,
        Zt.memoizedState,
        t,
        n
      );
    }
    function gh(t, n, s) {
      return s === void 0 || qf & 1073741824 ? t.memoizedState = n : (t.memoizedState = s, t = Lm(), nt.lanes |= t, td |= t, s);
    }
    function ya(t, n, s, f) {
      return Pa(s, n) ? s : I0.current !== null ? (t = gh(t, s, f), Pa(t, n) || (Lr = !0), t) : qf & 42 ? (t = Lm(), nt.lanes |= t, td |= t, n) : (Lr = !0, t.memoizedState = s);
    }
    function Ko(t, n, s, f, p) {
      var m = Qt.p;
      Qt.p = m !== 0 && m < Xa ? m : Xa;
      var E = me.T, I = {};
      me.T = I, yh(t, !1, n, s), I._updatedFibers = /* @__PURE__ */ new Set();
      try {
        var F = p(), z = me.S;
        if (z !== null && z(I, F), F !== null && typeof F == "object" && typeof F.then == "function") {
          var de = Vw(
            F,
            f
          );
          es(
            t,
            n,
            de,
            Hr(t)
          );
        } else
          es(
            t,
            n,
            f,
            Hr(t)
          );
      } catch (Ee) {
        es(
          t,
          n,
          { then: function() {
          }, status: "rejected", reason: Ee },
          Hr(t)
        );
      } finally {
        Qt.p = m, me.T = E, E === null && I._updatedFibers && (t = I._updatedFibers.size, I._updatedFibers.clear(), 10 < t && console.warn(
          "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
        ));
      }
    }
    function Jo(t, n, s, f) {
      if (t.tag !== 5)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var p = U1(t).queue;
      Ko(
        t,
        p,
        n,
        Cp,
        s === null ? S : function() {
          return Xi(t), s(f);
        }
      );
    }
    function U1(t) {
      var n = t.memoizedState;
      if (n !== null) return n;
      n = {
        memoizedState: Cp,
        baseState: Cp,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: xr,
          lastRenderedState: Cp
        },
        next: null
      };
      var s = {};
      return n.next = {
        memoizedState: s,
        baseState: s,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: xr,
          lastRenderedState: s
        },
        next: null
      }, t.memoizedState = n, t = t.alternate, t !== null && (t.memoizedState = n), n;
    }
    function Xi(t) {
      me.T === null && console.error(
        "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
      );
      var n = U1(t).next.queue;
      es(
        t,
        n,
        {},
        Hr(t)
      );
    }
    function wo() {
      var t = dh(!1);
      return t = Ko.bind(
        null,
        nt,
        t.queue,
        !0,
        !1
      ), zr().memoizedState = t, [!1, t];
    }
    function Cn() {
      var t = Ki(xr)[0], n = Nt().memoizedState;
      return [
        typeof t == "boolean" ? t : jo(t),
        n
      ];
    }
    function mh() {
      var t = Cr(xr)[0], n = Nt().memoizedState;
      return [
        typeof t == "boolean" ? t : jo(t),
        n
      ];
    }
    function Iu() {
      return qt(L2);
    }
    function z1() {
      var t = zr(), n = Xt.identifierPrefix;
      if (It) {
        var s = ac, f = rc;
        s = (f & ~(1 << 32 - Rr(f) - 1)).toString(32) + s, n = ":" + n + "R" + s, s = M3++, 0 < s && (n += "H" + s.toString(32)), n += ":";
      } else
        s = cP++, n = ":" + n + "r" + s.toString(32) + ":";
      return t.memoizedState = n;
    }
    function H1() {
      return zr().memoizedState = Un.bind(
        null,
        nt
      );
    }
    function Un(t, n) {
      for (var s = t.return; s !== null; ) {
        switch (s.tag) {
          case 24:
          case 3:
            var f = Hr(s);
            t = os(f);
            var p = is(s, t, f);
            p !== null && (Vt(p, s, f), xh(p, s, f)), s = Yi(), n != null && p !== null && console.error(
              "The seed argument is not enabled outside experimental channels."
            ), t.payload = { cache: s };
            return;
        }
        s = s.return;
      }
    }
    function V1(t, n, s, f) {
      typeof f == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), f = Hr(t), s = {
        lane: f,
        revertLane: 0,
        action: s,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, ts(t) ? Nu(n, s) : (s = E1(
        t,
        n,
        s,
        f
      ), s !== null && (Vt(
        s,
        t,
        f
      ), jw(
        s,
        n,
        f
      ))), Xr(t, f);
    }
    function cf(t, n, s, f) {
      typeof f == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), f = Hr(t), es(
        t,
        n,
        s,
        f
      ), Xr(t, f);
    }
    function es(t, n, s, f) {
      var p = {
        lane: f,
        revertLane: 0,
        action: s,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (ts(t)) Nu(n, p);
      else {
        var m = t.alternate;
        if (t.lanes === 0 && (m === null || m.lanes === 0) && (m = n.lastRenderedReducer, m !== null)) {
          var E = me.H;
          me.H = La;
          try {
            var I = n.lastRenderedState, F = m(I, s);
            if (p.hasEagerState = !0, p.eagerState = F, Pa(F, I))
              return qg(t, n, p, 0), Xt === null && Yg(), !1;
          } catch {
          } finally {
            me.H = E;
          }
        }
        if (s = E1(t, n, p, f), s !== null)
          return Vt(s, t, f), jw(s, n, f), !0;
      }
      return !1;
    }
    function yh(t, n, s, f) {
      if (me.T === null && fp === 0 && console.error(
        "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
      ), f = {
        lane: 2,
        revertLane: zm(),
        action: f,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, ts(t)) {
        if (n)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        n = E1(
          t,
          s,
          f,
          2
        ), n !== null && Vt(n, t, 2);
      Xr(t, 2);
    }
    function ts(t) {
      var n = t.alternate;
      return t === nt || n !== null && n === nt;
    }
    function Nu(t, n) {
      R0 = B3 = !0;
      var s = t.pending;
      s === null ? n.next = n : (n.next = s.next, s.next = n), t.pending = n;
    }
    function jw(t, n, s) {
      if (s & 4194176) {
        var f = n.lanes;
        f &= t.pendingLanes, s |= f, n.lanes = s, ea(t, s);
      }
    }
    function cm(t) {
      if (t !== null && typeof t != "function") {
        var n = String(t);
        iS.has(n) || (iS.add(n), console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          t
        ));
      }
    }
    function W1(t, n, s, f) {
      var p = t.memoizedState, m = s(f, p);
      if (t.mode & fa) {
        jt(!0);
        try {
          m = s(f, p);
        } finally {
          jt(!1);
        }
      }
      m === void 0 && (n = U(n) || "Component", nS.has(n) || (nS.add(n), console.error(
        "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
        n
      ))), p = m == null ? p : st({}, p, m), t.memoizedState = p, t.lanes === 0 && (t.updateQueue.baseState = p);
    }
    function G1(t, n, s, f, p, m, E) {
      var I = t.stateNode;
      if (typeof I.shouldComponentUpdate == "function") {
        if (s = I.shouldComponentUpdate(
          f,
          m,
          E
        ), t.mode & fa) {
          jt(!0);
          try {
            s = I.shouldComponentUpdate(
              f,
              m,
              E
            );
          } finally {
            jt(!1);
          }
        }
        return s === void 0 && console.error(
          "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
          U(n) || "Component"
        ), s;
      }
      return n.prototype && n.prototype.isPureReactComponent ? !eh(s, f) || !eh(p, m) : !0;
    }
    function sl(t, n, s, f) {
      var p = n.state;
      typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(s, f), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(s, f), n.state !== p && (t = Z(t) || "Component", K7.has(t) || (K7.add(t), console.error(
        "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
        t
      )), _6.enqueueReplaceState(
        n,
        n.state,
        null
      ));
    }
    function ns(t, n) {
      var s = n;
      if ("ref" in n) {
        s = {};
        for (var f in n)
          f !== "ref" && (s[f] = n[f]);
      }
      if (t = t.defaultProps) {
        s === n && (s = st({}, s));
        for (var p in t)
          s[p] === void 0 && (s[p] = t[p]);
      }
      return s;
    }
    function bh(t, n) {
      F3(t), t = L0 ? "An error occurred in the <" + L0 + "> component." : "An error occurred in one of your React components.";
      var s = me.getCurrentStack, f = n.componentStack != null ? n.componentStack : "";
      me.getCurrentStack = function() {
        return f;
      };
      try {
        console.warn(
          `%s

%s
`,
          t,
          `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`
        );
      } finally {
        me.getCurrentStack = s;
      }
    }
    function j1(t, n) {
      var s = L0 ? "The above error occurred in the <" + L0 + "> component." : "The above error occurred in one of your React components.", f = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((U6 || "Anonymous") + "."), p = me.getCurrentStack, m = n.componentStack != null ? n.componentStack : "";
      me.getCurrentStack = function() {
        return m;
      };
      try {
        typeof t == "object" && t !== null && typeof t.environmentName == "string" ? Df(
          "error",
          [
            `%o

%s

%s
`,
            t,
            s,
            f
          ],
          t.environmentName
        )() : console.error(
          `%o

%s

%s
`,
          t,
          s,
          f
        );
      } finally {
        me.getCurrentStack = p;
      }
    }
    function rs(t) {
      F3(t);
    }
    function ot(t, n) {
      try {
        L0 = n.source ? Z(n.source) : null, U6 = null;
        var s = n.value;
        if (me.actQueue !== null)
          me.thrownErrors.push(s);
        else {
          var f = t.onUncaughtError;
          f(s, { componentStack: n.stack });
        }
      } catch (p) {
        setTimeout(function() {
          throw p;
        });
      }
    }
    function Bt(t, n, s) {
      try {
        L0 = s.source ? Z(s.source) : null, U6 = Z(n);
        var f = t.onCaughtError;
        f(s.value, {
          componentStack: s.stack,
          errorBoundary: n.tag === 1 ? n.stateNode : null
        });
      } catch (p) {
        setTimeout(function() {
          throw p;
        });
      }
    }
    function gn(t, n, s) {
      return s = os(s), s.tag = G6, s.payload = { element: null }, s.callback = function() {
        V(n.source, ot, t, n);
      }, s;
    }
    function ff(t) {
      return t = os(t), t.tag = G6, t;
    }
    function ll(t, n, s, f) {
      var p = s.type.getDerivedStateFromError;
      if (typeof p == "function") {
        var m = f.value;
        t.payload = function() {
          return p(m);
        }, t.callback = function() {
          Bw(s), V(
            f.source,
            Bt,
            n,
            s,
            f
          );
        };
      }
      var E = s.stateNode;
      E !== null && typeof E.componentDidCatch == "function" && (t.callback = function() {
        Bw(s), V(
          f.source,
          Bt,
          n,
          s,
          f
        ), typeof p != "function" && (rd === null ? rd = /* @__PURE__ */ new Set([this]) : rd.add(this)), aP(this, f), typeof p == "function" || !(s.lanes & 2) && console.error(
          "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
          Z(s) || "Unknown"
        );
      });
    }
    function Pu(t, n, s, f, p) {
      if (s.flags |= 32768, Gr && nn(t, p), f !== null && typeof f == "object" && typeof f.then == "function") {
        if (n = s.alternate, n !== null && Sh(
          n,
          s,
          p,
          !0
        ), It && (oc = !0), s = Ei.current, s !== null) {
          switch (s.tag) {
            case 13:
              return ic === null ? Bh() : s.alternate === null && Nn === fc && (Nn = Z6), s.flags &= -257, s.flags |= 65536, s.lanes = p, f === O6 ? s.flags |= 16384 : (n = s.updateQueue, n === null ? s.updateQueue = /* @__PURE__ */ new Set([f]) : n.add(f), Ao(t, f, p)), !1;
            case 22:
              return s.flags |= 65536, f === O6 ? s.flags |= 16384 : (n = s.updateQueue, n === null ? (n = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([f])
              }, s.updateQueue = n) : (s = n.retryQueue, s === null ? n.retryQueue = /* @__PURE__ */ new Set([f]) : s.add(f)), Ao(t, f, p)), !1;
          }
          throw Error(
            "Unexpected Suspense handler tag (" + s.tag + "). This is a bug in React."
          );
        }
        return Ao(t, f, p), Bh(), !1;
      }
      if (It)
        return oc = !0, n = Ei.current, n !== null ? (!(n.flags & 65536) && (n.flags |= 256), n.flags |= 65536, n.lanes = p, f !== P6 && wu(
          ra(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
              { cause: f }
            ),
            s
          )
        )) : (f !== P6 && wu(
          ra(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
              { cause: f }
            ),
            s
          )
        ), t = t.current.alternate, t.flags |= 65536, p &= -p, t.lanes |= p, f = ra(f, s), p = gn(
          t.stateNode,
          f,
          p
        ), Ch(t, p), Nn !== mp && (Nn = U0)), !1;
      var m = ra(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: f }
        ),
        s
      );
      if (x2 === null ? x2 = [m] : x2.push(m), Nn !== mp && (Nn = U0), n === null) return !0;
      f = ra(f, s), s = n;
      do {
        switch (s.tag) {
          case 3:
            return s.flags |= 65536, t = p & -p, s.lanes |= t, t = gn(
              s.stateNode,
              f,
              t
            ), Ch(s, t), !1;
          case 1:
            if (n = s.type, m = s.stateNode, (s.flags & 128) === 0 && (typeof n.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (rd === null || !rd.has(m))))
              return s.flags |= 65536, p &= -p, s.lanes |= p, p = ff(p), ll(
                p,
                t,
                s,
                f
              ), Ch(s, p), !1;
        }
        s = s.return;
      } while (s !== null);
      return !1;
    }
    function Tn(t, n, s, f) {
      n.child = t === null ? j7(n, null, s, f) : cp(
        n,
        t.child,
        s,
        f
      );
    }
    function df(t, n, s, f, p) {
      s = s.render;
      var m = n.ref;
      if ("ref" in f) {
        var E = {};
        for (var I in f)
          I !== "ref" && (E[I] = f[I]);
      } else E = f;
      return ul(n), au(n), f = aa(
        t,
        n,
        s,
        E,
        m,
        p
      ), I = tf(), $s(), t !== null && !Lr ? (fh(t, n, p), ko(t, n, p)) : (It && I && T1(n), n.flags |= 1, Tn(t, n, f, p), n.child);
    }
    function Ou(t, n, s, f, p) {
      if (t === null) {
        var m = s.type;
        return typeof m == "function" && !Ph(m) && m.defaultProps === void 0 && s.compare === null ? (s = mu(m), n.tag = 15, n.type = s, vh(n, m), $w(
          t,
          n,
          s,
          f,
          p
        )) : (t = Pm(
          s.type,
          null,
          f,
          n,
          n.mode,
          p
        ), t.ref = n.ref, t.return = n, n.child = t);
      }
      if (m = t.child, !mm(t, p)) {
        var E = m.memoizedProps;
        if (s = s.compare, s = s !== null ? s : eh, s(E, f) && t.ref === n.ref)
          return ko(
            t,
            n,
            p
          );
      }
      return n.flags |= 1, t = ni(m, f), t.ref = n.ref, t.return = n, n.child = t;
    }
    function $w(t, n, s, f, p) {
      if (t !== null) {
        var m = t.memoizedProps;
        if (eh(m, f) && t.ref === n.ref && n.type === t.type)
          if (Lr = !1, n.pendingProps = f = m, mm(t, p))
            t.flags & 131072 && (Lr = !0);
          else
            return n.lanes = t.lanes, ko(t, n, p);
      }
      return dm(
        t,
        n,
        s,
        f,
        p
      );
    }
    function mn(t, n, s) {
      var f = n.pendingProps, p = f.children, m = (n.stateNode._pendingVisibility & i2) !== 0, E = t !== null ? t.memoizedState : null;
      if (Ru(t, n), f.mode === "hidden" || m) {
        if (n.flags & 128) {
          if (f = E !== null ? E.baseLanes | s : s, t !== null) {
            for (p = n.child = t.child, m = 0; p !== null; )
              m = m | p.lanes | p.childLanes, p = p.sibling;
            n.childLanes = m & ~f;
          } else n.childLanes = 0, n.child = null;
          return fm(
            t,
            n,
            f,
            s
          );
        }
        if (s & 536870912)
          n.memoizedState = { baseLanes: 0, cachePool: null }, t !== null && lh(
            n,
            E !== null ? E.cachePool : null
          ), E !== null ? tm(n, E) : R1(n), nm(n);
        else
          return n.lanes = n.childLanes = 536870912, fm(
            t,
            n,
            E !== null ? E.baseLanes | s : s,
            s
          );
      } else
        E !== null ? (lh(n, E.cachePool), tm(n, E), Qa(n), n.memoizedState = null) : (t !== null && lh(n, null), R1(n), Qa(n));
      return Tn(t, n, p, s), n.child;
    }
    function fm(t, n, s, f) {
      var p = rm();
      return p = p === null ? null : {
        parent: wr._currentValue,
        pool: p
      }, n.memoizedState = {
        baseLanes: s,
        cachePool: p
      }, t !== null && lh(n, null), R1(n), nm(n), t !== null && Sh(t, n, f, !0), null;
    }
    function Ru(t, n) {
      var s = n.ref;
      if (s === null)
        t !== null && t.ref !== null && (n.flags |= 2097664);
      else {
        if (typeof s != "function" && typeof s != "object")
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        (t === null || t.ref !== s) && (n.flags |= 2097664);
      }
    }
    function dm(t, n, s, f, p) {
      if (s.prototype && typeof s.prototype.render == "function") {
        var m = U(s) || "Unknown";
        lS[m] || (console.error(
          "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
          m,
          m
        ), lS[m] = !0);
      }
      return n.mode & fa && xs.recordLegacyContextWarning(
        n,
        null
      ), t === null && (vh(n, n.type), s.contextTypes && (m = U(s) || "Unknown", cS[m] || (cS[m] = !0, console.error(
        "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
        m
      )))), ul(n), au(n), s = aa(
        t,
        n,
        s,
        f,
        void 0,
        p
      ), f = tf(), $s(), t !== null && !Lr ? (fh(t, n, p), ko(t, n, p)) : (It && f && T1(n), n.flags |= 1, Tn(t, n, s, p), n.child);
    }
    function $1(t, n, s, f, p, m) {
      return ul(n), au(n), lc = -1, b2 = t !== null && t.type !== n.type, n.updateQueue = null, s = ch(
        n,
        f,
        s,
        p
      ), Su(t, n), f = tf(), $s(), t !== null && !Lr ? (fh(t, n, m), ko(t, n, m)) : (It && f && T1(n), n.flags |= 1, Tn(t, n, s, m), n.child);
    }
    function Qw(t, n, s, f, p) {
      switch (g(n)) {
        case !1:
          var m = n.stateNode, E = new n.type(
            n.memoizedProps,
            m.context
          ).state;
          m.updater.enqueueSetState(m, E, null);
          break;
        case !0:
          n.flags |= 128, n.flags |= 65536, m = Error("Simulated error coming from DevTools");
          var I = p & -p;
          if (n.lanes |= I, E = Xt, E === null)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          I = ff(I), ll(
            I,
            E,
            n,
            ra(m, n)
          ), Ch(n, I);
      }
      if (ul(n), n.stateNode === null) {
        if (E = Zf, m = s.contextType, "contextType" in s && m !== null && (m === void 0 || m.$$typeof !== Ca) && !oS.has(s) && (oS.add(s), I = m === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof m != "object" ? " However, it is set to a " + typeof m + "." : m.$$typeof === Qh ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(m).join(", ") + "}.", console.error(
          "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
          U(s) || "Component",
          I
        )), typeof m == "object" && m !== null && (E = qt(m)), m = new s(f, E), n.mode & fa) {
          jt(!0);
          try {
            m = new s(f, E);
          } finally {
            jt(!1);
          }
        }
        if (E = n.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = _6, n.stateNode = m, m._reactInternals = n, m._reactInternalInstance = q7, typeof s.getDerivedStateFromProps == "function" && E === null && (E = U(s) || "Component", J7.has(E) || (J7.add(E), console.error(
          "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
          E,
          m.state === null ? "null" : "undefined",
          E
        ))), typeof s.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function") {
          var F = I = E = null;
          if (typeof m.componentWillMount == "function" && m.componentWillMount.__suppressDeprecationWarning !== !0 ? E = "componentWillMount" : typeof m.UNSAFE_componentWillMount == "function" && (E = "UNSAFE_componentWillMount"), typeof m.componentWillReceiveProps == "function" && m.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? I = "componentWillReceiveProps" : typeof m.UNSAFE_componentWillReceiveProps == "function" && (I = "UNSAFE_componentWillReceiveProps"), typeof m.componentWillUpdate == "function" && m.componentWillUpdate.__suppressDeprecationWarning !== !0 ? F = "componentWillUpdate" : typeof m.UNSAFE_componentWillUpdate == "function" && (F = "UNSAFE_componentWillUpdate"), E !== null || I !== null || F !== null) {
            m = U(s) || "Component";
            var z = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            eS.has(m) || (eS.add(m), console.error(
              `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`,
              m,
              z,
              E !== null ? `
  ` + E : "",
              I !== null ? `
  ` + I : "",
              F !== null ? `
  ` + F : ""
            ));
          }
        }
        m = n.stateNode, E = U(s) || "Component", m.render || (s.prototype && typeof s.prototype.render == "function" ? console.error(
          "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
          E
        ) : console.error(
          "No `render` method found on the %s instance: you may have forgotten to define `render`.",
          E
        )), !m.getInitialState || m.getInitialState.isReactClassApproved || m.state || console.error(
          "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
          E
        ), m.getDefaultProps && !m.getDefaultProps.isReactClassApproved && console.error(
          "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
          E
        ), m.contextType && console.error(
          "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
          E
        ), s.childContextTypes && !aS.has(s) && (aS.add(s), console.error(
          "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
          E
        )), s.contextTypes && !rS.has(s) && (rS.add(s), console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
          E
        )), typeof m.componentShouldUpdate == "function" && console.error(
          "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
          E
        ), s.prototype && s.prototype.isPureReactComponent && typeof m.shouldComponentUpdate < "u" && console.error(
          "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
          U(s) || "A pure component"
        ), typeof m.componentDidUnmount == "function" && console.error(
          "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
          E
        ), typeof m.componentDidReceiveProps == "function" && console.error(
          "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
          E
        ), typeof m.componentWillRecieveProps == "function" && console.error(
          "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
          E
        ), typeof m.UNSAFE_componentWillRecieveProps == "function" && console.error(
          "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
          E
        ), I = m.props !== f, m.props !== void 0 && I && console.error(
          "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
          E
        ), m.defaultProps && console.error(
          "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
          E,
          E
        ), typeof m.getSnapshotBeforeUpdate != "function" || typeof m.componentDidUpdate == "function" || X7.has(s) || (X7.add(s), console.error(
          "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
          U(s)
        )), typeof m.getDerivedStateFromProps == "function" && console.error(
          "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          E
        ), typeof m.getDerivedStateFromError == "function" && console.error(
          "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          E
        ), typeof s.getSnapshotBeforeUpdate == "function" && console.error(
          "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
          E
        ), (I = m.state) && (typeof I != "object" || mr(I)) && console.error("%s.state: must be set to an object or null", E), typeof m.getChildContext == "function" && typeof s.childContextTypes != "object" && console.error(
          "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
          E
        ), m = n.stateNode, m.props = f, m.state = n.memoizedState, m.refs = {}, vm(n), E = s.contextType, m.context = typeof E == "object" && E !== null ? qt(E) : Zf, m.state === f && (E = U(s) || "Component", tS.has(E) || (tS.add(E), console.error(
          "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
          E
        ))), n.mode & fa && xs.recordLegacyContextWarning(
          n,
          m
        ), xs.recordUnsafeLifecycleWarnings(
          n,
          m
        ), m.state = n.memoizedState, E = s.getDerivedStateFromProps, typeof E == "function" && (W1(
          n,
          s,
          E,
          f
        ), m.state = n.memoizedState), typeof s.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function" || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (E = m.state, typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), E !== m.state && (console.error(
          "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          Z(n) || "Component"
        ), _6.enqueueReplaceState(
          m,
          m.state,
          null
        )), yf(n, f, m, p), ti(), m.state = n.memoizedState), typeof m.componentDidMount == "function" && (n.flags |= 4194308), (n.mode & As) !== sn && (n.flags |= 67108864), m = !0;
      } else if (t === null) {
        m = n.stateNode;
        var de = n.memoizedProps;
        I = ns(s, de), m.props = I;
        var Ee = m.context;
        F = s.contextType, E = Zf, typeof F == "object" && F !== null && (E = qt(F)), z = s.getDerivedStateFromProps, F = typeof z == "function" || typeof m.getSnapshotBeforeUpdate == "function", de = n.pendingProps !== de, F || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (de || Ee !== E) && sl(
          n,
          m,
          f,
          E
        ), ed = !1;
        var pe = n.memoizedState;
        m.state = pe, yf(n, f, m, p), ti(), Ee = n.memoizedState, de || pe !== Ee || ed ? (typeof z == "function" && (W1(
          n,
          s,
          z,
          f
        ), Ee = n.memoizedState), (I = ed || G1(
          n,
          s,
          I,
          f,
          pe,
          Ee,
          E
        )) ? (F || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount()), typeof m.componentDidMount == "function" && (n.flags |= 4194308), (n.mode & As) !== sn && (n.flags |= 67108864)) : (typeof m.componentDidMount == "function" && (n.flags |= 4194308), (n.mode & As) !== sn && (n.flags |= 67108864), n.memoizedProps = f, n.memoizedState = Ee), m.props = f, m.state = Ee, m.context = E, m = I) : (typeof m.componentDidMount == "function" && (n.flags |= 4194308), (n.mode & As) !== sn && (n.flags |= 67108864), m = !1);
      } else {
        m = n.stateNode, wm(t, n), E = n.memoizedProps, F = ns(s, E), m.props = F, z = n.pendingProps, pe = m.context, Ee = s.contextType, I = Zf, typeof Ee == "object" && Ee !== null && (I = qt(Ee)), de = s.getDerivedStateFromProps, (Ee = typeof de == "function" || typeof m.getSnapshotBeforeUpdate == "function") || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (E !== z || pe !== I) && sl(
          n,
          m,
          f,
          I
        ), ed = !1, pe = n.memoizedState, m.state = pe, yf(n, f, m, p), ti();
        var Se = n.memoizedState;
        E !== z || pe !== Se || ed || t !== null && t.dependencies !== null && Ah(t.dependencies) ? (typeof de == "function" && (W1(
          n,
          s,
          de,
          f
        ), Se = n.memoizedState), (F = ed || G1(
          n,
          s,
          F,
          f,
          pe,
          Se,
          I
        ) || t !== null && t.dependencies !== null && Ah(t.dependencies)) ? (Ee || typeof m.UNSAFE_componentWillUpdate != "function" && typeof m.componentWillUpdate != "function" || (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(f, Se, I), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(
          f,
          Se,
          I
        )), typeof m.componentDidUpdate == "function" && (n.flags |= 4), typeof m.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof m.componentDidUpdate != "function" || E === t.memoizedProps && pe === t.memoizedState || (n.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || E === t.memoizedProps && pe === t.memoizedState || (n.flags |= 1024), n.memoizedProps = f, n.memoizedState = Se), m.props = f, m.state = Se, m.context = I, m = F) : (typeof m.componentDidUpdate != "function" || E === t.memoizedProps && pe === t.memoizedState || (n.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || E === t.memoizedProps && pe === t.memoizedState || (n.flags |= 1024), m = !1);
      }
      if (I = m, Ru(t, n), E = (n.flags & 128) !== 0, I || E) {
        if (I = n.stateNode, me.getCurrentStack = n === null ? null : Ie, Ta = !1, Pr = n, E && typeof s.getDerivedStateFromError != "function")
          s = null, eo = -1;
        else {
          if (au(n), s = O7(I), n.mode & fa) {
            jt(!0);
            try {
              O7(I);
            } finally {
              jt(!1);
            }
          }
          $s();
        }
        n.flags |= 1, t !== null && E ? (n.child = cp(
          n,
          t.child,
          null,
          p
        ), n.child = cp(
          n,
          null,
          s,
          p
        )) : Tn(
          t,
          n,
          s,
          p
        ), n.memoizedState = I.state, t = n.child;
      } else
        t = ko(
          t,
          n,
          p
        );
      return p = n.stateNode, m && p.props !== f && (D0 || console.error(
        "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
        Z(n) || "a component"
      ), D0 = !0), t;
    }
    function hm(t, n, s, f) {
      return ef(), n.flags |= 256, Tn(t, n, s, f), n.child;
    }
    function vh(t, n) {
      n && n.childContextTypes && console.error(
        `childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`,
        n.displayName || n.name || "Component"
      ), typeof n.getDerivedStateFromProps == "function" && (t = U(n) || "Unknown", fS[t] || (console.error(
        "%s: Function components do not support getDerivedStateFromProps.",
        t
      ), fS[t] = !0)), typeof n.contextType == "object" && n.contextType !== null && (n = U(n) || "Unknown", uS[n] || (console.error(
        "%s: Function components do not support contextType.",
        n
      ), uS[n] = !0));
    }
    function wh(t) {
      return { baseLanes: t, cachePool: Ww() };
    }
    function Tr(t, n, s) {
      return t = t !== null ? t.childLanes & ~s : 0, n && (t |= Lo), t;
    }
    function kn(t, n, s) {
      var f, p = n.pendingProps;
      d(n) && (n.flags |= 128);
      var m = !1, E = (n.flags & 128) !== 0;
      if ((f = E) || (f = t !== null && t.memoizedState === null ? !1 : (br.current & g2) !== 0), f && (m = !0, n.flags &= -129), f = (n.flags & 32) !== 0, n.flags &= -33, t === null) {
        if (It) {
          if (m ? ga(n) : Qa(n), It) {
            var I = $r, F;
            if (!(F = !I)) {
              e: {
                var z = I;
                for (F = Ml; z.nodeType !== 8; ) {
                  if (!F) {
                    F = null;
                    break e;
                  }
                  if (z = sa(z.nextSibling), z === null) {
                    F = null;
                    break e;
                  }
                }
                F = z;
              }
              F !== null ? (Xs(), n.memoizedState = {
                dehydrated: F,
                treeContext: up !== null ? { id: rc, overflow: ac } : null,
                retryLane: 536870912
              }, z = b(18, null, null, sn), z.stateNode = F, z.return = n, n.child = z, Oa = n, $r = null, F = !0) : F = !1, F = !F;
            }
            F && (vu(
              n,
              I
            ), yo(n));
          }
          if (I = n.memoizedState, I !== null && (I = I.dehydrated, I !== null))
            return I.data === Ap ? n.lanes = 16 : n.lanes = 536870912, null;
          bo(n);
        }
        return I = p.children, p = p.fallback, m ? (Qa(n), m = n.mode, I = Lu(
          {
            mode: "hidden",
            children: I
          },
          m
        ), p = cs(
          p,
          m,
          s,
          null
        ), I.return = n, p.return = n, I.sibling = p, n.child = I, m = n.child, m.memoizedState = wh(s), m.childLanes = Tr(
          t,
          f,
          s
        ), n.memoizedState = H6, p) : (ga(n), hf(
          n,
          I
        ));
      }
      var de = t.memoizedState;
      if (de !== null && (I = de.dehydrated, I !== null)) {
        if (E)
          n.flags & 256 ? (ga(n), n.flags &= -257, n = pf(
            t,
            n,
            s
          )) : n.memoizedState !== null ? (Qa(n), n.child = t.child, n.flags |= 128, n = null) : (Qa(n), m = p.fallback, I = n.mode, p = Lu(
            {
              mode: "visible",
              children: p.children
            },
            I
          ), m = cs(
            m,
            I,
            s,
            null
          ), m.flags |= 2, p.return = n, m.return = n, p.sibling = m, n.child = p, cp(
            n,
            t.child,
            null,
            s
          ), p = n.child, p.memoizedState = wh(s), p.childLanes = Tr(
            t,
            f,
            s
          ), n.memoizedState = H6, n = m);
        else if (ga(n), It && console.error(
          "We should not be hydrating here. This is a bug in React. Please file a bug."
        ), I.data === Ap) {
          if (f = I.nextSibling && I.nextSibling.dataset, f) {
            F = f.dgst;
            var Ee = f.msg;
            z = f.stck;
            var pe = f.cstck;
          }
          I = Ee, f = F, p = z, F = m = pe, m = Error(I || "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), m.stack = p || "", m.digest = f, f = F === void 0 ? null : F, p = {
            value: m,
            source: null,
            stack: f
          }, typeof f == "string" && N6.set(
            m,
            p
          ), wu(p), n = pf(
            t,
            n,
            s
          );
        } else if (Lr || Sh(
          t,
          n,
          s,
          !1
        ), f = (s & t.childLanes) !== 0, Lr || f) {
          if (f = Xt, f !== null) {
            if (p = s & -s, p & 42)
              p = 1;
            else
              switch (p) {
                case 2:
                  p = 1;
                  break;
                case 8:
                  p = 4;
                  break;
                case 32:
                  p = 16;
                  break;
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                  p = 64;
                  break;
                case 268435456:
                  p = 134217728;
                  break;
                default:
                  p = 0;
              }
            if (p = p & (f.suspendedLanes | s) ? 0 : p, p !== 0 && p !== de.retryLane)
              throw de.retryLane = p, dr(
                t,
                p
              ), Vt(
                f,
                t,
                p
              ), sS;
          }
          I.data === Sp || Bh(), n = pf(
            t,
            n,
            s
          );
        } else
          I.data === Sp ? (n.flags |= 128, n.child = t.child, n = n3.bind(
            null,
            t
          ), I._reactRetry = n, n = null) : (t = de.treeContext, $r = sa(
            I.nextSibling
          ), Oa = n, It = !0, Cs = null, oc = !1, ki = null, Ml = !1, t !== null && (Xs(), vi[wi++] = rc, vi[wi++] = ac, vi[wi++] = up, rc = t.id, ac = t.overflow, up = n), n = hf(
            n,
            p.children
          ), n.flags |= 4096);
        return n;
      }
      return m ? (Qa(n), m = p.fallback, I = n.mode, F = t.child, z = F.sibling, p = ni(
        F,
        {
          mode: "hidden",
          children: p.children
        }
      ), p.subtreeFlags = F.subtreeFlags & 31457280, z !== null ? m = ni(
        z,
        m
      ) : (m = cs(
        m,
        I,
        s,
        null
      ), m.flags |= 2), m.return = n, p.return = n, p.sibling = m, n.child = p, p = m, m = n.child, I = t.child.memoizedState, I === null ? I = wh(s) : (F = I.cachePool, F !== null ? (z = wr._currentValue, F = F.parent !== z ? { parent: z, pool: z } : F) : F = Ww(), I = {
        baseLanes: I.baseLanes | s,
        cachePool: F
      }), m.memoizedState = I, m.childLanes = Tr(
        t,
        f,
        s
      ), n.memoizedState = H6, p) : (ga(n), s = t.child, t = s.sibling, s = ni(s, {
        mode: "visible",
        children: p.children
      }), s.return = n, s.sibling = null, t !== null && (f = n.deletions, f === null ? (n.deletions = [t], n.flags |= 16) : f.push(t)), n.child = s, n.memoizedState = null, s);
    }
    function hf(t, n) {
      return n = Lu(
        { mode: "visible", children: n },
        t.mode
      ), n.return = t, t.child = n;
    }
    function Lu(t, n) {
      return Om(t, n, 0, null);
    }
    function pf(t, n, s) {
      return cp(n, t.child, null, s), t = hf(
        n,
        n.pendingProps.children
      ), t.flags |= 2, n.memoizedState = null, t;
    }
    function pm(t, n, s) {
      t.lanes |= n;
      var f = t.alternate;
      f !== null && (f.lanes |= n), Eh(
        t.return,
        n,
        s
      );
    }
    function Xo(t, n) {
      var s = mr(t);
      return t = !s && typeof L(t) == "function", s || t ? (s = s ? "array" : "iterable", console.error(
        "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
        s,
        n,
        s
      ), !1) : !0;
    }
    function gf(t, n, s, f, p) {
      var m = t.memoizedState;
      m === null ? t.memoizedState = {
        isBackwards: n,
        rendering: null,
        renderingStartTime: 0,
        last: f,
        tail: s,
        tailMode: p
      } : (m.isBackwards = n, m.rendering = null, m.renderingStartTime = 0, m.last = f, m.tail = s, m.tailMode = p);
    }
    function gm(t, n, s) {
      var f = n.pendingProps, p = f.revealOrder, m = f.tail;
      if (f = f.children, p !== void 0 && p !== "forwards" && p !== "backwards" && p !== "together" && !dS[p])
        if (dS[p] = !0, typeof p == "string")
          switch (p.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                p,
                p.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                p,
                p.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                p
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
            p
          );
      m === void 0 || z6[m] || (m !== "collapsed" && m !== "hidden" ? (z6[m] = !0, console.error(
        '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
        m
      )) : p !== "forwards" && p !== "backwards" && (z6[m] = !0, console.error(
        '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
        m
      )));
      e: if ((p === "forwards" || p === "backwards") && f !== void 0 && f !== null && f !== !1)
        if (mr(f)) {
          for (var E = 0; E < f.length; E++)
            if (!Xo(f[E], E)) break e;
        } else if (E = L(f), typeof E == "function") {
          if (E = E.call(f))
            for (var I = E.next(), F = 0; !I.done; I = E.next()) {
              if (!Xo(I.value, F)) break e;
              F++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            p
          );
      if (Tn(t, n, f, s), f = br.current, f & g2)
        f = f & N0 | g2, n.flags |= 128;
      else {
        if (t !== null && t.flags & 128)
          e: for (t = n.child; t !== null; ) {
            if (t.tag === 13)
              t.memoizedState !== null && pm(
                t,
                s,
                n
              );
            else if (t.tag === 19)
              pm(t, s, n);
            else if (t.child !== null) {
              t.child.return = t, t = t.child;
              continue;
            }
            if (t === n) break e;
            for (; t.sibling === null; ) {
              if (t.return === null || t.return === n)
                break e;
              t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
          }
        f &= N0;
      }
      switch (Ce(br, f, n), p) {
        case "forwards":
          for (s = n.child, p = null; s !== null; )
            t = s.alternate, t !== null && sh(t) === null && (p = s), s = s.sibling;
          s = p, s === null ? (p = n.child, n.child = null) : (p = s.sibling, s.sibling = null), gf(
            n,
            !1,
            p,
            s,
            m
          );
          break;
        case "backwards":
          for (s = null, p = n.child, n.child = null; p !== null; ) {
            if (t = p.alternate, t !== null && sh(t) === null) {
              n.child = p;
              break;
            }
            t = p.sibling, p.sibling = s, s = p, p = t;
          }
          gf(
            n,
            !0,
            s,
            null,
            m
          );
          break;
        case "together":
          gf(n, !1, null, null, void 0);
          break;
        default:
          n.memoizedState = null;
      }
      return n.child;
    }
    function ko(t, n, s) {
      if (t !== null && (n.dependencies = t.dependencies), eo = -1, td |= n.lanes, !(s & n.childLanes))
        if (t !== null) {
          if (Sh(
            t,
            n,
            s,
            !1
          ), (s & n.childLanes) === 0)
            return null;
        } else return null;
      if (t !== null && n.child !== t.child)
        throw Error("Resuming work not yet implemented.");
      if (n.child !== null) {
        for (t = n.child, s = ni(t, t.pendingProps), n.child = s, s.return = n; t.sibling !== null; )
          t = t.sibling, s = s.sibling = ni(t, t.pendingProps), s.return = n;
        s.sibling = null;
      }
      return n.child;
    }
    function mm(t, n) {
      return t.lanes & n ? !0 : (t = t.dependencies, !!(t !== null && Ah(t)));
    }
    function Zw(t, n, s) {
      switch (n.tag) {
        case 3:
          Pe(
            n,
            n.stateNode.containerInfo
          ), as(
            n,
            wr,
            t.memoizedState.cache
          ), ef();
          break;
        case 27:
        case 5:
          at(n);
          break;
        case 4:
          Pe(
            n,
            n.stateNode.containerInfo
          );
          break;
        case 10:
          as(
            n,
            n.type,
            n.memoizedProps.value
          );
          break;
        case 12:
          s & n.childLanes && (n.flags |= 4), n.flags |= 2048;
          var f = n.stateNode;
          f.effectDuration = -0, f.passiveEffectDuration = -0;
          break;
        case 13:
          if (f = n.memoizedState, f !== null)
            return f.dehydrated !== null ? (ga(n), n.flags |= 128, null) : s & n.child.childLanes ? kn(
              t,
              n,
              s
            ) : (ga(n), t = ko(
              t,
              n,
              s
            ), t !== null ? t.sibling : null);
          ga(n);
          break;
        case 19:
          var p = (t.flags & 128) !== 0;
          if (f = (s & n.childLanes) !== 0, f || (Sh(
            t,
            n,
            s,
            !1
          ), f = (s & n.childLanes) !== 0), p) {
            if (f)
              return gm(
                t,
                n,
                s
              );
            n.flags |= 128;
          }
          if (p = n.memoizedState, p !== null && (p.rendering = null, p.tail = null, p.lastEffect = null), Ce(
            br,
            br.current,
            n
          ), f) break;
          return null;
        case 22:
        case 23:
          return n.lanes = 0, mn(t, n, s);
        case 24:
          as(
            n,
            wr,
            t.memoizedState.cache
          );
      }
      return ko(t, n, s);
    }
    function ym(t, n, s) {
      if (n._debugNeedsRemount && t !== null) {
        s = Pm(
          n.type,
          n.key,
          n.pendingProps,
          n._debugOwner || null,
          n.mode,
          n.lanes
        );
        var f = n.return;
        if (f === null) throw Error("Cannot swap the root fiber.");
        if (t.alternate = null, n.alternate = null, s.index = n.index, s.sibling = n.sibling, s.return = n.return, s.ref = n.ref, s._debugInfo = n._debugInfo, n === f.child)
          f.child = s;
        else {
          var p = f.child;
          if (p === null)
            throw Error("Expected parent to have a child.");
          for (; p.sibling !== n; )
            if (p = p.sibling, p === null)
              throw Error("Expected to find the previous sibling.");
          p.sibling = s;
        }
        return n = f.deletions, n === null ? (f.deletions = [t], f.flags |= 16) : n.push(t), s.flags |= 2, s;
      }
      if (t !== null)
        if (t.memoizedProps !== n.pendingProps || n.type !== t.type)
          Lr = !0;
        else {
          if (!mm(t, s) && !(n.flags & 128))
            return Lr = !1, Zw(
              t,
              n,
              s
            );
          Lr = !!(t.flags & 131072);
        }
      else
        Lr = !1, (f = It) && (Xs(), f = (n.flags & 1048576) !== 0), f && (f = n.index, Xs(), Mw(n, O3, f));
      switch (n.lanes = 0, n.tag) {
        case 16:
          e: if (f = n.pendingProps, t = Yf(n.elementType), n.type = t, typeof t == "function")
            Ph(t) ? (f = ns(
              t,
              f
            ), n.tag = 1, n.type = t = mu(t), n = Qw(
              null,
              n,
              t,
              f,
              s
            )) : (n.tag = 0, vh(n, t), n.type = t = mu(t), n = dm(
              null,
              n,
              t,
              f,
              s
            ));
          else {
            if (t != null) {
              if (p = t.$$typeof, p === Ju) {
                n.tag = 11, n.type = t = S1(t), n = df(
                  null,
                  n,
                  t,
                  f,
                  s
                );
                break e;
              } else if (p === Al) {
                n.tag = 14, n = Ou(
                  null,
                  n,
                  t,
                  f,
                  s
                );
                break e;
              }
            }
            throw n = "", t !== null && typeof t == "object" && t.$$typeof === Nr && (n = " Did you wrap a component in React.lazy() more than once?"), t = U(t) || t, Error(
              "Element type is invalid. Received a promise that resolves to: " + t + ". Lazy element type must resolve to a class or function." + n
            );
          }
          return n;
        case 0:
          return dm(
            t,
            n,
            n.type,
            n.pendingProps,
            s
          );
        case 1:
          return f = n.type, p = ns(
            f,
            n.pendingProps
          ), Qw(
            t,
            n,
            f,
            p,
            s
          );
        case 3:
          e: {
            if (Pe(
              n,
              n.stateNode.containerInfo
            ), t === null)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            var m = n.pendingProps;
            p = n.memoizedState, f = p.element, wm(t, n), yf(n, m, null, s);
            var E = n.memoizedState;
            if (m = E.cache, as(n, wr, m), m !== p.cache && bm(
              n,
              [wr],
              s,
              !0
            ), ti(), m = E.element, p.isDehydrated)
              if (p = {
                element: m,
                isDehydrated: !1,
                cache: E.cache
              }, n.updateQueue.baseState = p, n.memoizedState = p, n.flags & 256) {
                n = hm(
                  t,
                  n,
                  m,
                  s
                );
                break e;
              } else if (m !== f) {
                f = ra(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  n
                ), wu(f), n = hm(
                  t,
                  n,
                  m,
                  s
                );
                break e;
              } else
                for ($r = sa(
                  n.stateNode.containerInfo.firstChild
                ), Oa = n, It = !0, Cs = null, oc = !1, ki = null, Ml = !0, t = j7(
                  n,
                  null,
                  m,
                  s
                ), n.child = t; t; )
                  t.flags = t.flags & -3 | 4096, t = t.sibling;
            else {
              if (ef(), m === f) {
                n = ko(
                  t,
                  n,
                  s
                );
                break e;
              }
              Tn(
                t,
                n,
                m,
                s
              );
            }
            n = n.child;
          }
          return n;
        case 26:
          return Ru(t, n), t === null ? (t = qm(
            n.type,
            null,
            n.pendingProps,
            null
          )) ? n.memoizedState = t : It || (t = n.type, s = n.pendingProps, f = Be(
            or.current
          ), f = Qm(
            f
          ).createElement(t), f[yr] = n, f[ua] = s, cn(f, t, s), Dn(f), n.stateNode = f) : n.memoizedState = qm(
            n.type,
            t.memoizedProps,
            n.pendingProps,
            t.memoizedState
          ), null;
        case 27:
          return at(n), t === null && It && (p = Be(or.current), f = Xe(), p = n.stateNode = Of(
            n.type,
            n.pendingProps,
            p,
            f,
            !1
          ), oc || (f = s3(
            p,
            n.type,
            n.pendingProps,
            f
          ), f !== null && (el(n, 0).serverProps = f)), Oa = n, Ml = !0, $r = sa(
            p.firstChild
          )), f = n.pendingProps.children, t !== null || It ? Tn(
            t,
            n,
            f,
            s
          ) : n.child = cp(
            n,
            null,
            f,
            s
          ), Ru(t, n), n.child;
        case 5:
          return t === null && It && (m = Xe(), f = Hg(
            n.type,
            m.ancestorInfo
          ), p = $r, (E = !p) || (E = Hh(
            p,
            n.type,
            n.pendingProps,
            Ml
          ), E !== null ? (n.stateNode = E, oc || (m = s3(
            E,
            n.type,
            n.pendingProps,
            m
          ), m !== null && (el(n, 0).serverProps = m)), Oa = n, $r = sa(
            E.firstChild
          ), Ml = !1, m = !0) : m = !1, E = !m), E && (f && vu(n, p), yo(n))), at(n), p = n.type, m = n.pendingProps, E = t !== null ? t.memoizedProps : null, f = m.children, zt(p, m) ? f = null : E !== null && zt(p, E) && (n.flags |= 32), n.memoizedState !== null && (p = aa(
            t,
            n,
            am,
            null,
            null,
            s
          ), L2._currentValue = p), Ru(t, n), Tn(
            t,
            n,
            f,
            s
          ), n.child;
        case 6:
          return t === null && It && (t = n.pendingProps, s = Xe().ancestorInfo.current, t = s != null ? qd(t, s.tag) : !0, s = $r, (f = !s) || (f = di(
            s,
            n.pendingProps,
            Ml
          ), f !== null ? (n.stateNode = f, Oa = n, $r = null, f = !0) : f = !1, f = !f), f && (t && vu(n, s), yo(n))), null;
        case 13:
          return kn(t, n, s);
        case 4:
          return Pe(
            n,
            n.stateNode.containerInfo
          ), f = n.pendingProps, t === null ? n.child = cp(
            n,
            null,
            f,
            s
          ) : Tn(
            t,
            n,
            f,
            s
          ), n.child;
        case 11:
          return df(
            t,
            n,
            n.type,
            n.pendingProps,
            s
          );
        case 7:
          return Tn(
            t,
            n,
            n.pendingProps,
            s
          ), n.child;
        case 8:
          return Tn(
            t,
            n,
            n.pendingProps.children,
            s
          ), n.child;
        case 12:
          return n.flags |= 4, n.flags |= 2048, f = n.stateNode, f.effectDuration = -0, f.passiveEffectDuration = -0, Tn(
            t,
            n,
            n.pendingProps.children,
            s
          ), n.child;
        case 10:
          return f = n.type, p = n.pendingProps, m = p.value, "value" in p || hS || (hS = !0, console.error(
            "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
          )), as(n, f, m), Tn(
            t,
            n,
            p.children,
            s
          ), n.child;
        case 9:
          return p = n.type._context, f = n.pendingProps.children, typeof f != "function" && console.error(
            "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
          ), ul(n), p = qt(p), au(n), f = R6(
            f,
            p,
            void 0
          ), $s(), n.flags |= 1, Tn(
            t,
            n,
            f,
            s
          ), n.child;
        case 14:
          return Ou(
            t,
            n,
            n.type,
            n.pendingProps,
            s
          );
        case 15:
          return $w(
            t,
            n,
            n.type,
            n.pendingProps,
            s
          );
        case 19:
          return gm(
            t,
            n,
            s
          );
        case 22:
          return mn(t, n, s);
        case 24:
          return ul(n), f = qt(wr), t === null ? (p = rm(), p === null && (p = Xt, m = Yi(), p.pooledCache = m, Za(m), m !== null && (p.pooledCacheLanes |= s), p = m), n.memoizedState = {
            parent: f,
            cache: p
          }, vm(n), as(n, wr, p)) : (t.lanes & s && (wm(t, n), yf(n, null, null, s), ti()), p = t.memoizedState, m = n.memoizedState, p.parent !== f ? (p = {
            parent: f,
            cache: f
          }, n.memoizedState = p, n.lanes === 0 && (n.memoizedState = n.updateQueue.baseState = p), as(n, wr, f)) : (f = m.cache, as(n, wr, f), f !== p.cache && bm(
            n,
            [wr],
            s,
            !0
          ))), Tn(
            t,
            n,
            n.pendingProps.children,
            s
          ), n.child;
        case 29:
          throw n.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" + n.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function kh() {
      B0 = _3 = null, M0 = !1;
    }
    function as(t, n, s) {
      Ce(V6, n._currentValue, t), n._currentValue = s, Ce(W6, n._currentRenderer, t), n._currentRenderer !== void 0 && n._currentRenderer !== null && n._currentRenderer !== pS && console.error(
        "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
      ), n._currentRenderer = pS;
    }
    function ei(t, n) {
      t._currentValue = V6.current;
      var s = W6.current;
      xe(W6, n), t._currentRenderer = s, xe(V6, n);
    }
    function Eh(t, n, s) {
      for (; t !== null; ) {
        var f = t.alternate;
        if ((t.childLanes & n) !== n ? (t.childLanes |= n, f !== null && (f.childLanes |= n)) : f !== null && (f.childLanes & n) !== n && (f.childLanes |= n), t === s) break;
        t = t.return;
      }
      t !== s && console.error(
        "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function bm(t, n, s, f) {
      var p = t.child;
      for (p !== null && (p.return = t); p !== null; ) {
        var m = p.dependencies;
        if (m !== null) {
          var E = p.child;
          m = m.firstContext;
          e: for (; m !== null; ) {
            var I = m;
            m = p;
            for (var F = 0; F < n.length; F++)
              if (I.context === n[F]) {
                m.lanes |= s, I = m.alternate, I !== null && (I.lanes |= s), Eh(
                  m.return,
                  s,
                  t
                ), f || (E = null);
                break e;
              }
            m = I.next;
          }
        } else if (p.tag === 18) {
          if (E = p.return, E === null)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          E.lanes |= s, m = E.alternate, m !== null && (m.lanes |= s), Eh(
            E,
            s,
            t
          ), E = null;
        } else E = p.child;
        if (E !== null) E.return = p;
        else
          for (E = p; E !== null; ) {
            if (E === t) {
              E = null;
              break;
            }
            if (p = E.sibling, p !== null) {
              p.return = E.return, E = p;
              break;
            }
            E = E.return;
          }
        p = E;
      }
    }
    function Sh(t, n, s, f) {
      t = null;
      for (var p = n, m = !1; p !== null; ) {
        if (!m) {
          if (p.flags & 524288) m = !0;
          else if (p.flags & 262144) break;
        }
        if (p.tag === 10) {
          var E = p.alternate;
          if (E === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          if (E = E.memoizedProps, E !== null) {
            var I = p.type;
            Pa(p.pendingProps.value, E.value) || (t !== null ? t.push(I) : t = [I]);
          }
        } else if (p === ep.current) {
          if (E = p.alternate, E === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          E.memoizedState.memoizedState !== p.memoizedState.memoizedState && (t !== null ? t.push(L2) : t = [L2]);
        }
        p = p.return;
      }
      t !== null && bm(
        n,
        t,
        s,
        f
      ), n.flags |= 262144;
    }
    function Ah(t) {
      for (t = t.firstContext; t !== null; ) {
        if (!Pa(
          t.context._currentValue,
          t.memoizedValue
        ))
          return !0;
        t = t.next;
      }
      return !1;
    }
    function ul(t) {
      _3 = t, B0 = null, t = t.dependencies, t !== null && (t.firstContext = null);
    }
    function qt(t) {
      return M0 && console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      ), Q1(_3, t);
    }
    function mf(t, n) {
      return _3 === null && ul(t), Q1(t, n);
    }
    function Q1(t, n) {
      var s = n._currentValue;
      if (n = { context: n, memoizedValue: s, next: null }, B0 === null) {
        if (t === null)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        B0 = n, t.dependencies = {
          lanes: 0,
          firstContext: n,
          _debugThenableState: null
        }, t.flags |= 524288;
      } else B0 = B0.next = n;
      return s;
    }
    function vm(t) {
      t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function wm(t, n) {
      t = t.updateQueue, n.updateQueue === t && (n.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        callbacks: null
      });
    }
    function os(t) {
      return {
        lane: t,
        tag: gS,
        payload: null,
        callback: null,
        next: null
      };
    }
    function is(t, n, s) {
      var f = t.updateQueue;
      if (f === null) return null;
      if (f = f.shared, j6 === f && !bS) {
        var p = Z(t);
        console.error(
          `An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`,
          p
        ), bS = !0;
      }
      return (fn & Da) !== Oo ? (p = f.pending, p === null ? n.next = n : (n.next = p.next, p.next = n), f.pending = n, n = Kg(t), Lw(t, null, s), n) : (qg(t, f, n, s), Kg(t));
    }
    function xh(t, n, s) {
      if (n = n.updateQueue, n !== null && (n = n.shared, (s & 4194176) !== 0)) {
        var f = n.lanes;
        f &= t.pendingLanes, s |= f, n.lanes = s, ea(t, s);
      }
    }
    function Ch(t, n) {
      var s = t.updateQueue, f = t.alternate;
      if (f !== null && (f = f.updateQueue, s === f)) {
        var p = null, m = null;
        if (s = s.firstBaseUpdate, s !== null) {
          do {
            var E = {
              lane: s.lane,
              tag: s.tag,
              payload: s.payload,
              callback: null,
              next: null
            };
            m === null ? p = m = E : m = m.next = E, s = s.next;
          } while (s !== null);
          m === null ? p = m = n : m = m.next = n;
        } else p = m = n;
        s = {
          baseState: f.baseState,
          firstBaseUpdate: p,
          lastBaseUpdate: m,
          shared: f.shared,
          callbacks: f.callbacks
        }, t.updateQueue = s;
        return;
      }
      t = s.lastBaseUpdate, t === null ? s.firstBaseUpdate = n : t.next = n, s.lastBaseUpdate = n;
    }
    function ti() {
      if ($6) {
        var t = P0;
        if (t !== null) throw t;
      }
    }
    function yf(t, n, s, f) {
      $6 = !1;
      var p = t.updateQueue;
      ed = !1, j6 = p.shared;
      var m = p.firstBaseUpdate, E = p.lastBaseUpdate, I = p.shared.pending;
      if (I !== null) {
        p.shared.pending = null;
        var F = I, z = F.next;
        F.next = null, E === null ? m = z : E.next = z, E = F;
        var de = t.alternate;
        de !== null && (de = de.updateQueue, I = de.lastBaseUpdate, I !== E && (I === null ? de.firstBaseUpdate = z : I.next = z, de.lastBaseUpdate = F));
      }
      if (m !== null) {
        var Ee = p.baseState;
        E = 0, de = z = F = null, I = m;
        do {
          var pe = I.lane & -536870913, Se = pe !== I.lane;
          if (Se ? (St & pe) === pe : (f & pe) === pe) {
            pe !== 0 && pe === fp && ($6 = !0), de !== null && (de = de.next = {
              lane: 0,
              tag: I.tag,
              payload: I.payload,
              callback: null,
              next: null
            });
            e: {
              pe = t;
              var Ze = I, ct = n, Gn = s;
              switch (Ze.tag) {
                case mS:
                  if (Ze = Ze.payload, typeof Ze == "function") {
                    M0 = !0;
                    var _t = Ze.call(
                      Gn,
                      Ee,
                      ct
                    );
                    if (pe.mode & fa) {
                      jt(!0);
                      try {
                        Ze.call(Gn, Ee, ct);
                      } finally {
                        jt(!1);
                      }
                    }
                    M0 = !1, Ee = _t;
                    break e;
                  }
                  Ee = Ze;
                  break e;
                case G6:
                  pe.flags = pe.flags & -65537 | 128;
                case gS:
                  if (_t = Ze.payload, typeof _t == "function") {
                    if (M0 = !0, Ze = _t.call(
                      Gn,
                      Ee,
                      ct
                    ), pe.mode & fa) {
                      jt(!0);
                      try {
                        _t.call(Gn, Ee, ct);
                      } finally {
                        jt(!1);
                      }
                    }
                    M0 = !1;
                  } else Ze = _t;
                  if (Ze == null) break e;
                  Ee = st({}, Ee, Ze);
                  break e;
                case yS:
                  ed = !0;
              }
            }
            pe = I.callback, pe !== null && (t.flags |= 64, Se && (t.flags |= 8192), Se = p.callbacks, Se === null ? p.callbacks = [pe] : Se.push(pe));
          } else
            Se = {
              lane: pe,
              tag: I.tag,
              payload: I.payload,
              callback: I.callback,
              next: null
            }, de === null ? (z = de = Se, F = Ee) : de = de.next = Se, E |= pe;
          if (I = I.next, I === null) {
            if (I = p.shared.pending, I === null)
              break;
            Se = I, I = Se.next, Se.next = null, p.lastBaseUpdate = Se, p.shared.pending = null;
          }
        } while (!0);
        de === null && (F = Ee), p.baseState = F, p.firstBaseUpdate = z, p.lastBaseUpdate = de, m === null && (p.shared.lanes = 0), td |= E, t.lanes = E, t.memoizedState = Ee;
      }
      j6 = null;
    }
    function Th(t, n) {
      if (typeof t != "function")
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " + t
        );
      t.call(n);
    }
    function km(t, n) {
      var s = t.shared.hiddenCallbacks;
      if (s !== null)
        for (t.shared.hiddenCallbacks = null, t = 0; t < s.length; t++)
          Th(s[t], n);
    }
    function Z1(t, n) {
      var s = t.callbacks;
      if (s !== null)
        for (t.callbacks = null, t = 0; t < s.length; t++)
          Th(s[t], n);
    }
    function qa(t) {
      return (t.mode & jr) !== sn;
    }
    function Y1(t, n) {
      qa(t) ? (mo(), bf(n, t), go()) : bf(n, t);
    }
    function Em(t, n, s) {
      qa(t) ? (mo(), Du(
        s,
        t,
        n
      ), go()) : Du(
        s,
        t,
        n
      );
    }
    function bf(t, n) {
      try {
        var s = n.updateQueue, f = s !== null ? s.lastEffect : null;
        if (f !== null) {
          var p = f.next;
          s = p;
          do {
            if ((s.tag & t) === t && ((t & vr) !== Si ? Me !== null && typeof Me.markComponentPassiveEffectMountStarted == "function" && Me.markComponentPassiveEffectMountStarted(
              n
            ) : (t & Qr) !== Si && Me !== null && typeof Me.markComponentLayoutEffectMountStarted == "function" && Me.markComponentLayoutEffectMountStarted(
              n
            ), f = void 0, (t & Ra) !== Si && (V0 = !0), f = V(
              n,
              oP,
              s
            ), (t & Ra) !== Si && (V0 = !1), (t & vr) !== Si ? Me !== null && typeof Me.markComponentPassiveEffectMountStopped == "function" && Me.markComponentPassiveEffectMountStopped() : (t & Qr) !== Si && Me !== null && typeof Me.markComponentLayoutEffectMountStopped == "function" && Me.markComponentLayoutEffectMountStopped(), f !== void 0 && typeof f != "function")) {
              var m = void 0;
              m = s.tag & Qr ? "useLayoutEffect" : s.tag & Ra ? "useInsertionEffect" : "useEffect";
              var E = void 0;
              E = f === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof f.then == "function" ? `

It looks like you wrote ` + m + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + m + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + f, V(
                n,
                function(I, F) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    I,
                    F
                  );
                },
                m,
                E
              );
            }
            s = s.next;
          } while (s !== p);
        }
      } catch (I) {
        Rt(n, n.return, I);
      }
    }
    function Du(t, n, s) {
      try {
        var f = n.updateQueue, p = f !== null ? f.lastEffect : null;
        if (p !== null) {
          var m = p.next;
          f = m;
          do {
            if ((f.tag & t) === t) {
              var E = f.inst, I = E.destroy;
              I !== void 0 && (E.destroy = void 0, (t & vr) !== Si ? Me !== null && typeof Me.markComponentPassiveEffectUnmountStarted == "function" && Me.markComponentPassiveEffectUnmountStarted(
                n
              ) : (t & Qr) !== Si && Me !== null && typeof Me.markComponentLayoutEffectUnmountStarted == "function" && Me.markComponentLayoutEffectUnmountStarted(
                n
              ), (t & Ra) !== Si && (V0 = !0), V(
                n,
                iP,
                n,
                s,
                I
              ), (t & Ra) !== Si && (V0 = !1), (t & vr) !== Si ? Me !== null && typeof Me.markComponentPassiveEffectUnmountStopped == "function" && Me.markComponentPassiveEffectUnmountStopped() : (t & Qr) !== Si && Me !== null && typeof Me.markComponentLayoutEffectUnmountStopped == "function" && Me.markComponentLayoutEffectUnmountStopped());
            }
            f = f.next;
          } while (f !== m);
        }
      } catch (F) {
        Rt(n, n.return, F);
      }
    }
    function Sm(t, n) {
      qa(t) ? (mo(), bf(n, t), go()) : bf(n, t);
    }
    function Am(t, n, s) {
      qa(t) ? (mo(), Du(
        s,
        t,
        n
      ), go()) : Du(
        s,
        t,
        n
      );
    }
    function q1(t) {
      var n = t.updateQueue;
      if (n !== null) {
        var s = t.stateNode;
        t.type.defaultProps || "ref" in t.memoizedProps || D0 || (s.props !== t.memoizedProps && console.error(
          "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          Z(t) || "instance"
        ), s.state !== t.memoizedState && console.error(
          "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          Z(t) || "instance"
        ));
        try {
          V(
            t,
            Z1,
            n,
            s
          );
        } catch (f) {
          Rt(t, t.return, f);
        }
      }
    }
    function K1(t, n, s) {
      return t.getSnapshotBeforeUpdate(n, s);
    }
    function Yw(t, n) {
      var s = n.memoizedProps, f = n.memoizedState;
      n = t.stateNode, t.type.defaultProps || "ref" in t.memoizedProps || D0 || (n.props !== t.memoizedProps && console.error(
        "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
        Z(t) || "instance"
      ), n.state !== t.memoizedState && console.error(
        "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
        Z(t) || "instance"
      ));
      try {
        var p = ns(
          t.type,
          s,
          t.elementType === t.type
        ), m = V(
          t,
          K1,
          n,
          p,
          f
        );
        s = vS, m !== void 0 || s.has(t.type) || (s.add(t.type), V(t, function() {
          console.error(
            "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
            Z(t)
          );
        })), n.__reactInternalSnapshotBeforeUpdate = m;
      } catch (E) {
        Rt(t, t.return, E);
      }
    }
    function J1(t, n, s) {
      s.props = ns(
        t.type,
        t.memoizedProps
      ), s.state = t.memoizedState, qa(t) ? (mo(), V(
        t,
        F7,
        t,
        n,
        s
      ), go()) : V(
        t,
        F7,
        t,
        n,
        s
      );
    }
    function a6(t) {
      var n = t.ref;
      if (n !== null) {
        var s = t.stateNode;
        if (typeof n == "function")
          if (qa(t))
            try {
              mo(), t.refCleanup = n(s);
            } finally {
              go();
            }
          else t.refCleanup = n(s);
        else
          typeof n == "string" ? console.error("String refs are no longer supported.") : n.hasOwnProperty("current") || console.error(
            "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
            Z(t)
          ), n.current = s;
      }
    }
    function ss(t, n) {
      try {
        V(t, a6, t);
      } catch (s) {
        Rt(t, n, s);
      }
    }
    function ia(t, n) {
      var s = t.ref, f = t.refCleanup;
      if (s !== null)
        if (typeof f == "function")
          try {
            if (qa(t))
              try {
                mo(), V(t, f);
              } finally {
                go(t);
              }
            else V(t, f);
          } catch (p) {
            Rt(t, n, p);
          } finally {
            t.refCleanup = null, t = t.alternate, t != null && (t.refCleanup = null);
          }
        else if (typeof s == "function")
          try {
            if (qa(t))
              try {
                mo(), V(t, s, null);
              } finally {
                go(t);
              }
            else V(t, s, null);
          } catch (p) {
            Rt(t, n, p);
          }
        else s.current = null;
    }
    function X1(t, n, s, f) {
      var p = t.memoizedProps, m = p.id, E = p.onCommit;
      p = p.onRender, n = n === null ? "mount" : "update", T3 && (n = "nested-update"), typeof p == "function" && p(
        m,
        n,
        t.actualDuration,
        t.treeBaseDuration,
        t.actualStartTime,
        s
      ), typeof E == "function" && E(
        t.memoizedProps.id,
        n,
        f,
        s
      );
    }
    function eb(t, n, s, f) {
      var p = t.memoizedProps;
      t = p.id, p = p.onPostCommit, n = n === null ? "mount" : "update", T3 && (n = "nested-update"), typeof p == "function" && p(
        t,
        n,
        f,
        s
      );
    }
    function tb(t) {
      var n = t.type, s = t.memoizedProps, f = t.stateNode;
      try {
        V(
          t,
          $t,
          f,
          n,
          s,
          t
        );
      } catch (p) {
        Rt(t, t.return, p);
      }
    }
    function nb(t, n, s) {
      try {
        V(
          t,
          Aa,
          t.stateNode,
          t.type,
          s,
          n,
          t
        );
      } catch (f) {
        Rt(t, t.return, f);
      }
    }
    function qw(t) {
      return t.tag === 5 || t.tag === 3 || t.tag === 26 || t.tag === 27 || t.tag === 4;
    }
    function rb(t) {
      e: for (; ; ) {
        for (; t.sibling === null; ) {
          if (t.return === null || qw(t.return)) return null;
          t = t.return;
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 27 && t.tag !== 18; ) {
          if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
          t.child.return = t, t = t.child;
        }
        if (!(t.flags & 2)) return t.stateNode;
      }
    }
    function xm(t, n, s) {
      var f = t.tag;
      if (f === 5 || f === 6)
        t = t.stateNode, n ? s.nodeType === 8 ? s.parentNode.insertBefore(t, n) : s.insertBefore(t, n) : (s.nodeType === 8 ? (n = s.parentNode, n.insertBefore(t, s)) : (n = s, n.appendChild(t)), s = s._reactRootContainer, s != null || n.onclick !== null || (n.onclick = To));
      else if (f !== 4 && f !== 27 && (t = t.child, t !== null))
        for (xm(t, n, s), t = t.sibling; t !== null; )
          xm(t, n, s), t = t.sibling;
    }
    function cl(t, n, s) {
      var f = t.tag;
      if (f === 5 || f === 6)
        t = t.stateNode, n ? s.insertBefore(t, n) : s.appendChild(t);
      else if (f !== 4 && f !== 27 && (t = t.child, t !== null))
        for (cl(t, n, s), t = t.sibling; t !== null; )
          cl(t, n, s), t = t.sibling;
    }
    function ab(t) {
      if (t.tag !== 27) {
        e: {
          for (var n = t.return; n !== null; ) {
            if (qw(n)) {
              var s = n;
              break e;
            }
            n = n.return;
          }
          throw Error(
            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        switch (s.tag) {
          case 27:
            n = s.stateNode, s = rb(t), cl(t, s, n);
            break;
          case 5:
            n = s.stateNode, s.flags & 32 && (fi(n), s.flags &= -33), s = rb(t), cl(t, s, n);
            break;
          case 3:
          case 4:
            n = s.stateNode.containerInfo, s = rb(t), xm(
              t,
              s,
              n
            );
            break;
          default:
            throw Error(
              "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
            );
        }
      }
    }
    function Cm(t, n) {
      if (t = t.containerInfo, f8 = a4, t = Ow(t), Zg(t)) {
        if ("selectionStart" in t)
          var s = {
            start: t.selectionStart,
            end: t.selectionEnd
          };
        else
          e: {
            s = (s = t.ownerDocument) && s.defaultView || window;
            var f = s.getSelection && s.getSelection();
            if (f && f.rangeCount !== 0) {
              s = f.anchorNode;
              var p = f.anchorOffset, m = f.focusNode;
              f = f.focusOffset;
              try {
                s.nodeType, m.nodeType;
              } catch {
                s = null;
                break e;
              }
              var E = 0, I = -1, F = -1, z = 0, de = 0, Ee = t, pe = null;
              t: for (; ; ) {
                for (var Se; Ee !== s || p !== 0 && Ee.nodeType !== 3 || (I = E + p), Ee !== m || f !== 0 && Ee.nodeType !== 3 || (F = E + f), Ee.nodeType === 3 && (E += Ee.nodeValue.length), (Se = Ee.firstChild) !== null; )
                  pe = Ee, Ee = Se;
                for (; ; ) {
                  if (Ee === t) break t;
                  if (pe === s && ++z === p && (I = E), pe === m && ++de === f && (F = E), (Se = Ee.nextSibling) !== null) break;
                  Ee = pe, pe = Ee.parentNode;
                }
                Ee = Se;
              }
              s = I === -1 || F === -1 ? null : { start: I, end: F };
            } else s = null;
          }
        s = s || { start: 0, end: 0 };
      } else s = null;
      for (d8 = {
        focusedElem: t,
        selectionRange: s
      }, a4 = !1, Dr = n; Dr !== null; )
        if (n = Dr, t = n.child, (n.subtreeFlags & 1028) !== 0 && t !== null)
          t.return = n, Dr = t;
        else
          for (; Dr !== null; ) {
            switch (t = n = Dr, s = t.alternate, p = t.flags, t.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                p & 1024 && s !== null && Yw(t, s);
                break;
              case 3:
                if (p & 1024) {
                  if (t = t.stateNode.containerInfo, s = t.nodeType, s === 9)
                    vl(t);
                  else if (s === 1)
                    switch (t.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        vl(t);
                        break;
                      default:
                        t.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (p & 1024)
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            if (t = n.sibling, t !== null) {
              t.return = n.return, Dr = t;
              break;
            }
            Dr = n.return;
          }
      return n = kS, kS = !1, n;
    }
    function ob(t, n, s) {
      var f = s.flags;
      switch (s.tag) {
        case 0:
        case 11:
        case 15:
          Eo(t, s), f & 4 && Y1(s, Qr | Ai);
          break;
        case 1:
          if (Eo(t, s), f & 4)
            if (t = s.stateNode, n === null)
              s.type.defaultProps || "ref" in s.memoizedProps || D0 || (t.props !== s.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                Z(s) || "instance"
              ), t.state !== s.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                Z(s) || "instance"
              )), qa(s) ? (mo(), V(
                s,
                L6,
                s,
                t
              ), go()) : V(
                s,
                L6,
                s,
                t
              );
            else {
              var p = ns(
                s.type,
                n.memoizedProps
              );
              n = n.memoizedState, s.type.defaultProps || "ref" in s.memoizedProps || D0 || (t.props !== s.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                Z(s) || "instance"
              ), t.state !== s.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                Z(s) || "instance"
              )), qa(s) ? (mo(), V(
                s,
                D7,
                s,
                t,
                p,
                n,
                t.__reactInternalSnapshotBeforeUpdate
              ), go()) : V(
                s,
                D7,
                s,
                t,
                p,
                n,
                t.__reactInternalSnapshotBeforeUpdate
              );
            }
          f & 64 && q1(s), f & 512 && ss(s, s.return);
          break;
        case 3:
          if (n = Qi(), Eo(t, s), f & 64 && (f = s.updateQueue, f !== null)) {
            if (p = null, s.child !== null)
              switch (s.child.tag) {
                case 27:
                case 5:
                  p = s.child.stateNode;
                  break;
                case 1:
                  p = s.child.stateNode;
              }
            try {
              V(
                s,
                Z1,
                f,
                p
              );
            } catch (I) {
              Rt(s, s.return, I);
            }
          }
          t.effectDuration += Jg(n);
          break;
        case 26:
          Eo(t, s), f & 512 && ss(s, s.return);
          break;
        case 27:
        case 5:
          Eo(t, s), n === null && f & 4 && tb(s), f & 512 && ss(s, s.return);
          break;
        case 12:
          if (f & 4) {
            f = Qi(), Eo(t, s), t = s.stateNode, t.effectDuration += yu(f);
            try {
              V(
                s,
                X1,
                s,
                n,
                C3,
                t.effectDuration
              );
            } catch (I) {
              Rt(s, s.return, I);
            }
          } else Eo(t, s);
          break;
        case 13:
          Eo(t, s), f & 4 && ls(t, s);
          break;
        case 22:
          if (p = s.memoizedState !== null || uc, !p) {
            n = n !== null && n.memoizedState !== null || In;
            var m = uc, E = In;
            uc = p, (In = n) && !E ? So(
              t,
              s,
              (s.subtreeFlags & 8772) !== 0
            ) : Eo(t, s), uc = m, In = E;
          }
          f & 512 && (s.memoizedProps.mode === "manual" ? ss(s, s.return) : ia(s, s.return));
          break;
        default:
          Eo(t, s);
      }
    }
    function ib(t) {
      var n = t.alternate;
      n !== null && (t.alternate = null, ib(n)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (n = t.stateNode, n !== null && Hi(n)), t.stateNode = null, t._debugOwner = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
    }
    function er(t, n, s) {
      for (s = s.child; s !== null; )
        fl(
          t,
          n,
          s
        ), s = s.sibling;
    }
    function fl(t, n, s) {
      if (Or && typeof Or.onCommitFiberUnmount == "function")
        try {
          Or.onCommitFiberUnmount(Hf, s);
        } catch (m) {
          Wr || (Wr = !0, console.error(
            "React instrumentation encountered an error: %s",
            m
          ));
        }
      switch (s.tag) {
        case 26:
          In || ia(s, n), er(
            t,
            n,
            s
          ), s.memoizedState ? s.memoizedState.count-- : s.stateNode && (s = s.stateNode, s.parentNode.removeChild(s));
          break;
        case 27:
          In || ia(s, n);
          var f = sr, p = Po;
          for (sr = s.stateNode, er(
            t,
            n,
            s
          ), s = s.stateNode, t = s.attributes; t.length; )
            s.removeAttributeNode(t[0]);
          Hi(s), sr = f, Po = p;
          break;
        case 5:
          In || ia(s, n);
        case 6:
          if (f = sr, p = Po, sr = null, er(
            t,
            n,
            s
          ), sr = f, Po = p, sr !== null)
            if (Po)
              try {
                V(
                  s,
                  bs,
                  sr,
                  s.stateNode
                );
              } catch (m) {
                Rt(
                  s,
                  n,
                  m
                );
              }
            else
              try {
                V(
                  s,
                  Eb,
                  sr,
                  s.stateNode
                );
              } catch (m) {
                Rt(
                  s,
                  n,
                  m
                );
              }
          break;
        case 18:
          sr !== null && (Po ? (t = sr, s = s.stateNode, t.nodeType === 8 ? on(t.parentNode, s) : t.nodeType === 1 && on(t, s), Ff(t)) : on(sr, s.stateNode));
          break;
        case 4:
          f = sr, p = Po, sr = s.stateNode.containerInfo, Po = !0, er(
            t,
            n,
            s
          ), sr = f, Po = p;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          In || Du(
            Ra,
            s,
            n
          ), In || Em(
            s,
            n,
            Qr
          ), er(
            t,
            n,
            s
          );
          break;
        case 1:
          In || (ia(s, n), f = s.stateNode, typeof f.componentWillUnmount == "function" && J1(
            s,
            n,
            f
          )), er(
            t,
            n,
            s
          );
          break;
        case 21:
          er(
            t,
            n,
            s
          );
          break;
        case 22:
          In || ia(s, n), In = (f = In) || s.memoizedState !== null, er(
            t,
            n,
            s
          ), In = f;
          break;
        default:
          er(
            t,
            n,
            s
          );
      }
    }
    function ls(t, n) {
      if (n.memoizedState === null && (t = n.alternate, t !== null && (t = t.memoizedState, t !== null && (t = t.dehydrated, t !== null))))
        try {
          V(
            n,
            $u,
            t
          );
        } catch (s) {
          Rt(n, n.return, s);
        }
    }
    function Bu(t) {
      switch (t.tag) {
        case 13:
        case 19:
          var n = t.stateNode;
          return n === null && (n = t.stateNode = new wS()), n;
        case 22:
          return t = t.stateNode, n = t._retryCache, n === null && (n = t._retryCache = new wS()), n;
        default:
          throw Error(
            "Unexpected Suspense handler tag (" + t.tag + "). This is a bug in React."
          );
      }
    }
    function Ih(t, n) {
      var s = Bu(t);
      n.forEach(function(f) {
        var p = rr.bind(null, t, f);
        if (!s.has(f)) {
          if (s.add(f), Gr)
            if (F0 !== null && _0 !== null)
              nn(_0, F0);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          f.then(p, p);
        }
      });
    }
    function sb(t, n, s) {
      F0 = s, _0 = t, lb(n, t), _0 = F0 = null;
    }
    function ba(t, n) {
      var s = n.deletions;
      if (s !== null)
        for (var f = 0; f < s.length; f++) {
          var p = t, m = n, E = s[f], I = m;
          e: for (; I !== null; ) {
            switch (I.tag) {
              case 27:
              case 5:
                sr = I.stateNode, Po = !1;
                break e;
              case 3:
                sr = I.stateNode.containerInfo, Po = !0;
                break e;
              case 4:
                sr = I.stateNode.containerInfo, Po = !0;
                break e;
            }
            I = I.return;
          }
          if (sr === null)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          fl(p, m, E), sr = null, Po = !1, p = E, m = p.alternate, m !== null && (m.return = null), p.return = null;
        }
      if (n.subtreeFlags & 13878)
        for (n = n.child; n !== null; )
          lb(n, t), n = n.sibling;
    }
    function lb(t, n) {
      var s = t.alternate, f = t.flags;
      switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ba(n, t), tr(t), f & 4 && (Du(
            Ra | Ai,
            t,
            t.return
          ), bf(Ra | Ai, t), Em(
            t,
            t.return,
            Qr | Ai
          ));
          break;
        case 1:
          ba(n, t), tr(t), f & 512 && (In || s === null || ia(s, s.return)), f & 64 && uc && (t = t.updateQueue, t !== null && (f = t.callbacks, f !== null && (s = t.shared.hiddenCallbacks, t.shared.hiddenCallbacks = s === null ? f : s.concat(f))));
          break;
        case 26:
          var p = Ts;
          if (ba(n, t), tr(t), f & 512 && (In || s === null || ia(s, s.return)), f & 4)
            if (n = s !== null ? s.memoizedState : null, f = t.memoizedState, s === null)
              if (f === null)
                if (t.stateNode === null) {
                  e: {
                    f = t.type, s = t.memoizedProps, n = p.ownerDocument || p;
                    t: switch (f) {
                      case "title":
                        p = n.getElementsByTagName("title")[0], (!p || p[Pl] || p[yr] || p.namespaceURI === Na || p.hasAttribute("itemprop")) && (p = n.createElement(f), n.head.insertBefore(
                          p,
                          n.querySelector("head > title")
                        )), cn(p, f, s), p[yr] = t, Dn(p), f = p;
                        break e;
                      case "link":
                        var m = Tb(
                          "link",
                          "href",
                          n
                        ).get(f + (s.href || ""));
                        if (m) {
                          for (var E = 0; E < m.length; E++)
                            if (p = m[E], p.getAttribute("href") === (s.href == null ? null : s.href) && p.getAttribute("rel") === (s.rel == null ? null : s.rel) && p.getAttribute("title") === (s.title == null ? null : s.title) && p.getAttribute("crossorigin") === (s.crossOrigin == null ? null : s.crossOrigin)) {
                              m.splice(E, 1);
                              break t;
                            }
                        }
                        p = n.createElement(f), cn(p, f, s), n.head.appendChild(p);
                        break;
                      case "meta":
                        if (m = Tb(
                          "meta",
                          "content",
                          n
                        ).get(f + (s.content || ""))) {
                          for (E = 0; E < m.length; E++)
                            if (p = m[E], _e(
                              s.content,
                              "content"
                            ), p.getAttribute("content") === (s.content == null ? null : "" + s.content) && p.getAttribute("name") === (s.name == null ? null : s.name) && p.getAttribute("property") === (s.property == null ? null : s.property) && p.getAttribute("http-equiv") === (s.httpEquiv == null ? null : s.httpEquiv) && p.getAttribute("charset") === (s.charSet == null ? null : s.charSet)) {
                              m.splice(E, 1);
                              break t;
                            }
                        }
                        p = n.createElement(f), cn(p, f, s), n.head.appendChild(p);
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' + f + '". This is a bug in React.'
                        );
                    }
                    p[yr] = t, Dn(p), f = p;
                  }
                  t.stateNode = f;
                } else
                  Ib(
                    p,
                    t.type,
                    t.stateNode
                  );
              else
                t.stateNode = hi(
                  p,
                  f,
                  t.memoizedProps
                );
            else
              n !== f ? (n === null ? s.stateNode !== null && (s = s.stateNode, s.parentNode.removeChild(s)) : n.count--, f === null ? Ib(
                p,
                t.type,
                t.stateNode
              ) : hi(
                p,
                f,
                t.memoizedProps
              )) : f === null && t.stateNode !== null && nb(
                t,
                t.memoizedProps,
                s.memoizedProps
              );
          break;
        case 27:
          if (f & 4 && t.alternate === null) {
            p = t.stateNode, m = t.memoizedProps;
            try {
              for (E = p.firstChild; E; ) {
                var I = E.nextSibling, F = E.nodeName;
                E[Pl] || F === "HEAD" || F === "BODY" || F === "SCRIPT" || F === "STYLE" || F === "LINK" && E.rel.toLowerCase() === "stylesheet" || p.removeChild(E), E = I;
              }
              V(
                t,
                Ab,
                t.type,
                m,
                p,
                t
              );
            } catch (de) {
              Rt(t, t.return, de);
            }
          }
        case 5:
          if (ba(n, t), tr(t), f & 512 && (In || s === null || ia(s, s.return)), t.flags & 32) {
            n = t.stateNode;
            try {
              V(t, fi, n);
            } catch (de) {
              Rt(t, t.return, de);
            }
          }
          f & 4 && t.stateNode != null && (n = t.memoizedProps, nb(
            t,
            n,
            s !== null ? s.memoizedProps : n
          )), f & 1024 && (Q6 = !0, t.type !== "form" && console.error(
            "Unexpected host component type. Expected a form. This is a bug in React."
          ));
          break;
        case 6:
          if (ba(n, t), tr(t), f & 4) {
            if (t.stateNode === null)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            f = t.memoizedProps, s = s !== null ? s.memoizedProps : f, n = t.stateNode;
            try {
              V(
                t,
                Pf,
                n,
                s,
                f
              );
            } catch (de) {
              Rt(t, t.return, de);
            }
          }
          break;
        case 3:
          if (p = Qi(), t4 = null, m = Ts, Ts = Rf(n.containerInfo), ba(n, t), Ts = m, tr(t), f & 4 && s !== null && s.memoizedState.isDehydrated)
            try {
              V(
                t,
                Ym,
                n.containerInfo
              );
            } catch (de) {
              Rt(t, t.return, de);
            }
          Q6 && (Q6 = !1, Nh(t)), n.effectDuration += Jg(p);
          break;
        case 4:
          f = Ts, Ts = Rf(
            t.stateNode.containerInfo
          ), ba(n, t), tr(t), Ts = f;
          break;
        case 12:
          f = Qi(), ba(n, t), tr(t), t.stateNode.effectDuration += yu(f);
          break;
        case 13:
          ba(n, t), tr(t), t.child.flags & 8192 && t.memoizedState !== null != (s !== null && s.memoizedState !== null) && (X6 = mi()), f & 4 && (f = t.updateQueue, f !== null && (t.updateQueue = null, Ih(t, f)));
          break;
        case 22:
          f & 512 && (In || s === null || ia(s, s.return)), E = t.memoizedState !== null, I = s !== null && s.memoizedState !== null, F = uc;
          var z = In;
          if (uc = F || E, In = z || I, ba(n, t), In = z, uc = F, tr(t), n = t.stateNode, n._current = t, n._visibility &= -3, n._visibility |= n._pendingVisibility & i2, f & 8192 && (n._visibility = E ? n._visibility & -2 : n._visibility | x3, E && (n = uc || In, s === null || I || n || us(t)), t.memoizedProps === null || t.memoizedProps.mode !== "manual"))
            e: for (s = null, n = t; ; ) {
              if (n.tag === 5 || n.tag === 26 || n.tag === 27) {
                if (s === null) {
                  I = s = n;
                  try {
                    p = I.stateNode, E ? V(
                      I,
                      bl,
                      p
                    ) : V(
                      I,
                      Sb,
                      I.stateNode,
                      I.memoizedProps
                    );
                  } catch (de) {
                    Rt(I, I.return, de);
                  }
                }
              } else if (n.tag === 6) {
                if (s === null) {
                  I = n;
                  try {
                    m = I.stateNode, E ? V(
                      I,
                      ju,
                      m
                    ) : V(
                      I,
                      Ja,
                      m,
                      I.memoizedProps
                    );
                  } catch (de) {
                    Rt(I, I.return, de);
                  }
                }
              } else if ((n.tag !== 22 && n.tag !== 23 || n.memoizedState === null || n === t) && n.child !== null) {
                n.child.return = n, n = n.child;
                continue;
              }
              if (n === t) break e;
              for (; n.sibling === null; ) {
                if (n.return === null || n.return === t)
                  break e;
                s === n && (s = null), n = n.return;
              }
              s === n && (s = null), n.sibling.return = n.return, n = n.sibling;
            }
          f & 4 && (f = t.updateQueue, f !== null && (s = f.retryQueue, s !== null && (f.retryQueue = null, Ih(t, s))));
          break;
        case 19:
          ba(n, t), tr(t), f & 4 && (f = t.updateQueue, f !== null && (t.updateQueue = null, Ih(t, f)));
          break;
        case 21:
          break;
        default:
          ba(n, t), tr(t);
      }
    }
    function tr(t) {
      var n = t.flags;
      if (n & 2) {
        try {
          V(t, ab, t);
        } catch (s) {
          Rt(t, t.return, s);
        }
        t.flags &= -3;
      }
      n & 4096 && (t.flags &= -4097);
    }
    function Nh(t) {
      if (t.subtreeFlags & 1024)
        for (t = t.child; t !== null; ) {
          var n = t;
          Nh(n), n.tag === 5 && n.flags & 1024 && n.stateNode.reset(), t = t.sibling;
        }
    }
    function Kw(t, n, s) {
      F0 = s, _0 = n, ob(n, t.alternate, t), _0 = F0 = null;
    }
    function Eo(t, n) {
      if (n.subtreeFlags & 8772)
        for (n = n.child; n !== null; )
          ob(t, n.alternate, n), n = n.sibling;
    }
    function ub(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Em(
            t,
            t.return,
            Qr
          ), us(t);
          break;
        case 1:
          ia(t, t.return);
          var n = t.stateNode;
          typeof n.componentWillUnmount == "function" && J1(
            t,
            t.return,
            n
          ), us(t);
          break;
        case 26:
        case 27:
        case 5:
          ia(t, t.return), us(t);
          break;
        case 22:
          ia(t, t.return), t.memoizedState === null && us(t);
          break;
        default:
          us(t);
      }
    }
    function us(t) {
      for (t = t.child; t !== null; )
        ub(t), t = t.sibling;
    }
    function cb(t, n, s, f) {
      var p = s.flags;
      switch (s.tag) {
        case 0:
        case 11:
        case 15:
          So(
            t,
            s,
            f
          ), Y1(s, Qr);
          break;
        case 1:
          if (So(
            t,
            s,
            f
          ), n = s.stateNode, typeof n.componentDidMount == "function" && V(
            s,
            L6,
            s,
            n
          ), n = s.updateQueue, n !== null) {
            t = s.stateNode;
            try {
              V(
                s,
                km,
                n,
                t
              );
            } catch (m) {
              Rt(s, s.return, m);
            }
          }
          f && p & 64 && q1(s), ss(s, s.return);
          break;
        case 26:
        case 27:
        case 5:
          So(
            t,
            s,
            f
          ), f && n === null && p & 4 && tb(s), ss(s, s.return);
          break;
        case 12:
          if (f && p & 4) {
            p = Qi(), So(
              t,
              s,
              f
            ), f = s.stateNode, f.effectDuration += yu(p);
            try {
              V(
                s,
                X1,
                s,
                n,
                C3,
                f.effectDuration
              );
            } catch (m) {
              Rt(s, s.return, m);
            }
          } else
            So(
              t,
              s,
              f
            );
          break;
        case 13:
          So(
            t,
            s,
            f
          ), f && p & 4 && ls(t, s);
          break;
        case 22:
          s.memoizedState === null && So(
            t,
            s,
            f
          ), ss(s, s.return);
          break;
        default:
          So(
            t,
            s,
            f
          );
      }
    }
    function So(t, n, s) {
      for (s = s && (n.subtreeFlags & 8772) !== 0, n = n.child; n !== null; )
        cb(
          t,
          n.alternate,
          n,
          s
        ), n = n.sibling;
    }
    function Tm(t, n) {
      var s = null;
      t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (s = t.memoizedState.cachePool.pool), t = null, n.memoizedState !== null && n.memoizedState.cachePool !== null && (t = n.memoizedState.cachePool.pool), t !== s && (t != null && Za(t), s != null && ku(s));
    }
    function Im(t, n) {
      t = null, n.alternate !== null && (t = n.alternate.memoizedState.cache), n = n.memoizedState.cache, n !== t && (Za(n), t != null && ku(t));
    }
    function dl(t, n, s, f) {
      if (n.subtreeFlags & 10256)
        for (n = n.child; n !== null; )
          fb(
            t,
            n,
            s,
            f
          ), n = n.sibling;
    }
    function fb(t, n, s, f) {
      var p = n.flags;
      switch (n.tag) {
        case 0:
        case 11:
        case 15:
          dl(
            t,
            n,
            s,
            f
          ), p & 2048 && Sm(n, vr | Ai);
          break;
        case 3:
          var m = Qi();
          dl(
            t,
            n,
            s,
            f
          ), p & 2048 && (s = null, n.alternate !== null && (s = n.alternate.memoizedState.cache), n = n.memoizedState.cache, n !== s && (Za(n), s != null && ku(s))), t.passiveEffectDuration += Jg(m);
          break;
        case 12:
          if (p & 2048) {
            m = Qi(), dl(
              t,
              n,
              s,
              f
            ), t = n.stateNode, t.passiveEffectDuration += yu(m);
            try {
              V(
                n,
                eb,
                n,
                n.alternate,
                C3,
                t.passiveEffectDuration
              );
            } catch (E) {
              Rt(n, n.return, E);
            }
          } else
            dl(
              t,
              n,
              s,
              f
            );
          break;
        case 23:
          break;
        case 22:
          m = n.stateNode, n.memoizedState !== null ? m._visibility & ip ? dl(
            t,
            n,
            s,
            f
          ) : vf(
            t,
            n
          ) : m._visibility & ip ? dl(
            t,
            n,
            s,
            f
          ) : (m._visibility |= ip, un(
            t,
            n,
            s,
            f,
            (n.subtreeFlags & 10256) !== 0
          )), p & 2048 && Tm(
            n.alternate,
            n
          );
          break;
        case 24:
          dl(
            t,
            n,
            s,
            f
          ), p & 2048 && Im(n.alternate, n);
          break;
        default:
          dl(
            t,
            n,
            s,
            f
          );
      }
    }
    function un(t, n, s, f, p) {
      for (p = p && (n.subtreeFlags & 10256) !== 0, n = n.child; n !== null; )
        nr(
          t,
          n,
          s,
          f,
          p
        ), n = n.sibling;
    }
    function nr(t, n, s, f, p) {
      var m = n.flags;
      switch (n.tag) {
        case 0:
        case 11:
        case 15:
          un(
            t,
            n,
            s,
            f,
            p
          ), Sm(n, vr);
          break;
        case 23:
          break;
        case 22:
          var E = n.stateNode;
          n.memoizedState !== null ? E._visibility & ip ? un(
            t,
            n,
            s,
            f,
            p
          ) : vf(
            t,
            n
          ) : (E._visibility |= ip, un(
            t,
            n,
            s,
            f,
            p
          )), p && m & 2048 && Tm(
            n.alternate,
            n
          );
          break;
        case 24:
          un(
            t,
            n,
            s,
            f,
            p
          ), p && m & 2048 && Im(n.alternate, n);
          break;
        default:
          un(
            t,
            n,
            s,
            f,
            p
          );
      }
    }
    function vf(t, n) {
      if (n.subtreeFlags & 10256)
        for (n = n.child; n !== null; ) {
          var s = t, f = n, p = f.flags;
          switch (f.tag) {
            case 22:
              vf(
                s,
                f
              ), p & 2048 && Tm(
                f.alternate,
                f
              );
              break;
            case 24:
              vf(
                s,
                f
              ), p & 2048 && Im(
                f.alternate,
                f
              );
              break;
            default:
              vf(
                s,
                f
              );
          }
          n = n.sibling;
        }
    }
    function Mu(t) {
      if (t.subtreeFlags & v2)
        for (t = t.child; t !== null; )
          db(t), t = t.sibling;
    }
    function db(t) {
      switch (t.tag) {
        case 26:
          Mu(t), t.flags & v2 && t.memoizedState !== null && o6(
            Ts,
            t.memoizedState,
            t.memoizedProps
          );
          break;
        case 5:
          Mu(t);
          break;
        case 3:
        case 4:
          var n = Ts;
          Ts = Rf(
            t.stateNode.containerInfo
          ), Mu(t), Ts = n;
          break;
        case 22:
          t.memoizedState === null && (n = t.alternate, n !== null && n.memoizedState !== null ? (n = v2, v2 = 16777216, Mu(t), v2 = n) : Mu(t));
          break;
        default:
          Mu(t);
      }
    }
    function hb(t) {
      var n = t.alternate;
      if (n !== null && (t = n.child, t !== null)) {
        n.child = null;
        do
          n = t.sibling, t.sibling = null, t = n;
        while (t !== null);
      }
    }
    function wf(t) {
      var n = t.deletions;
      if (t.flags & 16) {
        if (n !== null)
          for (var s = 0; s < n.length; s++) {
            var f = n[s];
            Dr = f, gb(
              f,
              t
            );
          }
        hb(t);
      }
      if (t.subtreeFlags & 10256)
        for (t = t.child; t !== null; )
          kf(t), t = t.sibling;
    }
    function kf(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          wf(t), t.flags & 2048 && Am(
            t,
            t.return,
            vr | Ai
          );
          break;
        case 3:
          var n = Qi();
          wf(t), t.stateNode.passiveEffectDuration += Jg(n);
          break;
        case 12:
          n = Qi(), wf(t), t.stateNode.passiveEffectDuration += yu(n);
          break;
        case 22:
          n = t.stateNode, t.memoizedState !== null && n._visibility & ip && (t.return === null || t.return.tag !== 13) ? (n._visibility &= -5, Ef(t)) : wf(t);
          break;
        default:
          wf(t);
      }
    }
    function Ef(t) {
      var n = t.deletions;
      if (t.flags & 16) {
        if (n !== null)
          for (var s = 0; s < n.length; s++) {
            var f = n[s];
            Dr = f, gb(
              f,
              t
            );
          }
        hb(t);
      }
      for (t = t.child; t !== null; )
        pb(t), t = t.sibling;
    }
    function pb(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          Am(
            t,
            t.return,
            vr
          ), Ef(t);
          break;
        case 22:
          var n = t.stateNode;
          n._visibility & ip && (n._visibility &= -5, Ef(t));
          break;
        default:
          Ef(t);
      }
    }
    function gb(t, n) {
      for (; Dr !== null; ) {
        var s = Dr, f = s;
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            Am(
              f,
              n,
              vr
            );
            break;
          case 23:
          case 22:
            f.memoizedState !== null && f.memoizedState.cachePool !== null && (f = f.memoizedState.cachePool.pool, f != null && Za(f));
            break;
          case 24:
            ku(f.memoizedState.cache);
        }
        if (f = s.child, f !== null) f.return = s, Dr = f;
        else
          e: for (s = t; Dr !== null; ) {
            f = Dr;
            var p = f.sibling, m = f.return;
            if (ib(f), f === s) {
              Dr = null;
              break e;
            }
            if (p !== null) {
              p.return = m, Dr = p;
              break e;
            }
            Dr = m;
          }
      }
    }
    function Jw(t, n, s, f) {
      this.tag = t, this.key = s, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, ES || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
    }
    function Ph(t) {
      return t = t.prototype, !(!t || !t.isReactComponent);
    }
    function ni(t, n) {
      var s = t.alternate;
      switch (s === null ? (s = b(
        t.tag,
        n,
        t.key,
        t.mode
      ), s.elementType = t.elementType, s.type = t.type, s.stateNode = t.stateNode, s._debugOwner = t._debugOwner, s._debugHookTypes = t._debugHookTypes, s.alternate = t, t.alternate = s) : (s.pendingProps = n, s.type = t.type, s.flags = 0, s.subtreeFlags = 0, s.deletions = null, s.actualDuration = -0, s.actualStartTime = -1.1), s.flags = t.flags & 31457280, s.childLanes = t.childLanes, s.lanes = t.lanes, s.child = t.child, s.memoizedProps = t.memoizedProps, s.memoizedState = t.memoizedState, s.updateQueue = t.updateQueue, n = t.dependencies, s.dependencies = n === null ? null : {
        lanes: n.lanes,
        firstContext: n.firstContext,
        _debugThenableState: n._debugThenableState
      }, s.sibling = t.sibling, s.index = t.index, s.ref = t.ref, s.refCleanup = t.refCleanup, s.selfBaseDuration = t.selfBaseDuration, s.treeBaseDuration = t.treeBaseDuration, s._debugInfo = t._debugInfo, s._debugNeedsRemount = t._debugNeedsRemount, s.tag) {
        case 0:
        case 15:
          s.type = mu(t.type);
          break;
        case 1:
          s.type = mu(t.type);
          break;
        case 11:
          s.type = S1(t.type);
      }
      return s;
    }
    function Nm(t, n) {
      t.flags &= 31457282;
      var s = t.alternate;
      return s === null ? (t.childLanes = 0, t.lanes = n, t.child = null, t.subtreeFlags = 0, t.memoizedProps = null, t.memoizedState = null, t.updateQueue = null, t.dependencies = null, t.stateNode = null, t.selfBaseDuration = 0, t.treeBaseDuration = 0) : (t.childLanes = s.childLanes, t.lanes = s.lanes, t.child = s.child, t.subtreeFlags = 0, t.deletions = null, t.memoizedProps = s.memoizedProps, t.memoizedState = s.memoizedState, t.updateQueue = s.updateQueue, t.type = s.type, n = s.dependencies, t.dependencies = n === null ? null : {
        lanes: n.lanes,
        firstContext: n.firstContext,
        _debugThenableState: n._debugThenableState
      }, t.selfBaseDuration = s.selfBaseDuration, t.treeBaseDuration = s.treeBaseDuration), t;
    }
    function Pm(t, n, s, f, p, m) {
      var E = 0, I = t;
      if (typeof t == "function")
        Ph(t) && (E = 1), I = mu(I);
      else if (typeof t == "string")
        E = Xe(), E = c3(t, s, E) ? 26 : t === "html" || t === "head" || t === "body" ? 27 : 5;
      else
        e: switch (t) {
          case pi:
            return cs(
              s.children,
              p,
              m,
              n
            );
          case r0:
            E = 8, p |= fa, p |= As;
            break;
          case a0:
            return t = s, f = p, typeof t.id != "string" && console.error(
              'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
              typeof t.id
            ), n = b(12, t, n, f | jr), n.elementType = a0, n.lanes = m, n.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, n;
          case o0:
            return n = b(13, s, n, p), n.elementType = o0, n.lanes = m, n;
          case Zh:
            return n = b(19, s, n, p), n.elementType = Zh, n.lanes = m, n;
          case Xu:
            return Om(s, p, m, n);
          default:
            if (typeof t == "object" && t !== null)
              switch (t.$$typeof) {
                case At:
                case Ca:
                  E = 10;
                  break e;
                case Qh:
                  E = 9;
                  break e;
                case Ju:
                  E = 11, I = S1(I);
                  break e;
                case Al:
                  E = 14;
                  break e;
                case Nr:
                  E = 16, I = null;
                  break e;
              }
            I = "", (t === void 0 || typeof t == "object" && t !== null && Object.keys(t).length === 0) && (I += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), t === null ? s = "null" : mr(t) ? s = "array" : t !== void 0 && t.$$typeof === Sl ? (s = "<" + (U(t.type) || "Unknown") + " />", I = " Did you accidentally export a JSX literal instead of a component?") : s = typeof t, (E = f ? W(f) : null) && (I += `

Check the render method of \`` + E + "`."), E = 29, s = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (s + "." + I)
            ), I = null;
        }
      return n = b(E, s, n, p), n.elementType = t, n.type = I, n.lanes = m, n._debugOwner = f, n;
    }
    function Sf(t, n, s) {
      return n = Pm(
        t.type,
        t.key,
        t.props,
        t._owner,
        n,
        s
      ), n._debugOwner = t._owner, n;
    }
    function cs(t, n, s, f) {
      return t = b(7, t, f, n), t.lanes = s, t;
    }
    function Om(t, n, s, f) {
      t = b(22, t, f, n), t.elementType = Xu, t.lanes = s;
      var p = {
        _visibility: x3,
        _pendingVisibility: x3,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null,
        _current: null,
        detach: function() {
          var m = p, E = m._current;
          if (E === null)
            throw Error(
              "Calling Offscreen.detach before instance handle has been set."
            );
          if (!(m._pendingVisibility & i2)) {
            var I = dr(E, 2);
            I !== null && (m._pendingVisibility |= i2, Vt(I, E, 2));
          }
        },
        attach: function() {
          var m = p, E = m._current;
          if (E === null)
            throw Error(
              "Calling Offscreen.detach before instance handle has been set."
            );
          if (m._pendingVisibility & i2) {
            var I = dr(E, 2);
            I !== null && (m._pendingVisibility &= -3, Vt(I, E, 2));
          }
        }
      };
      return t.stateNode = p, t;
    }
    function Rm(t, n, s) {
      return t = b(6, t, null, n), t.lanes = s, t;
    }
    function Oh(t, n, s) {
      return n = b(
        4,
        t.children !== null ? t.children : [],
        t.key,
        n
      ), n.lanes = s, n.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
      }, n;
    }
    function ri(t) {
      t.flags |= 4;
    }
    function ai(t, n) {
      if (n.type !== "stylesheet" || (n.state.loading & Ci) !== xp)
        t.flags &= -16777217;
      else if (t.flags |= 16777216, !Km(n)) {
        if (n = Ei.current, n !== null && ((St & 4194176) === St ? ic !== null : (St & 62914560) !== St && !(St & 536870912) || n !== ic))
          throw h2 = O6, I7;
        t.flags |= 8192;
      }
    }
    function Af(t, n) {
      n !== null && (t.flags |= 4), t.flags & 16384 && (n = t.tag !== 22 ? kw() : 536870912, t.lanes |= n, bp |= n);
    }
    function Rh(t, n) {
      if (!It)
        switch (t.tailMode) {
          case "hidden":
            n = t.tail;
            for (var s = null; n !== null; )
              n.alternate !== null && (s = n), n = n.sibling;
            s === null ? t.tail = null : s.sibling = null;
            break;
          case "collapsed":
            s = t.tail;
            for (var f = null; s !== null; )
              s.alternate !== null && (f = s), s = s.sibling;
            f === null ? n || t.tail === null ? t.tail = null : t.tail.sibling = null : f.sibling = null;
        }
    }
    function Kt(t) {
      var n = t.alternate !== null && t.alternate.child === t.child, s = 0, f = 0;
      if (n)
        if ((t.mode & jr) !== sn) {
          for (var p = t.selfBaseDuration, m = t.child; m !== null; )
            s |= m.lanes | m.childLanes, f |= m.subtreeFlags & 31457280, f |= m.flags & 31457280, p += m.treeBaseDuration, m = m.sibling;
          t.treeBaseDuration = p;
        } else
          for (p = t.child; p !== null; )
            s |= p.lanes | p.childLanes, f |= p.subtreeFlags & 31457280, f |= p.flags & 31457280, p.return = t, p = p.sibling;
      else if ((t.mode & jr) !== sn) {
        p = t.actualDuration, m = t.selfBaseDuration;
        for (var E = t.child; E !== null; )
          s |= E.lanes | E.childLanes, f |= E.subtreeFlags, f |= E.flags, p += E.actualDuration, m += E.treeBaseDuration, E = E.sibling;
        t.actualDuration = p, t.treeBaseDuration = m;
      } else
        for (p = t.child; p !== null; )
          s |= p.lanes | p.childLanes, f |= p.subtreeFlags, f |= p.flags, p.return = t, p = p.sibling;
      return t.subtreeFlags |= f, t.childLanes = s, n;
    }
    function mb(t, n, s) {
      var f = n.pendingProps;
      switch (I1(n), n.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Kt(n), null;
        case 1:
          return Kt(n), null;
        case 3:
          return f = n.stateNode, s = null, t !== null && (s = t.memoizedState.cache), n.memoizedState.cache !== s && (n.flags |= 2048), ei(wr, n), Fe(n), f.pendingContext && (f.context = f.pendingContext, f.pendingContext = null), (t === null || t.child === null) && (Xc(n) ? (Xg(), ri(n)) : t === null || t.memoizedState.isDehydrated && !(n.flags & 256) || (n.flags |= 1024, Cs !== null && (fs(Cs), Cs = null))), Kt(n), null;
        case 26:
          return s = n.memoizedState, t === null ? (ri(n), s !== null ? (Kt(n), ai(
            n,
            s
          )) : (Kt(n), n.flags &= -16777217)) : s ? s !== t.memoizedState ? (ri(n), Kt(n), ai(
            n,
            s
          )) : (Kt(n), n.flags &= -16777217) : (t.memoizedProps !== f && ri(n), Kt(n), n.flags &= -16777217), null;
        case 27:
          tt(n), s = Be(or.current);
          var p = n.type;
          if (t !== null && n.stateNode != null)
            t.memoizedProps !== f && ri(n);
          else {
            if (!f) {
              if (n.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return Kt(n), null;
            }
            t = Xe(), Xc(n) ? Fw(n) : (t = Of(
              p,
              f,
              s,
              t,
              !0
            ), n.stateNode = t, ri(n));
          }
          return Kt(n), null;
        case 5:
          if (tt(n), s = n.type, t !== null && n.stateNode != null)
            t.memoizedProps !== f && ri(n);
          else {
            if (!f) {
              if (n.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return Kt(n), null;
            }
            if (p = Xe(), Xc(n))
              Fw(n);
            else {
              switch (t = Be(or.current), Hg(s, p.ancestorInfo), p = p.context, t = Qm(t), p) {
                case G0:
                  t = t.createElementNS(Na, s);
                  break;
                case e4:
                  t = t.createElementNS(
                    Dl,
                    s
                  );
                  break;
                default:
                  switch (s) {
                    case "svg":
                      t = t.createElementNS(
                        Na,
                        s
                      );
                      break;
                    case "math":
                      t = t.createElementNS(
                        Dl,
                        s
                      );
                      break;
                    case "script":
                      t = t.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild);
                      break;
                    case "select":
                      t = typeof f.is == "string" ? t.createElement("select", { is: f.is }) : t.createElement("select"), f.multiple ? t.multiple = !0 : f.size && (t.size = f.size);
                      break;
                    default:
                      t = typeof f.is == "string" ? t.createElement(s, {
                        is: f.is
                      }) : t.createElement(s), s.indexOf("-") === -1 && (s !== s.toLowerCase() && console.error(
                        "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                        s
                      ), Object.prototype.toString.call(t) !== "[object HTMLUnknownElement]" || gi.call(
                        BS,
                        s
                      ) || (BS[s] = !0, console.error(
                        "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                        s
                      )));
                  }
              }
              t[yr] = n, t[ua] = f;
              e: for (p = n.child; p !== null; ) {
                if (p.tag === 5 || p.tag === 6)
                  t.appendChild(p.stateNode);
                else if (p.tag !== 4 && p.tag !== 27 && p.child !== null) {
                  p.child.return = p, p = p.child;
                  continue;
                }
                if (p === n) break e;
                for (; p.sibling === null; ) {
                  if (p.return === null || p.return === n)
                    break e;
                  p = p.return;
                }
                p.sibling.return = p.return, p = p.sibling;
              }
              n.stateNode = t;
              e: switch (cn(t, s, f), s) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  t = !!f.autoFocus;
                  break e;
                case "img":
                  t = !0;
                  break e;
                default:
                  t = !1;
              }
              t && ri(n);
            }
          }
          return Kt(n), n.flags &= -16777217, null;
        case 6:
          if (t && n.stateNode != null)
            t.memoizedProps !== f && ri(n);
          else {
            if (typeof f != "string" && n.stateNode === null)
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            if (t = Be(or.current), s = Xe(), Xc(n)) {
              t = n.stateNode, f = n.memoizedProps, p = !oc, s = null;
              var m = Oa;
              if (m !== null)
                switch (m.tag) {
                  case 3:
                    p && (p = Vh(
                      t,
                      f,
                      s
                    ), p !== null && (el(n, 0).serverProps = p));
                    break;
                  case 27:
                  case 5:
                    s = m.memoizedProps, p && (p = Vh(
                      t,
                      f,
                      s
                    ), p !== null && (el(
                      n,
                      0
                    ).serverProps = p));
                }
              t[yr] = n, t = !!(t.nodeValue === f || s !== null && s.suppressHydrationWarning === !0 || Gm(t.nodeValue, f)), t || yo(n);
            } else
              s = s.ancestorInfo.current, s != null && qd(f, s.tag), t = Qm(t).createTextNode(
                f
              ), t[yr] = n, n.stateNode = t;
          }
          return Kt(n), null;
        case 13:
          if (f = n.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (p = Xc(n), f !== null && f.dehydrated !== null) {
              if (t === null) {
                if (!p)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                if (p = n.memoizedState, p = p !== null ? p.dehydrated : null, !p)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                p[yr] = n, Kt(n), (n.mode & jr) !== sn && f !== null && (p = n.child, p !== null && (n.treeBaseDuration -= p.treeBaseDuration));
              } else
                Xg(), ef(), !(n.flags & 128) && (n.memoizedState = null), n.flags |= 4, Kt(n), (n.mode & jr) !== sn && f !== null && (p = n.child, p !== null && (n.treeBaseDuration -= p.treeBaseDuration));
              p = !1;
            } else
              Cs !== null && (fs(Cs), Cs = null), p = !0;
            if (!p)
              return n.flags & 256 ? (bo(n), n) : (bo(n), null);
          }
          return bo(n), n.flags & 128 ? (n.lanes = s, (n.mode & jr) !== sn && th(n), n) : (f = f !== null, t = t !== null && t.memoizedState !== null, f && (s = n.child, p = null, s.alternate !== null && s.alternate.memoizedState !== null && s.alternate.memoizedState.cachePool !== null && (p = s.alternate.memoizedState.cachePool.pool), m = null, s.memoizedState !== null && s.memoizedState.cachePool !== null && (m = s.memoizedState.cachePool.pool), m !== p && (s.flags |= 2048)), f !== t && f && (n.child.flags |= 8192), Af(n, n.updateQueue), Kt(n), (n.mode & jr) !== sn && f && (t = n.child, t !== null && (n.treeBaseDuration -= t.treeBaseDuration)), null);
        case 4:
          return Fe(n), t === null && Vm(
            n.stateNode.containerInfo
          ), Kt(n), null;
        case 10:
          return ei(n.type, n), Kt(n), null;
        case 19:
          if (xe(br, n), p = n.memoizedState, p === null) return Kt(n), null;
          if (f = (n.flags & 128) !== 0, m = p.rendering, m === null)
            if (f) Rh(p, !1);
            else {
              if (Nn !== fc || t !== null && t.flags & 128)
                for (t = n.child; t !== null; ) {
                  if (m = sh(t), m !== null) {
                    for (n.flags |= 128, Rh(p, !1), t = m.updateQueue, n.updateQueue = t, Af(n, t), n.subtreeFlags = 0, t = s, f = n.child; f !== null; )
                      Nm(f, t), f = f.sibling;
                    return Ce(
                      br,
                      br.current & N0 | g2,
                      n
                    ), n.child;
                  }
                  t = t.sibling;
                }
              p.tail !== null && mi() > H3 && (n.flags |= 128, f = !0, Rh(p, !1), n.lanes = 4194304);
            }
          else {
            if (!f)
              if (t = sh(m), t !== null) {
                if (n.flags |= 128, f = !0, t = t.updateQueue, n.updateQueue = t, Af(n, t), Rh(p, !0), p.tail === null && p.tailMode === "hidden" && !m.alternate && !It)
                  return Kt(n), null;
              } else
                2 * mi() - p.renderingStartTime > H3 && s !== 536870912 && (n.flags |= 128, f = !0, Rh(p, !1), n.lanes = 4194304);
            p.isBackwards ? (m.sibling = n.child, n.child = m) : (t = p.last, t !== null ? t.sibling = m : n.child = m, p.last = m);
          }
          return p.tail !== null ? (t = p.tail, p.rendering = t, p.tail = t.sibling, p.renderingStartTime = mi(), t.sibling = null, s = br.current, s = f ? s & N0 | g2 : s & N0, Ce(br, s, n), t) : (Kt(n), null);
        case 22:
        case 23:
          return bo(n), L1(n), f = n.memoizedState !== null, t !== null ? t.memoizedState !== null !== f && (n.flags |= 8192) : f && (n.flags |= 8192), f ? s & 536870912 && !(n.flags & 128) && (Kt(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : Kt(n), f = n.updateQueue, f !== null && Af(n, f.retryQueue), f = null, t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (f = t.memoizedState.cachePool.pool), s = null, n.memoizedState !== null && n.memoizedState.cachePool !== null && (s = n.memoizedState.cachePool.pool), s !== f && (n.flags |= 2048), t !== null && xe(dp, n), null;
        case 24:
          return f = null, t !== null && (f = t.memoizedState.cache), n.memoizedState.cache !== f && (n.flags |= 2048), ei(wr, n), Kt(n), null;
        case 25:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" + n.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Fu(t, n) {
      switch (I1(n), n.tag) {
        case 1:
          return t = n.flags, t & 65536 ? (n.flags = t & -65537 | 128, (n.mode & jr) !== sn && th(n), n) : null;
        case 3:
          return ei(wr, n), Fe(n), t = n.flags, t & 65536 && !(t & 128) ? (n.flags = t & -65537 | 128, n) : null;
        case 26:
        case 27:
        case 5:
          return tt(n), null;
        case 13:
          if (bo(n), t = n.memoizedState, t !== null && t.dehydrated !== null) {
            if (n.alternate === null)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            ef();
          }
          return t = n.flags, t & 65536 ? (n.flags = t & -65537 | 128, (n.mode & jr) !== sn && th(n), n) : null;
        case 19:
          return xe(br, n), null;
        case 4:
          return Fe(n), null;
        case 10:
          return ei(n.type, n), null;
        case 22:
        case 23:
          return bo(n), L1(n), t !== null && xe(dp, n), t = n.flags, t & 65536 ? (n.flags = t & -65537 | 128, (n.mode & jr) !== sn && th(n), n) : null;
        case 24:
          return ei(wr, n), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function oi(t, n) {
      switch (I1(n), n.tag) {
        case 3:
          ei(wr, n), Fe(n);
          break;
        case 26:
        case 27:
        case 5:
          tt(n);
          break;
        case 4:
          Fe(n);
          break;
        case 13:
          bo(n);
          break;
        case 19:
          xe(br, n);
          break;
        case 10:
          ei(n.type, n);
          break;
        case 22:
        case 23:
          bo(n), L1(n), t !== null && xe(dp, n);
          break;
        case 24:
          ei(wr, n);
      }
    }
    function hl() {
      hP.forEach(function(t) {
        return t();
      });
    }
    function ii() {
      var t = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return t || me.actQueue === null || console.error(
        "The current testing environment is not configured to support act(...)"
      ), t;
    }
    function Hr(t) {
      if ((fn & Da) !== Oo && St !== 0)
        return St & -St;
      var n = me.T;
      return n !== null ? (n._updatedFibers || (n._updatedFibers = /* @__PURE__ */ new Set()), n._updatedFibers.add(t), t = fp, t !== 0 ? t : zm()) : jd();
    }
    function Lm() {
      Lo === 0 && (Lo = !(St & 536870912) || It ? ww() : 536870912);
      var t = Ei.current;
      return t !== null && (t.flags |= 32), Lo;
    }
    function Vt(t, n, s) {
      if (V0 && console.error("useInsertionEffect must not schedule updates."), r8 && (W3 = !0), (t === Xt && en === yp || t.cancelPendingCommit !== null) && (pl(t, 0), si(
        t,
        St,
        Lo,
        !1
      )), ur(t, s), fn & Da && t === Xt) {
        if (Ta)
          switch (n.tag) {
            case 0:
            case 11:
            case 15:
              t = kt && Z(kt) || "Unknown", NS.has(t) || (NS.add(t), n = Z(n) || "Unknown", console.error(
                "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                n,
                t,
                t
              ));
              break;
            case 1:
              IS || (console.error(
                "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
              ), IS = !0);
          }
      } else
        Gr && Ew(t, n, s), gs(n), t === Xt && ((fn & Da) === Oo && (nd |= s), Nn === mp && si(
          t,
          St,
          Lo,
          !1
        )), xo(t);
    }
    function Lh(t, n, s) {
      if ((fn & (Da | cc)) !== Oo)
        throw Error("Should not already be working.");
      var f = !s && (n & 60) === 0 && (n & t.expiredLanes) === 0 || Gd(t, n), p = f ? Fh(t, n) : Mh(t, n, !0), m = f;
      do {
        if (p === fc) {
          H0 && !f && si(t, n, 0, !1);
          break;
        } else if (p === U3)
          si(
            t,
            n,
            0,
            !dc
          );
        else {
          if (s = t.current.alternate, m && !Dm(s)) {
            p = Mh(t, n, !1), m = !1;
            continue;
          }
          if (p === U0) {
            if (m = n, t.errorRecoveryDisabledLanes & m)
              var E = 0;
            else
              E = t.pendingLanes & -536870913, E = E !== 0 ? E : E & 536870912 ? 536870912 : 0;
            if (E !== 0) {
              n = E;
              e: {
                p = t;
                var I = E;
                E = x2;
                var F = p.current.memoizedState.isDehydrated;
                if (F && (pl(
                  p,
                  I
                ).flags |= 256), I = Mh(
                  p,
                  I,
                  !1
                ), I !== U0) {
                  if (K6 && !F) {
                    p.errorRecoveryDisabledLanes |= m, nd |= m, p = mp;
                    break e;
                  }
                  p = Is, Is = E, p !== null && fs(p);
                }
                p = I;
              }
              if (m = !1, p !== U0) continue;
            }
          }
          if (p === k2) {
            pl(t, 0), si(t, n, 0, !0);
            break;
          }
          e: {
            switch (f = t, p) {
              case fc:
              case k2:
                throw Error("Root did not complete. This is a bug in React.");
              case mp:
                if ((n & 4194176) === n) {
                  si(
                    f,
                    n,
                    Lo,
                    !dc
                  );
                  break e;
                }
                break;
              case U0:
                Is = null;
                break;
              case Z6:
              case SS:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (f.finishedWork = s, f.finishedLanes = n, me.actQueue !== null)
              Vr(
                f,
                Is,
                C2,
                z3,
                Lo,
                nd,
                bp,
                TS,
                I6,
                0
              );
            else {
              if ((n & 62914560) === n && (p = X6 + xS - mi(), 10 < p)) {
                if (si(
                  f,
                  n,
                  Lo,
                  !dc
                ), ou(f, 0) !== 0) break e;
                f.timeoutHandle = MS(
                  gr.bind(
                    null,
                    f,
                    s,
                    Is,
                    C2,
                    z3,
                    n,
                    Lo,
                    nd,
                    bp,
                    dc,
                    bP,
                    I6,
                    0
                  ),
                  p
                );
                break e;
              }
              gr(
                f,
                s,
                Is,
                C2,
                z3,
                n,
                Lo,
                nd,
                bp,
                dc,
                TS,
                I6,
                0
              );
            }
          }
        }
        break;
      } while (!0);
      xo(t);
    }
    function fs(t) {
      Is === null ? Is = t : Is.push.apply(
        Is,
        t
      );
    }
    function gr(t, n, s, f, p, m, E, I, F, z, de, Ee, pe) {
      var Se = n.subtreeFlags;
      if ((Se & 8192 || (Se & 16785408) === 16785408) && (R2 = { stylesheets: null, count: 0, unsuspend: Nb }, db(n), n = i6(), n !== null)) {
        t.cancelPendingCommit = n(
          Vr.bind(
            null,
            t,
            s,
            f,
            p,
            E,
            I,
            F,
            yP,
            Ee,
            pe
          )
        ), si(
          t,
          m,
          E,
          !z
        );
        return;
      }
      Vr(
        t,
        s,
        f,
        p,
        E,
        I,
        F,
        de,
        Ee,
        pe
      );
    }
    function Dm(t) {
      for (var n = t; ; ) {
        var s = n.tag;
        if ((s === 0 || s === 11 || s === 15) && n.flags & 16384 && (s = n.updateQueue, s !== null && (s = s.stores, s !== null)))
          for (var f = 0; f < s.length; f++) {
            var p = s[f], m = p.getSnapshot;
            p = p.value;
            try {
              if (!Pa(m(), p)) return !1;
            } catch {
              return !1;
            }
          }
        if (s = n.child, n.subtreeFlags & 16384 && s !== null)
          s.return = n, n = s;
        else {
          if (n === t) break;
          for (; n.sibling === null; ) {
            if (n.return === null || n.return === t) return !0;
            n = n.return;
          }
          n.sibling.return = n.return, n = n.sibling;
        }
      }
      return !0;
    }
    function si(t, n, s, f) {
      n &= ~J6, n &= ~nd, t.suspendedLanes |= n, t.pingedLanes &= ~n, f && (t.warmLanes |= n), f = t.expirationTimes;
      for (var p = n; 0 < p; ) {
        var m = 31 - Rr(p), E = 1 << m;
        f[m] = -1, p &= ~E;
      }
      s !== 0 && zi(t, s, n);
    }
    function va() {
      return (fn & (Da | cc)) === Oo ? (If(0), !1) : !0;
    }
    function Dh() {
      if (kt !== null) {
        if (en === no)
          var t = kt.return;
        else
          t = kt, kh(), Go(t), T0 = null, p2 = 0, t = kt;
        for (; t !== null; )
          oi(t.alternate, t), t = t.return;
        kt = null;
      }
    }
    function pl(t, n) {
      t.finishedWork = null, t.finishedLanes = 0;
      var s = t.timeoutHandle;
      s !== p8 && (t.timeoutHandle = p8, xP(s)), s = t.cancelPendingCommit, s !== null && (t.cancelPendingCommit = null, s()), Dh(), Xt = t, kt = s = ni(t.current, null), St = n, en = no, Ro = null, dc = !1, H0 = Gd(t, n), K6 = !1, Nn = fc, bp = Lo = J6 = nd = td = 0, Is = x2 = null, z3 = !1, n & 8 && (n |= n & 32);
      var f = t.entangledLanes;
      if (f !== 0)
        for (t = t.entanglements, f &= n; 0 < f; ) {
          var p = 31 - Rr(f), m = 1 << p;
          n |= t[p], f &= ~m;
        }
      return _l = n, Yg(), xs.discardPendingWarnings(), s;
    }
    function ds(t, n) {
      nt = null, me.H = Fl, me.getCurrentStack = null, Ta = !1, Pr = null, n === R3 ? (n = Uw(), en = S2) : n === I7 ? (n = Uw(), en = AS) : en = n === sS ? q6 : n !== null && typeof n == "object" && typeof n.then == "function" ? z0 : E2, Ro = n;
      var s = kt;
      if (s === null)
        Nn = k2, ot(
          t,
          ra(n, t.current)
        );
      else
        switch (s.mode & jr && x1(s), $s(), en) {
          case E2:
            Me !== null && typeof Me.markComponentErrored == "function" && Me.markComponentErrored(
              s,
              n,
              St
            );
            break;
          case yp:
          case S2:
          case z0:
          case A2:
            Me !== null && typeof Me.markComponentSuspended == "function" && Me.markComponentSuspended(
              s,
              n,
              St
            );
        }
    }
    function hs() {
      var t = me.H;
      return me.H = Fl, t === null ? Fl : t;
    }
    function xf() {
      var t = me.A;
      return me.A = dP, t;
    }
    function Bh() {
      Nn = mp, dc || (St & 4194176) !== St && Ei.current !== null || (H0 = !0), !(td & 134217727) && !(nd & 134217727) || Xt === null || si(
        Xt,
        St,
        Lo,
        !1
      );
    }
    function Mh(t, n, s) {
      var f = fn;
      fn |= Da;
      var p = hs(), m = xf();
      if (Xt !== t || St !== n) {
        if (Gr) {
          var E = t.memoizedUpdaters;
          0 < E.size && (nn(t, St), E.clear()), Sw(t, n);
        }
        C2 = null, pl(t, n);
      }
      mw(n), n = !1, E = Nn;
      e: do
        try {
          if (en !== no && kt !== null) {
            var I = kt, F = Ro;
            switch (en) {
              case q6:
                Dh(), E = U3;
                break e;
              case S2:
              case yp:
              case z0:
                Ei.current === null && (n = !0);
                var z = en;
                if (en = no, Ro = null, _u(t, I, F, z), s && H0) {
                  E = fc;
                  break e;
                }
                break;
              default:
                z = en, en = no, Ro = null, _u(t, I, F, z);
            }
          }
          Cf(), E = Nn;
          break;
        } catch (de) {
          ds(t, de);
        }
      while (!0);
      return n && t.shellSuspendCounter++, kh(), fn = f, me.H = p, me.A = m, yw(), kt === null && (Xt = null, St = 0, Yg()), E;
    }
    function Cf() {
      for (; kt !== null; ) yb(kt);
    }
    function Fh(t, n) {
      var s = fn;
      fn |= Da;
      var f = hs(), p = xf();
      if (Xt !== t || St !== n) {
        if (Gr) {
          var m = t.memoizedUpdaters;
          0 < m.size && (nn(t, St), m.clear()), Sw(t, n);
        }
        C2 = null, H3 = mi() + CS, pl(t, n);
      } else
        H0 = Gd(
          t,
          n
        );
      mw(n);
      e: do
        try {
          if (en !== no && kt !== null)
            t: switch (n = kt, m = Ro, en) {
              case E2:
                en = no, Ro = null, _u(
                  t,
                  n,
                  m,
                  E2
                );
                break;
              case yp:
                if (P1(m)) {
                  en = no, Ro = null, Tf(n);
                  break;
                }
                n = function() {
                  en === yp && Xt === t && (en = A2), xo(t);
                }, m.then(n, n);
                break e;
              case S2:
                en = A2;
                break e;
              case AS:
                en = Y6;
                break e;
              case A2:
                P1(m) ? (en = no, Ro = null, Tf(n)) : (en = no, Ro = null, _u(
                  t,
                  n,
                  m,
                  A2
                ));
                break;
              case Y6:
                var E = null;
                switch (kt.tag) {
                  case 26:
                    E = kt.memoizedState;
                  case 5:
                  case 27:
                    var I = kt;
                    if (!E || Km(E)) {
                      en = no, Ro = null;
                      var F = I.sibling;
                      if (F !== null) kt = F;
                      else {
                        var z = I.return;
                        z !== null ? (kt = z, _h(z)) : kt = null;
                      }
                      break t;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                en = no, Ro = null, _u(
                  t,
                  n,
                  m,
                  Y6
                );
                break;
              case z0:
                en = no, Ro = null, _u(
                  t,
                  n,
                  m,
                  z0
                );
                break;
              case q6:
                Dh(), Nn = U3;
                break e;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          me.actQueue !== null ? Cf() : Xw();
          break;
        } catch (de) {
          ds(t, de);
        }
      while (!0);
      return kh(), me.H = f, me.A = p, fn = s, kt !== null ? (Me !== null && typeof Me.markRenderYielded == "function" && Me.markRenderYielded(), fc) : (yw(), Xt = null, St = 0, Yg(), Nn);
    }
    function Xw() {
      for (; kt !== null && !c0(); )
        yb(kt);
    }
    function yb(t) {
      var n = t.alternate;
      (t.mode & jr) !== sn ? (bu(t), n = V(
        t,
        ym,
        n,
        t,
        _l
      ), x1(t)) : n = V(
        t,
        ym,
        n,
        t,
        _l
      ), t.memoizedProps = t.pendingProps, n === null ? _h(t) : kt = n;
    }
    function Tf(t) {
      var n = V(t, gl, t);
      t.memoizedProps = t.pendingProps, n === null ? _h(t) : kt = n;
    }
    function gl(t) {
      var n = t.alternate, s = (t.mode & jr) !== sn;
      switch (s && bu(t), t.tag) {
        case 15:
        case 0:
          n = $1(
            n,
            t,
            t.pendingProps,
            t.type,
            void 0,
            St
          );
          break;
        case 11:
          n = $1(
            n,
            t,
            t.pendingProps,
            t.type.render,
            t.ref,
            St
          );
          break;
        case 5:
          Go(t);
        default:
          oi(n, t), t = kt = Nm(t, _l), n = ym(n, t, _l);
      }
      return s && x1(t), n;
    }
    function _u(t, n, s, f) {
      kh(), Go(n), T0 = null, p2 = 0;
      var p = n.return;
      try {
        if (Pu(
          t,
          p,
          n,
          s,
          St
        )) {
          Nn = k2, ot(
            t,
            ra(s, t.current)
          ), kt = null;
          return;
        }
      } catch (m) {
        if (p !== null) throw kt = p, m;
        Nn = k2, ot(
          t,
          ra(s, t.current)
        ), kt = null;
        return;
      }
      n.flags & 32768 ? (It || f === E2 ? t = !0 : H0 || St & 536870912 ? t = !1 : (dc = t = !0, (f === yp || f === S2 || f === z0) && (f = Ei.current, f !== null && f.tag === 13 && (f.flags |= 16384))), ml(n, t)) : _h(n);
    }
    function _h(t) {
      var n = t;
      do {
        if (n.flags & 32768) {
          ml(
            n,
            dc
          );
          return;
        }
        var s = n.alternate;
        if (t = n.return, bu(n), s = V(
          n,
          mb,
          s,
          n,
          _l
        ), (n.mode & jr) !== sn && C1(n), s !== null) {
          kt = s;
          return;
        }
        if (n = n.sibling, n !== null) {
          kt = n;
          return;
        }
        kt = n = t;
      } while (n !== null);
      Nn === fc && (Nn = SS);
    }
    function ml(t, n) {
      do {
        var s = Fu(t.alternate, t);
        if (s !== null) {
          s.flags &= 32767, kt = s;
          return;
        }
        if ((t.mode & jr) !== sn) {
          C1(t), s = t.actualDuration;
          for (var f = t.child; f !== null; )
            s += f.actualDuration, f = f.sibling;
          t.actualDuration = s;
        }
        if (s = t.return, s !== null && (s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null), !n && (t = t.sibling, t !== null)) {
          kt = t;
          return;
        }
        kt = t = s;
      } while (t !== null);
      Nn = U3, kt = null;
    }
    function Vr(t, n, s, f, p, m, E, I, F, z) {
      var de = me.T, Ee = Qt.p;
      try {
        Qt.p = Ia, me.T = null, e3(
          t,
          n,
          s,
          f,
          Ee,
          p,
          m,
          E,
          I,
          F,
          z
        );
      } finally {
        me.T = de, Qt.p = Ee;
      }
    }
    function e3(t, n, s, f, p, m, E, I) {
      do
        ps();
      while (vp !== null);
      if (xs.flushLegacyContextWarning(), xs.flushPendingUnsafeLifecycleWarnings(), (fn & (Da | cc)) !== Oo)
        throw Error("Should not already be working.");
      var F = t.finishedWork;
      if (f = t.finishedLanes, Me !== null && typeof Me.markCommitStarted == "function" && Me.markCommitStarted(f), F === null) return Rg(), null;
      if (f === 0 && console.error(
        "root.finishedLanes should not be empty during a commit. This is a bug in React."
      ), t.finishedWork = null, t.finishedLanes = 0, F === t.current)
        throw Error(
          "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
        );
      t.callbackNode = null, t.callbackPriority = 0, t.cancelPendingCommit = null;
      var z = F.lanes | F.childLanes;
      if (z |= T6, Yk(
        t,
        f,
        z,
        m,
        E,
        I
      ), t === Xt && (kt = Xt = null, St = 0), !(F.subtreeFlags & 10256) && !(F.flags & 10256) || V3 || (V3 = !0, e8 = z, t8 = s, wa(zf, function() {
        return ps(), null;
      })), C3 = A0(), s = (F.flags & 15990) !== 0, F.subtreeFlags & 15990 || s ? (s = me.T, me.T = null, m = Qt.p, Qt.p = Ia, E = fn, fn |= cc, Cm(t, F), sb(
        t,
        F,
        f
      ), r6(d8, t.containerInfo), a4 = !!f8, d8 = f8 = null, t.current = F, Me !== null && typeof Me.markLayoutEffectsStarted == "function" && Me.markLayoutEffectsStarted(
        f
      ), Kw(F, t, f), Me !== null && typeof Me.markLayoutEffectsStopped == "function" && Me.markLayoutEffectsStopped(), ws(), fn = E, Qt.p = m, me.T = s) : t.current = F, (s = V3) ? (V3 = !1, vp = t, T2 = f) : (bb(t, z), wp = 0, N2 = null), z = t.pendingLanes, z === 0 && (rd = null), s || vb(t), Ga(F.stateNode, p), Gr && t.memoizedUpdaters.clear(), hl(), xo(t), n !== null)
        for (p = t.onRecoverableError, F = 0; F < n.length; F++)
          z = n[F], s = t3(z.stack), V(
            z.source,
            p,
            z.value,
            s
          );
      return T2 & 3 && ps(), z = t.pendingLanes, f & 4194218 && z & 42 ? (I3 = !0, t === n8 ? I2++ : (I2 = 0, n8 = t)) : I2 = 0, If(0), Rg(), null;
    }
    function t3(t) {
      return t = { componentStack: t }, Object.defineProperty(t, "digest", {
        get: function() {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      }), t;
    }
    function bb(t, n) {
      (t.pooledCacheLanes &= n) === 0 && (n = t.pooledCache, n != null && (t.pooledCache = null, ku(n)));
    }
    function ps() {
      if (vp !== null) {
        var t = vp, n = e8;
        e8 = 0;
        var s = Aw(T2), f = No > s ? No : s;
        s = me.T;
        var p = Qt.p;
        try {
          if (Qt.p = f, me.T = null, vp === null)
            var m = !1;
          else {
            f = t8, t8 = null;
            var E = vp, I = T2;
            if (vp = null, T2 = 0, (fn & (Da | cc)) !== Oo)
              throw Error(
                "Cannot flush passive effects while already rendering."
              );
            r8 = !0, W3 = !1, Me !== null && typeof Me.markPassiveEffectsStarted == "function" && Me.markPassiveEffectsStarted(I);
            var F = fn;
            if (fn |= cc, kf(E.current), fb(
              E,
              E.current,
              I,
              f
            ), Me !== null && typeof Me.markPassiveEffectsStopped == "function" && Me.markPassiveEffectsStopped(), vb(E), fn = F, If(0, !1), W3 ? E === N2 ? wp++ : (wp = 0, N2 = E) : wp = 0, W3 = r8 = !1, Or && typeof Or.onPostCommitFiberRoot == "function")
              try {
                Or.onPostCommitFiberRoot(Hf, E);
              } catch (de) {
                Wr || (Wr = !0, console.error(
                  "React instrumentation encountered an error: %s",
                  de
                ));
              }
            var z = E.current.stateNode;
            z.effectDuration = 0, z.passiveEffectDuration = 0, m = !0;
          }
          return m;
        } finally {
          Qt.p = p, me.T = s, bb(t, n);
        }
      }
      return !1;
    }
    function Bm(t, n, s) {
      n = ra(s, n), n = gn(t.stateNode, n, 2), t = is(t, n, 2), t !== null && (ur(t, 2), xo(t));
    }
    function Rt(t, n, s) {
      if (V0 = !1, t.tag === 3)
        Bm(t, t, s);
      else {
        for (; n !== null; ) {
          if (n.tag === 3) {
            Bm(
              n,
              t,
              s
            );
            return;
          }
          if (n.tag === 1) {
            var f = n.stateNode;
            if (typeof n.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (rd === null || !rd.has(f))) {
              t = ra(s, t), s = ff(2), f = is(n, s, 2), f !== null && (ll(
                s,
                f,
                n,
                t
              ), ur(f, 2), xo(f));
              return;
            }
          }
          n = n.return;
        }
        console.error(
          `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
          s
        );
      }
    }
    function Ao(t, n, s) {
      var f = t.pingCache;
      if (f === null) {
        f = t.pingCache = new pP();
        var p = /* @__PURE__ */ new Set();
        f.set(n, p);
      } else
        p = f.get(n), p === void 0 && (p = /* @__PURE__ */ new Set(), f.set(n, p));
      p.has(s) || (K6 = !0, p.add(s), f = yn.bind(null, t, n, s), Gr && nn(t, s), n.then(f, f));
    }
    function yn(t, n, s) {
      var f = t.pingCache;
      f !== null && f.delete(n), t.pingedLanes |= t.suspendedLanes & s, t.warmLanes &= ~s, ii() && me.actQueue === null && console.error(
        `A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`
      ), Xt === t && (St & s) === s && (Nn === mp || Nn === Z6 && (St & 62914560) === St && mi() - X6 < xS ? (fn & Da) === Oo && pl(t, 0) : J6 |= s, bp === St && (bp = 0)), xo(t);
    }
    function Mm(t, n) {
      n === 0 && (n = kw()), t = dr(t, n), t !== null && (ur(t, n), xo(t));
    }
    function n3(t) {
      var n = t.memoizedState, s = 0;
      n !== null && (s = n.retryLane), Mm(t, s);
    }
    function rr(t, n) {
      var s = 0;
      switch (t.tag) {
        case 13:
          var f = t.stateNode, p = t.memoizedState;
          p !== null && (s = p.retryLane);
          break;
        case 19:
          f = t.stateNode;
          break;
        case 22:
          f = t.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      f !== null && f.delete(n), Mm(t, s);
    }
    function Fm(t, n, s) {
      if (n.subtreeFlags & 33562624)
        for (n = n.child; n !== null; ) {
          var f = t, p = n, m = p.type === r0;
          m = s || m, p.tag !== 22 ? p.flags & 33554432 ? m && V(
            p,
            r3,
            f,
            p,
            (p.mode & C7) === sn
          ) : Fm(
            f,
            p,
            m
          ) : p.memoizedState === null && (m && p.flags & 8192 ? V(
            p,
            r3,
            f,
            p
          ) : p.subtreeFlags & 33554432 && V(
            p,
            Fm,
            f,
            p,
            m
          )), n = n.sibling;
        }
    }
    function r3(t, n) {
      var s = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : !0;
      jt(!0);
      try {
        ub(n), s && pb(n), cb(t, n.alternate, n, !1), s && nr(t, n, 0, null, !1);
      } finally {
        jt(!1);
      }
    }
    function vb(t) {
      var n = !0;
      t.current.mode & (fa | As) || (n = !1), Fm(
        t,
        t.current,
        n
      );
    }
    function wb(t) {
      if ((fn & Da) === Oo) {
        var n = t.tag;
        if (n === 3 || n === 1 || n === 0 || n === 11 || n === 14 || n === 15) {
          if (n = Z(t) || "ReactComponent", G3 !== null) {
            if (G3.has(n)) return;
            G3.add(n);
          } else G3 = /* @__PURE__ */ new Set([n]);
          V(t, function() {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function nn(t, n) {
      Gr && t.memoizedUpdaters.forEach(function(s) {
        Ew(t, s, n);
      });
    }
    function wa(t, n) {
      var s = me.actQueue;
      return s !== null ? (s.push(n), vP) : la(t, n);
    }
    function gs(t) {
      ii() && me.actQueue === null && V(t, function() {
        console.error(
          `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`,
          Z(t)
        );
      });
    }
    function xo(t) {
      t !== W0 && t.next === null && (W0 === null ? j3 = W0 = t : W0 = W0.next = t), $3 = !0, me.actQueue !== null ? o8 || (o8 = !0, Ea(a3)) : a8 || (a8 = !0, Ea(a3));
    }
    function If(t, n) {
      if (!i8 && $3) {
        i8 = !0;
        do
          for (var s = !1, f = j3; f !== null; ) {
            if (t !== 0) {
              var p = f.pendingLanes;
              if (p === 0) var m = 0;
              else {
                var E = f.suspendedLanes, I = f.pingedLanes;
                m = (1 << 31 - Rr(42 | t) + 1) - 1, m &= p & ~(E & ~I), m = m & 201326677 ? m & 201326677 | 1 : m ? m | 2 : 0;
              }
              m !== 0 && (s = !0, Ka(f, m));
            } else
              m = St, m = ou(
                f,
                f === Xt ? m : 0
              ), !(m & 3) || Gd(f, m) || (s = !0, Ka(f, m));
            f = f.next;
          }
        while (s);
        i8 = !1;
      }
    }
    function a3() {
      $3 = o8 = a8 = !1;
      var t = 0;
      kp !== 0 && (wt() && (t = kp), kp = 0);
      for (var n = mi(), s = null, f = j3; f !== null; ) {
        var p = f.next, m = _m(f, n);
        m === 0 ? (f.next = null, s === null ? j3 = p : s.next = p, p === null && (W0 = s)) : (s = f, (t !== 0 || m & 3) && ($3 = !0)), f = p;
      }
      If(t);
    }
    function _m(t, n) {
      for (var s = t.suspendedLanes, f = t.pingedLanes, p = t.expirationTimes, m = t.pendingLanes & -62914561; 0 < m; ) {
        var E = 31 - Rr(m), I = 1 << E, F = p[E];
        F === -1 ? (!(I & s) || I & f) && (p[E] = vw(I, n)) : F <= n && (t.expiredLanes |= I), m &= ~I;
      }
      if (n = Xt, s = St, s = ou(
        t,
        t === n ? s : 0
      ), f = t.callbackNode, s === 0 || t === n && en === yp || t.cancelPendingCommit !== null)
        return f !== null && Um(f), t.callbackNode = null, t.callbackPriority = 0;
      if (!(s & 3) || Gd(t, s)) {
        if (n = s & -s, n !== t.callbackPriority || me.actQueue !== null && f !== s8)
          Um(f);
        else return n;
        switch (Aw(s)) {
          case Ia:
          case Xa:
            s = f0;
            break;
          case No:
            s = zf;
            break;
          case ec:
            s = jb;
            break;
          default:
            s = zf;
        }
        return f = ka.bind(null, t), me.actQueue !== null ? (me.actQueue.push(f), s = s8) : s = la(s, f), t.callbackPriority = n, t.callbackNode = s, n;
      }
      return f !== null && Um(f), t.callbackPriority = 2, t.callbackNode = null, 2;
    }
    function ka(t, n) {
      I3 = T3 = !1;
      var s = t.callbackNode;
      if (ps() && t.callbackNode !== s)
        return null;
      var f = St;
      return f = ou(
        t,
        t === Xt ? f : 0
      ), f === 0 ? null : (Lh(
        t,
        f,
        n
      ), _m(t, mi()), t.callbackNode != null && t.callbackNode === s ? ka.bind(null, t) : null);
    }
    function Ka(t, n) {
      if (ps()) return null;
      T3 = I3, I3 = !1, Lh(t, n, !0);
    }
    function Um(t) {
      t !== s8 && t !== null && y3(t);
    }
    function Ea(t) {
      me.actQueue !== null && me.actQueue.push(function() {
        return t(), null;
      }), CP(function() {
        (fn & (Da | cc)) !== Oo ? la(Tl, t) : t();
      });
    }
    function zm() {
      return kp === 0 && (kp = ww()), kp;
    }
    function li(t) {
      return t == null || typeof t == "symbol" || typeof t == "boolean" ? null : typeof t == "function" ? t : (_e(t, "action"), Wo("" + t));
    }
    function Uu(t, n) {
      var s = n.ownerDocument.createElement("input");
      return s.name = n.name, s.value = n.value, t.id && s.setAttribute("form", t.id), n.parentNode.insertBefore(s, n), t = new FormData(t), s.parentNode.removeChild(s), t;
    }
    function yl(t, n, s, f, p) {
      if (n === "submit" && s && s.stateNode === p) {
        var m = li(
          (p[ua] || null).action
        ), E = f.submitter;
        E && (n = (n = E[ua] || null) ? li(n.formAction) : E.getAttribute("formAction"), n !== null && (m = n, E = null));
        var I = new re(
          "action",
          "action",
          null,
          f,
          p
        );
        t.push({
          event: I,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (f.defaultPrevented) {
                  if (kp !== 0) {
                    var F = E ? Uu(
                      p,
                      E
                    ) : new FormData(p), z = {
                      pending: !0,
                      data: F,
                      method: p.method,
                      action: m
                    };
                    Object.freeze(z), Jo(
                      s,
                      z,
                      null,
                      F
                    );
                  }
                } else
                  typeof m == "function" && (I.preventDefault(), F = E ? Uu(
                    p,
                    E
                  ) : new FormData(p), z = {
                    pending: !0,
                    data: F,
                    method: p.method,
                    action: m
                  }, Object.freeze(z), Jo(
                    s,
                    z,
                    m,
                    F
                  ));
              },
              currentTarget: p
            }
          ]
        });
      }
    }
    function Hm(t, n) {
      n = (n & 4) !== 0;
      for (var s = 0; s < t.length; s++) {
        var f = t[s];
        e: {
          var p = void 0, m = f.event;
          if (f = f.listeners, n)
            for (var E = f.length - 1; 0 <= E; E--) {
              var I = f[E], F = I.instance, z = I.currentTarget;
              if (I = I.listener, F !== p && m.isPropagationStopped())
                break e;
              p = m, p.currentTarget = z;
              try {
                I(p);
              } catch (de) {
                F3(de);
              }
              p.currentTarget = null, p = F;
            }
          else
            for (E = 0; E < f.length; E++) {
              if (I = f[E], F = I.instance, z = I.currentTarget, I = I.listener, F !== p && m.isPropagationStopped())
                break e;
              p = m, p.currentTarget = z;
              try {
                I(p);
              } catch (de) {
                F3(de);
              }
              p.currentTarget = null, p = F;
            }
        }
      }
    }
    function vt(t, n) {
      l8.has(t) || console.error(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        t
      );
      var s = n[tc];
      s === void 0 && (s = n[tc] = /* @__PURE__ */ new Set());
      var f = t + "__bubble";
      s.has(f) || (zu(n, t, 2, !1), s.add(f));
    }
    function ui(t, n, s) {
      l8.has(t) && !n && console.error(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        t
      );
      var f = 0;
      n && (f |= 4), zu(
        s,
        t,
        f,
        n
      );
    }
    function Vm(t) {
      if (!t[Q3]) {
        t[Q3] = !0, np.forEach(function(s) {
          s !== "selectionchange" && (l8.has(s) || ui(s, !1, t), ui(s, !0, t));
        });
        var n = t.nodeType === 9 ? t : t.ownerDocument;
        n === null || n[Q3] || (n[Q3] = !0, ui("selectionchange", !1, n));
      }
    }
    function zu(t, n, s, f) {
      switch (Ku(n)) {
        case Ia:
          var p = h3;
          break;
        case Xa:
          p = l6;
          break;
        default:
          p = Db;
      }
      s = p.bind(
        null,
        n,
        s,
        t
      ), p = void 0, !ge || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (p = !0), f ? p !== void 0 ? t.addEventListener(n, s, {
        capture: !0,
        passive: p
      }) : t.addEventListener(n, s, !0) : p !== void 0 ? t.addEventListener(n, s, {
        passive: p
      }) : t.addEventListener(
        n,
        s,
        !1
      );
    }
    function Hu(t, n, s, f, p) {
      var m = f;
      if (!(n & 1) && !(n & 2) && f !== null)
        e: for (; ; ) {
          if (f === null) return;
          var E = f.tag;
          if (E === 3 || E === 4) {
            var I = f.stateNode.containerInfo;
            if (I === p || I.nodeType === 8 && I.parentNode === p)
              break;
            if (E === 4)
              for (E = f.return; E !== null; ) {
                var F = E.tag;
                if ((F === 3 || F === 4) && (F = E.stateNode.containerInfo, F === p || F.nodeType === 8 && F.parentNode === p))
                  return;
                E = E.return;
              }
            for (; I !== null; ) {
              if (E = zo(I), E === null) return;
              if (F = E.tag, F === 5 || F === 6 || F === 26 || F === 27) {
                f = m = E;
                continue e;
              }
              I = I.parentNode;
            }
          }
          f = f.return;
        }
      Wg(function() {
        var z = m, de = qs(s), Ee = [];
        e: {
          var pe = A7.get(t);
          if (pe !== void 0) {
            var Se = re, Ze = t;
            switch (t) {
              case "keypress":
                if (Yc(s) === 0) break e;
              case "keydown":
              case "keyup":
                Se = zN;
                break;
              case "focusin":
                Ze = "focus", Se = E6;
                break;
              case "focusout":
                Ze = "blur", Se = E6;
                break;
              case "beforeblur":
              case "afterblur":
                Se = E6;
                break;
              case "click":
                if (s.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                Se = Wn;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                Se = Bl;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                Se = WN;
                break;
              case w7:
              case k7:
              case E7:
                Se = ON;
                break;
              case S7:
                Se = jN;
                break;
              case "scroll":
              case "scrollend":
                Se = Ae;
                break;
              case "wheel":
                Se = QN;
                break;
              case "copy":
              case "cut":
              case "paste":
                Se = LN;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                Se = d7;
                break;
              case "toggle":
              case "beforetoggle":
                Se = YN;
            }
            var ct = (n & 4) !== 0, Gn = !ct && (t === "scroll" || t === "scrollend"), _t = ct ? pe !== null ? pe + "Capture" : null : pe;
            ct = [];
            for (var K = z, q; K !== null; ) {
              var te = K;
              if (q = te.stateNode, te = te.tag, te !== 5 && te !== 26 && te !== 27 || q === null || _t === null || (te = Qc(K, _t), te != null && ct.push(
                ms(
                  K,
                  te,
                  q
                )
              )), Gn) break;
              K = K.return;
            }
            0 < ct.length && (pe = new Se(
              pe,
              Ze,
              null,
              s,
              de
            ), Ee.push({
              event: pe,
              listeners: ct
            }));
          }
        }
        if (!(n & 7)) {
          e: {
            if (pe = t === "mouseover" || t === "pointerover", Se = t === "mouseout" || t === "pointerout", pe && s !== $ && (Ze = s.relatedTarget || s.fromElement) && (zo(Ze) || Ze[Nl]))
              break e;
            if ((Se || pe) && (pe = de.window === de ? de : (pe = de.ownerDocument) ? pe.defaultView || pe.parentWindow : window, Se ? (Ze = s.relatedTarget || s.toElement, Se = z, Ze = Ze ? zo(Ze) : null, Ze !== null && (Gn = B(Ze), ct = Ze.tag, Ze !== Gn || ct !== 5 && ct !== 27 && ct !== 6) && (Ze = null)) : (Se = null, Ze = z), Se !== Ze)) {
              if (ct = Wn, te = "onMouseLeave", _t = "onMouseEnter", K = "mouse", (t === "pointerout" || t === "pointerover") && (ct = d7, te = "onPointerLeave", _t = "onPointerEnter", K = "pointer"), Gn = Se == null ? pe : $d(Se), q = Ze == null ? pe : $d(Ze), pe = new ct(
                te,
                K + "leave",
                Se,
                s,
                de
              ), pe.target = Gn, pe.relatedTarget = q, te = null, zo(de) === z && (ct = new ct(
                _t,
                K + "enter",
                Ze,
                s,
                de
              ), ct.target = q, ct.relatedTarget = Gn, te = ct), Gn = te, Se && Ze)
                t: {
                  for (ct = Se, _t = Ze, K = 0, q = ct; q; q = Vu(q))
                    K++;
                  for (q = 0, te = _t; te; te = Vu(te))
                    q++;
                  for (; 0 < K - q; )
                    ct = Vu(ct), K--;
                  for (; 0 < q - K; )
                    _t = Vu(_t), q--;
                  for (; K--; ) {
                    if (ct === _t || _t !== null && ct === _t.alternate)
                      break t;
                    ct = Vu(ct), _t = Vu(_t);
                  }
                  ct = null;
                }
              else ct = null;
              Se !== null && kb(
                Ee,
                pe,
                Se,
                ct,
                !1
              ), Ze !== null && Gn !== null && kb(
                Ee,
                Gn,
                Ze,
                ct,
                !0
              );
            }
          }
          e: {
            if (pe = z ? $d(z) : window, Se = pe.nodeName && pe.nodeName.toLowerCase(), Se === "select" || Se === "input" && pe.type === "file")
              var we = Qg;
            else if (Js(pe))
              if (b7)
                we = n6;
              else {
                we = e6;
                var De = Tw;
              }
            else
              Se = pe.nodeName, !Se || Se.toLowerCase() !== "input" || pe.type !== "checkbox" && pe.type !== "radio" ? z && hu(z.elementType) && (we = Qg) : we = t6;
            if (we && (we = we(t, z))) {
              qc(
                Ee,
                we,
                s,
                de
              );
              break e;
            }
            De && De(t, pe, z), t === "focusout" && z && pe.type === "number" && z.memoizedProps.value != null && ji(pe, "number", pe.value);
          }
          switch (De = z ? $d(z) : window, t) {
            case "focusin":
              (Js(De) || De.contentEditable === "true") && (w0 = De, A6 = z, o2 = null);
              break;
            case "focusout":
              o2 = A6 = w0 = null;
              break;
            case "mousedown":
              x6 = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              x6 = !1, Rw(
                Ee,
                s,
                de
              );
              break;
            case "selectionchange":
              if (XN) break;
            case "keydown":
            case "keyup":
              Rw(
                Ee,
                s,
                de
              );
          }
          var it;
          if (S6)
            e: {
              switch (t) {
                case "compositionstart":
                  var je = "onCompositionStart";
                  break e;
                case "compositionend":
                  je = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  je = "onCompositionUpdate";
                  break e;
              }
              je = void 0;
            }
          else
            v0 ? Kd(t, s) && (je = "onCompositionEnd") : t === "keydown" && s.keyCode === h7 && (je = "onCompositionStart");
          je && (p7 && s.locale !== "ko" && (v0 || je !== "onCompositionStart" ? je === "onCompositionEnd" && v0 && (it = Zc()) : (Ue = de, et = "value" in Ue ? Ue.value : Ue.textContent, v0 = !0)), De = ys(
            z,
            je
          ), 0 < De.length && (je = new f7(
            je,
            t,
            null,
            s,
            de
          ), Ee.push({
            event: je,
            listeners: De
          }), it ? je.data = it : (it = Jd(s), it !== null && (je.data = it)))), (it = KN ? Cw(t, s) : na(t, s)) && (je = ys(
            z,
            "onBeforeInput"
          ), 0 < je.length && (De = new BN(
            "onBeforeInput",
            "beforeinput",
            null,
            s,
            de
          ), Ee.push({
            event: De,
            listeners: je
          }), De.data = it)), yl(
            Ee,
            t,
            z,
            s,
            de
          );
        }
        Hm(Ee, n);
      });
    }
    function ms(t, n, s) {
      return {
        instance: t,
        listener: n,
        currentTarget: s
      };
    }
    function ys(t, n) {
      for (var s = n + "Capture", f = []; t !== null; ) {
        var p = t, m = p.stateNode;
        p = p.tag, p !== 5 && p !== 26 && p !== 27 || m === null || (p = Qc(t, s), p != null && f.unshift(
          ms(t, p, m)
        ), p = Qc(t, n), p != null && f.push(
          ms(t, p, m)
        )), t = t.return;
      }
      return f;
    }
    function Vu(t) {
      if (t === null) return null;
      do
        t = t.return;
      while (t && t.tag !== 5 && t.tag !== 27);
      return t || null;
    }
    function kb(t, n, s, f, p) {
      for (var m = n._reactName, E = []; s !== null && s !== f; ) {
        var I = s, F = I.alternate, z = I.stateNode;
        if (I = I.tag, F !== null && F === f) break;
        I !== 5 && I !== 26 && I !== 27 || z === null || (F = z, p ? (z = Qc(s, m), z != null && E.unshift(
          ms(s, z, F)
        )) : p || (z = Qc(s, m), z != null && E.push(
          ms(s, z, F)
        ))), s = s.return;
      }
      E.length !== 0 && t.push({ event: n, listeners: E });
    }
    function Wu(t, n) {
      Vg(t, n), t !== "input" && t !== "textarea" && t !== "select" || n == null || n.value !== null || l || (l = !0, t === "select" && n.multiple ? console.error(
        "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
        t
      ) : console.error(
        "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
        t
      ));
      var s = {
        registrationNameDependencies: Es,
        possibleRegistrationNames: $b
      };
      hu(t) || typeof n.is == "string" || v1(t, n, s), n.contentEditable && !n.suppressContentEditableWarning && n.children != null && console.error(
        "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
      );
    }
    function zn(t, n, s, f) {
      n !== s && (s = Hn(s), Hn(n) !== s && (f[t] = n));
    }
    function Wm(t, n, s) {
      n.forEach(function(f) {
        s[jm(f)] = f === "style" ? Uh(t) : t.getAttribute(f);
      });
    }
    function Co(t, n) {
      n === !1 ? console.error(
        "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
        t,
        t,
        t
      ) : console.error(
        "Expected `%s` listener to be a function, instead got a value of `%s` type.",
        t,
        typeof n
      );
    }
    function o3(t, n) {
      return t = t.namespaceURI === Dl || t.namespaceURI === Na ? t.ownerDocument.createElementNS(
        t.namespaceURI,
        t.tagName
      ) : t.ownerDocument.createElement(t.tagName), t.innerHTML = n, t.innerHTML;
    }
    function Hn(t) {
      return Ve(t) && (console.error(
        "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
        Ye(t)
      ), Je(t)), (typeof t == "string" ? t : "" + t).replace(wP, `
`).replace(kP, "");
    }
    function Gm(t, n) {
      return n = Hn(n), Hn(t) === n;
    }
    function To() {
    }
    function Mt(t, n, s, f, p, m) {
      switch (s) {
        case "children":
          typeof f == "string" ? (qd(f, n), n === "body" || n === "textarea" && f === "" || Vo(t, f)) : (typeof f == "number" || typeof f == "bigint") && (qd("" + f, n), n !== "body" && Vo(t, "" + f));
          break;
        case "className":
          Zd(t, "class", f);
          break;
        case "tabIndex":
          Zd(t, "tabindex", f);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          Zd(t, s, f);
          break;
        case "style":
          y1(t, f, m);
          break;
        case "data":
          if (n !== "object") {
            Zd(t, "data", f);
            break;
          }
        case "src":
        case "href":
          if (f === "" && (n !== "a" || s !== "href")) {
            console.error(
              s === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
              s,
              s
            ), t.removeAttribute(s);
            break;
          }
          if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
            t.removeAttribute(s);
            break;
          }
          _e(f, s), f = Wo("" + f), t.setAttribute(s, f);
          break;
        case "action":
        case "formAction":
          if (f != null && (n === "form" ? s === "formAction" ? console.error(
            "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
          ) : typeof f == "function" && (p.encType == null && p.method == null || q3 || (q3 = !0, console.error(
            "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
          )), p.target == null || Y3 || (Y3 = !0, console.error(
            "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
          ))) : n === "input" || n === "button" ? s === "action" ? console.error(
            "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
          ) : n !== "input" || p.type === "submit" || p.type === "image" || Z3 ? n !== "button" || p.type == null || p.type === "submit" || Z3 ? typeof f == "function" && (p.name == null || RS || (RS = !0, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          )), p.formEncType == null && p.formMethod == null || q3 || (q3 = !0, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          )), p.formTarget == null || Y3 || (Y3 = !0, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ))) : (Z3 = !0, console.error(
            'A button can only specify a formAction along with type="submit" or no type.'
          )) : (Z3 = !0, console.error(
            'An input can only specify a formAction along with type="submit" or type="image".'
          )) : console.error(
            s === "action" ? "You can only pass the action prop to <form>." : "You can only pass the formAction prop to <input> or <button>."
          )), typeof f == "function") {
            t.setAttribute(
              s,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof m == "function" && (s === "formAction" ? (n !== "input" && Mt(t, n, "name", p.name, p, null), Mt(
              t,
              n,
              "formEncType",
              p.formEncType,
              p,
              null
            ), Mt(
              t,
              n,
              "formMethod",
              p.formMethod,
              p,
              null
            ), Mt(
              t,
              n,
              "formTarget",
              p.formTarget,
              p,
              null
            )) : (Mt(
              t,
              n,
              "encType",
              p.encType,
              p,
              null
            ), Mt(t, n, "method", p.method, p, null), Mt(
              t,
              n,
              "target",
              p.target,
              p,
              null
            )));
          if (f == null || typeof f == "symbol" || typeof f == "boolean") {
            t.removeAttribute(s);
            break;
          }
          _e(f, s), f = Wo("" + f), t.setAttribute(s, f);
          break;
        case "onClick":
          f != null && (typeof f != "function" && Co(s, f), t.onclick = To);
          break;
        case "onScroll":
          f != null && (typeof f != "function" && Co(s, f), vt("scroll", t));
          break;
        case "onScrollEnd":
          f != null && (typeof f != "function" && Co(s, f), vt("scrollend", t));
          break;
        case "dangerouslySetInnerHTML":
          if (f != null) {
            if (typeof f != "object" || !("__html" in f))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (s = f.__html, s != null) {
              if (p.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              t.innerHTML = s;
            }
          }
          break;
        case "multiple":
          t.multiple = f && typeof f != "function" && typeof f != "symbol";
          break;
        case "muted":
          t.muted = f && typeof f != "function" && typeof f != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
            t.removeAttribute("xlink:href");
            break;
          }
          _e(f, s), s = Wo("" + f), t.setAttributeNS(Ep, "xlink:href", s);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          f != null && typeof f != "function" && typeof f != "symbol" ? (_e(f, s), t.setAttribute(s, "" + f)) : t.removeAttribute(s);
          break;
        case "inert":
          f !== "" || K3[s] || (K3[s] = !0, console.error(
            "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
            s
          ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          f && typeof f != "function" && typeof f != "symbol" ? t.setAttribute(s, "") : t.removeAttribute(s);
          break;
        case "capture":
        case "download":
          f === !0 ? t.setAttribute(s, "") : f !== !1 && f != null && typeof f != "function" && typeof f != "symbol" ? (_e(f, s), t.setAttribute(s, f)) : t.removeAttribute(s);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? (_e(f, s), t.setAttribute(s, f)) : t.removeAttribute(s);
          break;
        case "rowSpan":
        case "start":
          f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? t.removeAttribute(s) : (_e(f, s), t.setAttribute(s, f));
          break;
        case "popover":
          vt("beforetoggle", t), vt("toggle", t), Qd(t, "popover", f);
          break;
        case "xlinkActuate":
          Wi(
            t,
            Ep,
            "xlink:actuate",
            f
          );
          break;
        case "xlinkArcrole":
          Wi(
            t,
            Ep,
            "xlink:arcrole",
            f
          );
          break;
        case "xlinkRole":
          Wi(
            t,
            Ep,
            "xlink:role",
            f
          );
          break;
        case "xlinkShow":
          Wi(
            t,
            Ep,
            "xlink:show",
            f
          );
          break;
        case "xlinkTitle":
          Wi(
            t,
            Ep,
            "xlink:title",
            f
          );
          break;
        case "xlinkType":
          Wi(
            t,
            Ep,
            "xlink:type",
            f
          );
          break;
        case "xmlBase":
          Wi(
            t,
            u8,
            "xml:base",
            f
          );
          break;
        case "xmlLang":
          Wi(
            t,
            u8,
            "xml:lang",
            f
          );
          break;
        case "xmlSpace":
          Wi(
            t,
            u8,
            "xml:space",
            f
          );
          break;
        case "is":
          m != null && console.error(
            'Cannot update the "is" prop after it has been initialized.'
          ), Qd(t, "is", f);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          LS || f == null || typeof f != "object" || (LS = !0, console.error(
            "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
            f
          ));
        default:
          !(2 < s.length) || s[0] !== "o" && s[0] !== "O" || s[1] !== "n" && s[1] !== "N" ? (s = xw(s), Qd(t, s, f)) : Es.hasOwnProperty(s) && f != null && typeof f != "function" && Co(s, f);
      }
    }
    function Nf(t, n, s, f, p, m) {
      switch (s) {
        case "style":
          y1(t, f, m);
          break;
        case "dangerouslySetInnerHTML":
          if (f != null) {
            if (typeof f != "object" || !("__html" in f))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (s = f.__html, s != null) {
              if (p.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              t.innerHTML = s;
            }
          }
          break;
        case "children":
          typeof f == "string" ? Vo(t, f) : (typeof f == "number" || typeof f == "bigint") && Vo(t, "" + f);
          break;
        case "onScroll":
          f != null && (typeof f != "function" && Co(s, f), vt("scroll", t));
          break;
        case "onScrollEnd":
          f != null && (typeof f != "function" && Co(s, f), vt("scrollend", t));
          break;
        case "onClick":
          f != null && (typeof f != "function" && Co(s, f), t.onclick = To);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (Es.hasOwnProperty(s))
            f != null && typeof f != "function" && Co(s, f);
          else
            e: {
              if (s[0] === "o" && s[1] === "n" && (p = s.endsWith("Capture"), n = s.slice(2, p ? s.length - 7 : void 0), m = t[ua] || null, m = m != null ? m[s] : null, typeof m == "function" && t.removeEventListener(n, m, p), typeof f == "function")) {
                typeof m != "function" && m !== null && (s in t ? t[s] = null : t.hasAttribute(s) && t.removeAttribute(s)), t.addEventListener(n, f, p);
                break e;
              }
              s in t ? t[s] = f : f === !0 ? t.setAttribute(s, "") : Qd(t, s, f);
            }
      }
    }
    function cn(t, n, s) {
      switch (Wu(n, s), n) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          vt("error", t), vt("load", t);
          var f = !1, p = !1, m;
          for (m in s)
            if (s.hasOwnProperty(m)) {
              var E = s[m];
              if (E != null)
                switch (m) {
                  case "src":
                    f = !0;
                    break;
                  case "srcSet":
                    p = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    Mt(t, n, m, E, s, null);
                }
            }
          p && Mt(t, n, "srcSet", s.srcSet, s, null), f && Mt(t, n, "src", s.src, s, null);
          return;
        case "input":
          Vc("input", s), vt("invalid", t);
          var I = m = E = p = null, F = null, z = null;
          for (f in s)
            if (s.hasOwnProperty(f)) {
              var de = s[f];
              if (de != null)
                switch (f) {
                  case "name":
                    p = de;
                    break;
                  case "type":
                    E = de;
                    break;
                  case "checked":
                    F = de;
                    break;
                  case "defaultChecked":
                    z = de;
                    break;
                  case "value":
                    m = de;
                    break;
                  case "defaultValue":
                    I = de;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (de != null)
                      throw Error(
                        n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    Mt(t, n, f, de, s, null);
                }
            }
          l1(t, s), Fg(
            t,
            m,
            I,
            F,
            z,
            E,
            p,
            !1
          ), Gi(t);
          return;
        case "select":
          Vc("select", s), vt("invalid", t), f = E = m = null;
          for (p in s)
            if (s.hasOwnProperty(p) && (I = s[p], I != null))
              switch (p) {
                case "value":
                  m = I;
                  break;
                case "defaultValue":
                  E = I;
                  break;
                case "multiple":
                  f = I;
                default:
                  Mt(
                    t,
                    n,
                    p,
                    I,
                    s,
                    null
                  );
              }
          Mn(t, s), n = m, s = E, t.multiple = !!f, n != null ? po(t, !!f, n, !1) : s != null && po(t, !!f, s, !0);
          return;
        case "textarea":
          Vc("textarea", s), vt("invalid", t), m = p = f = null;
          for (E in s)
            if (s.hasOwnProperty(E) && (I = s[E], I != null))
              switch (E) {
                case "value":
                  f = I;
                  break;
                case "defaultValue":
                  p = I;
                  break;
                case "children":
                  m = I;
                  break;
                case "dangerouslySetInnerHTML":
                  if (I != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  Mt(
                    t,
                    n,
                    E,
                    I,
                    s,
                    null
                  );
              }
          u1(t, s), Zs(t, f, p, m), Gi(t);
          return;
        case "option":
          uu(t, s);
          for (F in s)
            if (s.hasOwnProperty(F) && (f = s[F], f != null))
              switch (F) {
                case "selected":
                  t.selected = f && typeof f != "function" && typeof f != "symbol";
                  break;
                default:
                  Mt(t, n, F, f, s, null);
              }
          return;
        case "dialog":
          vt("cancel", t), vt("close", t);
          break;
        case "iframe":
        case "object":
          vt("load", t);
          break;
        case "video":
        case "audio":
          for (f = 0; f < P2.length; f++)
            vt(P2[f], t);
          break;
        case "image":
          vt("error", t), vt("load", t);
          break;
        case "details":
          vt("toggle", t);
          break;
        case "embed":
        case "source":
        case "link":
          vt("error", t), vt("load", t);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (z in s)
            if (s.hasOwnProperty(z) && (f = s[z], f != null))
              switch (z) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  Mt(t, n, z, f, s, null);
              }
          return;
        default:
          if (hu(n)) {
            for (de in s)
              s.hasOwnProperty(de) && (f = s[de], f !== void 0 && Nf(
                t,
                n,
                de,
                f,
                s,
                void 0
              ));
            return;
          }
      }
      for (I in s)
        s.hasOwnProperty(I) && (f = s[I], f != null && Mt(t, n, I, f, s, null));
    }
    function i3(t, n, s, f) {
      switch (Wu(n, f), n) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var p = null, m = null, E = null, I = null, F = null, z = null, de = null;
          for (Se in s) {
            var Ee = s[Se];
            if (s.hasOwnProperty(Se) && Ee != null)
              switch (Se) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  F = Ee;
                default:
                  f.hasOwnProperty(Se) || Mt(
                    t,
                    n,
                    Se,
                    null,
                    f,
                    Ee
                  );
              }
          }
          for (var pe in f) {
            var Se = f[pe];
            if (Ee = s[pe], f.hasOwnProperty(pe) && (Se != null || Ee != null))
              switch (pe) {
                case "type":
                  m = Se;
                  break;
                case "name":
                  p = Se;
                  break;
                case "checked":
                  z = Se;
                  break;
                case "defaultChecked":
                  de = Se;
                  break;
                case "value":
                  E = Se;
                  break;
                case "defaultValue":
                  I = Se;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Se != null)
                    throw Error(
                      n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  Se !== Ee && Mt(
                    t,
                    n,
                    pe,
                    Se,
                    f,
                    Ee
                  );
              }
          }
          n = s.type === "checkbox" || s.type === "radio" ? s.checked != null : s.value != null, f = f.type === "checkbox" || f.type === "radio" ? f.checked != null : f.value != null, n || !f || OS || (console.error(
            "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), OS = !0), !n || f || PS || (console.error(
            "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), PS = !0), lu(
            t,
            E,
            I,
            F,
            z,
            de,
            m,
            p
          );
          return;
        case "select":
          Se = E = I = pe = null;
          for (m in s)
            if (F = s[m], s.hasOwnProperty(m) && F != null)
              switch (m) {
                case "value":
                  break;
                case "multiple":
                  Se = F;
                default:
                  f.hasOwnProperty(m) || Mt(
                    t,
                    n,
                    m,
                    null,
                    f,
                    F
                  );
              }
          for (p in f)
            if (m = f[p], F = s[p], f.hasOwnProperty(p) && (m != null || F != null))
              switch (p) {
                case "value":
                  pe = m;
                  break;
                case "defaultValue":
                  I = m;
                  break;
                case "multiple":
                  E = m;
                default:
                  m !== F && Mt(
                    t,
                    n,
                    p,
                    m,
                    f,
                    F
                  );
              }
          f = I, n = E, s = Se, pe != null ? po(t, !!n, pe, !1) : !!s != !!n && (f != null ? po(t, !!n, f, !0) : po(t, !!n, n ? [] : "", !1));
          return;
        case "textarea":
          Se = pe = null;
          for (I in s)
            if (p = s[I], s.hasOwnProperty(I) && p != null && !f.hasOwnProperty(I))
              switch (I) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  Mt(t, n, I, null, f, p);
              }
          for (E in f)
            if (p = f[E], m = s[E], f.hasOwnProperty(E) && (p != null || m != null))
              switch (E) {
                case "value":
                  pe = p;
                  break;
                case "defaultValue":
                  Se = p;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (p != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  p !== m && Mt(t, n, E, p, f, m);
              }
          c1(t, pe, Se);
          return;
        case "option":
          for (var Ze in s)
            if (pe = s[Ze], s.hasOwnProperty(Ze) && pe != null && !f.hasOwnProperty(Ze))
              switch (Ze) {
                case "selected":
                  t.selected = !1;
                  break;
                default:
                  Mt(
                    t,
                    n,
                    Ze,
                    null,
                    f,
                    pe
                  );
              }
          for (F in f)
            if (pe = f[F], Se = s[F], f.hasOwnProperty(F) && pe !== Se && (pe != null || Se != null))
              switch (F) {
                case "selected":
                  t.selected = pe && typeof pe != "function" && typeof pe != "symbol";
                  break;
                default:
                  Mt(
                    t,
                    n,
                    F,
                    pe,
                    f,
                    Se
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var ct in s)
            pe = s[ct], s.hasOwnProperty(ct) && pe != null && !f.hasOwnProperty(ct) && Mt(
              t,
              n,
              ct,
              null,
              f,
              pe
            );
          for (z in f)
            if (pe = f[z], Se = s[z], f.hasOwnProperty(z) && pe !== Se && (pe != null || Se != null))
              switch (z) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (pe != null)
                    throw Error(
                      n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  Mt(
                    t,
                    n,
                    z,
                    pe,
                    f,
                    Se
                  );
              }
          return;
        default:
          if (hu(n)) {
            for (var Gn in s)
              pe = s[Gn], s.hasOwnProperty(Gn) && pe !== void 0 && !f.hasOwnProperty(Gn) && Nf(
                t,
                n,
                Gn,
                void 0,
                f,
                pe
              );
            for (de in f)
              pe = f[de], Se = s[de], !f.hasOwnProperty(de) || pe === Se || pe === void 0 && Se === void 0 || Nf(
                t,
                n,
                de,
                pe,
                f,
                Se
              );
            return;
          }
      }
      for (var _t in s)
        pe = s[_t], s.hasOwnProperty(_t) && pe != null && !f.hasOwnProperty(_t) && Mt(t, n, _t, null, f, pe);
      for (Ee in f)
        pe = f[Ee], Se = s[Ee], !f.hasOwnProperty(Ee) || pe === Se || pe == null && Se == null || Mt(t, n, Ee, pe, f, Se);
    }
    function jm(t) {
      switch (t) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return t;
      }
    }
    function Uh(t) {
      var n = {};
      t = t.style;
      for (var s = 0; s < t.length; s++) {
        var f = t[s];
        n[f] = t.getPropertyValue(f);
      }
      return n;
    }
    function ci(t, n, s) {
      if (n != null && typeof n != "object")
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else {
        var f, p = f = "", m;
        for (m in n)
          if (n.hasOwnProperty(m)) {
            var E = n[m];
            E != null && typeof E != "boolean" && E !== "" && (m.indexOf("--") === 0 ? (rt(E, m), f += p + m + ":" + ("" + E).trim()) : typeof E != "number" || E === 0 || $f.has(m) ? (rt(E, m), f += p + m.replace(Kb, "-$1").toLowerCase().replace(Wf, "-ms-") + ":" + ("" + E).trim()) : f += p + m.replace(Kb, "-$1").toLowerCase().replace(Wf, "-ms-") + ":" + E + "px", p = ";");
          }
        f = f || null, n = t.getAttribute("style"), n !== f && (f = Hn(f), Hn(n) !== f && (s.style = Uh(t)));
      }
    }
    function Sa(t, n, s, f, p, m) {
      if (p.delete(s), t = t.getAttribute(s), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (_e(f, n), t === "" + f)
              return;
        }
      zn(n, t, f, m);
    }
    function zh(t, n, s, f, p, m) {
      if (p.delete(s), t = t.getAttribute(s), t === null) {
        switch (typeof f) {
          case "function":
          case "symbol":
            return;
        }
        if (!f) return;
      } else
        switch (typeof f) {
          case "function":
          case "symbol":
            break;
          default:
            if (f) return;
        }
      zn(n, t, f, m);
    }
    function Gu(t, n, s, f, p, m) {
      if (p.delete(s), t = t.getAttribute(s), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
            break;
          default:
            if (_e(f, s), t === "" + f)
              return;
        }
      zn(n, t, f, m);
    }
    function rn(t, n, s, f, p, m) {
      if (p.delete(s), t = t.getAttribute(s), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(f)) return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (!isNaN(f) && (_e(f, n), t === "" + f))
              return;
        }
      zn(n, t, f, m);
    }
    function $m(t, n, s, f, p, m) {
      if (p.delete(s), t = t.getAttribute(s), t === null)
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (f != null)
        switch (typeof f) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (_e(f, n), s = Wo("" + f), t === s)
              return;
        }
      zn(n, t, f, m);
    }
    function s3(t, n, s, f) {
      for (var p = {}, m = /* @__PURE__ */ new Set(), E = t.attributes, I = 0; I < E.length; I++)
        switch (E[I].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            m.add(E[I].name);
        }
      if (hu(n)) {
        for (var F in s)
          if (s.hasOwnProperty(F)) {
            var z = s[F];
            if (z != null) {
              if (Es.hasOwnProperty(F))
                typeof z != "function" && Co(F, z);
              else if (s.suppressHydrationWarning !== !0)
                switch (F) {
                  case "children":
                    typeof z != "string" && typeof z != "number" || zn(
                      "children",
                      t.textContent,
                      z,
                      p
                    );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    E = t.innerHTML, z = z ? z.__html : void 0, z != null && (z = o3(t, z), zn(
                      F,
                      E,
                      z,
                      p
                    ));
                    continue;
                  case "style":
                    m.delete(F), ci(t, z, p);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    m.delete(F.toLowerCase()), console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      F
                    );
                    continue;
                  case "className":
                    m.delete("class"), E = s1(
                      t,
                      "class",
                      z
                    ), zn(
                      "className",
                      E,
                      z,
                      p
                    );
                    continue;
                  default:
                    f.context === ad && n !== "svg" && n !== "math" ? m.delete(F.toLowerCase()) : m.delete(F), E = s1(
                      t,
                      F,
                      z
                    ), zn(
                      F,
                      E,
                      z,
                      p
                    );
                }
            }
          }
      } else
        for (z in s)
          if (s.hasOwnProperty(z) && (F = s[z], F != null)) {
            if (Es.hasOwnProperty(z))
              typeof F != "function" && Co(z, F);
            else if (s.suppressHydrationWarning !== !0)
              switch (z) {
                case "children":
                  typeof F != "string" && typeof F != "number" || zn(
                    "children",
                    t.textContent,
                    F,
                    p
                  );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  E = t.innerHTML, F = F ? F.__html : void 0, F != null && (F = o3(t, F), E !== F && (p[z] = { __html: E }));
                  continue;
                case "className":
                  Sa(
                    t,
                    z,
                    "class",
                    F,
                    m,
                    p
                  );
                  continue;
                case "tabIndex":
                  Sa(
                    t,
                    z,
                    "tabindex",
                    F,
                    m,
                    p
                  );
                  continue;
                case "style":
                  m.delete(z), ci(t, F, p);
                  continue;
                case "multiple":
                  m.delete(z), zn(
                    z,
                    t.multiple,
                    F,
                    p
                  );
                  continue;
                case "muted":
                  m.delete(z), zn(
                    z,
                    t.muted,
                    F,
                    p
                  );
                  continue;
                case "autoFocus":
                  m.delete("autofocus"), zn(
                    z,
                    t.autofocus,
                    F,
                    p
                  );
                  continue;
                case "data":
                  if (n !== "object") {
                    m.delete(z), E = t.getAttribute("data"), zn(
                      z,
                      E,
                      F,
                      p
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (!(F !== "" || n === "a" && z === "href" || n === "object" && z === "data")) {
                    console.error(
                      z === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                      z,
                      z
                    ), $m(
                      t,
                      z,
                      z,
                      null,
                      m,
                      p
                    );
                    continue;
                  }
                  $m(
                    t,
                    z,
                    z,
                    F,
                    m,
                    p
                  );
                  continue;
                case "action":
                case "formAction":
                  if (E = t.getAttribute(z), typeof F == "function") {
                    m.delete(z.toLowerCase()), z === "formAction" ? (m.delete("name"), m.delete("formenctype"), m.delete("formmethod"), m.delete("formtarget")) : (m.delete("enctype"), m.delete("method"), m.delete("target"));
                    continue;
                  } else if (E === EP) {
                    m.delete(z.toLowerCase()), zn(
                      z,
                      "function",
                      F,
                      p
                    );
                    continue;
                  }
                  $m(
                    t,
                    z,
                    z.toLowerCase(),
                    F,
                    m,
                    p
                  );
                  continue;
                case "xlinkHref":
                  $m(
                    t,
                    z,
                    "xlink:href",
                    F,
                    m,
                    p
                  );
                  continue;
                case "contentEditable":
                  Gu(
                    t,
                    z,
                    "contenteditable",
                    F,
                    m,
                    p
                  );
                  continue;
                case "spellCheck":
                  Gu(
                    t,
                    z,
                    "spellcheck",
                    F,
                    m,
                    p
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  Gu(
                    t,
                    z,
                    z,
                    F,
                    m,
                    p
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  zh(
                    t,
                    z,
                    z.toLowerCase(),
                    F,
                    m,
                    p
                  );
                  continue;
                case "capture":
                case "download":
                  e: {
                    I = t;
                    var de = E = z, Ee = p;
                    if (m.delete(de), I = I.getAttribute(de), I === null)
                      switch (typeof F) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break e;
                        default:
                          if (F === !1) break e;
                      }
                    else if (F != null)
                      switch (typeof F) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (F === !0 && I === "") break e;
                          break;
                        default:
                          if (_e(F, E), I === "" + F)
                            break e;
                      }
                    zn(
                      E,
                      I,
                      F,
                      Ee
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  e: {
                    if (I = t, de = E = z, Ee = p, m.delete(de), I = I.getAttribute(de), I === null)
                      switch (typeof F) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break e;
                        default:
                          if (isNaN(F) || 1 > F) break e;
                      }
                    else if (F != null)
                      switch (typeof F) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (!(isNaN(F) || 1 > F) && (_e(F, E), I === "" + F))
                            break e;
                      }
                    zn(
                      E,
                      I,
                      F,
                      Ee
                    );
                  }
                  continue;
                case "rowSpan":
                  rn(
                    t,
                    z,
                    "rowspan",
                    F,
                    m,
                    p
                  );
                  continue;
                case "start":
                  rn(
                    t,
                    z,
                    z,
                    F,
                    m,
                    p
                  );
                  continue;
                case "xHeight":
                  Sa(
                    t,
                    z,
                    "x-height",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xlinkActuate":
                  Sa(
                    t,
                    z,
                    "xlink:actuate",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xlinkArcrole":
                  Sa(
                    t,
                    z,
                    "xlink:arcrole",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xlinkRole":
                  Sa(
                    t,
                    z,
                    "xlink:role",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xlinkShow":
                  Sa(
                    t,
                    z,
                    "xlink:show",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xlinkTitle":
                  Sa(
                    t,
                    z,
                    "xlink:title",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xlinkType":
                  Sa(
                    t,
                    z,
                    "xlink:type",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xmlBase":
                  Sa(
                    t,
                    z,
                    "xml:base",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xmlLang":
                  Sa(
                    t,
                    z,
                    "xml:lang",
                    F,
                    m,
                    p
                  );
                  continue;
                case "xmlSpace":
                  Sa(
                    t,
                    z,
                    "xml:space",
                    F,
                    m,
                    p
                  );
                  continue;
                case "inert":
                  F !== "" || K3[z] || (K3[z] = !0, console.error(
                    "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                    z
                  )), zh(
                    t,
                    z,
                    z,
                    F,
                    m,
                    p
                  );
                  continue;
                default:
                  if (!(2 < z.length) || z[0] !== "o" && z[0] !== "O" || z[1] !== "n" && z[1] !== "N") {
                    I = xw(z), E = !1, f.context === ad && n !== "svg" && n !== "math" ? m.delete(I.toLowerCase()) : (de = z.toLowerCase(), de = nc.hasOwnProperty(
                      de
                    ) && nc[de] || null, de !== null && de !== z && (E = !0, m.delete(de)), m.delete(I));
                    e: if (de = t, Ee = I, I = F, Dg(Ee))
                      if (de.hasAttribute(Ee))
                        de = de.getAttribute(
                          Ee
                        ), _e(
                          I,
                          Ee
                        ), I = de === "" + I ? I : de;
                      else {
                        switch (typeof I) {
                          case "function":
                          case "symbol":
                            break e;
                          case "boolean":
                            if (de = Ee.toLowerCase().slice(0, 5), de !== "data-" && de !== "aria-")
                              break e;
                        }
                        I = I === void 0 ? void 0 : null;
                      }
                    else I = void 0;
                    E || zn(
                      z,
                      I,
                      F,
                      p
                    );
                  }
              }
          }
      return 0 < m.size && s.suppressHydrationWarning !== !0 && Wm(t, m, p), Object.keys(p).length === 0 ? null : p;
    }
    function l3(t, n) {
      switch (t.length) {
        case 0:
          return "";
        case 1:
          return t[0];
        case 2:
          return t[0] + " " + n + " " + t[1];
        default:
          return t.slice(0, -1).join(", ") + ", " + n + " " + t[t.length - 1];
      }
    }
    function Qm(t) {
      return t.nodeType === 9 ? t : t.ownerDocument;
    }
    function u3(t) {
      switch (t) {
        case Na:
          return G0;
        case Dl:
          return e4;
        default:
          return ad;
      }
    }
    function an(t, n) {
      if (t === ad)
        switch (n) {
          case "svg":
            return G0;
          case "math":
            return e4;
          default:
            return ad;
        }
      return t === G0 && n === "foreignObject" ? ad : t;
    }
    function zt(t, n) {
      return t === "textarea" || t === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.children == "bigint" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null;
    }
    function wt() {
      var t = window.event;
      return t && t.type === "popstate" ? t === h8 ? !1 : (h8 = t, !0) : (h8 = null, !1);
    }
    function xt(t) {
      setTimeout(function() {
        throw t;
      });
    }
    function $t(t, n, s) {
      switch (n) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          s.autoFocus && t.focus();
          break;
        case "img":
          s.src ? t.src = s.src : s.srcSet && (t.srcset = s.srcSet);
      }
    }
    function Aa(t, n, s, f) {
      i3(t, n, s, f), t[ua] = f;
    }
    function fi(t) {
      Vo(t, "");
    }
    function Pf(t, n, s) {
      t.nodeValue = s;
    }
    function Eb(t, n) {
      t.removeChild(n);
    }
    function bs(t, n) {
      t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n);
    }
    function on(t, n) {
      var s = n, f = 0;
      do {
        var p = s.nextSibling;
        if (t.removeChild(s), p && p.nodeType === 8)
          if (s = p.data, s === X3) {
            if (f === 0) {
              t.removeChild(p), Ff(n);
              return;
            }
            f--;
          } else
            s !== J3 && s !== Sp && s !== Ap || f++;
        s = p;
      } while (s);
      Ff(n);
    }
    function bl(t) {
      t = t.style, typeof t.setProperty == "function" ? t.setProperty("display", "none", "important") : t.display = "none";
    }
    function ju(t) {
      t.nodeValue = "";
    }
    function Sb(t, n) {
      n = n[AP], n = n != null && n.hasOwnProperty("display") ? n.display : null, t.style.display = n == null || typeof n == "boolean" ? "" : ("" + n).trim();
    }
    function Ja(t, n) {
      t.nodeValue = n;
    }
    function vl(t) {
      var n = t.firstChild;
      for (n && n.nodeType === 10 && (n = n.nextSibling); n; ) {
        var s = n;
        switch (n = n.nextSibling, s.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            vl(s), Hi(s);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (s.rel.toLowerCase() === "stylesheet") continue;
        }
        t.removeChild(s);
      }
    }
    function Hh(t, n, s, f) {
      for (; t.nodeType === 1; ) {
        var p = s;
        if (t.nodeName.toLowerCase() !== n.toLowerCase()) {
          if (!f && (t.nodeName !== "INPUT" || t.type !== "hidden"))
            break;
        } else if (f) {
          if (!t[Pl])
            switch (n) {
              case "meta":
                if (!t.hasAttribute("itemprop")) break;
                return t;
              case "link":
                if (m = t.getAttribute("rel"), m === "stylesheet" && t.hasAttribute("data-precedence") || m !== p.rel || t.getAttribute("href") !== (p.href == null ? null : p.href) || t.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin) || t.getAttribute("title") !== (p.title == null ? null : p.title))
                  break;
                return t;
              case "style":
                if (t.hasAttribute("data-precedence")) break;
                return t;
              case "script":
                if (m = t.getAttribute("src"), (m !== (p.src == null ? null : p.src) || t.getAttribute("type") !== (p.type == null ? null : p.type) || t.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin)) && m && t.hasAttribute("async") && !t.hasAttribute("itemprop"))
                  break;
                return t;
              default:
                return t;
            }
        } else if (n === "input" && t.type === "hidden") {
          _e(p.name, "name");
          var m = p.name == null ? null : "" + p.name;
          if (p.type === "hidden" && t.getAttribute("name") === m)
            return t;
        } else return t;
        if (t = sa(t.nextSibling), t === null) break;
      }
      return null;
    }
    function di(t, n, s) {
      if (n === "") return null;
      for (; t.nodeType !== 3; )
        if ((t.nodeType !== 1 || t.nodeName !== "INPUT" || t.type !== "hidden") && !s || (t = sa(t.nextSibling), t === null)) return null;
      return t;
    }
    function sa(t) {
      for (; t != null; t = t.nextSibling) {
        var n = t.nodeType;
        if (n === 1 || n === 3) break;
        if (n === 8) {
          if (n = t.data, n === J3 || n === Ap || n === Sp || n === c8 || n === DS)
            break;
          if (n === X3) return null;
        }
      }
      return t;
    }
    function Zm(t) {
      if (t.nodeType === 1) {
        for (var n = t.nodeName.toLowerCase(), s = {}, f = t.attributes, p = 0; p < f.length; p++) {
          var m = f[p];
          s[jm(m.name)] = m.name.toLowerCase() === "style" ? Uh(t) : m.value;
        }
        return { type: n, props: s };
      }
      return t.nodeType === 8 ? { type: "Suspense", props: {} } : t.nodeValue;
    }
    function Vh(t, n, s) {
      return s === null || s[SP] !== !0 ? (t.nodeValue === n ? t = null : (n = Hn(n), t = Hn(t.nodeValue) === n ? null : t.nodeValue), t) : null;
    }
    function Wh(t) {
      t = t.nextSibling;
      for (var n = 0; t; ) {
        if (t.nodeType === 8) {
          var s = t.data;
          if (s === X3) {
            if (n === 0)
              return sa(t.nextSibling);
            n--;
          } else
            s !== J3 && s !== Ap && s !== Sp || n++;
        }
        t = t.nextSibling;
      }
      return null;
    }
    function vs(t) {
      t = t.previousSibling;
      for (var n = 0; t; ) {
        if (t.nodeType === 8) {
          var s = t.data;
          if (s === J3 || s === Ap || s === Sp) {
            if (n === 0) return t;
            n--;
          } else s === X3 && n++;
        }
        t = t.previousSibling;
      }
      return null;
    }
    function Ym(t) {
      Ff(t);
    }
    function $u(t) {
      Ff(t);
    }
    function Of(t, n, s, f, p) {
      switch (p && Hg(t, f.ancestorInfo), n = Qm(s), t) {
        case "html":
          if (t = n.documentElement, !t)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        case "head":
          if (t = n.head, !t)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        case "body":
          if (t = n.body, !t)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function Ab(t, n, s, f) {
      if (fo(s)) {
        var p = s.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          p,
          p,
          p
        );
      }
      switch (t) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (p = s.attributes; p.length; )
        s.removeAttributeNode(p[0]);
      cn(s, t, n), s[yr] = f, s[ua] = n;
    }
    function Rf(t) {
      return typeof t.getRootNode == "function" ? t.getRootNode() : t.ownerDocument;
    }
    function Lf(t, n, s) {
      var f = j0;
      if (f && typeof n == "string" && n) {
        var p = ho(n);
        p = 'link[rel="' + t + '"][href="' + p + '"]', typeof s == "string" && (p += '[crossorigin="' + s + '"]'), zS.has(p) || (zS.add(p), t = { rel: t, crossOrigin: s, href: n }, f.querySelector(p) === null && (n = f.createElement("link"), cn(n, "link", t), Dn(n), f.head.appendChild(n)));
      }
    }
    function qm(t, n, s, f) {
      var p = (p = or.current) ? Rf(p) : null;
      if (!p)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (t) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof s.precedence == "string" && typeof s.href == "string" ? (s = Qu(s.href), n = su(p).hoistableStyles, f = n.get(s), f || (f = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, n.set(s, f)), f) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (s.rel === "stylesheet" && typeof s.href == "string" && typeof s.precedence == "string") {
            t = Qu(s.href);
            var m = su(p).hoistableStyles, E = m.get(t);
            if (!E && (p = p.ownerDocument || p, E = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: xp, preload: null }
            }, m.set(t, E), (m = p.querySelector(
              Vn(t)
            )) && !m._p && (E.instance = m, E.state.loading = O2 | Ci), !Ti.has(t))) {
              var I = {
                rel: "preload",
                as: "style",
                href: s.href,
                crossOrigin: s.crossOrigin,
                integrity: s.integrity,
                media: s.media,
                hrefLang: s.hrefLang,
                referrerPolicy: s.referrerPolicy
              };
              Ti.set(t, I), m || Cb(
                p,
                t,
                I,
                E.state
              );
            }
            if (n && f === null)
              throw s = `

  - ` + Ir(n) + `
  + ` + Ir(s), Error(
                "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + s
              );
            return E;
          }
          if (n && f !== null)
            throw s = `

  - ` + Ir(n) + `
  + ` + Ir(s), Error(
              "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + s
            );
          return null;
        case "script":
          return n = s.async, s = s.src, typeof s == "string" && n && typeof n != "function" && typeof n != "symbol" ? (s = Zu(s), n = su(p).hoistableScripts, f = n.get(s), f || (f = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, n.set(s, f)), f) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' + t + '". this is a bug in React.'
          );
      }
    }
    function Ir(t) {
      var n = 0, s = "<link";
      return typeof t.rel == "string" ? (n++, s += ' rel="' + t.rel + '"') : gi.call(t, "rel") && (n++, s += ' rel="' + (t.rel === null ? "null" : "invalid type " + typeof t.rel) + '"'), typeof t.href == "string" ? (n++, s += ' href="' + t.href + '"') : gi.call(t, "href") && (n++, s += ' href="' + (t.href === null ? "null" : "invalid type " + typeof t.href) + '"'), typeof t.precedence == "string" ? (n++, s += ' precedence="' + t.precedence + '"') : gi.call(t, "precedence") && (n++, s += " precedence={" + (t.precedence === null ? "null" : "invalid type " + typeof t.precedence) + "}"), Object.getOwnPropertyNames(t).length > n && (s += " ..."), s + " />";
    }
    function Qu(t) {
      return 'href="' + ho(t) + '"';
    }
    function Vn(t) {
      return 'link[rel="stylesheet"][' + t + "]";
    }
    function xb(t) {
      return st({}, t, {
        "data-precedence": t.precedence,
        precedence: null
      });
    }
    function Cb(t, n, s, f) {
      t.querySelector(
        'link[rel="preload"][as="style"][' + n + "]"
      ) ? f.loading = O2 : (n = t.createElement("link"), f.preload = n, n.addEventListener("load", function() {
        return f.loading |= O2;
      }), n.addEventListener("error", function() {
        return f.loading |= _S;
      }), cn(n, "link", s), Dn(n), t.head.appendChild(n));
    }
    function Zu(t) {
      return '[src="' + ho(t) + '"]';
    }
    function Gh(t) {
      return "script[async]" + t;
    }
    function hi(t, n, s) {
      if (n.count++, n.instance === null)
        switch (n.type) {
          case "style":
            var f = t.querySelector(
              'style[data-href~="' + ho(s.href) + '"]'
            );
            if (f)
              return n.instance = f, Dn(f), f;
            var p = st({}, s, {
              "data-href": s.href,
              "data-precedence": s.precedence,
              href: null,
              precedence: null
            });
            return f = (t.ownerDocument || t).createElement("style"), Dn(f), cn(f, "style", p), Yu(f, s.precedence, t), n.instance = f;
          case "stylesheet":
            p = Qu(s.href);
            var m = t.querySelector(
              Vn(p)
            );
            if (m)
              return n.state.loading |= Ci, n.instance = m, Dn(m), m;
            f = xb(s), (p = Ti.get(p)) && jh(f, p), m = (t.ownerDocument || t).createElement("link"), Dn(m);
            var E = m;
            return E._p = new Promise(function(I, F) {
              E.onload = I, E.onerror = F;
            }), cn(m, "link", f), n.state.loading |= Ci, Yu(m, s.precedence, t), n.instance = m;
          case "script":
            return m = Zu(s.src), (p = t.querySelector(
              Gh(m)
            )) ? (n.instance = p, Dn(p), p) : (f = s, (p = Ti.get(m)) && (f = st({}, s), wl(f, p)), t = t.ownerDocument || t, p = t.createElement("script"), Dn(p), cn(p, "link", f), t.head.appendChild(p), n.instance = p);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' + n.type + '". this is a bug in React.'
            );
        }
      else
        n.type === "stylesheet" && (n.state.loading & Ci) === xp && (f = n.instance, n.state.loading |= Ci, Yu(f, s.precedence, t));
      return n.instance;
    }
    function Yu(t, n, s) {
      for (var f = s.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), p = f.length ? f[f.length - 1] : null, m = p, E = 0; E < f.length; E++) {
        var I = f[E];
        if (I.dataset.precedence === n) m = I;
        else if (m !== p) break;
      }
      m ? m.parentNode.insertBefore(t, m.nextSibling) : (n = s.nodeType === 9 ? s.head : s, n.insertBefore(t, n.firstChild));
    }
    function jh(t, n) {
      t.crossOrigin == null && (t.crossOrigin = n.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = n.referrerPolicy), t.title == null && (t.title = n.title);
    }
    function wl(t, n) {
      t.crossOrigin == null && (t.crossOrigin = n.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = n.referrerPolicy), t.integrity == null && (t.integrity = n.integrity);
    }
    function Tb(t, n, s) {
      if (t4 === null) {
        var f = /* @__PURE__ */ new Map(), p = t4 = /* @__PURE__ */ new Map();
        p.set(s, f);
      } else
        p = t4, f = p.get(s), f || (f = /* @__PURE__ */ new Map(), p.set(s, f));
      if (f.has(t)) return f;
      for (f.set(t, null), s = s.getElementsByTagName(t), p = 0; p < s.length; p++) {
        var m = s[p];
        if (!(m[Pl] || m[yr] || t === "link" && m.getAttribute("rel") === "stylesheet") && m.namespaceURI !== Na) {
          var E = m.getAttribute(n) || "";
          E = t + E;
          var I = f.get(E);
          I ? I.push(m) : f.set(E, [m]);
        }
      }
      return f;
    }
    function Ib(t, n, s) {
      t = t.ownerDocument || t, t.head.insertBefore(
        s,
        n === "title" ? t.querySelector("head > title") : null
      );
    }
    function c3(t, n, s) {
      var f = !s.ancestorInfo.containerTagInScope;
      if (s.context === G0 || n.itemProp != null)
        return !f || n.itemProp == null || t !== "meta" && t !== "title" && t !== "style" && t !== "link" && t !== "script" || console.error(
          "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
          t,
          t
        ), !1;
      switch (t) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof n.precedence != "string" || typeof n.href != "string" || n.href === "") {
            f && console.error(
              'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflic with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`, or move the <style> to the <style> tag.'
            );
            break;
          }
          return !0;
        case "link":
          if (typeof n.rel != "string" || typeof n.href != "string" || n.href === "" || n.onLoad || n.onError) {
            if (n.rel === "stylesheet" && typeof n.precedence == "string") {
              t = n.href;
              var p = n.onError, m = n.disabled;
              s = [], n.onLoad && s.push("`onLoad`"), p && s.push("`onError`"), m != null && s.push("`disabled`"), p = l3(s, "and"), p += s.length === 1 ? " prop" : " props", m = s.length === 1 ? "an " + p : "the " + p, s.length && console.error(
                'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                t,
                m,
                p
              );
            }
            f && (typeof n.rel != "string" || typeof n.href != "string" || n.href === "" ? console.error(
              "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
            ) : (n.onError || n.onLoad) && console.error(
              "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ));
            break;
          }
          switch (n.rel) {
            case "stylesheet":
              return t = n.precedence, n = n.disabled, typeof t != "string" && f && console.error(
                'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
              ), typeof t == "string" && n == null;
            default:
              return !0;
          }
        case "script":
          if (t = n.async && typeof n.async != "function" && typeof n.async != "symbol", !t || n.onLoad || n.onError || !n.src || typeof n.src != "string") {
            f && (t ? n.onLoad || n.onError ? console.error(
              "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
            ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          f && console.error(
            "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
            t
          );
      }
      return !1;
    }
    function Km(t) {
      return !(t.type === "stylesheet" && (t.state.loading & US) === xp);
    }
    function Nb() {
    }
    function o6(t, n, s) {
      if (R2 === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var f = R2;
      if (n.type === "stylesheet" && (typeof s.media != "string" || matchMedia(s.media).matches !== !1) && (n.state.loading & Ci) === xp) {
        if (n.instance === null) {
          var p = Qu(s.href), m = t.querySelector(
            Vn(p)
          );
          if (m) {
            t = m._p, t !== null && typeof t == "object" && typeof t.then == "function" && (f.count++, f = Jm.bind(f), t.then(f, f)), n.state.loading |= Ci, n.instance = m, Dn(m);
            return;
          }
          m = t.ownerDocument || t, s = xb(s), (p = Ti.get(p)) && jh(s, p), m = m.createElement("link"), Dn(m);
          var E = m;
          E._p = new Promise(function(I, F) {
            E.onload = I, E.onerror = F;
          }), cn(m, "link", s), n.instance = m;
        }
        f.stylesheets === null && (f.stylesheets = /* @__PURE__ */ new Map()), f.stylesheets.set(n, t), (t = n.state.preload) && (n.state.loading & US) === xp && (f.count++, n = Jm.bind(f), t.addEventListener("load", n), t.addEventListener("error", n));
      }
    }
    function i6() {
      if (R2 === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var t = R2;
      return t.stylesheets && t.count === 0 && Xm(t, t.stylesheets), 0 < t.count ? function(n) {
        var s = setTimeout(function() {
          if (t.stylesheets && Xm(t, t.stylesheets), t.unsuspend) {
            var f = t.unsuspend;
            t.unsuspend = null, f();
          }
        }, 6e4);
        return t.unsuspend = n, function() {
          t.unsuspend = null, clearTimeout(s);
        };
      } : null;
    }
    function Jm() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets)
          Xm(this, this.stylesheets);
        else if (this.unsuspend) {
          var t = this.unsuspend;
          this.unsuspend = null, t();
        }
      }
    }
    function Xm(t, n) {
      t.stylesheets = null, t.unsuspend !== null && (t.count++, n4 = /* @__PURE__ */ new Map(), n.forEach(f3, t), n4 = null, Jm.call(t));
    }
    function f3(t, n) {
      if (!(n.state.loading & Ci)) {
        var s = n4.get(t);
        if (s) var f = s.get(g8);
        else {
          s = /* @__PURE__ */ new Map(), n4.set(t, s);
          for (var p = t.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), m = 0; m < p.length; m++) {
            var E = p[m];
            (E.nodeName === "LINK" || E.getAttribute("media") !== "not all") && (s.set(E.dataset.precedence, E), f = E);
          }
          f && s.set(g8, f);
        }
        p = n.instance, E = p.getAttribute("data-precedence"), m = s.get(E) || f, m === f && s.set(g8, p), s.set(E, p), this.count++, f = Jm.bind(this), p.addEventListener("load", f), p.addEventListener("error", f), m ? m.parentNode.insertBefore(p, m.nextSibling) : (t = t.nodeType === 9 ? t.head : t, t.insertBefore(p, t.firstChild)), n.state.loading |= Ci;
      }
    }
    function Df(t, n, s) {
      var f = 0;
      switch (t) {
        case "dir":
        case "dirxml":
        case "groupEnd":
        case "table":
          return GS.apply(console[t], [console].concat(n));
        case "assert":
          f = 1;
      }
      return n = n.slice(0), typeof n[f] == "string" ? n.splice(
        f,
        1,
        HS + n[f],
        VS,
        r4 + s + r4,
        WS
      ) : n.splice(
        f,
        0,
        HS,
        VS,
        r4 + s + r4,
        WS
      ), n.unshift(console), GS.apply(console[t], n);
    }
    function e0(t, n, s, f, p, m, E, I) {
      for (this.tag = 1, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = p8, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = iu(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = iu(0), this.hiddenUpdates = iu(null), this.identifierPrefix = f, this.onUncaughtError = p, this.onCaughtError = m, this.onRecoverableError = E, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = I, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), t = this.pendingUpdatersLaneMap = [], n = 0; 31 > n; n++) t.push(/* @__PURE__ */ new Set());
      this._debugRootType = s ? "hydrateRoot()" : "createRoot()";
    }
    function Pb(t, n, s, f, p, m, E, I, F, z, de, Ee) {
      return t = new e0(
        t,
        n,
        s,
        E,
        I,
        F,
        z,
        Ee
      ), n = rP, m === !0 && (n |= fa | As), Gr && (n |= jr), m = b(3, null, null, n), t.current = m, m.stateNode = t, n = Yi(), Za(n), t.pooledCache = n, Za(n), m.memoizedState = {
        element: f,
        isDehydrated: s,
        cache: n
      }, vm(m), t;
    }
    function Ob(t) {
      return t ? (t = Zf, t) : Zf;
    }
    function d3(t, n, s, f) {
      return n.tag === 0 && ps(), Rb(
        n.current,
        2,
        t,
        n,
        s,
        f
      ), 2;
    }
    function Rb(t, n, s, f, p, m) {
      if (Or && typeof Or.onScheduleFiberRoot == "function")
        try {
          Or.onScheduleFiberRoot(Hf, f, s);
        } catch (E) {
          Wr || (Wr = !0, console.error(
            "React instrumentation encountered an error: %s",
            E
          ));
        }
      Me !== null && typeof Me.markRenderScheduled == "function" && Me.markRenderScheduled(n), p = Ob(p), f.context === null ? f.context = p : f.pendingContext = p, Ta && Pr !== null && !jS && (jS = !0, console.error(
        `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
        Z(Pr) || "Unknown"
      )), f = os(n), f.payload = { element: s }, m = m === void 0 ? null : m, m !== null && (typeof m != "function" && console.error(
        "Expected the last optional `callback` argument to be a function. Instead received: %s.",
        m
      ), f.callback = m), s = is(t, f, n), s !== null && (Vt(s, t, n), xh(s, t, n));
    }
    function qu(t, n) {
      if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
        var s = t.retryLane;
        t.retryLane = s !== 0 && s < n ? s : n;
      }
    }
    function t0(t, n) {
      qu(t, n), (t = t.alternate) && qu(t, n);
    }
    function Ht(t) {
      if (t.tag === 13) {
        var n = dr(t, 67108864);
        n !== null && Vt(n, t, 67108864), t0(t, 67108864);
      }
    }
    function Lb() {
      return Pr;
    }
    function s6() {
      for (var t = /* @__PURE__ */ new Map(), n = 1, s = 0; 31 > s; s++) {
        var f = bw(n);
        t.set(n, f), n *= 2;
      }
      return t;
    }
    function h3(t, n, s, f) {
      var p = me.T;
      me.T = null;
      var m = Qt.p;
      try {
        Qt.p = Ia, Db(t, n, s, f);
      } finally {
        Qt.p = m, me.T = p;
      }
    }
    function l6(t, n, s, f) {
      var p = me.T;
      me.T = null;
      var m = Qt.p;
      try {
        Qt.p = Xa, Db(t, n, s, f);
      } finally {
        Qt.p = m, me.T = p;
      }
    }
    function Db(t, n, s, f) {
      if (a4) {
        var p = Bb(f);
        if (p === null)
          Hu(
            t,
            n,
            f,
            o4,
            s
          ), n0(t, f);
        else if (Mb(
          p,
          t,
          n,
          s,
          f
        ))
          f.stopPropagation();
        else if (n0(t, f), n & 4 && -1 < TP.indexOf(t)) {
          for (; p !== null; ) {
            var m = fo(p);
            if (m !== null)
              switch (m.tag) {
                case 3:
                  if (m = m.stateNode, m.current.memoizedState.isDehydrated) {
                    var E = Qs(m.pendingLanes);
                    if (E !== 0) {
                      var I = m;
                      for (I.pendingLanes |= 2, I.entangledLanes |= 2; E; ) {
                        var F = 1 << 31 - Rr(E);
                        I.entanglements[1] |= F, E &= ~F;
                      }
                      xo(m), (fn & (Da | cc)) === Oo && (H3 = mi() + CS, If(0));
                    }
                  }
                  break;
                case 13:
                  I = dr(m, 2), I !== null && Vt(I, m, 2), va(), t0(m, 2);
              }
            if (m = Bb(f), m === null && Hu(
              t,
              n,
              f,
              o4,
              s
            ), m === p) break;
            p = m;
          }
          p !== null && f.stopPropagation();
        } else
          Hu(
            t,
            n,
            f,
            null,
            s
          );
      }
    }
    function Bb(t) {
      return t = qs(t), Bf(t);
    }
    function Bf(t) {
      if (o4 = null, t = zo(t), t !== null) {
        var n = B(t);
        if (n === null) t = null;
        else {
          var s = n.tag;
          if (s === 13) {
            if (t = P(n), t !== null) return t;
            t = null;
          } else if (s === 3) {
            if (n.stateNode.current.memoizedState.isDehydrated)
              return n.tag === 3 ? n.stateNode.containerInfo : null;
            t = null;
          } else n !== t && (t = null);
        }
      }
      return o4 = t, null;
    }
    function Ku(t) {
      switch (t) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Ia;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Xa;
        case "message":
          switch (d6()) {
            case Tl:
              return Ia;
            case f0:
              return Xa;
            case zf:
            case h6:
              return No;
            case jb:
              return ec;
            default:
              return No;
          }
        default:
          return No;
      }
    }
    function n0(t, n) {
      switch (t) {
        case "focusin":
        case "focusout":
          od = null;
          break;
        case "dragenter":
        case "dragleave":
          id = null;
          break;
        case "mouseover":
        case "mouseout":
          sd = null;
          break;
        case "pointerover":
        case "pointerout":
          D2.delete(n.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          B2.delete(n.pointerId);
      }
    }
    function kl(t, n, s, f, p, m) {
      return t === null || t.nativeEvent !== m ? (t = {
        blockedOn: n,
        domEventName: s,
        eventSystemFlags: f,
        nativeEvent: m,
        targetContainers: [p]
      }, n !== null && (n = fo(n), n !== null && Ht(n)), t) : (t.eventSystemFlags |= f, n = t.targetContainers, p !== null && n.indexOf(p) === -1 && n.push(p), t);
    }
    function Mb(t, n, s, f, p) {
      switch (n) {
        case "focusin":
          return od = kl(
            od,
            t,
            n,
            s,
            f,
            p
          ), !0;
        case "dragenter":
          return id = kl(
            id,
            t,
            n,
            s,
            f,
            p
          ), !0;
        case "mouseover":
          return sd = kl(
            sd,
            t,
            n,
            s,
            f,
            p
          ), !0;
        case "pointerover":
          var m = p.pointerId;
          return D2.set(
            m,
            kl(
              D2.get(m) || null,
              t,
              n,
              s,
              f,
              p
            )
          ), !0;
        case "gotpointercapture":
          return m = p.pointerId, B2.set(
            m,
            kl(
              B2.get(m) || null,
              t,
              n,
              s,
              f,
              p
            )
          ), !0;
      }
      return !1;
    }
    function El(t) {
      var n = zo(t.target);
      if (n !== null) {
        var s = B(n);
        if (s !== null) {
          if (n = s.tag, n === 13) {
            if (n = P(s), n !== null) {
              t.blockedOn = n, Lg(t.priority, function() {
                if (s.tag === 13) {
                  var f = Hr(s), p = dr(s, f);
                  p !== null && Vt(p, s, f), t0(s, f);
                }
              });
              return;
            }
          } else if (n === 3 && s.stateNode.current.memoizedState.isDehydrated) {
            t.blockedOn = s.tag === 3 ? s.stateNode.containerInfo : null;
            return;
          }
        }
      }
      t.blockedOn = null;
    }
    function xa(t) {
      if (t.blockedOn !== null) return !1;
      for (var n = t.targetContainers; 0 < n.length; ) {
        var s = Bb(t.nativeEvent);
        if (s === null) {
          s = t.nativeEvent;
          var f = new s.constructor(
            s.type,
            s
          ), p = f;
          $ !== null && console.error(
            "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
          ), $ = p, s.target.dispatchEvent(f), $ === null && console.error(
            "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
          ), $ = null;
        } else
          return n = fo(s), n !== null && Ht(n), t.blockedOn = s, !1;
        n.shift();
      }
      return !0;
    }
    function Mf(t, n, s) {
      xa(t) && s.delete(n);
    }
    function u6() {
      m8 = !1, od !== null && xa(od) && (od = null), id !== null && xa(id) && (id = null), sd !== null && xa(sd) && (sd = null), D2.forEach(Mf), B2.forEach(Mf);
    }
    function $h(t, n) {
      t.blockedOn === n && (t.blockedOn = null, m8 || (m8 = !0, En.unstable_scheduleCallback(
        En.unstable_NormalPriority,
        u6
      )));
    }
    function Fb(t) {
      i4 !== t && (i4 = t, En.unstable_scheduleCallback(
        En.unstable_NormalPriority,
        function() {
          i4 === t && (i4 = null);
          for (var n = 0; n < t.length; n += 3) {
            var s = t[n], f = t[n + 1], p = t[n + 2];
            if (typeof f != "function") {
              if (Bf(f || s) === null)
                continue;
              break;
            }
            var m = fo(s);
            m !== null && (t.splice(n, 3), n -= 3, s = {
              pending: !0,
              data: p,
              method: s.method,
              action: f
            }, Object.freeze(s), Jo(
              m,
              s,
              f,
              p
            ));
          }
        }
      ));
    }
    function Ff(t) {
      function n(F) {
        return $h(F, t);
      }
      od !== null && $h(od, t), id !== null && $h(id, t), sd !== null && $h(sd, t), D2.forEach(n), B2.forEach(n);
      for (var s = 0; s < ld.length; s++) {
        var f = ld[s];
        f.blockedOn === t && (f.blockedOn = null);
      }
      for (; 0 < ld.length && (s = ld[0], s.blockedOn === null); )
        El(s), s.blockedOn === null && ld.shift();
      if (s = (t.ownerDocument || t).$$reactFormReplay, s != null)
        for (f = 0; f < s.length; f += 3) {
          var p = s[f], m = s[f + 1], E = p[ua] || null;
          if (typeof m == "function")
            E || Fb(s);
          else if (E) {
            var I = null;
            if (m && m.hasAttribute("formAction")) {
              if (p = m, E = m[ua] || null)
                I = E.formAction;
              else if (Bf(p) !== null) continue;
            } else I = E.action;
            typeof I == "function" ? s[f + 1] = I : (s.splice(f, 3), f -= 3), Fb(s);
          }
        }
    }
    function _b(t) {
      this._internalRoot = t;
    }
    function _f(t) {
      this._internalRoot = t;
    }
    function Ub(t) {
      t[Nl] && (t._reactRootContainer ? console.error(
        "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
      ) : console.error(
        "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
      ));
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var En = kx(), zb = dE, Hb = hx, Vb = Symbol.for("react.element"), Sl = Symbol.for("react.transitional.element"), Uf = Symbol.for("react.portal"), pi = Symbol.for("react.fragment"), r0 = Symbol.for("react.strict_mode"), a0 = Symbol.for("react.profiler"), At = Symbol.for("react.provider"), Qh = Symbol.for("react.consumer"), Ca = Symbol.for("react.context"), Ju = Symbol.for("react.forward_ref"), o0 = Symbol.for("react.suspense"), Zh = Symbol.for("react.suspense_list"), Al = Symbol.for("react.memo"), Nr = Symbol.for("react.lazy"), Xu = Symbol.for("react.offscreen"), p3 = Symbol.for("react.memo_cache_sentinel"), g3 = Symbol.iterator, c6 = Symbol.for("react.client.reference"), me = zb.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, st = Object.assign, xl = 0, Ft, i0, ar, m3, s0, l0, Yh;
    J.__reactDisabledLog = !0;
    var u0, Wb, qh = !1, Kh = new (typeof WeakMap == "function" ? WeakMap : Map)(), Pr = null, Ta = !1, mr = Array.isArray, Qt = Hb.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, f6 = Object.freeze({
      pending: !1,
      data: null,
      method: null,
      action: null
    }), Gb = [], Jh = [], Io = -1, Cl = ce(null), Xh = ce(null), or = ce(null), ep = ce(null), gi = Object.prototype.hasOwnProperty, la = En.unstable_scheduleCallback, y3 = En.unstable_cancelCallback, c0 = En.unstable_shouldYield, ws = En.unstable_requestPaint, mi = En.unstable_now, d6 = En.unstable_getCurrentPriorityLevel, Tl = En.unstable_ImmediatePriority, f0 = En.unstable_UserBlockingPriority, zf = En.unstable_NormalPriority, h6 = En.unstable_LowPriority, jb = En.unstable_IdlePriority, p6 = En.log, g6 = En.unstable_setDisableYieldValue, Hf = null, Or = null, Me = null, Wr = !1, Gr = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u", Rr = Math.clz32 ? Math.clz32 : Zk, m6 = Math.log, Vf = Math.LN2, Il = 128, tp = 4194304, Ia = 2, Xa = 8, No = 32, ec = 268435456, ks = Math.random().toString(36).slice(2), yr = "__reactFiber$" + ks, ua = "__reactProps$" + ks, Nl = "__reactContainer$" + ks, tc = "__reactEvents$" + ks, y6 = "__reactListeners$" + ks, b6 = "__reactHandles$" + ks, b3 = "__reactResources$" + ks, Pl = "__reactMarker$" + ks, np = /* @__PURE__ */ new Set(), Es = {}, $b = {}, ca = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), v6 = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    }, v3 = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Qb = {}, Zb = {}, w3 = /[\n"\\]/g, d0 = !1, Yb = !1, rp = !1, k3 = !1, E3 = !1, h0 = !1, p0 = ["value", "defaultValue"], ap = !1, g0 = /["'&<>\n\t]|^\s|\s$/, S3 = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
      " "
    ), m0 = "applet caption html table td th marquee object template foreignObject desc title".split(
      " "
    ), Ol = m0.concat(["button"]), Rl = "dd dt li option optgroup p rp rt".split(" "), Ss = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null
    }, Ll = {}, Dl = "http://www.w3.org/1998/Math/MathML", Na = "http://www.w3.org/2000/svg", qb = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
        " "
      ),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
        " "
      ),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
        " "
      ),
      borderBlockEnd: [
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth"
      ],
      borderBlockStart: [
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth"
      ],
      borderBottom: [
        "borderBottomColor",
        "borderBottomStyle",
        "borderBottomWidth"
      ],
      borderColor: [
        "borderBottomColor",
        "borderLeftColor",
        "borderRightColor",
        "borderTopColor"
      ],
      borderImage: [
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth"
      ],
      borderInlineEnd: [
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth"
      ],
      borderInlineStart: [
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth"
      ],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: [
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius"
      ],
      borderRight: [
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth"
      ],
      borderStyle: [
        "borderBottomStyle",
        "borderLeftStyle",
        "borderRightStyle",
        "borderTopStyle"
      ],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: [
        "borderBottomWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth"
      ],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
        " "
      ),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
        " "
      ),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
        " "
      ),
      gridArea: [
        "gridColumnEnd",
        "gridColumnStart",
        "gridRowEnd",
        "gridRowStart"
      ],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: [
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows"
      ],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
        " "
      ),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: [
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationStyle"
      ],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: [
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction"
      ],
      wordWrap: ["overflowWrap"]
    }, Kb = /([A-Z])/g, Wf = /^ms-/, w6 = /^(?:webkit|moz|o)[A-Z]/, A3 = /^-ms-/, y0 = /-(.)/g, Jb = /;\s*$/, Gf = {}, jf = {}, op = !1, Xb = !1, $f = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    ), e2 = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), nc = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, t2 = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Qf = {}, b0 = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), o = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), l = !1, c = {}, h = /^on./, v = /^on[^A-Z]/, w = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), N = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), _ = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, $ = null, oe = null, ke = null, Ne = !1, ge = !1;
    if (ca)
      try {
        var ve = {};
        Object.defineProperty(ve, "passive", {
          get: function() {
            ge = !0;
          }
        }), window.addEventListener("test", ve, ve), window.removeEventListener("test", ve, ve);
      } catch {
        ge = !1;
      }
    var Ue = null, et = null, Jt = null, ue = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(t) {
        return t.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, re = Sr(ue), fe = st({}, ue, { view: 0, detail: 0 }), Ae = Sr(fe), ze, ut, $e, qe = st({}, fe, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: jg,
      button: 0,
      buttons: 0,
      relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
      },
      movementX: function(t) {
        return "movementX" in t ? t.movementX : (t !== $e && ($e && t.type === "mousemove" ? (ze = t.screenX - $e.screenX, ut = t.screenY - $e.screenY) : ut = ze = 0, $e = t), ze);
      },
      movementY: function(t) {
        return "movementY" in t ? t.movementY : ut;
      }
    }), Wn = Sr(qe), Pt = st({}, qe, { dataTransfer: 0 }), Bl = Sr(Pt), k6 = st({}, fe, { relatedTarget: 0 }), E6 = Sr(k6), PN = st({}, ue, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), ON = Sr(PN), RN = st({}, ue, {
      clipboardData: function(t) {
        return "clipboardData" in t ? t.clipboardData : window.clipboardData;
      }
    }), LN = Sr(RN), DN = st({}, ue, { data: 0 }), f7 = Sr(
      DN
    ), BN = f7, MN = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, FN = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, _N = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    }, UN = st({}, fe, {
      key: function(t) {
        if (t.key) {
          var n = MN[t.key] || t.key;
          if (n !== "Unidentified") return n;
        }
        return t.type === "keypress" ? (t = Yc(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? FN[t.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: jg,
      charCode: function(t) {
        return t.type === "keypress" ? Yc(t) : 0;
      },
      keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      },
      which: function(t) {
        return t.type === "keypress" ? Yc(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      }
    }), zN = Sr(UN), HN = st({}, qe, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), d7 = Sr(HN), VN = st({}, fe, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: jg
    }), WN = Sr(VN), GN = st({}, ue, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), jN = Sr(GN), $N = st({}, qe, {
      deltaX: function(t) {
        return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
      },
      deltaY: function(t) {
        return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), QN = Sr($N), ZN = st({}, ue, {
      newState: 0,
      oldState: 0
    }), YN = Sr(ZN), qN = [9, 13, 27, 32], h7 = 229, S6 = ca && "CompositionEvent" in window, n2 = null;
    ca && "documentMode" in document && (n2 = document.documentMode);
    var KN = ca && "TextEvent" in window && !n2, p7 = ca && (!S6 || n2 && 8 < n2 && 11 >= n2), g7 = 32, m7 = String.fromCharCode(g7), y7 = !1, v0 = !1, JN = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    }, r2 = null, a2 = null, b7 = !1;
    ca && (b7 = $g("input") && (!document.documentMode || 9 < document.documentMode));
    var Pa = typeof Object.is == "function" ? Object.is : k1, XN = ca && "documentMode" in document && 11 >= document.documentMode, w0 = null, A6 = null, o2 = null, x6 = !1, k0 = {
      animationend: pu("Animation", "AnimationEnd"),
      animationiteration: pu("Animation", "AnimationIteration"),
      animationstart: pu("Animation", "AnimationStart"),
      transitionrun: pu("Transition", "TransitionRun"),
      transitionstart: pu("Transition", "TransitionStart"),
      transitioncancel: pu("Transition", "TransitionCancel"),
      transitionend: pu("Transition", "TransitionEnd")
    }, C6 = {}, v7 = {};
    ca && (v7 = document.createElement("div").style, "AnimationEvent" in window || (delete k0.animationend.animation, delete k0.animationiteration.animation, delete k0.animationstart.animation), "TransitionEvent" in window || delete k0.transitionend.transition);
    var w7 = gu("animationend"), k7 = gu("animationiteration"), E7 = gu("animationstart"), eP = gu("transitionrun"), tP = gu("transitionstart"), nP = gu("transitioncancel"), S7 = gu("transitionend"), A7 = /* @__PURE__ */ new Map(), x7 = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
      " "
    ), x3 = 1, i2 = 2, ip = 4, yi = [], E0 = 0, T6 = 0, Zf = {};
    Object.freeze(Zf);
    var bi = null, S0 = null, sn = 0, rP = 1, jr = 2, fa = 8, As = 16, C7 = 64, A0 = En.unstable_now, I6 = -0, C3 = -0, eo = -1.1, sp = -0, T3 = !1, I3 = !1, xs = {
      recordUnsafeLifecycleWarnings: function() {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function() {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    }, s2 = [], l2 = [], u2 = [], c2 = [], f2 = [], d2 = [], lp = /* @__PURE__ */ new Set();
    xs.recordUnsafeLifecycleWarnings = function(t, n) {
      lp.has(t.type) || (typeof n.componentWillMount == "function" && n.componentWillMount.__suppressDeprecationWarning !== !0 && s2.push(t), t.mode & fa && typeof n.UNSAFE_componentWillMount == "function" && l2.push(t), typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && u2.push(t), t.mode & fa && typeof n.UNSAFE_componentWillReceiveProps == "function" && c2.push(t), typeof n.componentWillUpdate == "function" && n.componentWillUpdate.__suppressDeprecationWarning !== !0 && f2.push(t), t.mode & fa && typeof n.UNSAFE_componentWillUpdate == "function" && d2.push(t));
    }, xs.flushPendingUnsafeLifecycleWarnings = function() {
      var t = /* @__PURE__ */ new Set();
      0 < s2.length && (s2.forEach(function(I) {
        t.add(
          Z(I) || "Component"
        ), lp.add(I.type);
      }), s2 = []);
      var n = /* @__PURE__ */ new Set();
      0 < l2.length && (l2.forEach(function(I) {
        n.add(
          Z(I) || "Component"
        ), lp.add(I.type);
      }), l2 = []);
      var s = /* @__PURE__ */ new Set();
      0 < u2.length && (u2.forEach(function(I) {
        s.add(
          Z(I) || "Component"
        ), lp.add(I.type);
      }), u2 = []);
      var f = /* @__PURE__ */ new Set();
      0 < c2.length && (c2.forEach(
        function(I) {
          f.add(
            Z(I) || "Component"
          ), lp.add(I.type);
        }
      ), c2 = []);
      var p = /* @__PURE__ */ new Set();
      0 < f2.length && (f2.forEach(function(I) {
        p.add(
          Z(I) || "Component"
        ), lp.add(I.type);
      }), f2 = []);
      var m = /* @__PURE__ */ new Set();
      if (0 < d2.length && (d2.forEach(function(I) {
        m.add(
          Z(I) || "Component"
        ), lp.add(I.type);
      }), d2 = []), 0 < n.size) {
        var E = x(
          n
        );
        console.error(
          `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
          E
        );
      }
      0 < f.size && (E = x(
        f
      ), console.error(
        `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`,
        E
      )), 0 < m.size && (E = x(
        m
      ), console.error(
        `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
        E
      )), 0 < t.size && (E = x(t), console.warn(
        `componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        E
      )), 0 < s.size && (E = x(
        s
      ), console.warn(
        `componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        E
      )), 0 < p.size && (E = x(p), console.warn(
        `componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        E
      ));
    };
    var N3 = /* @__PURE__ */ new Map(), T7 = /* @__PURE__ */ new Set();
    xs.recordLegacyContextWarning = function(t, n) {
      for (var s = null, f = t; f !== null; )
        f.mode & fa && (s = f), f = f.return;
      s === null ? console.error(
        "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
      ) : !T7.has(t.type) && (f = N3.get(s), t.type.contextTypes != null || t.type.childContextTypes != null || n !== null && typeof n.getChildContext == "function") && (f === void 0 && (f = [], N3.set(s, f)), f.push(t));
    }, xs.flushLegacyContextWarning = function() {
      N3.forEach(function(t) {
        if (t.length !== 0) {
          var n = t[0], s = /* @__PURE__ */ new Set();
          t.forEach(function(p) {
            s.add(Z(p) || "Component"), T7.add(p.type);
          });
          var f = x(s);
          V(n, function() {
            console.error(
              `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`,
              f
            );
          });
        }
      });
    }, xs.discardPendingWarnings = function() {
      s2 = [], l2 = [], u2 = [], c2 = [], f2 = [], d2 = [], N3 = /* @__PURE__ */ new Map();
    };
    var N6 = /* @__PURE__ */ new WeakMap(), x0 = [], C0 = 0, P3 = null, O3 = 0, vi = [], wi = 0, up = null, rc = 1, ac = "", Oa = null, $r = null, It = !1, oc = !1, ki = null, Cs = null, Ml = !1, P6 = Error(
      "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), R3 = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"
    ), I7 = Error(
      "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), O6 = {
      then: function() {
        console.error(
          'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
        );
      }
    }, h2 = null, L3 = !1, N7 = {
      "react-stack-bottom-frame": function(t, n, s) {
        var f = Ta;
        Ta = !0;
        try {
          return t(n, s);
        } finally {
          Ta = f;
        }
      }
    }, R6 = N7["react-stack-bottom-frame"].bind(N7), P7 = {
      "react-stack-bottom-frame": function(t) {
        var n = Ta;
        Ta = !0;
        try {
          return t.render();
        } finally {
          Ta = n;
        }
      }
    }, O7 = P7["react-stack-bottom-frame"].bind(P7), R7 = {
      "react-stack-bottom-frame": function(t, n) {
        try {
          n.componentDidMount();
        } catch (s) {
          Rt(t, t.return, s);
        }
      }
    }, L6 = R7["react-stack-bottom-frame"].bind(R7), L7 = {
      "react-stack-bottom-frame": function(t, n, s, f, p) {
        try {
          n.componentDidUpdate(s, f, p);
        } catch (m) {
          Rt(t, t.return, m);
        }
      }
    }, D7 = L7["react-stack-bottom-frame"].bind(L7), B7 = {
      "react-stack-bottom-frame": function(t, n) {
        var s = n.stack;
        t.componentDidCatch(n.value, {
          componentStack: s !== null ? s : ""
        });
      }
    }, aP = B7["react-stack-bottom-frame"].bind(B7), M7 = {
      "react-stack-bottom-frame": function(t, n, s) {
        try {
          s.componentWillUnmount();
        } catch (f) {
          Rt(t, n, f);
        }
      }
    }, F7 = M7["react-stack-bottom-frame"].bind(M7), _7 = {
      "react-stack-bottom-frame": function(t) {
        var n = t.create;
        return t = t.inst, n = n(), t.destroy = n;
      }
    }, oP = _7["react-stack-bottom-frame"].bind(_7), U7 = {
      "react-stack-bottom-frame": function(t, n, s) {
        try {
          s();
        } catch (f) {
          Rt(t, n, f);
        }
      }
    }, iP = U7["react-stack-bottom-frame"].bind(U7), z7 = {
      "react-stack-bottom-frame": function(t) {
        var n = t._init;
        return n(t._payload);
      }
    }, Yf = z7["react-stack-bottom-frame"].bind(z7), T0 = null, p2 = 0, dt = null, D6, H7 = D6 = !1, V7 = {}, W7 = {}, G7 = {};
    A = function(t, n, s) {
      if (s !== null && typeof s == "object" && s._store && (!s._store.validated && s.key == null || s._store.validated === 2)) {
        if (typeof s._store != "object")
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        s._store.validated = 1;
        var f = Z(t), p = f || "null";
        if (!V7[p]) {
          V7[p] = !0, s = s._owner, t = t._debugOwner;
          var m = "";
          t && typeof t.tag == "number" && (p = Z(t)) && (m = `

Check the render method of \`` + p + "`."), m || f && (m = `

Check the top-level render call using <` + f + ">.");
          var E = "";
          s != null && t !== s && (f = null, typeof s.tag == "number" ? f = Z(s) : typeof s.name == "string" && (f = s.name), f && (E = " It was passed a child from " + f + ".")), V(n, function() {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              m,
              E
            );
          });
        }
      }
    };
    var cp = O1(!0), j7 = O1(!1), I0 = ce(null), D3 = ce(0), Ei = ce(null), ic = null, N0 = 1, g2 = 2, br = ce(0), Si = 0, Ai = 1, Ra = 2, Qr = 4, vr = 8, sP = typeof AbortController < "u" ? AbortController : function() {
      var t = [], n = this.signal = {
        aborted: !1,
        addEventListener: function(s, f) {
          t.push(f);
        }
      };
      this.abort = function() {
        n.aborted = !0, t.forEach(function(s) {
          return s();
        });
      };
    }, lP = En.unstable_scheduleCallback, uP = En.unstable_NormalPriority, wr = {
      $$typeof: Ca,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, m2 = null, B6 = 0, fp = 0, P0 = null, $7 = me.S;
    me.S = function(t, n) {
      typeof n == "object" && n !== null && typeof n.then == "function" && Hw(t, n), $7 !== null && $7(t, n);
    };
    var dp = ce(null), O0, Q7 = /* @__PURE__ */ new Set(), Z7 = /* @__PURE__ */ new Set(), M6 = /* @__PURE__ */ new Set(), Y7 = /* @__PURE__ */ new Set(), qf = 0, nt = null, Zt = null, ir = null, B3 = !1, R0 = !1, hp = !1, M3 = 0, y2 = 0, sc = null, cP = 0, fP = 25, be = null, xi = null, lc = -1, b2 = !1, F6 = function() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }, Fl = {
      readContext: qt,
      use: qi,
      useCallback: pn,
      useContext: pn,
      useEffect: pn,
      useImperativeHandle: pn,
      useLayoutEffect: pn,
      useInsertionEffect: pn,
      useMemo: pn,
      useReducer: pn,
      useRef: pn,
      useState: pn,
      useDebugValue: pn,
      useDeferredValue: pn,
      useTransition: pn,
      useSyncExternalStore: pn,
      useId: pn
    };
    Fl.useCacheRefresh = pn, Fl.useMemoCache = pn, Fl.useHostTransitionStatus = pn, Fl.useFormState = pn, Fl.useActionState = pn, Fl.useOptimistic = pn;
    var Kf = null, pp = null, Jf = null, gp = null, to = null, La = null, Xf = null;
    Kf = {
      readContext: function(t) {
        return qt(t);
      },
      use: qi,
      useCallback: function(t, n) {
        return be = "useCallback", ht(), Eu(n), sm(t, n);
      },
      useContext: function(t) {
        return be = "useContext", ht(), qt(t);
      },
      useEffect: function(t, n) {
        return be = "useEffect", ht(), Eu(n), il(t, n);
      },
      useImperativeHandle: function(t, n, s) {
        return be = "useImperativeHandle", ht(), Eu(s), lf(t, n, s);
      },
      useInsertionEffect: function(t, n) {
        be = "useInsertionEffect", ht(), Eu(n), ol(4, Ra, t, n);
      },
      useLayoutEffect: function(t, n) {
        return be = "useLayoutEffect", ht(), Eu(n), of(t, n);
      },
      useMemo: function(t, n) {
        be = "useMemo", ht(), Eu(n);
        var s = me.H;
        me.H = to;
        try {
          return lm(t, n);
        } finally {
          me.H = s;
        }
      },
      useReducer: function(t, n, s) {
        be = "useReducer", ht();
        var f = me.H;
        me.H = to;
        try {
          return nl(t, n, s);
        } finally {
          me.H = f;
        }
      },
      useRef: function(t) {
        return be = "useRef", ht(), Tu(t);
      },
      useState: function(t) {
        be = "useState", ht();
        var n = me.H;
        me.H = to;
        try {
          return pr(t);
        } finally {
          me.H = n;
        }
      },
      useDebugValue: function() {
        be = "useDebugValue", ht();
      },
      useDeferredValue: function(t, n) {
        return be = "useDeferredValue", ht(), uf(t, n);
      },
      useTransition: function() {
        return be = "useTransition", ht(), wo();
      },
      useSyncExternalStore: function(t, n, s) {
        return be = "useSyncExternalStore", ht(), oa(
          t,
          n,
          s
        );
      },
      useId: function() {
        return be = "useId", ht(), z1();
      },
      useCacheRefresh: function() {
        return be = "useCacheRefresh", ht(), H1();
      }
    }, Kf.useMemoCache = Xn, Kf.useHostTransitionStatus = Iu, Kf.useFormState = function(t, n) {
      return be = "useFormState", ht(), uh(), Yo(t, n);
    }, Kf.useActionState = function(t, n) {
      return be = "useActionState", ht(), Yo(t, n);
    }, Kf.useOptimistic = function(t) {
      return be = "useOptimistic", ht(), Fn(t);
    }, pp = {
      readContext: function(t) {
        return qt(t);
      },
      use: qi,
      useCallback: function(t, n) {
        return be = "useCallback", Le(), sm(t, n);
      },
      useContext: function(t) {
        return be = "useContext", Le(), qt(t);
      },
      useEffect: function(t, n) {
        return be = "useEffect", Le(), il(t, n);
      },
      useImperativeHandle: function(t, n, s) {
        return be = "useImperativeHandle", Le(), lf(t, n, s);
      },
      useInsertionEffect: function(t, n) {
        be = "useInsertionEffect", Le(), ol(4, Ra, t, n);
      },
      useLayoutEffect: function(t, n) {
        return be = "useLayoutEffect", Le(), of(t, n);
      },
      useMemo: function(t, n) {
        be = "useMemo", Le();
        var s = me.H;
        me.H = to;
        try {
          return lm(t, n);
        } finally {
          me.H = s;
        }
      },
      useReducer: function(t, n, s) {
        be = "useReducer", Le();
        var f = me.H;
        me.H = to;
        try {
          return nl(t, n, s);
        } finally {
          me.H = f;
        }
      },
      useRef: function(t) {
        return be = "useRef", Le(), Tu(t);
      },
      useState: function(t) {
        be = "useState", Le();
        var n = me.H;
        me.H = to;
        try {
          return pr(t);
        } finally {
          me.H = n;
        }
      },
      useDebugValue: function() {
        be = "useDebugValue", Le();
      },
      useDeferredValue: function(t, n) {
        return be = "useDeferredValue", Le(), uf(t, n);
      },
      useTransition: function() {
        return be = "useTransition", Le(), wo();
      },
      useSyncExternalStore: function(t, n, s) {
        return be = "useSyncExternalStore", Le(), oa(
          t,
          n,
          s
        );
      },
      useId: function() {
        return be = "useId", Le(), z1();
      },
      useCacheRefresh: function() {
        return be = "useCacheRefresh", Le(), H1();
      }
    }, pp.useMemoCache = Xn, pp.useHostTransitionStatus = Iu, pp.useFormState = function(t, n) {
      return be = "useFormState", Le(), uh(), Yo(t, n);
    }, pp.useActionState = function(t, n) {
      return be = "useActionState", Le(), Yo(t, n);
    }, pp.useOptimistic = function(t) {
      return be = "useOptimistic", Le(), Fn(t);
    }, Jf = {
      readContext: function(t) {
        return qt(t);
      },
      use: qi,
      useCallback: function(t, n) {
        return be = "useCallback", Le(), qo(t, n);
      },
      useContext: function(t) {
        return be = "useContext", Le(), qt(t);
      },
      useEffect: function(t, n) {
        be = "useEffect", Le(), _n(2048, vr, t, n);
      },
      useImperativeHandle: function(t, n, s) {
        return be = "useImperativeHandle", Le(), ph(t, n, s);
      },
      useInsertionEffect: function(t, n) {
        return be = "useInsertionEffect", Le(), _n(4, Ra, t, n);
      },
      useLayoutEffect: function(t, n) {
        return be = "useLayoutEffect", Le(), _n(4, Qr, t, n);
      },
      useMemo: function(t, n) {
        be = "useMemo", Le();
        var s = me.H;
        me.H = La;
        try {
          return Ji(t, n);
        } finally {
          me.H = s;
        }
      },
      useReducer: function(t, n, s) {
        be = "useReducer", Le();
        var f = me.H;
        me.H = La;
        try {
          return Ki(t, n, s);
        } finally {
          me.H = f;
        }
      },
      useRef: function() {
        return be = "useRef", Le(), Nt().memoizedState;
      },
      useState: function() {
        be = "useState", Le();
        var t = me.H;
        me.H = La;
        try {
          return Ki(xr);
        } finally {
          me.H = t;
        }
      },
      useDebugValue: function() {
        be = "useDebugValue", Le();
      },
      useDeferredValue: function(t, n) {
        return be = "useDeferredValue", Le(), _1(t, n);
      },
      useTransition: function() {
        return be = "useTransition", Le(), Cn();
      },
      useSyncExternalStore: function(t, n, s) {
        return be = "useSyncExternalStore", Le(), $o(
          t,
          n,
          s
        );
      },
      useId: function() {
        return be = "useId", Le(), Nt().memoizedState;
      },
      useCacheRefresh: function() {
        return be = "useCacheRefresh", Le(), Nt().memoizedState;
      }
    }, Jf.useMemoCache = Xn, Jf.useHostTransitionStatus = Iu, Jf.useFormState = function(t) {
      return be = "useFormState", Le(), uh(), hh(t);
    }, Jf.useActionState = function(t) {
      return be = "useActionState", Le(), hh(t);
    }, Jf.useOptimistic = function(t, n) {
      return be = "useOptimistic", Le(), Tt(t, n);
    }, gp = {
      readContext: function(t) {
        return qt(t);
      },
      use: qi,
      useCallback: function(t, n) {
        return be = "useCallback", Le(), qo(t, n);
      },
      useContext: function(t) {
        return be = "useContext", Le(), qt(t);
      },
      useEffect: function(t, n) {
        be = "useEffect", Le(), _n(2048, vr, t, n);
      },
      useImperativeHandle: function(t, n, s) {
        return be = "useImperativeHandle", Le(), ph(t, n, s);
      },
      useInsertionEffect: function(t, n) {
        return be = "useInsertionEffect", Le(), _n(4, Ra, t, n);
      },
      useLayoutEffect: function(t, n) {
        return be = "useLayoutEffect", Le(), _n(4, Qr, t, n);
      },
      useMemo: function(t, n) {
        be = "useMemo", Le();
        var s = me.H;
        me.H = Xf;
        try {
          return Ji(t, n);
        } finally {
          me.H = s;
        }
      },
      useReducer: function(t, n, s) {
        be = "useReducer", Le();
        var f = me.H;
        me.H = Xf;
        try {
          return Cr(t, n, s);
        } finally {
          me.H = f;
        }
      },
      useRef: function() {
        return be = "useRef", Le(), Nt().memoizedState;
      },
      useState: function() {
        be = "useState", Le();
        var t = me.H;
        me.H = Xf;
        try {
          return Cr(xr);
        } finally {
          me.H = t;
        }
      },
      useDebugValue: function() {
        be = "useDebugValue", Le();
      },
      useDeferredValue: function(t, n) {
        return be = "useDeferredValue", Le(), um(t, n);
      },
      useTransition: function() {
        return be = "useTransition", Le(), mh();
      },
      useSyncExternalStore: function(t, n, s) {
        return be = "useSyncExternalStore", Le(), $o(
          t,
          n,
          s
        );
      },
      useId: function() {
        return be = "useId", Le(), Nt().memoizedState;
      },
      useCacheRefresh: function() {
        return be = "useCacheRefresh", Le(), Nt().memoizedState;
      }
    }, gp.useMemoCache = Xn, gp.useHostTransitionStatus = Iu, gp.useFormState = function(t) {
      return be = "useFormState", Le(), uh(), xu(t);
    }, gp.useActionState = function(t) {
      return be = "useActionState", Le(), xu(t);
    }, gp.useOptimistic = function(t, n) {
      return be = "useOptimistic", Le(), vo(t, n);
    }, to = {
      readContext: function(t) {
        return k(), qt(t);
      },
      use: function(t) {
        return y(), qi(t);
      },
      useCallback: function(t, n) {
        return be = "useCallback", y(), ht(), sm(t, n);
      },
      useContext: function(t) {
        return be = "useContext", y(), ht(), qt(t);
      },
      useEffect: function(t, n) {
        return be = "useEffect", y(), ht(), il(t, n);
      },
      useImperativeHandle: function(t, n, s) {
        return be = "useImperativeHandle", y(), ht(), lf(t, n, s);
      },
      useInsertionEffect: function(t, n) {
        be = "useInsertionEffect", y(), ht(), ol(4, Ra, t, n);
      },
      useLayoutEffect: function(t, n) {
        return be = "useLayoutEffect", y(), ht(), of(t, n);
      },
      useMemo: function(t, n) {
        be = "useMemo", y(), ht();
        var s = me.H;
        me.H = to;
        try {
          return lm(t, n);
        } finally {
          me.H = s;
        }
      },
      useReducer: function(t, n, s) {
        be = "useReducer", y(), ht();
        var f = me.H;
        me.H = to;
        try {
          return nl(t, n, s);
        } finally {
          me.H = f;
        }
      },
      useRef: function(t) {
        return be = "useRef", y(), ht(), Tu(t);
      },
      useState: function(t) {
        be = "useState", y(), ht();
        var n = me.H;
        me.H = to;
        try {
          return pr(t);
        } finally {
          me.H = n;
        }
      },
      useDebugValue: function() {
        be = "useDebugValue", y(), ht();
      },
      useDeferredValue: function(t, n) {
        return be = "useDeferredValue", y(), ht(), uf(t, n);
      },
      useTransition: function() {
        return be = "useTransition", y(), ht(), wo();
      },
      useSyncExternalStore: function(t, n, s) {
        return be = "useSyncExternalStore", y(), ht(), oa(
          t,
          n,
          s
        );
      },
      useId: function() {
        return be = "useId", y(), ht(), z1();
      },
      useCacheRefresh: function() {
        return be = "useCacheRefresh", ht(), H1();
      },
      useMemoCache: function(t) {
        return y(), Xn(t);
      }
    }, to.useHostTransitionStatus = Iu, to.useFormState = function(t, n) {
      return be = "useFormState", y(), ht(), Yo(t, n);
    }, to.useActionState = function(t, n) {
      return be = "useActionState", y(), ht(), Yo(t, n);
    }, to.useOptimistic = function(t) {
      return be = "useOptimistic", y(), ht(), Fn(t);
    }, La = {
      readContext: function(t) {
        return k(), qt(t);
      },
      use: function(t) {
        return y(), qi(t);
      },
      useCallback: function(t, n) {
        return be = "useCallback", y(), Le(), qo(t, n);
      },
      useContext: function(t) {
        return be = "useContext", y(), Le(), qt(t);
      },
      useEffect: function(t, n) {
        be = "useEffect", y(), Le(), _n(2048, vr, t, n);
      },
      useImperativeHandle: function(t, n, s) {
        return be = "useImperativeHandle", y(), Le(), ph(t, n, s);
      },
      useInsertionEffect: function(t, n) {
        return be = "useInsertionEffect", y(), Le(), _n(4, Ra, t, n);
      },
      useLayoutEffect: function(t, n) {
        return be = "useLayoutEffect", y(), Le(), _n(4, Qr, t, n);
      },
      useMemo: function(t, n) {
        be = "useMemo", y(), Le();
        var s = me.H;
        me.H = La;
        try {
          return Ji(t, n);
        } finally {
          me.H = s;
        }
      },
      useReducer: function(t, n, s) {
        be = "useReducer", y(), Le();
        var f = me.H;
        me.H = La;
        try {
          return Ki(t, n, s);
        } finally {
          me.H = f;
        }
      },
      useRef: function() {
        return be = "useRef", y(), Le(), Nt().memoizedState;
      },
      useState: function() {
        be = "useState", y(), Le();
        var t = me.H;
        me.H = La;
        try {
          return Ki(xr);
        } finally {
          me.H = t;
        }
      },
      useDebugValue: function() {
        be = "useDebugValue", y(), Le();
      },
      useDeferredValue: function(t, n) {
        return be = "useDeferredValue", y(), Le(), _1(t, n);
      },
      useTransition: function() {
        return be = "useTransition", y(), Le(), Cn();
      },
      useSyncExternalStore: function(t, n, s) {
        return be = "useSyncExternalStore", y(), Le(), $o(
          t,
          n,
          s
        );
      },
      useId: function() {
        return be = "useId", y(), Le(), Nt().memoizedState;
      },
      useCacheRefresh: function() {
        return be = "useCacheRefresh", Le(), Nt().memoizedState;
      },
      useMemoCache: function(t) {
        return y(), Xn(t);
      }
    }, La.useHostTransitionStatus = Iu, La.useFormState = function(t) {
      return be = "useFormState", y(), Le(), hh(t);
    }, La.useActionState = function(t) {
      return be = "useActionState", y(), Le(), hh(t);
    }, La.useOptimistic = function(t, n) {
      return be = "useOptimistic", y(), Le(), Tt(t, n);
    }, Xf = {
      readContext: function(t) {
        return k(), qt(t);
      },
      use: function(t) {
        return y(), qi(t);
      },
      useCallback: function(t, n) {
        return be = "useCallback", y(), Le(), qo(t, n);
      },
      useContext: function(t) {
        return be = "useContext", y(), Le(), qt(t);
      },
      useEffect: function(t, n) {
        be = "useEffect", y(), Le(), _n(2048, vr, t, n);
      },
      useImperativeHandle: function(t, n, s) {
        return be = "useImperativeHandle", y(), Le(), ph(t, n, s);
      },
      useInsertionEffect: function(t, n) {
        return be = "useInsertionEffect", y(), Le(), _n(4, Ra, t, n);
      },
      useLayoutEffect: function(t, n) {
        return be = "useLayoutEffect", y(), Le(), _n(4, Qr, t, n);
      },
      useMemo: function(t, n) {
        be = "useMemo", y(), Le();
        var s = me.H;
        me.H = La;
        try {
          return Ji(t, n);
        } finally {
          me.H = s;
        }
      },
      useReducer: function(t, n, s) {
        be = "useReducer", y(), Le();
        var f = me.H;
        me.H = La;
        try {
          return Cr(t, n, s);
        } finally {
          me.H = f;
        }
      },
      useRef: function() {
        return be = "useRef", y(), Le(), Nt().memoizedState;
      },
      useState: function() {
        be = "useState", y(), Le();
        var t = me.H;
        me.H = La;
        try {
          return Cr(xr);
        } finally {
          me.H = t;
        }
      },
      useDebugValue: function() {
        be = "useDebugValue", y(), Le();
      },
      useDeferredValue: function(t, n) {
        return be = "useDeferredValue", y(), Le(), um(t, n);
      },
      useTransition: function() {
        return be = "useTransition", y(), Le(), mh();
      },
      useSyncExternalStore: function(t, n, s) {
        return be = "useSyncExternalStore", y(), Le(), $o(
          t,
          n,
          s
        );
      },
      useId: function() {
        return be = "useId", y(), Le(), Nt().memoizedState;
      },
      useCacheRefresh: function() {
        return be = "useCacheRefresh", Le(), Nt().memoizedState;
      },
      useMemoCache: function(t) {
        return y(), Xn(t);
      }
    }, Xf.useHostTransitionStatus = Iu, Xf.useFormState = function(t) {
      return be = "useFormState", y(), Le(), xu(t);
    }, Xf.useActionState = function(t) {
      return be = "useActionState", y(), Le(), xu(t);
    }, Xf.useOptimistic = function(t, n) {
      return be = "useOptimistic", y(), Le(), vo(t, n);
    };
    var q7 = {}, K7 = /* @__PURE__ */ new Set(), J7 = /* @__PURE__ */ new Set(), X7 = /* @__PURE__ */ new Set(), eS = /* @__PURE__ */ new Set(), tS = /* @__PURE__ */ new Set(), nS = /* @__PURE__ */ new Set(), rS = /* @__PURE__ */ new Set(), aS = /* @__PURE__ */ new Set(), oS = /* @__PURE__ */ new Set(), iS = /* @__PURE__ */ new Set();
    Object.freeze(q7);
    var _6 = {
      isMounted: function(t) {
        var n = Pr;
        if (n !== null && Ta && n.tag === 1) {
          var s = n.stateNode;
          s._warnedAboutRefsInRender || console.error(
            "%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",
            Z(n) || "A component"
          ), s._warnedAboutRefsInRender = !0;
        }
        return (t = t._reactInternals) ? B(t) === t : !1;
      },
      enqueueSetState: function(t, n, s) {
        t = t._reactInternals;
        var f = Hr(t), p = os(f);
        p.payload = n, s != null && (cm(s), p.callback = s), n = is(t, p, f), n !== null && (Vt(n, t, f), xh(n, t, f)), Xr(t, f);
      },
      enqueueReplaceState: function(t, n, s) {
        t = t._reactInternals;
        var f = Hr(t), p = os(f);
        p.tag = mS, p.payload = n, s != null && (cm(s), p.callback = s), n = is(t, p, f), n !== null && (Vt(n, t, f), xh(n, t, f)), Xr(t, f);
      },
      enqueueForceUpdate: function(t, n) {
        t = t._reactInternals;
        var s = Hr(t), f = os(s);
        f.tag = yS, n != null && (cm(n), f.callback = n), n = is(t, f, s), n !== null && (Vt(n, t, s), xh(n, t, s)), Me !== null && typeof Me.markForceUpdateScheduled == "function" && Me.markForceUpdateScheduled(t, s);
      }
    }, F3 = typeof reportError == "function" ? reportError : function(t) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var n = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof t == "object" && t !== null && typeof t.message == "string" ? String(t.message) : String(t),
          error: t
        });
        if (!window.dispatchEvent(n)) return;
      } else if (typeof Gs == "object" && typeof Gs.emit == "function") {
        Gs.emit("uncaughtException", t);
        return;
      }
      console.error(t);
    }, L0 = null, U6 = null, sS = Error(
      "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
    ), Lr = !1, lS = {}, uS = {}, cS = {}, fS = {}, D0 = !1, dS = {}, z6 = {}, H6 = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0
    }, hS = !1, V6 = ce(null), W6 = ce(null), pS = {}, _3 = null, B0 = null, M0 = !1, gS = 0, mS = 1, yS = 2, G6 = 3, ed = !1, bS = !1, j6 = null, $6 = !1, vS = null;
    vS = /* @__PURE__ */ new Set();
    var uc = !1, In = !1, Q6 = !1, wS = typeof WeakSet == "function" ? WeakSet : Set, Dr = null, F0 = null, _0 = null, kS = !1, sr = null, Po = !1, Ts = null, v2 = 8192, ES = !1;
    try {
      var fW = Object.preventExtensions({});
    } catch {
      ES = !0;
    }
    var dP = {
      getCacheForType: function(t) {
        var n = qt(wr), s = n.data.get(t);
        return s === void 0 && (s = t(), n.data.set(t, s)), s;
      },
      getOwner: function() {
        return Pr;
      }
    };
    if (typeof Symbol == "function" && Symbol.for) {
      var w2 = Symbol.for;
      w2("selector.component"), w2("selector.has_pseudo_class"), w2("selector.role"), w2("selector.test_id"), w2("selector.text");
    }
    var hP = [], pP = typeof WeakMap == "function" ? WeakMap : Map, Oo = 0, Da = 2, cc = 4, fc = 0, k2 = 1, U0 = 2, Z6 = 3, mp = 4, SS = 5, U3 = 6, fn = Oo, Xt = null, kt = null, St = 0, no = 0, E2 = 1, yp = 2, S2 = 3, AS = 4, Y6 = 5, z0 = 6, A2 = 7, q6 = 8, en = no, Ro = null, dc = !1, H0 = !1, K6 = !1, _l = 0, Nn = fc, td = 0, nd = 0, J6 = 0, Lo = 0, bp = 0, x2 = null, Is = null, z3 = !1, X6 = 0, xS = 300, H3 = 1 / 0, CS = 500, C2 = null, rd = null, V3 = !1, vp = null, T2 = 0, e8 = 0, t8 = null, gP = 50, I2 = 0, n8 = null, r8 = !1, W3 = !1, mP = 50, wp = 0, N2 = null, V0 = !1, TS = 0, yP = 1, bP = 2, G3 = null, IS = !1, NS = /* @__PURE__ */ new Set(), vP = {}, j3 = null, W0 = null, a8 = !1, o8 = !1, $3 = !1, i8 = !1, kp = 0, s8 = {};
    (function() {
      for (var t = 0; t < x7.length; t++) {
        var n = x7[t], s = n.toLowerCase();
        n = n[0].toUpperCase() + n.slice(1), pa(s, "on" + n);
      }
      pa(w7, "onAnimationEnd"), pa(k7, "onAnimationIteration"), pa(E7, "onAnimationStart"), pa("dblclick", "onDoubleClick"), pa("focusin", "onFocus"), pa("focusout", "onBlur"), pa(eP, "onTransitionRun"), pa(tP, "onTransitionStart"), pa(nP, "onTransitionCancel"), pa(S7, "onTransitionEnd");
    })(), Ho("onMouseEnter", ["mouseout", "mouseover"]), Ho("onMouseLeave", ["mouseout", "mouseover"]), Ho("onPointerEnter", ["pointerout", "pointerover"]), Ho("onPointerLeave", ["pointerout", "pointerover"]), Vi(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ), Vi(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), Vi("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), Vi(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), Vi(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), Vi(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var P2 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), l8 = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(P2)
    ), Q3 = "_reactListening" + Math.random().toString(36).slice(2), PS = !1, OS = !1, Z3 = !1, RS = !1, Y3 = !1, q3 = !1, LS = !1, K3 = {}, wP = /\r\n?/g, kP = /\u0000|\uFFFD/g, Ep = "http://www.w3.org/1999/xlink", u8 = "http://www.w3.org/XML/1998/namespace", EP = "javascript:throw new Error('React form unexpectedly submitted.')", SP = "suppressHydrationWarning", J3 = "$", X3 = "/$", Sp = "$?", Ap = "$!", c8 = "F!", DS = "F", AP = "style", ad = 0, G0 = 1, e4 = 2, f8 = null, d8 = null, BS = { dialog: !0, webview: !0 }, h8 = null, MS = typeof setTimeout == "function" ? setTimeout : void 0, xP = typeof clearTimeout == "function" ? clearTimeout : void 0, p8 = -1, FS = typeof Promise == "function" ? Promise : void 0, CP = typeof queueMicrotask == "function" ? queueMicrotask : typeof FS < "u" ? function(t) {
      return FS.resolve(null).then(t).catch(xt);
    } : MS, xp = 0, O2 = 1, _S = 2, US = 3, Ci = 4, Ti = /* @__PURE__ */ new Map(), zS = /* @__PURE__ */ new Set(), hc = Qt.d;
    Qt.d = {
      f: function() {
        var t = hc.f(), n = va();
        return t || n;
      },
      r: function(t) {
        var n = fo(t);
        n !== null && n.tag === 5 && n.type === "form" ? Xi(n) : hc.r(t);
      },
      D: function(t) {
        hc.D(t), Lf("dns-prefetch", t, null);
      },
      C: function(t, n) {
        hc.C(t, n), Lf("preconnect", t, n);
      },
      L: function(t, n, s) {
        hc.L(t, n, s);
        var f = j0;
        if (f && t && n) {
          var p = 'link[rel="preload"][as="' + ho(n) + '"]';
          n === "image" && s && s.imageSrcSet ? (p += '[imagesrcset="' + ho(
            s.imageSrcSet
          ) + '"]', typeof s.imageSizes == "string" && (p += '[imagesizes="' + ho(
            s.imageSizes
          ) + '"]')) : p += '[href="' + ho(t) + '"]';
          var m = p;
          switch (n) {
            case "style":
              m = Qu(t);
              break;
            case "script":
              m = Zu(t);
          }
          Ti.has(m) || (t = st(
            {
              rel: "preload",
              href: n === "image" && s && s.imageSrcSet ? void 0 : t,
              as: n
            },
            s
          ), Ti.set(m, t), f.querySelector(p) !== null || n === "style" && f.querySelector(
            Vn(m)
          ) || n === "script" && f.querySelector(Gh(m)) || (n = f.createElement("link"), cn(n, "link", t), Dn(n), f.head.appendChild(n)));
        }
      },
      m: function(t, n) {
        hc.m(t, n);
        var s = j0;
        if (s && t) {
          var f = n && typeof n.as == "string" ? n.as : "script", p = 'link[rel="modulepreload"][as="' + ho(f) + '"][href="' + ho(t) + '"]', m = p;
          switch (f) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              m = Zu(t);
          }
          if (!Ti.has(m) && (t = st({ rel: "modulepreload", href: t }, n), Ti.set(m, t), s.querySelector(p) === null)) {
            switch (f) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (s.querySelector(Gh(m)))
                  return;
            }
            f = s.createElement("link"), cn(f, "link", t), Dn(f), s.head.appendChild(f);
          }
        }
      },
      X: function(t, n) {
        hc.X(t, n);
        var s = j0;
        if (s && t) {
          var f = su(s).hoistableScripts, p = Zu(t), m = f.get(p);
          m || (m = s.querySelector(
            Gh(p)
          ), m || (t = st({ src: t, async: !0 }, n), (n = Ti.get(p)) && wl(t, n), m = s.createElement("script"), Dn(m), cn(m, "link", t), s.head.appendChild(m)), m = {
            type: "script",
            instance: m,
            count: 1,
            state: null
          }, f.set(p, m));
        }
      },
      S: function(t, n, s) {
        hc.S(t, n, s);
        var f = j0;
        if (f && t) {
          var p = su(f).hoistableStyles, m = Qu(t);
          n = n || "default";
          var E = p.get(m);
          if (!E) {
            var I = { loading: xp, preload: null };
            if (E = f.querySelector(
              Vn(m)
            ))
              I.loading = O2 | Ci;
            else {
              t = st(
                {
                  rel: "stylesheet",
                  href: t,
                  "data-precedence": n
                },
                s
              ), (s = Ti.get(m)) && jh(t, s);
              var F = E = f.createElement("link");
              Dn(F), cn(F, "link", t), F._p = new Promise(function(z, de) {
                F.onload = z, F.onerror = de;
              }), F.addEventListener("load", function() {
                I.loading |= O2;
              }), F.addEventListener("error", function() {
                I.loading |= _S;
              }), I.loading |= Ci, Yu(E, n, f);
            }
            E = {
              type: "stylesheet",
              instance: E,
              count: 1,
              state: I
            }, p.set(m, E);
          }
        }
      },
      M: function(t, n) {
        hc.M(t, n);
        var s = j0;
        if (s && t) {
          var f = su(s).hoistableScripts, p = Zu(t), m = f.get(p);
          m || (m = s.querySelector(
            Gh(p)
          ), m || (t = st({ src: t, async: !0, type: "module" }, n), (n = Ti.get(p)) && wl(t, n), m = s.createElement("script"), Dn(m), cn(m, "link", t), s.head.appendChild(m)), m = {
            type: "script",
            instance: m,
            count: 1,
            state: null
          }, f.set(p, m));
        }
      }
    };
    var j0 = typeof document > "u" ? null : document, t4 = null, R2 = null, g8 = null, n4 = null, Cp = f6, L2 = {
      $$typeof: Ca,
      Provider: null,
      Consumer: null,
      _currentValue: Cp,
      _currentValue2: Cp,
      _threadCount: 0
    }, HS = "%c%s%c ", VS = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", WS = "", r4 = " ", GS = Function.prototype.bind, jS = !1, $S = null, QS = null, ZS = null, YS = null, qS = null, KS = null, JS = null, XS = null, eA = null;
    $S = function(t, n, s, f) {
      n = a(t, n), n !== null && (s = e(n.memoizedState, s, 0, f), n.memoizedState = s, n.baseState = s, t.memoizedProps = st({}, t.memoizedProps), s = dr(t, 2), s !== null && Vt(s, t, 2));
    }, QS = function(t, n, s) {
      n = a(t, n), n !== null && (s = u(n.memoizedState, s, 0), n.memoizedState = s, n.baseState = s, t.memoizedProps = st({}, t.memoizedProps), s = dr(t, 2), s !== null && Vt(s, t, 2));
    }, ZS = function(t, n, s, f) {
      n = a(t, n), n !== null && (s = r(n.memoizedState, s, f), n.memoizedState = s, n.baseState = s, t.memoizedProps = st({}, t.memoizedProps), s = dr(t, 2), s !== null && Vt(s, t, 2));
    }, YS = function(t, n, s) {
      t.pendingProps = e(t.memoizedProps, n, 0, s), t.alternate && (t.alternate.pendingProps = t.pendingProps), n = dr(t, 2), n !== null && Vt(n, t, 2);
    }, qS = function(t, n) {
      t.pendingProps = u(t.memoizedProps, n, 0), t.alternate && (t.alternate.pendingProps = t.pendingProps), n = dr(t, 2), n !== null && Vt(n, t, 2);
    }, KS = function(t, n, s) {
      t.pendingProps = r(
        t.memoizedProps,
        n,
        s
      ), t.alternate && (t.alternate.pendingProps = t.pendingProps), n = dr(t, 2), n !== null && Vt(n, t, 2);
    }, JS = function(t) {
      var n = dr(t, 2);
      n !== null && Vt(n, t, 2);
    }, XS = function(t) {
      g = t;
    }, eA = function(t) {
      d = t;
    };
    var a4 = !0, o4 = null, m8 = !1, od = null, id = null, sd = null, D2 = /* @__PURE__ */ new Map(), B2 = /* @__PURE__ */ new Map(), ld = [], TP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    ), i4 = null;
    if (_f.prototype.render = _b.prototype.render = function(t, n) {
      var s = this._internalRoot;
      if (s === null) throw Error("Cannot update an unmounted root.");
      typeof n == "function" ? console.error(
        "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ) : T(n) ? console.error(
        "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
      ) : typeof n < "u" && console.error(
        "You passed a second argument to root.render(...) but it only accepts one argument."
      ), n = s.current;
      var f = Hr(n);
      Rb(
        n,
        f,
        t,
        s,
        null,
        null
      );
    }, _f.prototype.unmount = _b.prototype.unmount = function(t) {
      if (typeof t == "function" && console.error(
        "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ), t = this._internalRoot, t !== null) {
        this._internalRoot = null;
        var n = t.containerInfo;
        (fn & (Da | cc)) !== Oo && console.error(
          "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
        ), d3(
          null,
          t,
          null,
          null
        ), va(), n[Nl] = null;
      }
    }, _f.prototype.unstable_scheduleHydration = function(t) {
      if (t) {
        var n = jd();
        t = { blockedOn: null, target: t, priority: n };
        for (var s = 0; s < ld.length && n !== 0 && n < ld[s].priority; s++) ;
        ld.splice(s, 0, t), s === 0 && El(t);
      }
    }, function() {
      var t = zb.version;
      if (t !== "19.0.0")
        throw Error(
          `Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (t + `
  - react-dom:  19.0.0
Learn more: https://react.dev/warnings/version-mismatch`)
        );
    }(), typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
    ), Qt.findDOMNode = function(t) {
      var n = t._reactInternals;
      if (n === void 0)
        throw typeof t.render == "function" ? Error("Unable to find node on an unmounted component.") : (t = Object.keys(t).join(","), Error(
          "Argument appears to not be a ReactComponent. Keys: " + t
        ));
      return t = G(n), t = t !== null ? ie(t) : null, t = t === null ? null : t.stateNode, t;
    }, !function() {
      var t = {
        bundleType: 1,
        version: "19.0.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: me,
        findFiberByHostInstance: zo,
        reconcilerVersion: "19.0.0"
      };
      return t.overrideHookState = $S, t.overrideHookStateDeletePath = QS, t.overrideHookStateRenamePath = ZS, t.overrideProps = YS, t.overridePropsDeletePath = qS, t.overridePropsRenamePath = KS, t.scheduleUpdate = JS, t.setErrorHandler = XS, t.setSuspenseHandler = eA, t.scheduleRefresh = D, t.scheduleRoot = M, t.setRefreshHandler = O, t.getCurrentFiber = Lb, t.getLaneLabelMap = s6, t.injectProfilingHooks = Og, Er(t);
    }() && ca && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && navigator.userAgent.indexOf("Edge") === -1 || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var tA = window.location.protocol;
      /^(https?|file):$/.test(tA) && console.info(
        "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (tA === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq` : ""),
        "font-weight:bold"
      );
    }
    l4.createRoot = function(t, n) {
      if (!T(t))
        throw Error("Target container is not a DOM element.");
      Ub(t);
      var s = !1, f = "", p = bh, m = j1, E = rs, I = null;
      return n != null && (n.hydrate ? console.warn(
        "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
      ) : typeof n == "object" && n !== null && n.$$typeof === Sl && console.error(
        `You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`
      ), n.unstable_strictMode === !0 && (s = !0), n.identifierPrefix !== void 0 && (f = n.identifierPrefix), n.onUncaughtError !== void 0 && (p = n.onUncaughtError), n.onCaughtError !== void 0 && (m = n.onCaughtError), n.onRecoverableError !== void 0 && (E = n.onRecoverableError), n.unstable_transitionCallbacks !== void 0 && (I = n.unstable_transitionCallbacks)), n = Pb(
        t,
        1,
        !1,
        null,
        null,
        s,
        f,
        p,
        m,
        E,
        I,
        null
      ), t[Nl] = n.current, Vm(
        t.nodeType === 8 ? t.parentNode : t
      ), new _b(n);
    }, l4.hydrateRoot = function(t, n, s) {
      if (!T(t))
        throw Error("Target container is not a DOM element.");
      Ub(t), n === void 0 && console.error(
        "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
      );
      var f = !1, p = "", m = bh, E = j1, I = rs, F = null, z = null;
      return s != null && (s.unstable_strictMode === !0 && (f = !0), s.identifierPrefix !== void 0 && (p = s.identifierPrefix), s.onUncaughtError !== void 0 && (m = s.onUncaughtError), s.onCaughtError !== void 0 && (E = s.onCaughtError), s.onRecoverableError !== void 0 && (I = s.onRecoverableError), s.unstable_transitionCallbacks !== void 0 && (F = s.unstable_transitionCallbacks), s.formState !== void 0 && (z = s.formState)), n = Pb(
        t,
        1,
        !0,
        n,
        s ?? null,
        f,
        p,
        m,
        E,
        I,
        F,
        z
      ), n.context = Ob(null), s = n.current, f = Hr(s), p = os(f), p.callback = null, is(s, p, f), n.current.lanes = f, ur(n, f), xo(n), t[Nl] = n.current, Vm(t), new _f(n);
    }, l4.version = "19.0.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), l4;
}
var fA;
function nO() {
  if (fA) return s4.exports;
  fA = 1;
  function a() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (Gs.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(a);
      } catch (e) {
        console.error(e);
      }
    }
  }
  return Gs.env.NODE_ENV === "production" ? (a(), s4.exports = eO()) : s4.exports = tO(), s4.exports;
}
var rO = nO();
const aO = /* @__PURE__ */ mx(rO);
function dA(a) {
  return "send" in a && typeof a.send == "function";
}
function oO(a) {
  return "request" in a && typeof a.request == "function";
}
function iO(a) {
  if (dA(a))
    return a;
  if (a.provider && dA(a.provider))
    return a.provider;
}
function sO(a) {
  if (oO(a))
    return a.request;
  const e = iO(a);
  if (e)
    return async (r) => {
      const { method: i, params: u } = r;
      return e.send(i, u ?? []);
    };
}
const Ex = "#SAPPHIRE_WRAPPED_ETHERS_PROVIDER";
function lO(a) {
  return Ex in a;
}
function uO(a, e) {
  if (lO(a))
    return a;
  const r = sO(a);
  if (!r)
    throw new Error("Couldn't make request function!");
  const i = RP(e);
  return LP(a, Ex, i, {
    // Calls can be unsigned, but must be enveloped.
    call: hA(a, "call", i, r),
    estimateGas: hA(a, "estimateGas", i, r),
    request: r
    // TODO: wrap `getSigner()`
  });
}
function cO(a) {
  return a instanceof OP;
}
async function fO(a, e, r, i) {
  let u = e.data ?? void 0;
  return r || (u = nA(i.encryptCall(e.data))), await a?.({
    ...e,
    data: u ? nA(u) : "0x"
  });
}
function hA(a, e, r, i) {
  return async (u) => {
    const d = await r.fetcher.cipher({ request: i }), g = DP(u.data ?? void 0), b = a[e];
    if (!b)
      throw new Error(`${e} not found in runner!`);
    const y = await fO(b.bind(a), cO(a) ? await a.populateCall(u) : u, g, d);
    return !g && y && typeof y == "string" ? d.decryptResult(y) : y;
  };
}
const dO = "6.13.5";
function hO(a, e, r) {
  const i = e.split("|").map((d) => d.trim());
  for (let d = 0; d < i.length; d++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof a === e)
          return;
    }
  const u = new Error(`invalid value for type ${e}`);
  throw u.code = "INVALID_ARGUMENT", u.argument = `value.${r}`, u.value = a, u;
}
async function _a(a) {
  const e = Object.keys(a);
  return (await Promise.all(e.map((r) => Promise.resolve(a[r])))).reduce((r, i, u) => (r[e[u]] = i, r), {});
}
function Ke(a, e, r) {
  for (let i in e) {
    let u = e[i];
    const d = r ? r[i] : null;
    d && hO(u, d, i), Object.defineProperty(a, i, { enumerable: !0, value: u, writable: !1 });
  }
}
function yy(a) {
  if (a == null)
    return "null";
  if (Array.isArray(a))
    return "[ " + a.map(yy).join(", ") + " ]";
  if (a instanceof Uint8Array) {
    const e = "0123456789abcdef";
    let r = "0x";
    for (let i = 0; i < a.length; i++)
      r += e[a[i] >> 4], r += e[a[i] & 15];
    return r;
  }
  if (typeof a == "object" && typeof a.toJSON == "function")
    return yy(a.toJSON());
  switch (typeof a) {
    case "boolean":
    case "symbol":
      return a.toString();
    case "bigint":
      return BigInt(a).toString();
    case "number":
      return a.toString();
    case "string":
      return JSON.stringify(a);
    case "object": {
      const e = Object.keys(a);
      return e.sort(), "{ " + e.map((r) => `${yy(r)}: ${yy(a[r])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function qr(a, e) {
  return a && a.code === e;
}
function yE(a) {
  return qr(a, "CALL_EXCEPTION");
}
function Pn(a, e, r) {
  let i = a;
  {
    const d = [];
    if (r) {
      if ("message" in r || "code" in r || "name" in r)
        throw new Error(`value will overwrite populated values: ${yy(r)}`);
      for (const g in r) {
        if (g === "shortMessage")
          continue;
        const b = r[g];
        d.push(g + "=" + yy(b));
      }
    }
    d.push(`code=${e}`), d.push(`version=${dO}`), d.length && (a += " (" + d.join(", ") + ")");
  }
  let u;
  switch (e) {
    case "INVALID_ARGUMENT":
      u = new TypeError(a);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      u = new RangeError(a);
      break;
    default:
      u = new Error(a);
  }
  return Ke(u, { code: e }), r && Object.assign(u, r), u.shortMessage == null && Ke(u, { shortMessage: i }), u;
}
function Te(a, e, r, i) {
  if (!a)
    throw Pn(e, r, i);
}
function se(a, e, r, i) {
  Te(a, e, "INVALID_ARGUMENT", { argument: r, value: i });
}
function Sx(a, e, r) {
  r == null && (r = ""), r && (r = ": " + r), Te(a >= e, "missing argument" + r, "MISSING_ARGUMENT", {
    count: a,
    expectedCount: e
  }), Te(a <= e, "too many arguments" + r, "UNEXPECTED_ARGUMENT", {
    count: a,
    expectedCount: e
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((a, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "é".normalize("NFD") !== "é")
      throw new Error("broken");
    a.push(e);
  } catch {
  }
  return a;
}, []);
function tw(a, e, r) {
  if (r == null && (r = ""), a !== e) {
    let i = r, u = "new";
    r && (i += ".", u += " " + r), Te(!1, `private constructor; use ${i}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: u
    });
  }
}
function Ax(a, e, r) {
  if (a instanceof Uint8Array)
    return r ? new Uint8Array(a) : a;
  if (typeof a == "string" && a.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const i = new Uint8Array((a.length - 2) / 2);
    let u = 2;
    for (let d = 0; d < i.length; d++)
      i[d] = parseInt(a.substring(u, u + 2), 16), u += 2;
    return i;
  }
  se(!1, "invalid BytesLike value", e || "value", a);
}
function mt(a, e) {
  return Ax(a, e, !1);
}
function Ua(a, e) {
  return Ax(a, e, !0);
}
function ln(a, e) {
  return !(typeof a != "string" || !a.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && a.length !== 2 + 2 * e || e === !0 && a.length % 2 !== 0);
}
function bE(a) {
  return ln(a, !0) || a instanceof Uint8Array;
}
const pA = "0123456789abcdef";
function Ge(a) {
  const e = mt(a);
  let r = "0x";
  for (let i = 0; i < e.length; i++) {
    const u = e[i];
    r += pA[(u & 240) >> 4] + pA[u & 15];
  }
  return r;
}
function vn(a) {
  return "0x" + a.map((e) => Ge(e).substring(2)).join("");
}
function ug(a) {
  return ln(a, !0) ? (a.length - 2) / 2 : mt(a).length;
}
function On(a, e, r) {
  const i = mt(a);
  return r != null && r > i.length && Te(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: i,
    length: i.length,
    offset: r
  }), Ge(i.slice(e ?? 0, r ?? i.length));
}
function xx(a, e, r) {
  const i = mt(a);
  Te(e >= i.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(i),
    length: e,
    offset: e + 1
  });
  const u = new Uint8Array(e);
  return u.fill(0), r ? u.set(i, e - i.length) : u.set(i, 0), Ge(u);
}
function eu(a, e) {
  return xx(a, e, !0);
}
function vE(a, e) {
  return xx(a, e, !1);
}
const hk = BigInt(0), zs = BigInt(1), i5 = 9007199254740991;
function q4(a, e) {
  const r = pk(a, "value"), i = BigInt(yt(e, "width"));
  if (Te(r >> i === hk, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: a
  }), r >> i - zs) {
    const u = (zs << i) - zs;
    return -((~r & u) + zs);
  }
  return r;
}
function wE(a, e) {
  let r = Qe(a, "value");
  const i = BigInt(yt(e, "width")), u = zs << i - zs;
  if (r < hk) {
    r = -r, Te(r <= u, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: a
    });
    const d = (zs << i) - zs;
    return (~r & d) + zs;
  } else
    Te(r < u, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: a
    });
  return r;
}
function eg(a, e) {
  const r = pk(a, "value"), i = BigInt(yt(e, "bits"));
  return r & (zs << i) - zs;
}
function Qe(a, e) {
  switch (typeof a) {
    case "bigint":
      return a;
    case "number":
      return se(Number.isInteger(a), "underflow", e || "value", a), se(a >= -9007199254740991 && a <= i5, "overflow", e || "value", a), BigInt(a);
    case "string":
      try {
        if (a === "")
          throw new Error("empty string");
        return a[0] === "-" && a[1] !== "-" ? -BigInt(a.substring(1)) : BigInt(a);
      } catch (r) {
        se(!1, `invalid BigNumberish string: ${r.message}`, e || "value", a);
      }
  }
  se(!1, "invalid BigNumberish value", e || "value", a);
}
function pk(a, e) {
  const r = Qe(a, e);
  return Te(r >= hk, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: a
  }), r;
}
const gA = "0123456789abcdef";
function By(a) {
  if (a instanceof Uint8Array) {
    let e = "0x0";
    for (const r of a)
      e += gA[r >> 4], e += gA[r & 15];
    return BigInt(e);
  }
  return Qe(a);
}
function yt(a, e) {
  switch (typeof a) {
    case "bigint":
      return se(a >= -9007199254740991 && a <= i5, "overflow", e || "value", a), Number(a);
    case "number":
      return se(Number.isInteger(a), "underflow", e || "value", a), se(a >= -9007199254740991 && a <= i5, "overflow", e || "value", a), a;
    case "string":
      try {
        if (a === "")
          throw new Error("empty string");
        return yt(BigInt(a), e);
      } catch (r) {
        se(!1, `invalid numeric string: ${r.message}`, e || "value", a);
      }
  }
  se(!1, "invalid numeric value", e || "value", a);
}
function pO(a) {
  return yt(By(a));
}
function Ud(a, e) {
  let r = pk(a, "value").toString(16);
  if (e == null)
    r.length % 2 && (r = "0" + r);
  else {
    const i = yt(e, "width");
    for (Te(i * 2 >= r.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: a
    }); r.length < i * 2; )
      r = "0" + r;
  }
  return "0x" + r;
}
function kr(a) {
  const e = pk(a, "value");
  if (e === hk)
    return new Uint8Array([]);
  let r = e.toString(16);
  r.length % 2 && (r = "0" + r);
  const i = new Uint8Array(r.length / 2);
  for (let u = 0; u < i.length; u++) {
    const d = u * 2;
    i[u] = parseInt(r.substring(d, d + 2), 16);
  }
  return i;
}
function by(a) {
  let e = Ge(bE(a) ? a : kr(a)).substring(2);
  for (; e.startsWith("0"); )
    e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
const mA = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const yA = BigInt(58);
function gO(a) {
  const e = mt(a);
  let r = By(e), i = "";
  for (; r; )
    i = mA[Number(r % yA)] + i, r /= yA;
  for (let u = 0; u < e.length && !e[u]; u++)
    i = mA[0] + i;
  return i;
}
function mO(a) {
  a = atob(a);
  const e = new Uint8Array(a.length);
  for (let r = 0; r < a.length; r++)
    e[r] = a.charCodeAt(r);
  return mt(e);
}
function yO(a) {
  const e = mt(a);
  let r = "";
  for (let i = 0; i < e.length; i++)
    r += String.fromCharCode(e[i]);
  return btoa(r);
}
var H2;
class Cx {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(e, r, i) {
    le(this, "filter"), le(this, "emitter"), ye(this, H2), Q(this, H2, r), Ke(this, { emitter: e, filter: i });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    R(this, H2) != null && await this.emitter.off(this.filter, R(this, H2));
  }
}
H2 = /* @__PURE__ */ new WeakMap();
function bO(a, e, r, i, u) {
  se(!1, `invalid codepoint at offset ${e}; ${a}`, "bytes", r);
}
function Tx(a, e, r, i, u) {
  if (a === "BAD_PREFIX" || a === "UNEXPECTED_CONTINUE") {
    let d = 0;
    for (let g = e + 1; g < r.length && r[g] >> 6 === 2; g++)
      d++;
    return d;
  }
  return a === "OVERRUN" ? r.length - e - 1 : 0;
}
function vO(a, e, r, i, u) {
  return a === "OVERLONG" ? (se(typeof u == "number", "invalid bad code point for replacement", "badCodepoint", u), i.push(u), 0) : (i.push(65533), Tx(a, e, r));
}
const wO = Object.freeze({
  error: bO,
  ignore: Tx,
  replace: vO
});
function kO(a, e) {
  e == null && (e = wO.error);
  const r = mt(a, "bytes"), i = [];
  let u = 0;
  for (; u < r.length; ) {
    const d = r[u++];
    if (!(d >> 7)) {
      i.push(d);
      continue;
    }
    let g = null, b = null;
    if ((d & 224) === 192)
      g = 1, b = 127;
    else if ((d & 240) === 224)
      g = 2, b = 2047;
    else if ((d & 248) === 240)
      g = 3, b = 65535;
    else {
      (d & 192) === 128 ? u += e("UNEXPECTED_CONTINUE", u - 1, r, i) : u += e("BAD_PREFIX", u - 1, r, i);
      continue;
    }
    if (u - 1 + g >= r.length) {
      u += e("OVERRUN", u - 1, r, i);
      continue;
    }
    let y = d & (1 << 8 - g - 1) - 1;
    for (let k = 0; k < g; k++) {
      let S = r[u];
      if ((S & 192) != 128) {
        u += e("MISSING_CONTINUE", u, r, i), y = null;
        break;
      }
      y = y << 6 | S & 63, u++;
    }
    if (y !== null) {
      if (y > 1114111) {
        u += e("OUT_OF_RANGE", u - 1 - g, r, i, y);
        continue;
      }
      if (y >= 55296 && y <= 57343) {
        u += e("UTF16_SURROGATE", u - 1 - g, r, i, y);
        continue;
      }
      if (y <= b) {
        u += e("OVERLONG", u - 1 - g, r, i, y);
        continue;
      }
      i.push(y);
    }
  }
  return i;
}
function lo(a, e) {
  se(typeof a == "string", "invalid string value", "str", a);
  let r = [];
  for (let i = 0; i < a.length; i++) {
    const u = a.charCodeAt(i);
    if (u < 128)
      r.push(u);
    else if (u < 2048)
      r.push(u >> 6 | 192), r.push(u & 63 | 128);
    else if ((u & 64512) == 55296) {
      i++;
      const d = a.charCodeAt(i);
      se(i < a.length && (d & 64512) === 56320, "invalid surrogate pair", "str", a);
      const g = 65536 + ((u & 1023) << 10) + (d & 1023);
      r.push(g >> 18 | 240), r.push(g >> 12 & 63 | 128), r.push(g >> 6 & 63 | 128), r.push(g & 63 | 128);
    } else
      r.push(u >> 12 | 224), r.push(u >> 6 & 63 | 128), r.push(u & 63 | 128);
  }
  return new Uint8Array(r);
}
function EO(a) {
  return a.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function K4(a, e) {
  return EO(kO(a, e));
}
function Ix(a) {
  async function e(r, i) {
    Te(i == null || !i.cancelled, "request cancelled before sending", "CANCELLED");
    const u = r.url.split(":")[0].toLowerCase();
    Te(u === "http" || u === "https", `unsupported protocol ${u}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: u },
      operation: "request"
    }), Te(u === "https" || !r.credentials || r.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let d = null;
    const g = new AbortController(), b = setTimeout(() => {
      d = Pn("request timeout", "TIMEOUT"), g.abort();
    }, r.timeout);
    i && i.addListener(() => {
      d = Pn("request cancelled", "CANCELLED"), g.abort();
    });
    const y = {
      method: r.method,
      headers: new Headers(Array.from(r)),
      body: r.body || void 0,
      signal: g.signal
    };
    let k;
    try {
      k = await fetch(r.url, y);
    } catch (M) {
      throw clearTimeout(b), d || M;
    }
    clearTimeout(b);
    const S = {};
    k.headers.forEach((M, D) => {
      S[D.toLowerCase()] = M;
    });
    const A = await k.arrayBuffer(), x = A == null ? null : new Uint8Array(A);
    return {
      statusCode: k.status,
      statusMessage: k.statusText,
      headers: S,
      body: x
    };
  }
  return e;
}
const SO = 12, AO = 250;
let bA = Ix();
const xO = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), CO = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let b8 = !1;
async function Nx(a, e) {
  try {
    const r = a.match(xO);
    if (!r)
      throw new Error("invalid data");
    return new My(200, "OK", {
      "content-type": r[1] || "text/plain"
    }, r[2] ? mO(r[3]) : PO(r[3]));
  } catch {
    return new My(599, "BAD REQUEST (invalid data: URI)", {}, null, new Mc(a));
  }
}
function Px(a) {
  async function e(r, i) {
    try {
      const u = r.match(CO);
      if (!u)
        throw new Error("invalid link");
      return new Mc(`${a}${u[2]}`);
    } catch {
      return new My(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Mc(r));
    }
  }
  return e;
}
const J4 = {
  data: Nx,
  ipfs: Px("https://gateway.ipfs.io/ipfs/")
}, Ox = /* @__PURE__ */ new WeakMap();
var K0, Ip;
class TO {
  constructor(e) {
    ye(this, K0), ye(this, Ip), Q(this, K0, []), Q(this, Ip, !1), Ox.set(e, () => {
      if (!R(this, Ip)) {
        Q(this, Ip, !0);
        for (const r of R(this, K0))
          setTimeout(() => {
            r();
          }, 0);
        Q(this, K0, []);
      }
    });
  }
  addListener(e) {
    Te(!R(this, Ip), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), R(this, K0).push(e);
  }
  get cancelled() {
    return R(this, Ip);
  }
  checkSignal() {
    Te(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
K0 = /* @__PURE__ */ new WeakMap(), Ip = /* @__PURE__ */ new WeakMap();
function u4(a) {
  if (a == null)
    throw new Error("missing signal; should not happen");
  return a.checkSignal(), a;
}
var V2, W2, Wl, kd, G2, j2, Zr, Pi, Ed, J0, X0, ey, Ac, ql, Np, vy, $2;
const IO = class s5 {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(e) {
    ye(this, vy), ye(this, V2), ye(this, W2), ye(this, Wl), ye(this, kd), ye(this, G2), ye(this, j2), ye(this, Zr), ye(this, Pi), ye(this, Ed), ye(this, J0), ye(this, X0), ye(this, ey), ye(this, Ac), ye(this, ql), ye(this, Np), Q(this, j2, String(e)), Q(this, V2, !1), Q(this, W2, !0), Q(this, Wl, {}), Q(this, kd, ""), Q(this, G2, 3e5), Q(this, ql, {
      slotInterval: AO,
      maxAttempts: SO
    }), Q(this, Np, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return R(this, j2);
  }
  set url(e) {
    Q(this, j2, String(e));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return R(this, Zr) == null ? null : new Uint8Array(R(this, Zr));
  }
  set body(e) {
    if (e == null)
      Q(this, Zr, void 0), Q(this, Pi, void 0);
    else if (typeof e == "string")
      Q(this, Zr, lo(e)), Q(this, Pi, "text/plain");
    else if (e instanceof Uint8Array)
      Q(this, Zr, e), Q(this, Pi, "application/octet-stream");
    else if (typeof e == "object")
      Q(this, Zr, lo(JSON.stringify(e))), Q(this, Pi, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return R(this, Zr) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return R(this, kd) ? R(this, kd) : this.hasBody() ? "POST" : "GET";
  }
  set method(e) {
    e == null && (e = ""), Q(this, kd, String(e).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const e = Object.assign({}, R(this, Wl));
    return R(this, Ed) && (e.authorization = `Basic ${yO(lo(R(this, Ed)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && R(this, Pi) && (e["content-type"] = R(this, Pi)), this.body && (e["content-length"] = String(this.body.length)), e;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(e, r) {
    R(this, Wl)[String(e).toLowerCase()] = String(r);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    Q(this, Wl, {});
  }
  [Symbol.iterator]() {
    const e = this.headers, r = Object.keys(e);
    let i = 0;
    return {
      next: () => {
        if (i < r.length) {
          const u = r[i++];
          return {
            value: [u, e[u]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return R(this, Ed) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(e, r) {
    se(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), Q(this, Ed, `${e}:${r}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return R(this, W2);
  }
  set allowGzip(e) {
    Q(this, W2, !!e);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!R(this, V2);
  }
  set allowInsecureAuthentication(e) {
    Q(this, V2, !!e);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return R(this, G2);
  }
  set timeout(e) {
    se(e >= 0, "timeout must be non-zero", "timeout", e), Q(this, G2, e);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return R(this, J0) || null;
  }
  set preflightFunc(e) {
    Q(this, J0, e);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return R(this, X0) || null;
  }
  set processFunc(e) {
    Q(this, X0, e);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return R(this, ey) || null;
  }
  set retryFunc(e) {
    Q(this, ey, e);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return R(this, Np) || bA;
  }
  set getUrlFunc(e) {
    Q(this, Np, e);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${R(this, Zr) ? Ge(R(this, Zr)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(e) {
    e.slotInterval != null && (R(this, ql).slotInterval = e.slotInterval), e.maxAttempts != null && (R(this, ql).maxAttempts = e.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return Te(R(this, Ac) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), Q(this, Ac, new TO(this)), Oe(this, vy, $2).call(this, 0, Lx() + this.timeout, 0, this, new My(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    Te(R(this, Ac) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const e = Ox.get(this);
    if (!e)
      throw new Error("missing signal; should not happen");
    e();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(e) {
    const r = this.url.split(":")[0].toLowerCase(), i = e.split(":")[0].toLowerCase();
    Te(this.method === "GET" && (r !== "https" || i !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
    });
    const u = new s5(e);
    return u.method = "GET", u.allowGzip = this.allowGzip, u.timeout = this.timeout, Q(u, Wl, Object.assign({}, R(this, Wl))), R(this, Zr) && Q(u, Zr, new Uint8Array(R(this, Zr))), Q(u, Pi, R(this, Pi)), u;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const e = new s5(this.url);
    return Q(e, kd, R(this, kd)), R(this, Zr) && Q(e, Zr, R(this, Zr)), Q(e, Pi, R(this, Pi)), Q(e, Wl, Object.assign({}, R(this, Wl))), Q(e, Ed, R(this, Ed)), this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), Q(e, J0, R(this, J0)), Q(e, X0, R(this, X0)), Q(e, ey, R(this, ey)), Q(e, ql, Object.assign({}, R(this, ql))), Q(e, Np, R(this, Np)), e;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    b8 = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(e) {
    return J4[e.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(e, r) {
    if (e = e.toLowerCase(), e === "http" || e === "https")
      throw new Error(`cannot intercept ${e}; use registerGetUrl`);
    if (b8)
      throw new Error("gateways locked");
    J4[e] = r;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(e) {
    if (b8)
      throw new Error("gateways locked");
    bA = e;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(e) {
    return Ix();
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return Nx;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(e) {
    return Px(e);
  }
};
V2 = /* @__PURE__ */ new WeakMap(), W2 = /* @__PURE__ */ new WeakMap(), Wl = /* @__PURE__ */ new WeakMap(), kd = /* @__PURE__ */ new WeakMap(), G2 = /* @__PURE__ */ new WeakMap(), j2 = /* @__PURE__ */ new WeakMap(), Zr = /* @__PURE__ */ new WeakMap(), Pi = /* @__PURE__ */ new WeakMap(), Ed = /* @__PURE__ */ new WeakMap(), J0 = /* @__PURE__ */ new WeakMap(), X0 = /* @__PURE__ */ new WeakMap(), ey = /* @__PURE__ */ new WeakMap(), Ac = /* @__PURE__ */ new WeakMap(), ql = /* @__PURE__ */ new WeakMap(), Np = /* @__PURE__ */ new WeakMap(), vy = /* @__PURE__ */ new WeakSet(), $2 = async function(a, e, r, i, u) {
  var d, g, b;
  if (a >= R(this, ql).maxAttempts)
    return u.makeServerError("exceeded maximum retry limit");
  Te(Lx() <= e, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: i
  }), r > 0 && await OO(r);
  let y = this.clone();
  const k = (y.url.split(":")[0] || "").toLowerCase();
  if (k in J4) {
    const x = await J4[k](y.url, u4(R(i, Ac)));
    if (x instanceof My) {
      let M = x;
      if (this.processFunc) {
        u4(R(i, Ac));
        try {
          M = await this.processFunc(y, M);
        } catch (D) {
          (D.throttle == null || typeof D.stall != "number") && M.makeServerError("error in post-processing function", D).assertOk();
        }
      }
      return M;
    }
    y = x;
  }
  this.preflightFunc && (y = await this.preflightFunc(y));
  const S = await this.getUrlFunc(y, u4(R(i, Ac)));
  let A = new My(S.statusCode, S.statusMessage, S.headers, S.body, i);
  if (A.statusCode === 301 || A.statusCode === 302) {
    try {
      const x = A.headers.location || "";
      return Oe(d = y.redirect(x), vy, $2).call(d, a + 1, e, 0, i, A);
    } catch {
    }
    return A;
  } else if (A.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(y, A, a))) {
    const x = A.headers["retry-after"];
    let M = R(this, ql).slotInterval * Math.trunc(Math.random() * Math.pow(2, a));
    return typeof x == "string" && x.match(/^[1-9][0-9]*$/) && (M = parseInt(x)), Oe(g = y.clone(), vy, $2).call(g, a + 1, e, M, i, A);
  }
  if (this.processFunc) {
    u4(R(i, Ac));
    try {
      A = await this.processFunc(y, A);
    } catch (x) {
      (x.throttle == null || typeof x.stall != "number") && A.makeServerError("error in post-processing function", x).assertOk();
      let M = R(this, ql).slotInterval * Math.trunc(Math.random() * Math.pow(2, a));
      return x.stall >= 0 && (M = x.stall), Oe(b = y.clone(), vy, $2).call(b, a + 1, e, M, i, A);
    }
  }
  return A;
};
let Mc = IO;
var S4, A4, x4, Oi, Q2, ty;
const NO = class Rx {
  constructor(e, r, i, u, d) {
    ye(this, S4), ye(this, A4), ye(this, x4), ye(this, Oi), ye(this, Q2), ye(this, ty), Q(this, S4, e), Q(this, A4, r), Q(this, x4, Object.keys(i).reduce((g, b) => (g[b.toLowerCase()] = String(i[b]), g), {})), Q(this, Oi, u == null ? null : new Uint8Array(u)), Q(this, Q2, d || null), Q(this, ty, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${R(this, Oi) ? Ge(R(this, Oi)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return R(this, S4);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return R(this, A4);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, R(this, x4));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return R(this, Oi) == null ? null : new Uint8Array(R(this, Oi));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return R(this, Oi) == null ? "" : K4(R(this, Oi));
    } catch {
      Te(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      Te(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const e = this.headers, r = Object.keys(e);
    let i = 0;
    return {
      next: () => {
        if (i < r.length) {
          const u = r[i++];
          return {
            value: [u, e[u]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(e, r) {
    let i;
    e ? i = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, i = `CLIENT ESCALATED SERVER ERROR (${e})`);
    const u = new Rx(599, i, this.headers, this.body, R(this, Q2) || void 0);
    return Q(u, ty, { message: e, error: r }), u;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(e, r) {
    r == null ? r = -1 : se(Number.isInteger(r) && r >= 0, "invalid stall timeout", "stall", r);
    const i = new Error(e || "throttling requests");
    throw Ke(i, { stall: r, throttle: !0 }), i;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return R(this, Oi) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return R(this, Q2);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return R(this, ty).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: e, error: r } = R(this, ty);
    e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
    let i = null;
    this.request && (i = this.request.url);
    let u = null;
    try {
      R(this, Oi) && (u = K4(R(this, Oi)));
    } catch {
    }
    Te(!1, e, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: r,
      info: {
        requestUrl: i,
        responseBody: u,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
S4 = /* @__PURE__ */ new WeakMap(), A4 = /* @__PURE__ */ new WeakMap(), x4 = /* @__PURE__ */ new WeakMap(), Oi = /* @__PURE__ */ new WeakMap(), Q2 = /* @__PURE__ */ new WeakMap(), ty = /* @__PURE__ */ new WeakMap();
let My = NO;
function Lx() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function PO(a) {
  return lo(a.replace(/%([0-9a-f][0-9a-f])/gi, (e, r) => String.fromCharCode(parseInt(r, 16))));
}
function OO(a) {
  return new Promise((e) => setTimeout(e, a));
}
const RO = BigInt(-1), Ls = BigInt(0), wy = BigInt(1), LO = BigInt(5), ny = {};
let Ty = "0000";
for (; Ty.length < 80; )
  Ty += Ty;
function Tp(a) {
  let e = Ty;
  for (; e.length < a; )
    e += e;
  return BigInt("1" + e.substring(0, a));
}
function Z2(a, e, r) {
  const i = BigInt(e.width);
  if (e.signed) {
    const u = wy << i - wy;
    Te(r == null || a >= -u && a < u, "overflow", "NUMERIC_FAULT", {
      operation: r,
      fault: "overflow",
      value: a
    }), a > Ls ? a = q4(eg(a, i), i) : a = -q4(eg(-a, i), i);
  } else {
    const u = wy << i;
    Te(r == null || a >= 0 && a < u, "overflow", "NUMERIC_FAULT", {
      operation: r,
      fault: "overflow",
      value: a
    }), a = (a % u + u) % u & u - wy;
  }
  return a;
}
function v8(a) {
  typeof a == "number" && (a = `fixed128x${a}`);
  let e = !0, r = 128, i = 18;
  if (typeof a == "string") {
    if (a !== "fixed") if (a === "ufixed")
      e = !1;
    else {
      const d = a.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      se(d, "invalid fixed format", "format", a), e = d[1] !== "u", r = parseInt(d[2]), i = parseInt(d[3]);
    }
  } else if (a) {
    const d = a, g = (b, y, k) => d[b] == null ? k : (se(typeof d[b] === y, "invalid fixed format (" + b + " not " + y + ")", "format." + b, d[b]), d[b]);
    e = g("signed", "boolean", e), r = g("width", "number", r), i = g("decimals", "number", i);
  }
  se(r % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", r), se(i <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", i);
  const u = (e ? "" : "u") + "fixed" + String(r) + "x" + String(i);
  return { signed: e, width: r, decimals: i, name: u };
}
function DO(a, e) {
  let r = "";
  a < Ls && (r = "-", a *= RO);
  let i = a.toString();
  if (e === 0)
    return r + i;
  for (; i.length <= e; )
    i = Ty + i;
  const u = i.length - e;
  for (i = i.substring(0, u) + "." + i.substring(u); i[0] === "0" && i[1] !== "."; )
    i = i.substring(1);
  for (; i[i.length - 1] === "0" && i[i.length - 2] !== "."; )
    i = i.substring(0, i.length - 1);
  return r + i;
}
var Yl, tn, ro, bn, Gp, xc, l5, u5, c5, f5;
const Dx = class ry {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(e, r, i) {
    ye(this, bn), le(this, "format"), ye(this, Yl), ye(this, tn), ye(this, ro), le(this, "_value"), tw(e, ny, "FixedNumber"), Q(this, tn, r), Q(this, Yl, i);
    const u = DO(r, i.decimals);
    Ke(this, { format: i.name, _value: u }), Q(this, ro, Tp(i.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return R(this, Yl).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return R(this, Yl).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return R(this, Yl).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return R(this, tn);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(e) {
    return Oe(this, bn, l5).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(e) {
    return Oe(this, bn, l5).call(this, e, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(e) {
    return Oe(this, bn, u5).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(e) {
    return Oe(this, bn, u5).call(this, e, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(e) {
    return Oe(this, bn, c5).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(e) {
    return Oe(this, bn, c5).call(this, e, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(e) {
    Oe(this, bn, Gp).call(this, e);
    const r = R(this, tn) * R(e, tn);
    return Te(r % R(this, ro) === Ls, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    }), Oe(this, bn, xc).call(this, r / R(this, ro), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(e) {
    return Oe(this, bn, f5).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(e) {
    return Oe(this, bn, f5).call(this, e, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(e) {
    Te(R(e, tn) !== Ls, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    }), Oe(this, bn, Gp).call(this, e);
    const r = R(this, tn) * R(this, ro);
    return Te(r % R(e, tn) === Ls, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    }), Oe(this, bn, xc).call(this, r / R(e, tn), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(e) {
    let r = this.value, i = e.value;
    const u = this.decimals - e.decimals;
    return u > 0 ? i *= Tp(u) : u < 0 && (r *= Tp(-u)), r < i ? -1 : r > i ? 1 : 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(e) {
    return this.cmp(e) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(e) {
    return this.cmp(e) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(e) {
    return this.cmp(e) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(e) {
    return this.cmp(e) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(e) {
    return this.cmp(e) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let e = R(this, tn);
    return R(this, tn) < Ls && (e -= R(this, ro) - wy), e = R(this, tn) / R(this, ro) * R(this, ro), Oe(this, bn, xc).call(this, e, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let e = R(this, tn);
    return R(this, tn) > Ls && (e += R(this, ro) - wy), e = R(this, tn) / R(this, ro) * R(this, ro), Oe(this, bn, xc).call(this, e, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(e) {
    if (e == null && (e = 0), e >= this.decimals)
      return this;
    const r = this.decimals - e, i = LO * Tp(r - 1);
    let u = this.value + i;
    const d = Tp(r);
    return u = u / d * d, Z2(u, R(this, Yl), "round"), new ry(ny, u, R(this, Yl));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return R(this, tn) === Ls;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return R(this, tn) < Ls;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(e) {
    return ry.fromString(this.toString(), e);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(e, r, i) {
    const u = r == null ? 0 : yt(r), d = v8(i);
    let g = Qe(e, "value");
    const b = u - d.decimals;
    if (b > 0) {
      const y = Tp(b);
      Te(g % y === Ls, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: e
      }), g /= y;
    } else b < 0 && (g *= Tp(-b));
    return Z2(g, d, "fromValue"), new ry(ny, g, d);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(e, r) {
    const i = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    se(i && i[2].length + i[3].length > 0, "invalid FixedNumber string value", "value", e);
    const u = v8(r);
    let d = i[2] || "0", g = i[3] || "";
    for (; g.length < u.decimals; )
      g += Ty;
    Te(g.substring(u.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: e
    }), g = g.substring(0, u.decimals);
    const b = BigInt(i[1] + d + g);
    return Z2(b, u, "fromString"), new ry(ny, b, u);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(e, r) {
    let i = By(mt(e, "value"));
    const u = v8(r);
    return u.signed && (i = q4(i, u.width)), Z2(i, u, "fromBytes"), new ry(ny, i, u);
  }
};
Yl = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new WeakMap(), ro = /* @__PURE__ */ new WeakMap(), bn = /* @__PURE__ */ new WeakSet(), Gp = function(a) {
  se(this.format === a.format, "incompatible format; use fixedNumber.toFormat", "other", a);
}, xc = function(a, e) {
  return a = Z2(a, R(this, Yl), e), new Dx(ny, a, R(this, Yl));
}, l5 = function(a, e) {
  return Oe(this, bn, Gp).call(this, a), Oe(this, bn, xc).call(this, R(this, tn) + R(a, tn), e);
}, u5 = function(a, e) {
  return Oe(this, bn, Gp).call(this, a), Oe(this, bn, xc).call(this, R(this, tn) - R(a, tn), e);
}, c5 = function(a, e) {
  return Oe(this, bn, Gp).call(this, a), Oe(this, bn, xc).call(this, R(this, tn) * R(a, tn) / R(this, ro), e);
}, f5 = function(a, e) {
  return Te(R(a, tn) !== Ls, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  }), Oe(this, bn, Gp).call(this, a), Oe(this, bn, xc).call(this, R(this, tn) * R(this, ro) / R(a, tn), e);
};
let BO = Dx;
function MO(a) {
  let e = a.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return "0x" + e;
}
function vA(a, e, r) {
  let i = 0;
  for (let u = 0; u < r; u++)
    i = i * 256 + a[e + u];
  return i;
}
function wA(a, e, r, i) {
  const u = [];
  for (; r < e + 1 + i; ) {
    const d = Bx(a, r);
    u.push(d.result), r += d.consumed, Te(r <= e + 1 + i, "child data too short", "BUFFER_OVERRUN", {
      buffer: a,
      length: i,
      offset: e
    });
  }
  return { consumed: 1 + i, result: u };
}
function Bx(a, e) {
  Te(a.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: a,
    length: 0,
    offset: 1
  });
  const r = (i) => {
    Te(i <= a.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: a,
      length: a.length,
      offset: i
    });
  };
  if (a[e] >= 248) {
    const i = a[e] - 247;
    r(e + 1 + i);
    const u = vA(a, e + 1, i);
    return r(e + 1 + i + u), wA(a, e, e + 1 + i, i + u);
  } else if (a[e] >= 192) {
    const i = a[e] - 192;
    return r(e + 1 + i), wA(a, e, e + 1, i);
  } else if (a[e] >= 184) {
    const i = a[e] - 183;
    r(e + 1 + i);
    const u = vA(a, e + 1, i);
    r(e + 1 + i + u);
    const d = Ge(a.slice(e + 1 + i, e + 1 + i + u));
    return { consumed: 1 + i + u, result: d };
  } else if (a[e] >= 128) {
    const i = a[e] - 128;
    r(e + 1 + i);
    const u = Ge(a.slice(e + 1, e + 1 + i));
    return { consumed: 1 + i, result: u };
  }
  return { consumed: 1, result: MO(a[e]) };
}
function gk(a) {
  const e = mt(a, "data"), r = Bx(e, 0);
  return se(r.consumed === e.length, "unexpected junk after rlp payload", "data", a), r.result;
}
function kA(a) {
  const e = [];
  for (; a; )
    e.unshift(a & 255), a >>= 8;
  return e;
}
function Mx(a) {
  if (Array.isArray(a)) {
    let i = [];
    if (a.forEach(function(d) {
      i = i.concat(Mx(d));
    }), i.length <= 55)
      return i.unshift(192 + i.length), i;
    const u = kA(i.length);
    return u.unshift(247 + u.length), u.concat(i);
  }
  const e = Array.prototype.slice.call(mt(a, "object"));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const r = kA(e.length);
  return r.unshift(183 + r.length), r.concat(e);
}
const EA = "0123456789abcdef";
function bg(a) {
  let e = "0x";
  for (const r of Mx(a))
    e += EA[r >> 4], e += EA[r & 15];
  return e;
}
const FO = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function SA(a, e) {
  let r = 18;
  if (typeof e == "string") {
    const i = FO.indexOf(e);
    se(i >= 0, "invalid unit", "unit", e), r = 3 * i;
  } else e != null && (r = yt(e, "unit"));
  return BO.fromValue(a, r, { decimals: r, width: 512 }).toString();
}
const za = 32, d5 = new Uint8Array(za), _O = ["then"], c4 = {}, Fx = /* @__PURE__ */ new WeakMap();
function jp(a) {
  return Fx.get(a);
}
function AA(a, e) {
  Fx.set(a, e);
}
function F2(a, e) {
  const r = new Error(`deferred error during ABI decoding triggered accessing ${a}`);
  throw r.error = e, r;
}
function h5(a, e, r) {
  return a.indexOf(null) >= 0 ? e.map((i, u) => i instanceof X4 ? h5(jp(i), i, r) : i) : a.reduce((i, u, d) => {
    let g = e.getValue(u);
    return u in i || (r && g instanceof X4 && (g = h5(jp(g), g, r)), i[u] = g), i;
  }, {});
}
var Y2;
const UO = class q2 extends Array {
  /**
   *  @private
   */
  constructor(...e) {
    const r = e[0];
    let i = e[1], u = (e[2] || []).slice(), d = !0;
    r !== c4 && (i = e, u = [], d = !1), super(i.length), ye(this, Y2), i.forEach((y, k) => {
      this[k] = y;
    });
    const g = u.reduce((y, k) => (typeof k == "string" && y.set(k, (y.get(k) || 0) + 1), y), /* @__PURE__ */ new Map());
    if (AA(this, Object.freeze(i.map((y, k) => {
      const S = u[k];
      return S != null && g.get(S) === 1 ? S : null;
    }))), Q(this, Y2, []), R(this, Y2) == null && R(this, Y2), !d)
      return;
    Object.freeze(this);
    const b = new Proxy(this, {
      get: (y, k, S) => {
        if (typeof k == "string") {
          if (k.match(/^[0-9]+$/)) {
            const x = yt(k, "%index");
            if (x < 0 || x >= this.length)
              throw new RangeError("out of result range");
            const M = y[x];
            return M instanceof Error && F2(`index ${x}`, M), M;
          }
          if (_O.indexOf(k) >= 0)
            return Reflect.get(y, k, S);
          const A = y[k];
          if (A instanceof Function)
            return function(...x) {
              return A.apply(this === S ? y : this, x);
            };
          if (!(k in y))
            return y.getValue.apply(this === S ? y : this, [k]);
        }
        return Reflect.get(y, k, S);
      }
    });
    return AA(b, jp(this)), b;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(e) {
    const r = [];
    return this.forEach((i, u) => {
      i instanceof Error && F2(`index ${u}`, i), e && i instanceof q2 && (i = i.toArray(e)), r.push(i);
    }), r;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(e) {
    const r = jp(this);
    return r.reduce((i, u, d) => (Te(u != null, `value at index ${d} unnamed`, "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), h5(r, this, e)), {});
  }
  /**
   *  @_ignore
   */
  slice(e, r) {
    e == null && (e = 0), e < 0 && (e += this.length, e < 0 && (e = 0)), r == null && (r = this.length), r < 0 && (r += this.length, r < 0 && (r = 0)), r > this.length && (r = this.length);
    const i = jp(this), u = [], d = [];
    for (let g = e; g < r; g++)
      u.push(this[g]), d.push(i[g]);
    return new q2(c4, u, d);
  }
  /**
   *  @_ignore
   */
  filter(e, r) {
    const i = jp(this), u = [], d = [];
    for (let g = 0; g < this.length; g++) {
      const b = this[g];
      b instanceof Error && F2(`index ${g}`, b), e.call(r, b, g, this) && (u.push(b), d.push(i[g]));
    }
    return new q2(c4, u, d);
  }
  /**
   *  @_ignore
   */
  map(e, r) {
    const i = [];
    for (let u = 0; u < this.length; u++) {
      const d = this[u];
      d instanceof Error && F2(`index ${u}`, d), i.push(e.call(r, d, u, this));
    }
    return i;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(e) {
    const r = jp(this).indexOf(e);
    if (r === -1)
      return;
    const i = this[r];
    return i instanceof Error && F2(`property ${JSON.stringify(e)}`, i.error), i;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(e, r) {
    return new q2(c4, e, r);
  }
};
Y2 = /* @__PURE__ */ new WeakMap();
let X4 = UO;
function xA(a) {
  let e = kr(a);
  return Te(e.length <= za, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: e, length: za, offset: e.length }), e.length !== za && (e = Ua(vn([d5.slice(e.length % za), e]))), e;
}
class Uc {
  constructor(e, r, i, u) {
    le(this, "name"), le(this, "type"), le(this, "localName"), le(this, "dynamic"), Ke(this, { name: e, type: r, localName: i, dynamic: u }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(e, r) {
    se(!1, e, this.localName, r);
  }
}
var Rd, Ld, K2, C4;
class p5 {
  constructor() {
    ye(this, K2), ye(this, Rd), ye(this, Ld), Q(this, Rd, []), Q(this, Ld, 0);
  }
  get data() {
    return vn(R(this, Rd));
  }
  get length() {
    return R(this, Ld);
  }
  appendWriter(e) {
    return Oe(this, K2, C4).call(this, Ua(e.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(e) {
    let r = Ua(e);
    const i = r.length % za;
    return i && (r = Ua(vn([r, d5.slice(i)]))), Oe(this, K2, C4).call(this, r);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(e) {
    return Oe(this, K2, C4).call(this, xA(e));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const e = R(this, Rd).length;
    return R(this, Rd).push(d5), Q(this, Ld, R(this, Ld) + za), (r) => {
      R(this, Rd)[e] = xA(r);
    };
  }
}
Rd = /* @__PURE__ */ new WeakMap(), Ld = /* @__PURE__ */ new WeakMap(), K2 = /* @__PURE__ */ new WeakSet(), C4 = function(a) {
  return R(this, Rd).push(a), Q(this, Ld, R(this, Ld) + a.length), a.length;
};
var Fo, _o, $p, Iy, tg, Ov, g5, _x;
const zO = class Ux {
  constructor(e, r, i) {
    ye(this, Ov), le(this, "allowLoose"), ye(this, Fo), ye(this, _o), ye(this, $p), ye(this, Iy), ye(this, tg), Ke(this, { allowLoose: !!r }), Q(this, Fo, Ua(e)), Q(this, $p, 0), Q(this, Iy, null), Q(this, tg, i ?? 1024), Q(this, _o, 0);
  }
  get data() {
    return Ge(R(this, Fo));
  }
  get dataLength() {
    return R(this, Fo).length;
  }
  get consumed() {
    return R(this, _o);
  }
  get bytes() {
    return new Uint8Array(R(this, Fo));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(e) {
    const r = new Ux(R(this, Fo).slice(R(this, _o) + e), this.allowLoose, R(this, tg));
    return Q(r, Iy, this), r;
  }
  // Read bytes
  readBytes(e, r) {
    let i = Oe(this, Ov, _x).call(this, 0, e, !!r);
    return Oe(this, Ov, g5).call(this, e), Q(this, _o, R(this, _o) + i.length), i.slice(0, e);
  }
  // Read a numeric values
  readValue() {
    return By(this.readBytes(za));
  }
  readIndex() {
    return pO(this.readBytes(za));
  }
};
Fo = /* @__PURE__ */ new WeakMap(), _o = /* @__PURE__ */ new WeakMap(), $p = /* @__PURE__ */ new WeakMap(), Iy = /* @__PURE__ */ new WeakMap(), tg = /* @__PURE__ */ new WeakMap(), Ov = /* @__PURE__ */ new WeakSet(), g5 = function(a) {
  var e;
  if (R(this, Iy))
    return Oe(e = R(this, Iy), Ov, g5).call(e, a);
  Q(this, $p, R(this, $p) + a), Te(R(this, tg) < 1 || R(this, $p) <= R(this, tg) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${R(this, tg)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: Ua(R(this, Fo)),
    offset: R(this, _o),
    length: a,
    info: {
      bytesRead: R(this, $p),
      dataLength: this.dataLength
    }
  });
}, _x = function(a, e, r) {
  let i = Math.ceil(e / za) * za;
  return R(this, _o) + i > R(this, Fo).length && (this.allowLoose && r && R(this, _o) + e <= R(this, Fo).length ? i = e : Te(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: Ua(R(this, Fo)),
    length: R(this, Fo).length,
    offset: R(this, _o) + i
  })), R(this, Fo).slice(R(this, _o), R(this, _o) + i);
};
let HO = zO;
const CA = globalThis || void 0 || self;
function ek(a) {
  if (!Number.isSafeInteger(a) || a < 0)
    throw new Error(`Wrong positive integer: ${a}`);
}
function kE(a, ...e) {
  if (!(a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(a.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${a.length}`);
}
function VO(a) {
  if (typeof a != "function" || typeof a.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  ek(a.outputLen), ek(a.blockLen);
}
function Fy(a, e = !0) {
  if (a.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && a.finished)
    throw new Error("Hash#digest() has already been called");
}
function zx(a, e) {
  kE(a);
  const r = e.outputLen;
  if (a.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const w8 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Hx = (a) => a instanceof Uint8Array, WO = (a) => new Uint32Array(a.buffer, a.byteOffset, Math.floor(a.byteLength / 4)), k8 = (a) => new DataView(a.buffer, a.byteOffset, a.byteLength), Ul = (a, e) => a << 32 - e | a >>> e, GO = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!GO)
  throw new Error("Non little-endian hardware is not supported");
function jO(a) {
  if (typeof a != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof a}`);
  return new Uint8Array(new TextEncoder().encode(a));
}
function mk(a) {
  if (typeof a == "string" && (a = jO(a)), !Hx(a))
    throw new Error(`expected Uint8Array, got ${typeof a}`);
  return a;
}
function $O(...a) {
  const e = new Uint8Array(a.reduce((i, u) => i + u.length, 0));
  let r = 0;
  return a.forEach((i) => {
    if (!Hx(i))
      throw new Error("Uint8Array expected");
    e.set(i, r), r += i.length;
  }), e;
}
let EE = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function SE(a) {
  const e = (i) => a().update(mk(i)).digest(), r = a();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => a(), e;
}
function QO(a = 32) {
  if (w8 && typeof w8.getRandomValues == "function")
    return w8.getRandomValues(new Uint8Array(a));
  throw new Error("crypto.getRandomValues must be defined");
}
let Vx = class extends EE {
  constructor(a, e) {
    super(), this.finished = !1, this.destroyed = !1, VO(a);
    const r = mk(e);
    if (this.iHash = a.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, u = new Uint8Array(i);
    u.set(r.length > i ? a.create().update(r).digest() : r);
    for (let d = 0; d < u.length; d++)
      u[d] ^= 54;
    this.iHash.update(u), this.oHash = a.create();
    for (let d = 0; d < u.length; d++)
      u[d] ^= 106;
    this.oHash.update(u), u.fill(0);
  }
  update(a) {
    return Fy(this), this.iHash.update(a), this;
  }
  digestInto(a) {
    Fy(this), kE(a, this.outputLen), this.finished = !0, this.iHash.digestInto(a), this.oHash.update(a), this.oHash.digestInto(a), this.destroy();
  }
  digest() {
    const a = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(a), a;
  }
  _cloneInto(a) {
    a || (a = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: e, iHash: r, finished: i, destroyed: u, blockLen: d, outputLen: g } = this;
    return a = a, a.finished = i, a.destroyed = u, a.blockLen = d, a.outputLen = g, a.oHash = e._cloneInto(a.oHash), a.iHash = r._cloneInto(a.iHash), a;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const Wx = (a, e, r) => new Vx(a, e).update(r).digest();
Wx.create = (a, e) => new Vx(a, e);
function ZO(a, e, r, i) {
  if (typeof a.setBigUint64 == "function")
    return a.setBigUint64(e, r, i);
  const u = BigInt(32), d = BigInt(4294967295), g = Number(r >> u & d), b = Number(r & d), y = i ? 4 : 0, k = i ? 0 : 4;
  a.setUint32(e + y, g, i), a.setUint32(e + k, b, i);
}
class Gx extends EE {
  constructor(e, r, i, u) {
    super(), this.blockLen = e, this.outputLen = r, this.padOffset = i, this.isLE = u, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = k8(this.buffer);
  }
  update(e) {
    Fy(this);
    const { view: r, buffer: i, blockLen: u } = this;
    e = mk(e);
    const d = e.length;
    for (let g = 0; g < d; ) {
      const b = Math.min(u - this.pos, d - g);
      if (b === u) {
        const y = k8(e);
        for (; u <= d - g; g += u)
          this.process(y, g);
        continue;
      }
      i.set(e.subarray(g, g + b), this.pos), this.pos += b, g += b, this.pos === u && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Fy(this), zx(e, this), this.finished = !0;
    const { buffer: r, view: i, blockLen: u, isLE: d } = this;
    let { pos: g } = this;
    r[g++] = 128, this.buffer.subarray(g).fill(0), this.padOffset > u - g && (this.process(i, 0), g = 0);
    for (let A = g; A < u; A++)
      r[A] = 0;
    ZO(i, u - 8, BigInt(this.length * 8), d), this.process(i, 0);
    const b = k8(e), y = this.outputLen;
    if (y % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const k = y / 4, S = this.get();
    if (k > S.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let A = 0; A < k; A++)
      b.setUint32(4 * A, S[A], d);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const i = e.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: i, length: u, finished: d, destroyed: g, pos: b } = this;
    return e.length = u, e.pos = b, e.finished = d, e.destroyed = g, u % r && e.buffer.set(i), e;
  }
}
const YO = (a, e, r) => a & e ^ ~a & r, qO = (a, e, r) => a & e ^ a & r ^ e & r, KO = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ud = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), cd = /* @__PURE__ */ new Uint32Array(64);
let JO = class extends Gx {
  constructor() {
    super(64, 32, 8, !1), this.A = ud[0] | 0, this.B = ud[1] | 0, this.C = ud[2] | 0, this.D = ud[3] | 0, this.E = ud[4] | 0, this.F = ud[5] | 0, this.G = ud[6] | 0, this.H = ud[7] | 0;
  }
  get() {
    const { A: a, B: e, C: r, D: i, E: u, F: d, G: g, H: b } = this;
    return [a, e, r, i, u, d, g, b];
  }
  // prettier-ignore
  set(a, e, r, i, u, d, g, b) {
    this.A = a | 0, this.B = e | 0, this.C = r | 0, this.D = i | 0, this.E = u | 0, this.F = d | 0, this.G = g | 0, this.H = b | 0;
  }
  process(a, e) {
    for (let S = 0; S < 16; S++, e += 4)
      cd[S] = a.getUint32(e, !1);
    for (let S = 16; S < 64; S++) {
      const A = cd[S - 15], x = cd[S - 2], M = Ul(A, 7) ^ Ul(A, 18) ^ A >>> 3, D = Ul(x, 17) ^ Ul(x, 19) ^ x >>> 10;
      cd[S] = D + cd[S - 7] + M + cd[S - 16] | 0;
    }
    let { A: r, B: i, C: u, D: d, E: g, F: b, G: y, H: k } = this;
    for (let S = 0; S < 64; S++) {
      const A = Ul(g, 6) ^ Ul(g, 11) ^ Ul(g, 25), x = k + A + YO(g, b, y) + KO[S] + cd[S] | 0, M = (Ul(r, 2) ^ Ul(r, 13) ^ Ul(r, 22)) + qO(r, i, u) | 0;
      k = y, y = b, b = g, g = d + x | 0, d = u, u = i, i = r, r = x + M | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, u = u + this.C | 0, d = d + this.D | 0, g = g + this.E | 0, b = b + this.F | 0, y = y + this.G | 0, k = k + this.H | 0, this.set(r, i, u, d, g, b, y, k);
  }
  roundClean() {
    cd.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const jx = /* @__PURE__ */ SE(() => new JO()), f4 = /* @__PURE__ */ BigInt(2 ** 32 - 1), m5 = /* @__PURE__ */ BigInt(32);
function $x(a, e = !1) {
  return e ? { h: Number(a & f4), l: Number(a >> m5 & f4) } : { h: Number(a >> m5 & f4) | 0, l: Number(a & f4) | 0 };
}
function Qx(a, e = !1) {
  let r = new Uint32Array(a.length), i = new Uint32Array(a.length);
  for (let u = 0; u < a.length; u++) {
    const { h: d, l: g } = $x(a[u], e);
    [r[u], i[u]] = [d, g];
  }
  return [r, i];
}
const XO = (a, e) => BigInt(a >>> 0) << m5 | BigInt(e >>> 0), eR = (a, e, r) => a >>> r, tR = (a, e, r) => a << 32 - r | e >>> r, nR = (a, e, r) => a >>> r | e << 32 - r, rR = (a, e, r) => a << 32 - r | e >>> r, aR = (a, e, r) => a << 64 - r | e >>> r - 32, oR = (a, e, r) => a >>> r - 32 | e << 64 - r, iR = (a, e) => e, sR = (a, e) => a, Zx = (a, e, r) => a << r | e >>> 32 - r, Yx = (a, e, r) => e << r | a >>> 32 - r, qx = (a, e, r) => e << r - 32 | a >>> 64 - r, Kx = (a, e, r) => a << r - 32 | e >>> 64 - r;
function lR(a, e, r, i) {
  const u = (e >>> 0) + (i >>> 0);
  return { h: a + r + (u / 2 ** 32 | 0) | 0, l: u | 0 };
}
const uR = (a, e, r) => (a >>> 0) + (e >>> 0) + (r >>> 0), cR = (a, e, r, i) => e + r + i + (a / 2 ** 32 | 0) | 0, fR = (a, e, r, i) => (a >>> 0) + (e >>> 0) + (r >>> 0) + (i >>> 0), dR = (a, e, r, i, u) => e + r + i + u + (a / 2 ** 32 | 0) | 0, hR = (a, e, r, i, u) => (a >>> 0) + (e >>> 0) + (r >>> 0) + (i >>> 0) + (u >>> 0), pR = (a, e, r, i, u, d) => e + r + i + u + d + (a / 2 ** 32 | 0) | 0, pt = {
  fromBig: $x,
  split: Qx,
  toBig: XO,
  shrSH: eR,
  shrSL: tR,
  rotrSH: nR,
  rotrSL: rR,
  rotrBH: aR,
  rotrBL: oR,
  rotr32H: iR,
  rotr32L: sR,
  rotlSH: Zx,
  rotlSL: Yx,
  rotlBH: qx,
  rotlBL: Kx,
  add: lR,
  add3L: uR,
  add3H: cR,
  add4L: fR,
  add4H: dR,
  add5H: pR,
  add5L: hR
}, [gR, mR] = pt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((a) => BigInt(a))), fd = /* @__PURE__ */ new Uint32Array(80), dd = /* @__PURE__ */ new Uint32Array(80);
class yR extends Gx {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: r, Bh: i, Bl: u, Ch: d, Cl: g, Dh: b, Dl: y, Eh: k, El: S, Fh: A, Fl: x, Gh: M, Gl: D, Hh: O, Hl: T } = this;
    return [e, r, i, u, d, g, b, y, k, S, A, x, M, D, O, T];
  }
  // prettier-ignore
  set(e, r, i, u, d, g, b, y, k, S, A, x, M, D, O, T) {
    this.Ah = e | 0, this.Al = r | 0, this.Bh = i | 0, this.Bl = u | 0, this.Ch = d | 0, this.Cl = g | 0, this.Dh = b | 0, this.Dl = y | 0, this.Eh = k | 0, this.El = S | 0, this.Fh = A | 0, this.Fl = x | 0, this.Gh = M | 0, this.Gl = D | 0, this.Hh = O | 0, this.Hl = T | 0;
  }
  process(e, r) {
    for (let W = 0; W < 16; W++, r += 4)
      fd[W] = e.getUint32(r), dd[W] = e.getUint32(r += 4);
    for (let W = 16; W < 80; W++) {
      const Z = fd[W - 15] | 0, J = dd[W - 15] | 0, Y = pt.rotrSH(Z, J, 1) ^ pt.rotrSH(Z, J, 8) ^ pt.shrSH(Z, J, 7), X = pt.rotrSL(Z, J, 1) ^ pt.rotrSL(Z, J, 8) ^ pt.shrSL(Z, J, 7), ee = fd[W - 2] | 0, j = dd[W - 2] | 0, ne = pt.rotrSH(ee, j, 19) ^ pt.rotrBH(ee, j, 61) ^ pt.shrSH(ee, j, 6), ae = pt.rotrSL(ee, j, 19) ^ pt.rotrBL(ee, j, 61) ^ pt.shrSL(ee, j, 6), he = pt.add4L(X, ae, dd[W - 7], dd[W - 16]), Ie = pt.add4H(he, Y, ne, fd[W - 7], fd[W - 16]);
      fd[W] = Ie | 0, dd[W] = he | 0;
    }
    let { Ah: i, Al: u, Bh: d, Bl: g, Ch: b, Cl: y, Dh: k, Dl: S, Eh: A, El: x, Fh: M, Fl: D, Gh: O, Gl: T, Hh: L, Hl: U } = this;
    for (let W = 0; W < 80; W++) {
      const Z = pt.rotrSH(A, x, 14) ^ pt.rotrSH(A, x, 18) ^ pt.rotrBH(A, x, 41), J = pt.rotrSL(A, x, 14) ^ pt.rotrSL(A, x, 18) ^ pt.rotrBL(A, x, 41), Y = A & M ^ ~A & O, X = x & D ^ ~x & T, ee = pt.add5L(U, J, X, mR[W], dd[W]), j = pt.add5H(ee, L, Z, Y, gR[W], fd[W]), ne = ee | 0, ae = pt.rotrSH(i, u, 28) ^ pt.rotrBH(i, u, 34) ^ pt.rotrBH(i, u, 39), he = pt.rotrSL(i, u, 28) ^ pt.rotrBL(i, u, 34) ^ pt.rotrBL(i, u, 39), Ie = i & d ^ i & b ^ d & b, V = u & g ^ u & y ^ g & y;
      L = O | 0, U = T | 0, O = M | 0, T = D | 0, M = A | 0, D = x | 0, { h: A, l: x } = pt.add(k | 0, S | 0, j | 0, ne | 0), k = b | 0, S = y | 0, b = d | 0, y = g | 0, d = i | 0, g = u | 0;
      const B = pt.add3L(ne, he, V);
      i = pt.add3H(B, j, ae, Ie), u = B | 0;
    }
    ({ h: i, l: u } = pt.add(this.Ah | 0, this.Al | 0, i | 0, u | 0)), { h: d, l: g } = pt.add(this.Bh | 0, this.Bl | 0, d | 0, g | 0), { h: b, l: y } = pt.add(this.Ch | 0, this.Cl | 0, b | 0, y | 0), { h: k, l: S } = pt.add(this.Dh | 0, this.Dl | 0, k | 0, S | 0), { h: A, l: x } = pt.add(this.Eh | 0, this.El | 0, A | 0, x | 0), { h: M, l: D } = pt.add(this.Fh | 0, this.Fl | 0, M | 0, D | 0), { h: O, l: T } = pt.add(this.Gh | 0, this.Gl | 0, O | 0, T | 0), { h: L, l: U } = pt.add(this.Hh | 0, this.Hl | 0, L | 0, U | 0), this.set(i, u, d, g, b, y, k, S, A, x, M, D, O, T, L, U);
  }
  roundClean() {
    fd.fill(0), dd.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const bR = /* @__PURE__ */ SE(() => new yR());
function vR() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof CA < "u")
    return CA;
  throw new Error("unable to locate global object");
}
const TA = vR();
TA.crypto || TA.msCrypto;
function wR(a) {
  switch (a) {
    case "sha256":
      return jx.create();
    case "sha512":
      return bR.create();
  }
  se(!1, "invalid hashing algorithm name", "algorithm", a);
}
const [Jx, Xx, eC] = [[], [], []], kR = /* @__PURE__ */ BigInt(0), _2 = /* @__PURE__ */ BigInt(1), ER = /* @__PURE__ */ BigInt(2), SR = /* @__PURE__ */ BigInt(7), AR = /* @__PURE__ */ BigInt(256), xR = /* @__PURE__ */ BigInt(113);
for (let a = 0, e = _2, r = 1, i = 0; a < 24; a++) {
  [r, i] = [i, (2 * r + 3 * i) % 5], Jx.push(2 * (5 * i + r)), Xx.push((a + 1) * (a + 2) / 2 % 64);
  let u = kR;
  for (let d = 0; d < 7; d++)
    e = (e << _2 ^ (e >> SR) * xR) % AR, e & ER && (u ^= _2 << (_2 << /* @__PURE__ */ BigInt(d)) - _2);
  eC.push(u);
}
const [CR, TR] = /* @__PURE__ */ Qx(eC, !0), IA = (a, e, r) => r > 32 ? qx(a, e, r) : Zx(a, e, r), NA = (a, e, r) => r > 32 ? Kx(a, e, r) : Yx(a, e, r);
function IR(a, e = 24) {
  const r = new Uint32Array(10);
  for (let i = 24 - e; i < 24; i++) {
    for (let g = 0; g < 10; g++)
      r[g] = a[g] ^ a[g + 10] ^ a[g + 20] ^ a[g + 30] ^ a[g + 40];
    for (let g = 0; g < 10; g += 2) {
      const b = (g + 8) % 10, y = (g + 2) % 10, k = r[y], S = r[y + 1], A = IA(k, S, 1) ^ r[b], x = NA(k, S, 1) ^ r[b + 1];
      for (let M = 0; M < 50; M += 10)
        a[g + M] ^= A, a[g + M + 1] ^= x;
    }
    let u = a[2], d = a[3];
    for (let g = 0; g < 24; g++) {
      const b = Xx[g], y = IA(u, d, b), k = NA(u, d, b), S = Jx[g];
      u = a[S], d = a[S + 1], a[S] = y, a[S + 1] = k;
    }
    for (let g = 0; g < 50; g += 10) {
      for (let b = 0; b < 10; b++)
        r[b] = a[g + b];
      for (let b = 0; b < 10; b++)
        a[g + b] ^= ~r[(b + 2) % 10] & r[(b + 4) % 10];
    }
    a[0] ^= CR[i], a[1] ^= TR[i];
  }
  r.fill(0);
}
let NR = class tC extends EE {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, r, i, u = !1, d = 24) {
    if (super(), this.blockLen = e, this.suffix = r, this.outputLen = i, this.enableXOF = u, this.rounds = d, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, ek(i), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = WO(this.state);
  }
  keccak() {
    IR(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Fy(this);
    const { blockLen: r, state: i } = this;
    e = mk(e);
    const u = e.length;
    for (let d = 0; d < u; ) {
      const g = Math.min(r - this.pos, u - d);
      for (let b = 0; b < g; b++)
        i[this.pos++] ^= e[d++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: r, pos: i, blockLen: u } = this;
    e[i] ^= r, r & 128 && i === u - 1 && this.keccak(), e[u - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Fy(this, !1), kE(e), this.finish();
    const r = this.state, { blockLen: i } = this;
    for (let u = 0, d = e.length; u < d; ) {
      this.posOut >= i && this.keccak();
      const g = Math.min(i - this.posOut, d - u);
      e.set(r.subarray(this.posOut, this.posOut + g), u), this.posOut += g, u += g;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return ek(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (zx(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: r, suffix: i, outputLen: u, rounds: d, enableXOF: g } = this;
    return e || (e = new tC(r, i, u, g, d)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = d, e.suffix = i, e.outputLen = u, e.enableXOF = g, e.destroyed = this.destroyed, e;
  }
};
const PR = (a, e, r) => SE(() => new NR(e, a, r)), OR = /* @__PURE__ */ PR(1, 136, 256 / 8);
let nC = !1;
const rC = function(a) {
  return OR(a);
};
let aC = rC;
function xn(a) {
  const e = mt(a, "data");
  return Ge(aC(e));
}
xn._ = rC;
xn.lock = function() {
  nC = !0;
};
xn.register = function(a) {
  if (nC)
    throw new TypeError("keccak256 is locked");
  aC = a;
};
Object.freeze(xn);
const oC = function(a) {
  return wR("sha256").update(a).digest();
};
let iC = oC, sC = !1;
function zd(a) {
  const e = mt(a, "data");
  return Ge(iC(e));
}
zd._ = oC;
zd.lock = function() {
  sC = !0;
};
zd.register = function(a) {
  if (sC)
    throw new Error("sha256 is locked");
  iC = a;
};
Object.freeze(zd);
Object.freeze(zd);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const lC = BigInt(0), yk = BigInt(1), RR = BigInt(2), bk = (a) => a instanceof Uint8Array, LR = /* @__PURE__ */ Array.from({ length: 256 }, (a, e) => e.toString(16).padStart(2, "0"));
function _y(a) {
  if (!bk(a))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let r = 0; r < a.length; r++)
    e += LR[a[r]];
  return e;
}
function uC(a) {
  const e = a.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function AE(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  return BigInt(a === "" ? "0" : `0x${a}`);
}
function Uy(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  const e = a.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(e / 2);
  for (let i = 0; i < r.length; i++) {
    const u = i * 2, d = a.slice(u, u + 2), g = Number.parseInt(d, 16);
    if (Number.isNaN(g) || g < 0)
      throw new Error("Invalid byte sequence");
    r[i] = g;
  }
  return r;
}
function cg(a) {
  return AE(_y(a));
}
function xE(a) {
  if (!bk(a))
    throw new Error("Uint8Array expected");
  return AE(_y(Uint8Array.from(a).reverse()));
}
function zy(a, e) {
  return Uy(a.toString(16).padStart(e * 2, "0"));
}
function CE(a, e) {
  return zy(a, e).reverse();
}
function DR(a) {
  return Uy(uC(a));
}
function Ds(a, e, r) {
  let i;
  if (typeof e == "string")
    try {
      i = Uy(e);
    } catch (d) {
      throw new Error(`${a} must be valid hex string, got "${e}". Cause: ${d}`);
    }
  else if (bk(e))
    i = Uint8Array.from(e);
  else
    throw new Error(`${a} must be hex string or Uint8Array`);
  const u = i.length;
  if (typeof r == "number" && u !== r)
    throw new Error(`${a} expected ${r} bytes, got ${u}`);
  return i;
}
function Uv(...a) {
  const e = new Uint8Array(a.reduce((i, u) => i + u.length, 0));
  let r = 0;
  return a.forEach((i) => {
    if (!bk(i))
      throw new Error("Uint8Array expected");
    e.set(i, r), r += i.length;
  }), e;
}
function BR(a, e) {
  if (a.length !== e.length)
    return !1;
  for (let r = 0; r < a.length; r++)
    if (a[r] !== e[r])
      return !1;
  return !0;
}
function MR(a) {
  if (typeof a != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof a}`);
  return new Uint8Array(new TextEncoder().encode(a));
}
function FR(a) {
  let e;
  for (e = 0; a > lC; a >>= yk, e += 1)
    ;
  return e;
}
function _R(a, e) {
  return a >> BigInt(e) & yk;
}
const UR = (a, e, r) => a | (r ? yk : lC) << BigInt(e), TE = (a) => (RR << BigInt(a - 1)) - yk, E8 = (a) => new Uint8Array(a), PA = (a) => Uint8Array.from(a);
function cC(a, e, r) {
  if (typeof a != "number" || a < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let i = E8(a), u = E8(a), d = 0;
  const g = () => {
    i.fill(1), u.fill(0), d = 0;
  }, b = (...S) => r(u, i, ...S), y = (S = E8()) => {
    u = b(PA([0]), S), i = b(), S.length !== 0 && (u = b(PA([1]), S), i = b());
  }, k = () => {
    if (d++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let S = 0;
    const A = [];
    for (; S < e; ) {
      i = b();
      const x = i.slice();
      A.push(x), S += i.length;
    }
    return Uv(...A);
  };
  return (S, A) => {
    g(), y(S);
    let x;
    for (; !(x = A(k())); )
      y();
    return g(), x;
  };
}
const zR = {
  bigint: (a) => typeof a == "bigint",
  function: (a) => typeof a == "function",
  boolean: (a) => typeof a == "boolean",
  string: (a) => typeof a == "string",
  stringOrUint8Array: (a) => typeof a == "string" || a instanceof Uint8Array,
  isSafeInteger: (a) => Number.isSafeInteger(a),
  array: (a) => Array.isArray(a),
  field: (a, e) => e.Fp.isValid(a),
  hash: (a) => typeof a == "function" && Number.isSafeInteger(a.outputLen)
};
function nw(a, e, r = {}) {
  const i = (u, d, g) => {
    const b = zR[d];
    if (typeof b != "function")
      throw new Error(`Invalid validator "${d}", expected function`);
    const y = a[u];
    if (!(g && y === void 0) && !b(y, a))
      throw new Error(`Invalid param ${String(u)}=${y} (${typeof y}), expected ${d}`);
  };
  for (const [u, d] of Object.entries(e))
    i(u, d, !1);
  for (const [u, d] of Object.entries(r))
    i(u, d, !0);
  return a;
}
const HR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: _R,
  bitLen: FR,
  bitMask: TE,
  bitSet: UR,
  bytesToHex: _y,
  bytesToNumberBE: cg,
  bytesToNumberLE: xE,
  concatBytes: Uv,
  createHmacDrbg: cC,
  ensureBytes: Ds,
  equalBytes: BR,
  hexToBytes: Uy,
  hexToNumber: AE,
  numberToBytesBE: zy,
  numberToBytesLE: CE,
  numberToHexUnpadded: uC,
  numberToVarBytesBE: DR,
  utf8ToBytes: MR,
  validateObject: nw
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _r = BigInt(0), Qn = BigInt(1), Qp = BigInt(2), VR = BigInt(3), y5 = BigInt(4), OA = BigInt(5), RA = BigInt(8);
BigInt(9);
BigInt(16);
function oo(a, e) {
  const r = a % e;
  return r >= _r ? r : e + r;
}
function WR(a, e, r) {
  if (r <= _r || e < _r)
    throw new Error("Expected power/modulo > 0");
  if (r === Qn)
    return _r;
  let i = Qn;
  for (; e > _r; )
    e & Qn && (i = i * a % r), a = a * a % r, e >>= Qn;
  return i;
}
function Ii(a, e, r) {
  let i = a;
  for (; e-- > _r; )
    i *= i, i %= r;
  return i;
}
function b5(a, e) {
  if (a === _r || e <= _r)
    throw new Error(`invert: expected positive integers, got n=${a} mod=${e}`);
  let r = oo(a, e), i = e, u = _r, d = Qn;
  for (; r !== _r; ) {
    const g = i / r, b = i % r, y = u - d * g;
    i = r, r = b, u = d, d = y;
  }
  if (i !== Qn)
    throw new Error("invert: does not exist");
  return oo(u, e);
}
function GR(a) {
  const e = (a - Qn) / Qp;
  let r, i, u;
  for (r = a - Qn, i = 0; r % Qp === _r; r /= Qp, i++)
    ;
  for (u = Qp; u < a && WR(u, e, a) !== a - Qn; u++)
    ;
  if (i === 1) {
    const g = (a + Qn) / y5;
    return function(b, y) {
      const k = b.pow(y, g);
      if (!b.eql(b.sqr(k), y))
        throw new Error("Cannot find square root");
      return k;
    };
  }
  const d = (r + Qn) / Qp;
  return function(g, b) {
    if (g.pow(b, e) === g.neg(g.ONE))
      throw new Error("Cannot find square root");
    let y = i, k = g.pow(g.mul(g.ONE, u), r), S = g.pow(b, d), A = g.pow(b, r);
    for (; !g.eql(A, g.ONE); ) {
      if (g.eql(A, g.ZERO))
        return g.ZERO;
      let x = 1;
      for (let D = g.sqr(A); x < y && !g.eql(D, g.ONE); x++)
        D = g.sqr(D);
      const M = g.pow(k, Qn << BigInt(y - x - 1));
      k = g.sqr(M), S = g.mul(S, M), A = g.mul(A, k), y = x;
    }
    return S;
  };
}
function jR(a) {
  if (a % y5 === VR) {
    const e = (a + Qn) / y5;
    return function(r, i) {
      const u = r.pow(i, e);
      if (!r.eql(r.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  if (a % RA === OA) {
    const e = (a - OA) / RA;
    return function(r, i) {
      const u = r.mul(i, Qp), d = r.pow(u, e), g = r.mul(i, d), b = r.mul(r.mul(g, Qp), d), y = r.mul(g, r.sub(b, r.ONE));
      if (!r.eql(r.sqr(y), i))
        throw new Error("Cannot find square root");
      return y;
    };
  }
  return GR(a);
}
const $R = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function QR(a) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = $R.reduce((i, u) => (i[u] = "function", i), e);
  return nw(a, r);
}
function ZR(a, e, r) {
  if (r < _r)
    throw new Error("Expected power > 0");
  if (r === _r)
    return a.ONE;
  if (r === Qn)
    return e;
  let i = a.ONE, u = e;
  for (; r > _r; )
    r & Qn && (i = a.mul(i, u)), u = a.sqr(u), r >>= Qn;
  return i;
}
function YR(a, e) {
  const r = new Array(e.length), i = e.reduce((d, g, b) => a.is0(g) ? d : (r[b] = d, a.mul(d, g)), a.ONE), u = a.inv(i);
  return e.reduceRight((d, g, b) => a.is0(g) ? d : (r[b] = a.mul(d, r[b]), a.mul(d, g)), u), r;
}
function fC(a, e) {
  const r = e !== void 0 ? e : a.toString(2).length, i = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: i };
}
function qR(a, e, r = !1, i = {}) {
  if (a <= _r)
    throw new Error(`Expected Field ORDER > 0, got ${a}`);
  const { nBitLength: u, nByteLength: d } = fC(a, e);
  if (d > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const g = jR(a), b = Object.freeze({
    ORDER: a,
    BITS: u,
    BYTES: d,
    MASK: TE(u),
    ZERO: _r,
    ONE: Qn,
    create: (y) => oo(y, a),
    isValid: (y) => {
      if (typeof y != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof y}`);
      return _r <= y && y < a;
    },
    is0: (y) => y === _r,
    isOdd: (y) => (y & Qn) === Qn,
    neg: (y) => oo(-y, a),
    eql: (y, k) => y === k,
    sqr: (y) => oo(y * y, a),
    add: (y, k) => oo(y + k, a),
    sub: (y, k) => oo(y - k, a),
    mul: (y, k) => oo(y * k, a),
    pow: (y, k) => ZR(b, y, k),
    div: (y, k) => oo(y * b5(k, a), a),
    // Same as above, but doesn't normalize
    sqrN: (y) => y * y,
    addN: (y, k) => y + k,
    subN: (y, k) => y - k,
    mulN: (y, k) => y * k,
    inv: (y) => b5(y, a),
    sqrt: i.sqrt || ((y) => g(b, y)),
    invertBatch: (y) => YR(b, y),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (y, k, S) => S ? k : y,
    toBytes: (y) => r ? CE(y, d) : zy(y, d),
    fromBytes: (y) => {
      if (y.length !== d)
        throw new Error(`Fp.fromBytes: expected ${d}, got ${y.length}`);
      return r ? xE(y) : cg(y);
    }
  });
  return Object.freeze(b);
}
function dC(a) {
  if (typeof a != "bigint")
    throw new Error("field order must be bigint");
  const e = a.toString(2).length;
  return Math.ceil(e / 8);
}
function hC(a) {
  const e = dC(a);
  return e + Math.ceil(e / 2);
}
function KR(a, e, r = !1) {
  const i = a.length, u = dC(e), d = hC(e);
  if (i < 16 || i < d || i > 1024)
    throw new Error(`expected ${d}-1024 bytes of input, got ${i}`);
  const g = r ? cg(a) : xE(a), b = oo(g, e - Qn) + Qn;
  return r ? CE(b, u) : zy(b, u);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const JR = BigInt(0), S8 = BigInt(1);
function XR(a, e) {
  const r = (u, d) => {
    const g = d.negate();
    return u ? g : d;
  }, i = (u) => {
    const d = Math.ceil(e / u) + 1, g = 2 ** (u - 1);
    return { windows: d, windowSize: g };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(u, d) {
      let g = a.ZERO, b = u;
      for (; d > JR; )
        d & S8 && (g = g.add(b)), b = b.double(), d >>= S8;
      return g;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(u, d) {
      const { windows: g, windowSize: b } = i(d), y = [];
      let k = u, S = k;
      for (let A = 0; A < g; A++) {
        S = k, y.push(S);
        for (let x = 1; x < b; x++)
          S = S.add(k), y.push(S);
        k = S.double();
      }
      return y;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(u, d, g) {
      const { windows: b, windowSize: y } = i(u);
      let k = a.ZERO, S = a.BASE;
      const A = BigInt(2 ** u - 1), x = 2 ** u, M = BigInt(u);
      for (let D = 0; D < b; D++) {
        const O = D * y;
        let T = Number(g & A);
        g >>= M, T > y && (T -= x, g += S8);
        const L = O, U = O + Math.abs(T) - 1, W = D % 2 !== 0, Z = T < 0;
        T === 0 ? S = S.add(r(W, d[L])) : k = k.add(r(Z, d[U]));
      }
      return { p: k, f: S };
    },
    wNAFCached(u, d, g, b) {
      const y = u._WINDOW_SIZE || 1;
      let k = d.get(u);
      return k || (k = this.precomputeWindow(u, y), y !== 1 && d.set(u, b(k))), this.wNAF(y, k, g);
    }
  };
}
function pC(a) {
  return QR(a.Fp), nw(a, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...fC(a.n, a.nBitLength),
    ...a,
    p: a.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function eL(a) {
  const e = pC(a);
  nw(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: i, a: u } = e;
  if (r) {
    if (!i.eql(u, i.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: tL, hexToBytes: nL } = HR, ng = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(a = "") {
      super(a);
    }
  },
  _parseInt(a) {
    const { Err: e } = ng;
    if (a.length < 2 || a[0] !== 2)
      throw new e("Invalid signature integer tag");
    const r = a[1], i = a.subarray(2, r + 2);
    if (!r || i.length !== r)
      throw new e("Invalid signature integer: wrong length");
    if (i[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (i[0] === 0 && !(i[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: tL(i), l: a.subarray(r + 2) };
  },
  toSig(a) {
    const { Err: e } = ng, r = typeof a == "string" ? nL(a) : a;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let i = r.length;
    if (i < 2 || r[0] != 48)
      throw new e("Invalid signature tag");
    if (r[1] !== i - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: u, l: d } = ng._parseInt(r.subarray(2)), { d: g, l: b } = ng._parseInt(d);
    if (b.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: u, s: g };
  },
  hexFromSig(a) {
    const e = (k) => Number.parseInt(k[0], 16) & 8 ? "00" + k : k, r = (k) => {
      const S = k.toString(16);
      return S.length & 1 ? `0${S}` : S;
    }, i = e(r(a.s)), u = e(r(a.r)), d = i.length / 2, g = u.length / 2, b = r(d), y = r(g);
    return `30${r(g + d + 4)}02${y}${u}02${b}${i}`;
  }
}, Cc = BigInt(0), Li = BigInt(1);
BigInt(2);
const LA = BigInt(3);
BigInt(4);
function rL(a) {
  const e = eL(a), { Fp: r } = e, i = e.toBytes || ((D, O, T) => {
    const L = O.toAffine();
    return Uv(Uint8Array.from([4]), r.toBytes(L.x), r.toBytes(L.y));
  }), u = e.fromBytes || ((D) => {
    const O = D.subarray(1), T = r.fromBytes(O.subarray(0, r.BYTES)), L = r.fromBytes(O.subarray(r.BYTES, 2 * r.BYTES));
    return { x: T, y: L };
  });
  function d(D) {
    const { a: O, b: T } = e, L = r.sqr(D), U = r.mul(L, D);
    return r.add(r.add(U, r.mul(D, O)), T);
  }
  if (!r.eql(r.sqr(e.Gy), d(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function g(D) {
    return typeof D == "bigint" && Cc < D && D < e.n;
  }
  function b(D) {
    if (!g(D))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function y(D) {
    const { allowedPrivateKeyLengths: O, nByteLength: T, wrapPrivateKey: L, n: U } = e;
    if (O && typeof D != "bigint") {
      if (D instanceof Uint8Array && (D = _y(D)), typeof D != "string" || !O.includes(D.length))
        throw new Error("Invalid key");
      D = D.padStart(T * 2, "0");
    }
    let W;
    try {
      W = typeof D == "bigint" ? D : cg(Ds("private key", D, T));
    } catch {
      throw new Error(`private key must be ${T} bytes, hex or bigint, not ${typeof D}`);
    }
    return L && (W = oo(W, U)), b(W), W;
  }
  const k = /* @__PURE__ */ new Map();
  function S(D) {
    if (!(D instanceof A))
      throw new Error("ProjectivePoint expected");
  }
  class A {
    constructor(O, T, L) {
      if (this.px = O, this.py = T, this.pz = L, O == null || !r.isValid(O))
        throw new Error("x required");
      if (T == null || !r.isValid(T))
        throw new Error("y required");
      if (L == null || !r.isValid(L))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(O) {
      const { x: T, y: L } = O || {};
      if (!O || !r.isValid(T) || !r.isValid(L))
        throw new Error("invalid affine point");
      if (O instanceof A)
        throw new Error("projective point not allowed");
      const U = (W) => r.eql(W, r.ZERO);
      return U(T) && U(L) ? A.ZERO : new A(T, L, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(O) {
      const T = r.invertBatch(O.map((L) => L.pz));
      return O.map((L, U) => L.toAffine(T[U])).map(A.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(O) {
      const T = A.fromAffine(u(Ds("pointHex", O)));
      return T.assertValidity(), T;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(O) {
      return A.BASE.multiply(y(O));
    }
    // "Private method", don't use it directly
    _setWindowSize(O) {
      this._WINDOW_SIZE = O, k.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !r.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: O, y: T } = this.toAffine();
      if (!r.isValid(O) || !r.isValid(T))
        throw new Error("bad point: x or y not FE");
      const L = r.sqr(T), U = d(O);
      if (!r.eql(L, U))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: O } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(O);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(O) {
      S(O);
      const { px: T, py: L, pz: U } = this, { px: W, py: Z, pz: J } = O, Y = r.eql(r.mul(T, J), r.mul(W, U)), X = r.eql(r.mul(L, J), r.mul(Z, U));
      return Y && X;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new A(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: O, b: T } = e, L = r.mul(T, LA), { px: U, py: W, pz: Z } = this;
      let J = r.ZERO, Y = r.ZERO, X = r.ZERO, ee = r.mul(U, U), j = r.mul(W, W), ne = r.mul(Z, Z), ae = r.mul(U, W);
      return ae = r.add(ae, ae), X = r.mul(U, Z), X = r.add(X, X), J = r.mul(O, X), Y = r.mul(L, ne), Y = r.add(J, Y), J = r.sub(j, Y), Y = r.add(j, Y), Y = r.mul(J, Y), J = r.mul(ae, J), X = r.mul(L, X), ne = r.mul(O, ne), ae = r.sub(ee, ne), ae = r.mul(O, ae), ae = r.add(ae, X), X = r.add(ee, ee), ee = r.add(X, ee), ee = r.add(ee, ne), ee = r.mul(ee, ae), Y = r.add(Y, ee), ne = r.mul(W, Z), ne = r.add(ne, ne), ee = r.mul(ne, ae), J = r.sub(J, ee), X = r.mul(ne, j), X = r.add(X, X), X = r.add(X, X), new A(J, Y, X);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(O) {
      S(O);
      const { px: T, py: L, pz: U } = this, { px: W, py: Z, pz: J } = O;
      let Y = r.ZERO, X = r.ZERO, ee = r.ZERO;
      const j = e.a, ne = r.mul(e.b, LA);
      let ae = r.mul(T, W), he = r.mul(L, Z), Ie = r.mul(U, J), V = r.add(T, L), B = r.add(W, Z);
      V = r.mul(V, B), B = r.add(ae, he), V = r.sub(V, B), B = r.add(T, U);
      let P = r.add(W, J);
      return B = r.mul(B, P), P = r.add(ae, Ie), B = r.sub(B, P), P = r.add(L, U), Y = r.add(Z, J), P = r.mul(P, Y), Y = r.add(he, Ie), P = r.sub(P, Y), ee = r.mul(j, B), Y = r.mul(ne, Ie), ee = r.add(Y, ee), Y = r.sub(he, ee), ee = r.add(he, ee), X = r.mul(Y, ee), he = r.add(ae, ae), he = r.add(he, ae), Ie = r.mul(j, Ie), B = r.mul(ne, B), he = r.add(he, Ie), Ie = r.sub(ae, Ie), Ie = r.mul(j, Ie), B = r.add(B, Ie), ae = r.mul(he, B), X = r.add(X, ae), ae = r.mul(P, B), Y = r.mul(V, Y), Y = r.sub(Y, ae), ae = r.mul(V, he), ee = r.mul(P, ee), ee = r.add(ee, ae), new A(Y, X, ee);
    }
    subtract(O) {
      return this.add(O.negate());
    }
    is0() {
      return this.equals(A.ZERO);
    }
    wNAF(O) {
      return M.wNAFCached(this, k, O, (T) => {
        const L = r.invertBatch(T.map((U) => U.pz));
        return T.map((U, W) => U.toAffine(L[W])).map(A.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(O) {
      const T = A.ZERO;
      if (O === Cc)
        return T;
      if (b(O), O === Li)
        return this;
      const { endo: L } = e;
      if (!L)
        return M.unsafeLadder(this, O);
      let { k1neg: U, k1: W, k2neg: Z, k2: J } = L.splitScalar(O), Y = T, X = T, ee = this;
      for (; W > Cc || J > Cc; )
        W & Li && (Y = Y.add(ee)), J & Li && (X = X.add(ee)), ee = ee.double(), W >>= Li, J >>= Li;
      return U && (Y = Y.negate()), Z && (X = X.negate()), X = new A(r.mul(X.px, L.beta), X.py, X.pz), Y.add(X);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(O) {
      b(O);
      let T = O, L, U;
      const { endo: W } = e;
      if (W) {
        const { k1neg: Z, k1: J, k2neg: Y, k2: X } = W.splitScalar(T);
        let { p: ee, f: j } = this.wNAF(J), { p: ne, f: ae } = this.wNAF(X);
        ee = M.constTimeNegate(Z, ee), ne = M.constTimeNegate(Y, ne), ne = new A(r.mul(ne.px, W.beta), ne.py, ne.pz), L = ee.add(ne), U = j.add(ae);
      } else {
        const { p: Z, f: J } = this.wNAF(T);
        L = Z, U = J;
      }
      return A.normalizeZ([L, U])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(O, T, L) {
      const U = A.BASE, W = (J, Y) => Y === Cc || Y === Li || !J.equals(U) ? J.multiplyUnsafe(Y) : J.multiply(Y), Z = W(this, T).add(W(O, L));
      return Z.is0() ? void 0 : Z;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(O) {
      const { px: T, py: L, pz: U } = this, W = this.is0();
      O == null && (O = W ? r.ONE : r.inv(U));
      const Z = r.mul(T, O), J = r.mul(L, O), Y = r.mul(U, O);
      if (W)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(Y, r.ONE))
        throw new Error("invZ was invalid");
      return { x: Z, y: J };
    }
    isTorsionFree() {
      const { h: O, isTorsionFree: T } = e;
      if (O === Li)
        return !0;
      if (T)
        return T(A, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: O, clearCofactor: T } = e;
      return O === Li ? this : T ? T(A, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(O = !0) {
      return this.assertValidity(), i(A, this, O);
    }
    toHex(O = !0) {
      return _y(this.toRawBytes(O));
    }
  }
  A.BASE = new A(e.Gx, e.Gy, r.ONE), A.ZERO = new A(r.ZERO, r.ONE, r.ZERO);
  const x = e.nBitLength, M = XR(A, e.endo ? Math.ceil(x / 2) : x);
  return {
    CURVE: e,
    ProjectivePoint: A,
    normPrivateKeyToScalar: y,
    weierstrassEquation: d,
    isWithinCurveOrder: g
  };
}
function aL(a) {
  const e = pC(a);
  return nw(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function oL(a) {
  const e = aL(a), { Fp: r, n: i } = e, u = r.BYTES + 1, d = 2 * r.BYTES + 1;
  function g(B) {
    return Cc < B && B < r.ORDER;
  }
  function b(B) {
    return oo(B, i);
  }
  function y(B) {
    return b5(B, i);
  }
  const { ProjectivePoint: k, normPrivateKeyToScalar: S, weierstrassEquation: A, isWithinCurveOrder: x } = rL({
    ...e,
    toBytes(B, P, H) {
      const G = P.toAffine(), ie = r.toBytes(G.x), ce = Uv;
      return H ? ce(Uint8Array.from([P.hasEvenY() ? 2 : 3]), ie) : ce(Uint8Array.from([4]), ie, r.toBytes(G.y));
    },
    fromBytes(B) {
      const P = B.length, H = B[0], G = B.subarray(1);
      if (P === u && (H === 2 || H === 3)) {
        const ie = cg(G);
        if (!g(ie))
          throw new Error("Point is not on curve");
        const ce = A(ie);
        let xe = r.sqrt(ce);
        const Ce = (xe & Li) === Li;
        return (H & 1) === 1 !== Ce && (xe = r.neg(xe)), { x: ie, y: xe };
      } else if (P === d && H === 4) {
        const ie = r.fromBytes(G.subarray(0, r.BYTES)), ce = r.fromBytes(G.subarray(r.BYTES, 2 * r.BYTES));
        return { x: ie, y: ce };
      } else
        throw new Error(`Point of length ${P} was invalid. Expected ${u} compressed bytes or ${d} uncompressed bytes`);
    }
  }), M = (B) => _y(zy(B, e.nByteLength));
  function D(B) {
    const P = i >> Li;
    return B > P;
  }
  function O(B) {
    return D(B) ? b(-B) : B;
  }
  const T = (B, P, H) => cg(B.slice(P, H));
  class L {
    constructor(P, H, G) {
      this.r = P, this.s = H, this.recovery = G, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(P) {
      const H = e.nByteLength;
      return P = Ds("compactSignature", P, H * 2), new L(T(P, 0, H), T(P, H, 2 * H));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(P) {
      const { r: H, s: G } = ng.toSig(Ds("DER", P));
      return new L(H, G);
    }
    assertValidity() {
      if (!x(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!x(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(P) {
      return new L(this.r, this.s, P);
    }
    recoverPublicKey(P) {
      const { r: H, s: G, recovery: ie } = this, ce = X(Ds("msgHash", P));
      if (ie == null || ![0, 1, 2, 3].includes(ie))
        throw new Error("recovery id invalid");
      const xe = ie === 2 || ie === 3 ? H + e.n : H;
      if (xe >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Ce = ie & 1 ? "03" : "02", Be = k.fromHex(Ce + M(xe)), Pe = y(xe), Fe = b(-ce * Pe), Xe = b(G * Pe), at = k.BASE.multiplyAndAddUnsafe(Be, Fe, Xe);
      if (!at)
        throw new Error("point at infinify");
      return at.assertValidity(), at;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return D(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new L(this.r, b(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Uy(this.toDERHex());
    }
    toDERHex() {
      return ng.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Uy(this.toCompactHex());
    }
    toCompactHex() {
      return M(this.r) + M(this.s);
    }
  }
  const U = {
    isValidPrivateKey(B) {
      try {
        return S(B), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: S,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const B = hC(e.n);
      return KR(e.randomBytes(B), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(B = 8, P = k.BASE) {
      return P._setWindowSize(B), P.multiply(BigInt(3)), P;
    }
  };
  function W(B, P = !0) {
    return k.fromPrivateKey(B).toRawBytes(P);
  }
  function Z(B) {
    const P = B instanceof Uint8Array, H = typeof B == "string", G = (P || H) && B.length;
    return P ? G === u || G === d : H ? G === 2 * u || G === 2 * d : B instanceof k;
  }
  function J(B, P, H = !0) {
    if (Z(B))
      throw new Error("first arg must be private key");
    if (!Z(P))
      throw new Error("second arg must be public key");
    return k.fromHex(P).multiply(S(B)).toRawBytes(H);
  }
  const Y = e.bits2int || function(B) {
    const P = cg(B), H = B.length * 8 - e.nBitLength;
    return H > 0 ? P >> BigInt(H) : P;
  }, X = e.bits2int_modN || function(B) {
    return b(Y(B));
  }, ee = TE(e.nBitLength);
  function j(B) {
    if (typeof B != "bigint")
      throw new Error("bigint expected");
    if (!(Cc <= B && B < ee))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return zy(B, e.nByteLength);
  }
  function ne(B, P, H = ae) {
    if (["recovered", "canonical"].some((Ye) => Ye in H))
      throw new Error("sign() legacy options not supported");
    const { hash: G, randomBytes: ie } = e;
    let { lowS: ce, prehash: xe, extraEntropy: Ce } = H;
    ce == null && (ce = !0), B = Ds("msgHash", B), xe && (B = Ds("prehashed msgHash", G(B)));
    const Be = X(B), Pe = S(P), Fe = [j(Pe), j(Be)];
    if (Ce != null) {
      const Ye = Ce === !0 ? ie(r.BYTES) : Ce;
      Fe.push(Ds("extraEntropy", Ye));
    }
    const Xe = Uv(...Fe), at = Be;
    function tt(Ye) {
      const Ve = Y(Ye);
      if (!x(Ve))
        return;
      const Je = y(Ve), _e = k.BASE.multiply(Ve).toAffine(), rt = b(_e.x);
      if (rt === Cc)
        return;
      const Gt = b(Je * b(at + rt * Pe));
      if (Gt === Cc)
        return;
      let Er = (_e.x === rt ? 0 : 2) | Number(_e.y & Li), Ga = Gt;
      return ce && D(Gt) && (Ga = O(Gt), Er ^= 1), new L(rt, Ga, Er);
    }
    return { seed: Xe, k2sig: tt };
  }
  const ae = { lowS: e.lowS, prehash: !1 }, he = { lowS: e.lowS, prehash: !1 };
  function Ie(B, P, H = ae) {
    const { seed: G, k2sig: ie } = ne(B, P, H), ce = e;
    return cC(ce.hash.outputLen, ce.nByteLength, ce.hmac)(G, ie);
  }
  k.BASE._setWindowSize(8);
  function V(B, P, H, G = he) {
    var ie;
    const ce = B;
    if (P = Ds("msgHash", P), H = Ds("publicKey", H), "strict" in G)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: xe, prehash: Ce } = G;
    let Be, Pe;
    try {
      if (typeof ce == "string" || ce instanceof Uint8Array)
        try {
          Be = L.fromDER(ce);
        } catch (_e) {
          if (!(_e instanceof ng.Err))
            throw _e;
          Be = L.fromCompact(ce);
        }
      else if (typeof ce == "object" && typeof ce.r == "bigint" && typeof ce.s == "bigint") {
        const { r: _e, s: rt } = ce;
        Be = new L(_e, rt);
      } else
        throw new Error("PARSE");
      Pe = k.fromHex(H);
    } catch (_e) {
      if (_e.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (xe && Be.hasHighS())
      return !1;
    Ce && (P = e.hash(P));
    const { r: Fe, s: Xe } = Be, at = X(P), tt = y(Xe), Ye = b(at * tt), Ve = b(Fe * tt), Je = (ie = k.BASE.multiplyAndAddUnsafe(Pe, Ye, Ve)) == null ? void 0 : ie.toAffine();
    return Je ? b(Je.x) === Fe : !1;
  }
  return {
    CURVE: e,
    getPublicKey: W,
    getSharedSecret: J,
    sign: Ie,
    verify: V,
    ProjectivePoint: k,
    Signature: L,
    utils: U
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function iL(a) {
  return {
    hash: a,
    hmac: (e, ...r) => Wx(a, e, $O(...r)),
    randomBytes: QO
  };
}
function sL(a, e) {
  const r = (i) => oL({ ...a, ...iL(i) });
  return Object.freeze({ ...r(e), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const gC = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), DA = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), lL = BigInt(1), v5 = BigInt(2), BA = (a, e) => (a + e / v5) / e;
function uL(a) {
  const e = gC, r = BigInt(3), i = BigInt(6), u = BigInt(11), d = BigInt(22), g = BigInt(23), b = BigInt(44), y = BigInt(88), k = a * a * a % e, S = k * k * a % e, A = Ii(S, r, e) * S % e, x = Ii(A, r, e) * S % e, M = Ii(x, v5, e) * k % e, D = Ii(M, u, e) * M % e, O = Ii(D, d, e) * D % e, T = Ii(O, b, e) * O % e, L = Ii(T, y, e) * T % e, U = Ii(L, b, e) * O % e, W = Ii(U, r, e) * S % e, Z = Ii(W, g, e) * D % e, J = Ii(Z, i, e) * k % e, Y = Ii(J, v5, e);
  if (!w5.eql(w5.sqr(Y), a))
    throw new Error("Cannot find square root");
  return Y;
}
const w5 = qR(gC, void 0, void 0, { sqrt: uL }), Sd = sL({
  a: BigInt(0),
  b: BigInt(7),
  Fp: w5,
  n: DA,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (a) => {
      const e = DA, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), i = -lL * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), u = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), d = r, g = BigInt("0x100000000000000000000000000000000"), b = BA(d * a, e), y = BA(-i * a, e);
      let k = oo(a - b * r - y * u, e), S = oo(-b * i - y * d, e);
      const A = k > g, x = S > g;
      if (A && (k = e - k), x && (S = e - S), k > g || S > g)
        throw new Error("splitScalar: Endomorphism failed, k=" + a);
      return { k1neg: A, k1: k, k2neg: x, k2: S };
    }
  }
}, jx);
BigInt(0);
Sd.ProjectivePoint;
const n1 = "0x0000000000000000000000000000000000000000", fg = "0x0000000000000000000000000000000000000000000000000000000000000000", cL = `Ethereum Signed Message:
`, MA = BigInt(0), FA = BigInt(1), _A = BigInt(2), UA = BigInt(27), zA = BigInt(28), d4 = BigInt(35), $0 = {};
function HA(a) {
  return eu(kr(a), 32);
}
var J2, X2, ev, ay;
const fL = class Gl {
  /**
   *  @private
   */
  constructor(e, r, i, u) {
    ye(this, J2), ye(this, X2), ye(this, ev), ye(this, ay), tw(e, $0, "Signature"), Q(this, J2, r), Q(this, X2, i), Q(this, ev, u), Q(this, ay, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return R(this, J2);
  }
  set r(e) {
    se(ug(e) === 32, "invalid r", "value", e), Q(this, J2, Ge(e));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return R(this, X2);
  }
  set s(e) {
    se(ug(e) === 32, "invalid s", "value", e);
    const r = Ge(e);
    se(parseInt(r.substring(0, 3)) < 8, "non-canonical s", "value", r), Q(this, X2, r);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return R(this, ev);
  }
  set v(e) {
    const r = yt(e, "value");
    se(r === 27 || r === 28, "invalid v", "v", e), Q(this, ev, r);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return R(this, ay);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : Gl.getChainId(e);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const e = mt(this.s);
    return this.yParity && (e[0] |= 128), Ge(e);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return vn([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return vn([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const e = new Gl($0, this.r, this.s, this.v);
    return this.networkV && Q(e, ay, this.networkV), e;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(e) {
    const r = Qe(e, "v");
    return r == UA || r == zA ? MA : (se(r >= d4, "invalid EIP-155 v", "v", e), (r - d4) / _A);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(e, r) {
    return Qe(e) * _A + BigInt(35 + r - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(e) {
    const r = Qe(e);
    return r === MA || r === UA ? 27 : r === FA || r === zA ? 28 : (se(r >= d4, "invalid v", "v", e), r & FA ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(e) {
    function r(k, S) {
      se(k, S, "signature", e);
    }
    if (e == null)
      return new Gl($0, fg, fg, 27);
    if (typeof e == "string") {
      const k = mt(e, "signature");
      if (k.length === 64) {
        const S = Ge(k.slice(0, 32)), A = k.slice(32, 64), x = A[0] & 128 ? 28 : 27;
        return A[0] &= 127, new Gl($0, S, Ge(A), x);
      }
      if (k.length === 65) {
        const S = Ge(k.slice(0, 32)), A = k.slice(32, 64);
        r((A[0] & 128) === 0, "non-canonical s");
        const x = Gl.getNormalizedV(k[64]);
        return new Gl($0, S, Ge(A), x);
      }
      r(!1, "invalid raw signature length");
    }
    if (e instanceof Gl)
      return e.clone();
    const i = e.r;
    r(i != null, "missing r");
    const u = HA(i), d = function(k, S) {
      if (k != null)
        return HA(k);
      if (S != null) {
        r(ln(S, 32), "invalid yParityAndS");
        const A = mt(S);
        return A[0] &= 127, Ge(A);
      }
      r(!1, "missing s");
    }(e.s, e.yParityAndS);
    r((mt(d)[0] & 128) == 0, "non-canonical s");
    const { networkV: g, v: b } = function(k, S, A) {
      if (k != null) {
        const x = Qe(k);
        return {
          networkV: x >= d4 ? x : void 0,
          v: Gl.getNormalizedV(x)
        };
      }
      if (S != null)
        return r(ln(S, 32), "invalid yParityAndS"), { v: mt(S)[0] & 128 ? 28 : 27 };
      if (A != null) {
        switch (yt(A, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        r(!1, "invalid yParity");
      }
      r(!1, "missing v");
    }(e.v, e.yParityAndS, e.yParity), y = new Gl($0, u, d, b);
    return g && Q(y, ay, g), r(e.yParity == null || yt(e.yParity, "sig.yParity") === y.yParity, "yParity mismatch"), r(e.yParityAndS == null || e.yParityAndS === y.yParityAndS, "yParityAndS mismatch"), y;
  }
};
J2 = /* @__PURE__ */ new WeakMap(), X2 = /* @__PURE__ */ new WeakMap(), ev = /* @__PURE__ */ new WeakMap(), ay = /* @__PURE__ */ new WeakMap();
let nu = fL;
var Ad;
const dL = class oy {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(e) {
    ye(this, Ad), se(ug(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), Q(this, Ad, Ge(e));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return R(this, Ad);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return oy.computePublicKey(R(this, Ad));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return oy.computePublicKey(R(this, Ad), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(e) {
    se(ug(e) === 32, "invalid digest length", "digest", e);
    const r = Sd.sign(Ua(e), Ua(R(this, Ad)), {
      lowS: !0
    });
    return nu.from({
      r: Ud(r.r, 32),
      s: Ud(r.s, 32),
      v: r.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(e) {
    const r = oy.computePublicKey(e);
    return Ge(Sd.getSharedSecret(Ua(R(this, Ad)), mt(r), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(e, r) {
    let i = mt(e, "key");
    if (i.length === 32) {
      const d = Sd.getPublicKey(i, !!r);
      return Ge(d);
    }
    if (i.length === 64) {
      const d = new Uint8Array(65);
      d[0] = 4, d.set(i, 1), i = d;
    }
    const u = Sd.ProjectivePoint.fromHex(i);
    return Ge(u.toRawBytes(r));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(e, r) {
    se(ug(e) === 32, "invalid digest length", "digest", e);
    const i = nu.from(r);
    let u = Sd.Signature.fromCompact(Ua(vn([i.r, i.s])));
    u = u.addRecoveryBit(i.yParity);
    const d = u.recoverPublicKey(Ua(e));
    return se(d != null, "invalid signautre for digest", "signature", r), "0x" + d.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(e, r, i) {
    const u = Sd.ProjectivePoint.fromHex(oy.computePublicKey(e).substring(2)), d = Sd.ProjectivePoint.fromHex(oy.computePublicKey(r).substring(2));
    return "0x" + u.add(d).toHex(!!i);
  }
};
Ad = /* @__PURE__ */ new WeakMap();
let IE = dL;
const hL = BigInt(0), pL = BigInt(36);
function VA(a) {
  a = a.toLowerCase();
  const e = a.substring(2).split(""), r = new Uint8Array(40);
  for (let u = 0; u < 40; u++)
    r[u] = e[u].charCodeAt(0);
  const i = mt(xn(r));
  for (let u = 0; u < 40; u += 2)
    i[u >> 1] >> 4 >= 8 && (e[u] = e[u].toUpperCase()), (i[u >> 1] & 15) >= 8 && (e[u + 1] = e[u + 1].toUpperCase());
  return "0x" + e.join("");
}
const NE = {};
for (let a = 0; a < 10; a++)
  NE[String(a)] = String(a);
for (let a = 0; a < 26; a++)
  NE[String.fromCharCode(65 + a)] = String(10 + a);
const WA = 15;
function gL(a) {
  a = a.toUpperCase(), a = a.substring(4) + a.substring(0, 2) + "00";
  let e = a.split("").map((i) => NE[i]).join("");
  for (; e.length >= WA; ) {
    let i = e.substring(0, WA);
    e = parseInt(i, 10) % 97 + e.substring(i.length);
  }
  let r = String(98 - parseInt(e, 10) % 97);
  for (; r.length < 2; )
    r = "0" + r;
  return r;
}
const mL = function() {
  const a = {};
  for (let e = 0; e < 36; e++) {
    const r = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    a[r] = BigInt(e);
  }
  return a;
}();
function yL(a) {
  a = a.toLowerCase();
  let e = hL;
  for (let r = 0; r < a.length; r++)
    e = e * pL + mL[a[r]];
  return e;
}
function Wt(a) {
  if (se(typeof a == "string", "invalid address", "address", a), a.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    a.startsWith("0x") || (a = "0x" + a);
    const e = VA(a);
    return se(!a.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === a, "bad address checksum", "address", a), e;
  }
  if (a.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    se(a.substring(2, 4) === gL(a), "bad icap checksum", "address", a);
    let e = yL(a.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return VA("0x" + e);
  }
  se(!1, "invalid address", "address", a);
}
function bL(a) {
  const e = Wt(a.from);
  let r = Qe(a.nonce, "tx.nonce").toString(16);
  return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, Wt(On(xn(bg([e, r])), 12));
}
function mC(a) {
  return a && typeof a.getAddress == "function";
}
async function A8(a, e) {
  const r = await e;
  return (r == null || r === "0x0000000000000000000000000000000000000000") && (Te(typeof a != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: a }), se(!1, "invalid AddressLike value; did not resolve to a value address", "target", a)), Wt(r);
}
function Ha(a, e) {
  if (typeof a == "string")
    return a.match(/^0x[0-9a-f]{40}$/i) ? Wt(a) : (Te(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), A8(a, e.resolveName(a)));
  if (mC(a))
    return A8(a, a.getAddress());
  if (a && typeof a.then == "function")
    return A8(a, a);
  se(!1, "unsupported addressable value", "target", a);
}
const vc = {};
function We(a, e) {
  let r = !1;
  return e < 0 && (r = !0, e *= -1), new uo(vc, `${r ? "" : "u"}int${e}`, a, { signed: r, width: e });
}
function Lt(a, e) {
  return new uo(vc, `bytes${e || ""}`, a, { size: e });
}
const GA = Symbol.for("_ethers_typed");
var iy;
const vL = class xd {
  /**
   *  @_ignore:
   */
  constructor(e, r, i, u) {
    le(this, "type"), le(this, "value"), ye(this, iy), le(this, "_typedSymbol"), u == null && (u = null), tw(vc, e, "Typed"), Ke(this, { _typedSymbol: GA, type: r, value: i }), Q(this, iy, u), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((e) => e.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return R(this, iy);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return R(this, iy) === !0 ? -1 : R(this, iy) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(e, r) {
    return new xd(vc, e, r);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(e) {
    return We(e, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(e) {
    return We(e, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(e) {
    return We(e, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(e) {
    return We(e, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(e) {
    return We(e, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(e) {
    return We(e, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(e) {
    return We(e, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(e) {
    return We(e, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(e) {
    return We(e, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(e) {
    return We(e, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(e) {
    return We(e, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(e) {
    return We(e, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(e) {
    return We(e, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(e) {
    return We(e, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(e) {
    return We(e, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(e) {
    return We(e, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(e) {
    return We(e, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(e) {
    return We(e, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(e) {
    return We(e, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(e) {
    return We(e, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(e) {
    return We(e, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(e) {
    return We(e, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(e) {
    return We(e, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(e) {
    return We(e, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(e) {
    return We(e, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(e) {
    return We(e, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(e) {
    return We(e, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(e) {
    return We(e, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(e) {
    return We(e, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(e) {
    return We(e, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(e) {
    return We(e, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(e) {
    return We(e, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(e) {
    return We(e, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(e) {
    return We(e, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(e) {
    return We(e, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(e) {
    return We(e, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(e) {
    return We(e, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(e) {
    return We(e, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(e) {
    return We(e, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(e) {
    return We(e, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(e) {
    return We(e, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(e) {
    return We(e, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(e) {
    return We(e, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(e) {
    return We(e, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(e) {
    return We(e, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(e) {
    return We(e, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(e) {
    return We(e, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(e) {
    return We(e, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(e) {
    return We(e, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(e) {
    return We(e, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(e) {
    return We(e, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(e) {
    return We(e, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(e) {
    return We(e, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(e) {
    return We(e, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(e) {
    return We(e, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(e) {
    return We(e, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(e) {
    return We(e, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(e) {
    return We(e, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(e) {
    return We(e, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(e) {
    return We(e, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(e) {
    return We(e, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(e) {
    return We(e, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(e) {
    return We(e, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(e) {
    return We(e, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(e) {
    return We(e, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(e) {
    return We(e, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(e) {
    return Lt(e, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(e) {
    return Lt(e, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(e) {
    return Lt(e, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(e) {
    return Lt(e, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(e) {
    return Lt(e, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(e) {
    return Lt(e, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(e) {
    return Lt(e, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(e) {
    return Lt(e, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(e) {
    return Lt(e, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(e) {
    return Lt(e, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(e) {
    return Lt(e, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(e) {
    return Lt(e, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(e) {
    return Lt(e, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(e) {
    return Lt(e, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(e) {
    return Lt(e, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(e) {
    return Lt(e, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(e) {
    return Lt(e, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(e) {
    return Lt(e, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(e) {
    return Lt(e, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(e) {
    return Lt(e, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(e) {
    return Lt(e, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(e) {
    return Lt(e, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(e) {
    return Lt(e, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(e) {
    return Lt(e, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(e) {
    return Lt(e, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(e) {
    return Lt(e, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(e) {
    return Lt(e, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(e) {
    return Lt(e, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(e) {
    return Lt(e, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(e) {
    return Lt(e, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(e) {
    return Lt(e, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(e) {
    return Lt(e, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(e) {
    return new xd(vc, "address", e);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(e) {
    return new xd(vc, "bool", !!e);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(e) {
    return new xd(vc, "bytes", e);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(e) {
    return new xd(vc, "string", e);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(e, r) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(e, r) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(e) {
    return new xd(vc, "overrides", Object.assign({}, e));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(e) {
    return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === GA;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(e, r) {
    if (xd.isTyped(e)) {
      if (e.type !== r)
        throw new Error(`invalid type: expecetd ${r}, got ${e.type}`);
      return e.value;
    }
    return e;
  }
};
iy = /* @__PURE__ */ new WeakMap();
let uo = vL;
class wL extends Uc {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, r) {
    let i = uo.dereference(r, "string");
    try {
      i = Wt(i);
    } catch (u) {
      return this._throwError(u.message, r);
    }
    return e.writeValue(i);
  }
  decode(e) {
    return Wt(Ud(e.readValue(), 20));
  }
}
class kL extends Uc {
  constructor(e) {
    super(e.name, e.type, "_", e.dynamic), le(this, "coder"), this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, r) {
    return this.coder.encode(e, r);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
function yC(a, e, r) {
  let i = [];
  if (Array.isArray(r))
    i = r;
  else if (r && typeof r == "object") {
    let y = {};
    i = e.map((k) => {
      const S = k.localName;
      return Te(S, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: k }, value: r }), Te(!y[S], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: k }, value: r }), y[S] = !0, r[S];
    });
  } else
    se(!1, "invalid tuple value", "tuple", r);
  se(e.length === i.length, "types/value length mismatch", "tuple", r);
  let u = new p5(), d = new p5(), g = [];
  e.forEach((y, k) => {
    let S = i[k];
    if (y.dynamic) {
      let A = d.length;
      y.encode(d, S);
      let x = u.writeUpdatableValue();
      g.push((M) => {
        x(M + A);
      });
    } else
      y.encode(u, S);
  }), g.forEach((y) => {
    y(u.length);
  });
  let b = a.appendWriter(u);
  return b += a.appendWriter(d), b;
}
function bC(a, e) {
  let r = [], i = [], u = a.subReader(0);
  return e.forEach((d) => {
    let g = null;
    if (d.dynamic) {
      let b = a.readIndex(), y = u.subReader(b);
      try {
        g = d.decode(y);
      } catch (k) {
        if (qr(k, "BUFFER_OVERRUN"))
          throw k;
        g = k, g.baseType = d.name, g.name = d.localName, g.type = d.type;
      }
    } else
      try {
        g = d.decode(a);
      } catch (b) {
        if (qr(b, "BUFFER_OVERRUN"))
          throw b;
        g = b, g.baseType = d.name, g.name = d.localName, g.type = d.type;
      }
    if (g == null)
      throw new Error("investigate");
    r.push(g), i.push(d.localName || null);
  }), X4.fromItems(r, i);
}
class EL extends Uc {
  constructor(e, r, i) {
    const u = e.type + "[" + (r >= 0 ? r : "") + "]", d = r === -1 || e.dynamic;
    super("array", u, i, d), le(this, "coder"), le(this, "length"), Ke(this, { coder: e, length: r });
  }
  defaultValue() {
    const e = this.coder.defaultValue(), r = [];
    for (let i = 0; i < this.length; i++)
      r.push(e);
    return r;
  }
  encode(e, r) {
    const i = uo.dereference(r, "array");
    Array.isArray(i) || this._throwError("expected array value", i);
    let u = this.length;
    u === -1 && (u = i.length, e.writeValue(i.length)), Sx(i.length, u, "coder array" + (this.localName ? " " + this.localName : ""));
    let d = [];
    for (let g = 0; g < i.length; g++)
      d.push(this.coder);
    return yC(e, d, i);
  }
  decode(e) {
    let r = this.length;
    r === -1 && (r = e.readIndex(), Te(r * za <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: e.bytes, offset: r * za, length: e.dataLength }));
    let i = [];
    for (let u = 0; u < r; u++)
      i.push(new kL(this.coder));
    return bC(e, i);
  }
}
class SL extends Uc {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, r) {
    const i = uo.dereference(r, "bool");
    return e.writeValue(i ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
}
class vC extends Uc {
  constructor(e, r) {
    super(e, e, r, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, r) {
    r = Ua(r);
    let i = e.writeValue(r.length);
    return i += e.writeBytes(r), i;
  }
  decode(e) {
    return e.readBytes(e.readIndex(), !0);
  }
}
class AL extends vC {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return Ge(super.decode(e));
  }
}
class xL extends Uc {
  constructor(e, r) {
    let i = "bytes" + String(e);
    super(i, i, r, !1), le(this, "size"), Ke(this, { size: e }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, r) {
    let i = Ua(uo.dereference(r, this.type));
    return i.length !== this.size && this._throwError("incorrect data length", r), e.writeBytes(i);
  }
  decode(e) {
    return Ge(e.readBytes(this.size));
  }
}
const CL = new Uint8Array([]);
class TL extends Uc {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, r) {
    return r != null && this._throwError("not null", r), e.writeBytes(CL);
  }
  decode(e) {
    return e.readBytes(0), null;
  }
}
const IL = BigInt(0), NL = BigInt(1), PL = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class OL extends Uc {
  constructor(e, r, i) {
    const u = (r ? "int" : "uint") + e * 8;
    super(u, u, i, !1), le(this, "size"), le(this, "signed"), Ke(this, { size: e, signed: r }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(e, r) {
    let i = Qe(uo.dereference(r, this.type)), u = eg(PL, za * 8);
    if (this.signed) {
      let d = eg(u, this.size * 8 - 1);
      (i > d || i < -(d + NL)) && this._throwError("value out-of-bounds", r), i = wE(i, 8 * za);
    } else (i < IL || i > eg(u, this.size * 8)) && this._throwError("value out-of-bounds", r);
    return e.writeValue(i);
  }
  decode(e) {
    let r = eg(e.readValue(), this.size * 8);
    return this.signed && (r = q4(r, this.size * 8)), r;
  }
}
class RL extends vC {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, r) {
    return super.encode(e, lo(uo.dereference(r, "string")));
  }
  decode(e) {
    return K4(super.decode(e));
  }
}
class T4 extends Uc {
  constructor(e, r) {
    let i = !1;
    const u = [];
    e.forEach((g) => {
      g.dynamic && (i = !0), u.push(g.type);
    });
    const d = "tuple(" + u.join(",") + ")";
    super("tuple", d, r, i), le(this, "coders"), Ke(this, { coders: Object.freeze(e.slice()) });
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((i) => {
      e.push(i.defaultValue());
    });
    const r = this.coders.reduce((i, u) => {
      const d = u.localName;
      return d && (i[d] || (i[d] = 0), i[d]++), i;
    }, {});
    return this.coders.forEach((i, u) => {
      let d = i.localName;
      !d || r[d] !== 1 || (d === "length" && (d = "_length"), e[d] == null && (e[d] = e[u]));
    }), Object.freeze(e);
  }
  encode(e, r) {
    const i = uo.dereference(r, "tuple");
    return yC(e, this.coders, i);
  }
  decode(e) {
    return bC(e, this.coders);
  }
}
function vg(a) {
  return xn(lo(a));
}
var LL = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const jA = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), $A = 4;
function DL(a) {
  let e = 0;
  function r() {
    return a[e++] << 8 | a[e++];
  }
  let i = r(), u = 1, d = [0, 1];
  for (let J = 1; J < i; J++)
    d.push(u += r());
  let g = r(), b = e;
  e += g;
  let y = 0, k = 0;
  function S() {
    return y == 0 && (k = k << 8 | a[e++], y = 8), k >> --y & 1;
  }
  const A = 31, x = 2 ** A, M = x >>> 1, D = M >> 1, O = x - 1;
  let T = 0;
  for (let J = 0; J < A; J++) T = T << 1 | S();
  let L = [], U = 0, W = x;
  for (; ; ) {
    let J = Math.floor(((T - U + 1) * u - 1) / W), Y = 0, X = i;
    for (; X - Y > 1; ) {
      let ne = Y + X >>> 1;
      J < d[ne] ? X = ne : Y = ne;
    }
    if (Y == 0) break;
    L.push(Y);
    let ee = U + Math.floor(W * d[Y] / u), j = U + Math.floor(W * d[Y + 1] / u) - 1;
    for (; !((ee ^ j) & M); )
      T = T << 1 & O | S(), ee = ee << 1 & O, j = j << 1 & O | 1;
    for (; ee & ~j & D; )
      T = T & M | T << 1 & O >>> 1 | S(), ee = ee << 1 ^ M, j = (j ^ M) << 1 | M | 1;
    U = ee, W = 1 + j - ee;
  }
  let Z = i - 4;
  return L.map((J) => {
    switch (J - Z) {
      case 3:
        return Z + 65792 + (a[b++] << 16 | a[b++] << 8 | a[b++]);
      case 2:
        return Z + 256 + (a[b++] << 8 | a[b++]);
      case 1:
        return Z + a[b++];
      default:
        return J - 1;
    }
  });
}
function BL(a) {
  let e = 0;
  return () => a[e++];
}
function wC(a) {
  return BL(DL(ML(a)));
}
function ML(a) {
  let e = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((u, d) => e[u.charCodeAt(0)] = d);
  let r = a.length, i = new Uint8Array(6 * r >> 3);
  for (let u = 0, d = 0, g = 0, b = 0; u < r; u++)
    b = b << 6 | e[a.charCodeAt(u)], g += 6, g >= 8 && (i[d++] = b >> (g -= 8));
  return i;
}
function FL(a) {
  return a & 1 ? ~a >> 1 : a >> 1;
}
function _L(a, e) {
  let r = Array(a);
  for (let i = 0, u = 0; i < a; i++) r[i] = u += FL(e());
  return r;
}
function zv(a, e = 0) {
  let r = [];
  for (; ; ) {
    let i = a(), u = a();
    if (!u) break;
    e += i;
    for (let d = 0; d < u; d++)
      r.push(e + d);
    e += u + 1;
  }
  return r;
}
function kC(a) {
  return Hv(() => {
    let e = zv(a);
    if (e.length) return e;
  });
}
function EC(a) {
  let e = [];
  for (; ; ) {
    let r = a();
    if (r == 0) break;
    e.push(UL(r, a));
  }
  for (; ; ) {
    let r = a() - 1;
    if (r < 0) break;
    e.push(zL(r, a));
  }
  return e.flat();
}
function Hv(a) {
  let e = [];
  for (; ; ) {
    let r = a(e.length);
    if (!r) break;
    e.push(r);
  }
  return e;
}
function SC(a, e, r) {
  let i = Array(a).fill().map(() => []);
  for (let u = 0; u < e; u++)
    _L(a, r).forEach((d, g) => i[g].push(d));
  return i;
}
function UL(a, e) {
  let r = 1 + e(), i = e(), u = Hv(e);
  return SC(u.length, 1 + a, e).flatMap((d, g) => {
    let [b, ...y] = d;
    return Array(u[g]).fill().map((k, S) => {
      let A = S * i;
      return [b + S * r, y.map((x) => x + A)];
    });
  });
}
function zL(a, e) {
  let r = 1 + e();
  return SC(r, 1 + a, e).map((i) => [i[0], i.slice(1)]);
}
function HL(a) {
  let e = [], r = zv(a);
  return u(i([]), []), e;
  function i(d) {
    let g = a(), b = Hv(() => {
      let y = zv(a).map((k) => r[k]);
      if (y.length) return i(y);
    });
    return { S: g, B: b, Q: d };
  }
  function u({ S: d, B: g }, b, y) {
    if (!(d & 4 && y === b[b.length - 1])) {
      d & 2 && (y = b[b.length - 1]), d & 1 && e.push(b);
      for (let k of g)
        for (let S of k.Q)
          u(k, [...b, S], y);
    }
  }
}
function VL(a) {
  return a.toString(16).toUpperCase().padStart(2, "0");
}
function AC(a) {
  return `{${VL(a)}}`;
}
function WL(a) {
  let e = [];
  for (let r = 0, i = a.length; r < i; ) {
    let u = a.codePointAt(r);
    r += u < 65536 ? 1 : 2, e.push(u);
  }
  return e;
}
function Hy(a) {
  let e = a.length;
  if (e < 4096) return String.fromCodePoint(...a);
  let r = [];
  for (let i = 0; i < e; )
    r.push(String.fromCodePoint(...a.slice(i, i += 4096)));
  return r.join("");
}
function GL(a, e) {
  let r = a.length, i = r - e.length;
  for (let u = 0; i == 0 && u < r; u++) i = a[u] - e[u];
  return i;
}
var jL = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const Vv = 44032, tk = 4352, nk = 4449, rk = 4519, xC = 19, CC = 21, Vy = 28, ak = CC * Vy, $L = xC * ak, QL = Vv + $L, ZL = tk + xC, YL = nk + CC, qL = rk + Vy;
function tv(a) {
  return a >> 24 & 255;
}
function TC(a) {
  return a & 16777215;
}
let k5, QA, E5, I4;
function KL() {
  let a = wC(jL);
  k5 = new Map(kC(a).flatMap((e, r) => e.map((i) => [i, r + 1 << 24]))), QA = new Set(zv(a)), E5 = /* @__PURE__ */ new Map(), I4 = /* @__PURE__ */ new Map();
  for (let [e, r] of EC(a)) {
    if (!QA.has(e) && r.length == 2) {
      let [i, u] = r, d = I4.get(i);
      d || (d = /* @__PURE__ */ new Map(), I4.set(i, d)), d.set(u, e);
    }
    E5.set(e, r.reverse());
  }
}
function IC(a) {
  return a >= Vv && a < QL;
}
function JL(a, e) {
  if (a >= tk && a < ZL && e >= nk && e < YL)
    return Vv + (a - tk) * ak + (e - nk) * Vy;
  if (IC(a) && e > rk && e < qL && (a - Vv) % Vy == 0)
    return a + (e - rk);
  {
    let r = I4.get(a);
    return r && (r = r.get(e), r) ? r : -1;
  }
}
function NC(a) {
  k5 || KL();
  let e = [], r = [], i = !1;
  function u(d) {
    let g = k5.get(d);
    g && (i = !0, d |= g), e.push(d);
  }
  for (let d of a)
    for (; ; ) {
      if (d < 128)
        e.push(d);
      else if (IC(d)) {
        let g = d - Vv, b = g / ak | 0, y = g % ak / Vy | 0, k = g % Vy;
        u(tk + b), u(nk + y), k > 0 && u(rk + k);
      } else {
        let g = E5.get(d);
        g ? r.push(...g) : u(d);
      }
      if (!r.length) break;
      d = r.pop();
    }
  if (i && e.length > 1) {
    let d = tv(e[0]);
    for (let g = 1; g < e.length; g++) {
      let b = tv(e[g]);
      if (b == 0 || d <= b) {
        d = b;
        continue;
      }
      let y = g - 1;
      for (; ; ) {
        let k = e[y + 1];
        if (e[y + 1] = e[y], e[y] = k, !y || (d = tv(e[--y]), d <= b)) break;
      }
      d = tv(e[g]);
    }
  }
  return e;
}
function XL(a) {
  let e = [], r = [], i = -1, u = 0;
  for (let d of a) {
    let g = tv(d), b = TC(d);
    if (i == -1)
      g == 0 ? i = b : e.push(b);
    else if (u > 0 && u >= g)
      g == 0 ? (e.push(i, ...r), r.length = 0, i = b) : r.push(b), u = g;
    else {
      let y = JL(i, b);
      y >= 0 ? i = y : u == 0 && g == 0 ? (e.push(i), i = b) : (r.push(b), u = g);
    }
  }
  return i >= 0 && e.push(i, ...r), e;
}
function PC(a) {
  return NC(a).map(TC);
}
function eD(a) {
  return XL(NC(a));
}
const ZA = 45, OC = ".", RC = 65039, LC = 1, ok = (a) => Array.from(a);
function Wv(a, e) {
  return a.P.has(e) || a.Q.has(e);
}
class tD extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let S5, DC, rg, A5, BC, Ny, x8, sy, Pp, YA, x5;
function PE() {
  if (S5) return;
  let a = wC(LL);
  const e = () => zv(a), r = () => new Set(e()), i = (S, A) => A.forEach((x) => S.add(x));
  S5 = new Map(EC(a)), DC = r(), rg = e(), A5 = new Set(e().map((S) => rg[S])), rg = new Set(rg), BC = r(), r();
  let u = kC(a), d = a();
  const g = () => {
    let S = /* @__PURE__ */ new Set();
    return e().forEach((A) => i(S, u[A])), i(S, e()), S;
  };
  Ny = Hv((S) => {
    let A = Hv(a).map((x) => x + 96);
    if (A.length) {
      let x = S >= d;
      A[0] -= 32, A = Hy(A), x && (A = `Restricted[${A}]`);
      let M = g(), D = g(), O = !a();
      return { N: A, P: M, Q: D, M: O, R: x };
    }
  }), x8 = r(), sy = /* @__PURE__ */ new Map();
  let b = e().concat(ok(x8)).sort((S, A) => S - A);
  b.forEach((S, A) => {
    let x = a(), M = b[A] = x ? b[A - x] : { V: [], M: /* @__PURE__ */ new Map() };
    M.V.push(S), x8.has(S) || sy.set(S, M);
  });
  for (let { V: S, M: A } of new Set(sy.values())) {
    let x = [];
    for (let D of S) {
      let O = Ny.filter((L) => Wv(L, D)), T = x.find(({ G: L }) => O.some((U) => L.has(U)));
      T || (T = { G: /* @__PURE__ */ new Set(), V: [] }, x.push(T)), T.V.push(D), i(T.G, O);
    }
    let M = x.flatMap((D) => ok(D.G));
    for (let { G: D, V: O } of x) {
      let T = new Set(M.filter((L) => !D.has(L)));
      for (let L of O)
        A.set(L, T);
    }
  }
  Pp = /* @__PURE__ */ new Set();
  let y = /* @__PURE__ */ new Set();
  const k = (S) => Pp.has(S) ? y.add(S) : Pp.add(S);
  for (let S of Ny) {
    for (let A of S.P) k(A);
    for (let A of S.Q) k(A);
  }
  for (let S of Pp)
    !sy.has(S) && !y.has(S) && sy.set(S, LC);
  i(Pp, PC(Pp)), YA = HL(a).map((S) => tD.from(S)).sort(GL), x5 = /* @__PURE__ */ new Map();
  for (let S of YA) {
    let A = [x5];
    for (let x of S) {
      let M = A.map((D) => {
        let O = D.get(x);
        return O || (O = /* @__PURE__ */ new Map(), D.set(x, O)), O;
      });
      x === RC ? A.push(...M) : A = M;
    }
    for (let x of A)
      x.V = S;
  }
}
function OE(a) {
  return (MC(a) ? "" : `${RE(vk([a]))} `) + AC(a);
}
function RE(a) {
  return `"${a}"‎`;
}
function nD(a) {
  if (a.length >= 4 && a[2] == ZA && a[3] == ZA)
    throw new Error(`invalid label extension: "${Hy(a.slice(0, 4))}"`);
}
function rD(a) {
  for (let e = a.lastIndexOf(95); e > 0; )
    if (a[--e] !== 95)
      throw new Error("underscore allowed only at start");
}
function aD(a) {
  let e = a[0], r = jA.get(e);
  if (r) throw Rv(`leading ${r}`);
  let i = a.length, u = -1;
  for (let d = 1; d < i; d++) {
    e = a[d];
    let g = jA.get(e);
    if (g) {
      if (u == d) throw Rv(`${r} + ${g}`);
      u = d + 1, r = g;
    }
  }
  if (u == i) throw Rv(`trailing ${r}`);
}
function vk(a, e = 1 / 0, r = AC) {
  let i = [];
  oD(a[0]) && i.push("◌"), a.length > e && (e >>= 1, a = [...a.slice(0, e), 8230, ...a.slice(-e)]);
  let u = 0, d = a.length;
  for (let g = 0; g < d; g++) {
    let b = a[g];
    MC(b) && (i.push(Hy(a.slice(u, g))), i.push(r(b)), u = g + 1);
  }
  return i.push(Hy(a.slice(u, d))), i.join("");
}
function oD(a) {
  return PE(), rg.has(a);
}
function MC(a) {
  return PE(), BC.has(a);
}
function iD(a) {
  return cD(sD(a, eD, hD));
}
function sD(a, e, r) {
  if (!a) return [];
  PE();
  let i = 0;
  return a.split(OC).map((u) => {
    let d = WL(u), g = {
      input: d,
      offset: i
      // codepoint, not substring!
    };
    i += d.length + 1;
    try {
      let b = g.tokens = dD(d, e, r), y = b.length, k;
      if (!y)
        throw new Error("empty label");
      let S = g.output = b.flat();
      if (rD(S), !(g.emoji = y > 1 || b[0].is_emoji) && S.every((A) => A < 128))
        nD(S), k = "ASCII";
      else {
        let A = b.flatMap((x) => x.is_emoji ? [] : x);
        if (!A.length)
          k = "Emoji";
        else {
          if (rg.has(S[0])) throw Rv("leading combining mark");
          for (let D = 1; D < y; D++) {
            let O = b[D];
            if (!O.is_emoji && rg.has(O[0]))
              throw Rv(`emoji + combining mark: "${Hy(b[D - 1])} + ${vk([O[0]])}"`);
          }
          aD(S);
          let x = ok(new Set(A)), [M] = uD(x);
          fD(M, A), lD(M, x), k = M.N;
        }
      }
      g.type = k;
    } catch (b) {
      g.error = b;
    }
    return g;
  });
}
function lD(a, e) {
  let r, i = [];
  for (let u of e) {
    let d = sy.get(u);
    if (d === LC) return;
    if (d) {
      let g = d.M.get(u);
      if (r = r ? r.filter((b) => g.has(b)) : ok(g), !r.length) return;
    } else
      i.push(u);
  }
  if (r) {
    for (let u of r)
      if (i.every((d) => Wv(u, d)))
        throw new Error(`whole-script confusable: ${a.N}/${u.N}`);
  }
}
function uD(a) {
  let e = Ny;
  for (let r of a) {
    let i = e.filter((u) => Wv(u, r));
    if (!i.length)
      throw Ny.some((u) => Wv(u, r)) ? _C(e[0], r) : FC(r);
    if (e = i, i.length == 1) break;
  }
  return e;
}
function cD(a) {
  return a.map(({ input: e, error: r, output: i }) => {
    if (r) {
      let u = r.message;
      throw new Error(a.length == 1 ? u : `Invalid label ${RE(vk(e, 63))}: ${u}`);
    }
    return Hy(i);
  }).join(OC);
}
function FC(a) {
  return new Error(`disallowed character: ${OE(a)}`);
}
function _C(a, e) {
  let r = OE(e), i = Ny.find((u) => u.P.has(e));
  return i && (r = `${i.N} ${r}`), new Error(`illegal mixture: ${a.N} + ${r}`);
}
function Rv(a) {
  return new Error(`illegal placement: ${a}`);
}
function fD(a, e) {
  for (let r of e)
    if (!Wv(a, r))
      throw _C(a, r);
  if (a.M) {
    let r = PC(e);
    for (let i = 1, u = r.length; i < u; i++)
      if (A5.has(r[i])) {
        let d = i + 1;
        for (let g; d < u && A5.has(g = r[d]); d++)
          for (let b = i; b < d; b++)
            if (r[b] == g)
              throw new Error(`duplicate non-spacing marks: ${OE(g)}`);
        if (d - i > $A)
          throw new Error(`excessive non-spacing marks: ${RE(vk(r.slice(i - 1, d)))} (${d - i}/${$A})`);
        i = d;
      }
  }
}
function dD(a, e, r) {
  let i = [], u = [];
  for (a = a.slice().reverse(); a.length; ) {
    let d = pD(a);
    if (d)
      u.length && (i.push(e(u)), u = []), i.push(r(d));
    else {
      let g = a.pop();
      if (Pp.has(g))
        u.push(g);
      else {
        let b = S5.get(g);
        if (b)
          u.push(...b);
        else if (!DC.has(g))
          throw FC(g);
      }
    }
  }
  return u.length && i.push(e(u)), i;
}
function hD(a) {
  return a.filter((e) => e != RC);
}
function pD(a, e) {
  let r = x5, i, u = a.length;
  for (; u && (r = r.get(a[--u]), !!r); ) {
    let { V: d } = r;
    d && (i = d, a.length = u);
  }
  return i;
}
const UC = new Uint8Array(32);
UC.fill(0);
function qA(a) {
  return se(a.length !== 0, "invalid ENS name; empty component", "comp", a), a;
}
function zC(a) {
  const e = lo(gD(a)), r = [];
  if (a.length === 0)
    return r;
  let i = 0;
  for (let u = 0; u < e.length; u++)
    e[u] === 46 && (r.push(qA(e.slice(i, u))), i = u + 1);
  return se(i < e.length, "invalid ENS name; empty component", "name", a), r.push(qA(e.slice(i))), r;
}
function gD(a) {
  try {
    if (a.length === 0)
      throw new Error("empty label");
    return iD(a);
  } catch (e) {
    se(!1, `invalid ENS name (${e.message})`, "name", a);
  }
}
function C5(a) {
  se(typeof a == "string", "invalid ENS name; not a string", "name", a), se(a.length, "invalid ENS name (empty label)", "name", a);
  let e = UC;
  const r = zC(a);
  for (; r.length; )
    e = xn(vn([e, xn(r.pop())]));
  return Ge(e);
}
function mD(a, e) {
  const r = e;
  return se(r <= 255, "DNS encoded label cannot exceed 255", "length", r), Ge(vn(zC(a).map((i) => {
    se(i.length <= r, `label ${JSON.stringify(a)} exceeds ${r} bytes`, "name", a);
    const u = new Uint8Array(i.length + 1);
    return u.set(i, 1), u[0] = u.length - 1, u;
  }))) + "00";
}
function C8(a, e) {
  return {
    address: Wt(a),
    storageKeys: e.map((r, i) => (se(ln(r, 32), "invalid slot", `storageKeys[${i}]`, r), r.toLowerCase()))
  };
}
function Pg(a) {
  if (Array.isArray(a))
    return a.map((r, i) => Array.isArray(r) ? (se(r.length === 2, "invalid slot set", `value[${i}]`, r), C8(r[0], r[1])) : (se(r != null && typeof r == "object", "invalid address-slot set", "value", a), C8(r.address, r.storageKeys)));
  se(a != null && typeof a == "object", "invalid access list", "value", a);
  const e = Object.keys(a).map((r) => {
    const i = a[r].reduce((u, d) => (u[d] = !0, u), {});
    return C8(r, Object.keys(i).sort());
  });
  return e.sort((r, i) => r.address.localeCompare(i.address)), e;
}
function yD(a) {
  let e;
  return typeof a == "string" ? e = IE.computePublicKey(a, !1) : e = a.publicKey, Wt(xn("0x" + e.substring(4)).substring(26));
}
function bD(a, e) {
  return yD(IE.recoverPublicKey(a, e));
}
const Fr = BigInt(0), vD = BigInt(2), wD = BigInt(27), kD = BigInt(28), ED = BigInt(35), SD = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), T8 = 4096 * 32;
function KA(a, e) {
  let r = a.toString(16);
  for (; r.length < 2; )
    r = "0" + r;
  return r += zd(e).substring(4), "0x" + r;
}
function wk(a) {
  return a === "0x" ? null : Wt(a);
}
function LE(a, e) {
  try {
    return Pg(a);
  } catch (r) {
    se(!1, r.message, e, a);
  }
}
function rw(a, e) {
  return a === "0x" ? 0 : yt(a, e);
}
function Zn(a, e) {
  if (a === "0x")
    return Fr;
  const r = Qe(a, e);
  return se(r <= SD, "value exceeds uint size", e, r), r;
}
function hn(a, e) {
  const r = Qe(a, "value"), i = kr(r);
  return se(i.length <= 32, "value too large", `tx.${e}`, r), i;
}
function DE(a) {
  return Pg(a).map((e) => [e.address, e.storageKeys]);
}
function AD(a, e) {
  se(Array.isArray(a), `invalid ${e}`, "value", a);
  for (let r = 0; r < a.length; r++)
    se(ln(a[r], 32), "invalid ${ param } hash", `value[${r}]`, a[r]);
  return a;
}
function xD(a) {
  const e = gk(a);
  se(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", a);
  const r = {
    type: 0,
    nonce: rw(e[0], "nonce"),
    gasPrice: Zn(e[1], "gasPrice"),
    gasLimit: Zn(e[2], "gasLimit"),
    to: wk(e[3]),
    value: Zn(e[4], "value"),
    data: Ge(e[5]),
    chainId: Fr
  };
  if (e.length === 6)
    return r;
  const i = Zn(e[6], "v"), u = Zn(e[7], "r"), d = Zn(e[8], "s");
  if (u === Fr && d === Fr)
    r.chainId = i;
  else {
    let g = (i - ED) / vD;
    g < Fr && (g = Fr), r.chainId = g, se(g !== Fr || i === wD || i === kD, "non-canonical legacy v", "v", e[6]), r.signature = nu.from({
      r: eu(e[7], 32),
      s: eu(e[8], 32),
      v: i
    });
  }
  return r;
}
function CD(a, e) {
  const r = [
    hn(a.nonce, "nonce"),
    hn(a.gasPrice || 0, "gasPrice"),
    hn(a.gasLimit, "gasLimit"),
    a.to || "0x",
    hn(a.value, "value"),
    a.data
  ];
  let i = Fr;
  if (a.chainId != Fr)
    i = Qe(a.chainId, "tx.chainId"), se(!e || e.networkV == null || e.legacyChainId === i, "tx.chainId/sig.v mismatch", "sig", e);
  else if (a.signature) {
    const d = a.signature.legacyChainId;
    d != null && (i = d);
  }
  if (!e)
    return i !== Fr && (r.push(kr(i)), r.push("0x"), r.push("0x")), bg(r);
  let u = BigInt(27 + e.yParity);
  return i !== Fr ? u = nu.getChainIdV(i, e.v) : BigInt(e.v) !== u && se(!1, "tx.chainId/sig.v mismatch", "sig", e), r.push(kr(u)), r.push(kr(e.r)), r.push(kr(e.s)), bg(r);
}
function BE(a, e) {
  let r;
  try {
    if (r = rw(e[0], "yParity"), r !== 0 && r !== 1)
      throw new Error("bad yParity");
  } catch {
    se(!1, "invalid yParity", "yParity", e[0]);
  }
  const i = eu(e[1], 32), u = eu(e[2], 32), d = nu.from({ r: i, s: u, yParity: r });
  a.signature = d;
}
function TD(a) {
  const e = gk(mt(a).slice(1));
  se(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", Ge(a));
  const r = {
    type: 2,
    chainId: Zn(e[0], "chainId"),
    nonce: rw(e[1], "nonce"),
    maxPriorityFeePerGas: Zn(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Zn(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Zn(e[4], "gasLimit"),
    to: wk(e[5]),
    value: Zn(e[6], "value"),
    data: Ge(e[7]),
    accessList: LE(e[8], "accessList")
  };
  return e.length === 9 || BE(r, e.slice(9)), r;
}
function ID(a, e) {
  const r = [
    hn(a.chainId, "chainId"),
    hn(a.nonce, "nonce"),
    hn(a.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    hn(a.maxFeePerGas || 0, "maxFeePerGas"),
    hn(a.gasLimit, "gasLimit"),
    a.to || "0x",
    hn(a.value, "value"),
    a.data,
    DE(a.accessList || [])
  ];
  return e && (r.push(hn(e.yParity, "yParity")), r.push(kr(e.r)), r.push(kr(e.s))), vn(["0x02", bg(r)]);
}
function ND(a) {
  const e = gk(mt(a).slice(1));
  se(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", Ge(a));
  const r = {
    type: 1,
    chainId: Zn(e[0], "chainId"),
    nonce: rw(e[1], "nonce"),
    gasPrice: Zn(e[2], "gasPrice"),
    gasLimit: Zn(e[3], "gasLimit"),
    to: wk(e[4]),
    value: Zn(e[5], "value"),
    data: Ge(e[6]),
    accessList: LE(e[7], "accessList")
  };
  return e.length === 8 || BE(r, e.slice(8)), r;
}
function PD(a, e) {
  const r = [
    hn(a.chainId, "chainId"),
    hn(a.nonce, "nonce"),
    hn(a.gasPrice || 0, "gasPrice"),
    hn(a.gasLimit, "gasLimit"),
    a.to || "0x",
    hn(a.value, "value"),
    a.data,
    DE(a.accessList || [])
  ];
  return e && (r.push(hn(e.yParity, "recoveryParam")), r.push(kr(e.r)), r.push(kr(e.s))), vn(["0x01", bg(r)]);
}
function OD(a) {
  let e = gk(mt(a).slice(1)), r = "3", i = null;
  if (e.length === 4 && Array.isArray(e[0])) {
    r = "3 (network format)";
    const d = e[1], g = e[2], b = e[3];
    se(Array.isArray(d), "invalid network format: blobs not an array", "fields[1]", d), se(Array.isArray(g), "invalid network format: commitments not an array", "fields[2]", g), se(Array.isArray(b), "invalid network format: proofs not an array", "fields[3]", b), se(d.length === g.length, "invalid network format: blobs/commitments length mismatch", "fields", e), se(d.length === b.length, "invalid network format: blobs/proofs length mismatch", "fields", e), i = [];
    for (let y = 0; y < e[1].length; y++)
      i.push({
        data: d[y],
        commitment: g[y],
        proof: b[y]
      });
    e = e[0];
  }
  se(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${r}`, "data", Ge(a));
  const u = {
    type: 3,
    chainId: Zn(e[0], "chainId"),
    nonce: rw(e[1], "nonce"),
    maxPriorityFeePerGas: Zn(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Zn(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Zn(e[4], "gasLimit"),
    to: wk(e[5]),
    value: Zn(e[6], "value"),
    data: Ge(e[7]),
    accessList: LE(e[8], "accessList"),
    maxFeePerBlobGas: Zn(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10]
  };
  i && (u.blobs = i), se(u.to != null, `invalid address for transaction type: ${r}`, "data", a), se(Array.isArray(u.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", a);
  for (let d = 0; d < u.blobVersionedHashes.length; d++)
    se(ln(u.blobVersionedHashes[d], 32), `invalid blobVersionedHash at index ${d}: must be length 32`, "data", a);
  return e.length === 11 || BE(u, e.slice(11)), u;
}
function RD(a, e, r) {
  const i = [
    hn(a.chainId, "chainId"),
    hn(a.nonce, "nonce"),
    hn(a.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    hn(a.maxFeePerGas || 0, "maxFeePerGas"),
    hn(a.gasLimit, "gasLimit"),
    a.to || n1,
    hn(a.value, "value"),
    a.data,
    DE(a.accessList || []),
    hn(a.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    AD(a.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return e && (i.push(hn(e.yParity, "yParity")), i.push(kr(e.r)), i.push(kr(e.s)), r) ? vn([
    "0x03",
    bg([
      i,
      r.map((u) => u.data),
      r.map((u) => u.commitment),
      r.map((u) => u.proof)
    ])
  ]) : vn(["0x03", bg(i)]);
}
var yc, nv, rv, av, ov, iv, sv, lv, uv, cv, fv, dv, ly, Op, Cd, Rp, hv, N4;
const LD = class Td {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    ye(this, hv), ye(this, yc), ye(this, nv), ye(this, rv), ye(this, av), ye(this, ov), ye(this, iv), ye(this, sv), ye(this, lv), ye(this, uv), ye(this, cv), ye(this, fv), ye(this, dv), ye(this, ly), ye(this, Op), ye(this, Cd), ye(this, Rp), Q(this, yc, null), Q(this, nv, null), Q(this, av, 0), Q(this, ov, Fr), Q(this, iv, null), Q(this, sv, null), Q(this, lv, null), Q(this, rv, "0x"), Q(this, uv, Fr), Q(this, cv, Fr), Q(this, fv, null), Q(this, dv, null), Q(this, ly, null), Q(this, Op, null), Q(this, Rp, null), Q(this, Cd, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return R(this, yc);
  }
  set type(e) {
    switch (e) {
      case null:
        Q(this, yc, null);
        break;
      case 0:
      case "legacy":
        Q(this, yc, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        Q(this, yc, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        Q(this, yc, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        Q(this, yc, 3);
        break;
      default:
        se(!1, "unsupported transaction type", "type", e);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const e = R(this, nv);
    return e == null && this.type === 3 ? n1 : e;
  }
  set to(e) {
    Q(this, nv, e == null ? null : Wt(e));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return R(this, av);
  }
  set nonce(e) {
    Q(this, av, yt(e, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return R(this, ov);
  }
  set gasLimit(e) {
    Q(this, ov, Qe(e));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const e = R(this, iv);
    return e == null && (this.type === 0 || this.type === 1) ? Fr : e;
  }
  set gasPrice(e) {
    Q(this, iv, e == null ? null : Qe(e, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    return R(this, sv) ?? (this.type === 2 || this.type === 3 ? Fr : null);
  }
  set maxPriorityFeePerGas(e) {
    Q(this, sv, e == null ? null : Qe(e, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    return R(this, lv) ?? (this.type === 2 || this.type === 3 ? Fr : null);
  }
  set maxFeePerGas(e) {
    Q(this, lv, e == null ? null : Qe(e, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return R(this, rv);
  }
  set data(e) {
    Q(this, rv, Ge(e));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return R(this, uv);
  }
  set value(e) {
    Q(this, uv, Qe(e, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return R(this, cv);
  }
  set chainId(e) {
    Q(this, cv, Qe(e));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return R(this, fv) || null;
  }
  set signature(e) {
    Q(this, fv, e == null ? null : nu.from(e));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    return (R(this, dv) || null) ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(e) {
    Q(this, dv, e == null ? null : Pg(e));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const e = R(this, ly);
    return e == null && this.type === 3 ? Fr : e;
  }
  set maxFeePerBlobGas(e) {
    Q(this, ly, e == null ? null : Qe(e, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let e = R(this, Op);
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      se(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
      for (let r = 0; r < e.length; r++)
        se(ln(e[r], 32), "invalid blobVersionedHash", `value[${r}]`, e[r]);
    }
    Q(this, Op, e);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return R(this, Rp) == null ? null : R(this, Rp).map((e) => Object.assign({}, e));
  }
  set blobs(e) {
    if (e == null) {
      Q(this, Rp, null);
      return;
    }
    const r = [], i = [];
    for (let u = 0; u < e.length; u++) {
      const d = e[u];
      if (bE(d)) {
        Te(R(this, Cd), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let g = mt(d);
        if (se(g.length <= T8, "blob is too large", `blobs[${u}]`, d), g.length !== T8) {
          const k = new Uint8Array(T8);
          k.set(g), g = k;
        }
        const b = R(this, Cd).blobToKzgCommitment(g), y = Ge(R(this, Cd).computeBlobKzgProof(g, b));
        r.push({
          data: Ge(g),
          commitment: Ge(b),
          proof: y
        }), i.push(KA(1, b));
      } else {
        const g = Ge(d.commitment);
        r.push({
          data: Ge(d.data),
          commitment: g,
          proof: Ge(d.proof)
        }), i.push(KA(1, g));
      }
    }
    Q(this, Rp, r), Q(this, Op, i);
  }
  get kzg() {
    return R(this, Cd);
  }
  set kzg(e) {
    Q(this, Cd, e);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : xn(Oe(this, hv, N4).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return xn(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : bD(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : IE.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return Oe(this, hv, N4).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return Oe(this, hv, N4).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const e = this.gasPrice != null, r = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, i = this.accessList != null, u = R(this, ly) != null || R(this, Op);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && Te(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), Te(!r || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), Te(this.type !== 0 || !i, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const d = [];
    return this.type != null ? d.push(this.type) : r ? d.push(2) : e ? (d.push(1), i || d.push(0)) : i ? (d.push(1), d.push(2)) : (u && this.to || (d.push(0), d.push(1), d.push(2)), d.push(3)), d.sort(), d;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return Td.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const e = (r) => r == null ? null : r.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(e) {
    if (e == null)
      return new Td();
    if (typeof e == "string") {
      const i = mt(e);
      if (i[0] >= 127)
        return Td.from(xD(i));
      switch (i[0]) {
        case 1:
          return Td.from(ND(i));
        case 2:
          return Td.from(TD(i));
        case 3:
          return Td.from(OD(i));
      }
      Te(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const r = new Td();
    return e.type != null && (r.type = e.type), e.to != null && (r.to = e.to), e.nonce != null && (r.nonce = e.nonce), e.gasLimit != null && (r.gasLimit = e.gasLimit), e.gasPrice != null && (r.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (r.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (r.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (r.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (r.data = e.data), e.value != null && (r.value = e.value), e.chainId != null && (r.chainId = e.chainId), e.signature != null && (r.signature = nu.from(e.signature)), e.accessList != null && (r.accessList = e.accessList), e.blobVersionedHashes != null && (r.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (r.kzg = e.kzg), e.blobs != null && (r.blobs = e.blobs), e.hash != null && (se(r.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), se(r.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (se(r.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), se(r.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), r;
  }
};
yc = /* @__PURE__ */ new WeakMap(), nv = /* @__PURE__ */ new WeakMap(), rv = /* @__PURE__ */ new WeakMap(), av = /* @__PURE__ */ new WeakMap(), ov = /* @__PURE__ */ new WeakMap(), iv = /* @__PURE__ */ new WeakMap(), sv = /* @__PURE__ */ new WeakMap(), lv = /* @__PURE__ */ new WeakMap(), uv = /* @__PURE__ */ new WeakMap(), cv = /* @__PURE__ */ new WeakMap(), fv = /* @__PURE__ */ new WeakMap(), dv = /* @__PURE__ */ new WeakMap(), ly = /* @__PURE__ */ new WeakMap(), Op = /* @__PURE__ */ new WeakMap(), Cd = /* @__PURE__ */ new WeakMap(), Rp = /* @__PURE__ */ new WeakMap(), hv = /* @__PURE__ */ new WeakSet(), N4 = function(a, e) {
  Te(!a || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const r = a ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return CD(this, r);
    case 1:
      return PD(this, r);
    case 2:
      return ID(this, r);
    case 3:
      return RD(this, r, e ? this.blobs : null);
  }
  Te(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let HC = LD;
function DD(a) {
  return typeof a == "string" && (a = lo(a)), xn(vn([
    lo(cL),
    lo(String(a.length)),
    a
  ]));
}
const BD = new RegExp("^bytes([0-9]+)$"), MD = new RegExp("^(u?int)([0-9]*)$"), FD = new RegExp("^(.*)\\[([0-9]*)\\]$");
function VC(a, e, r) {
  switch (a) {
    case "address":
      return mt(r ? eu(e, 32) : Wt(e));
    case "string":
      return lo(e);
    case "bytes":
      return mt(e);
    case "bool":
      return e = e ? "0x01" : "0x00", mt(r ? eu(e, 32) : e);
  }
  let i = a.match(MD);
  if (i) {
    let u = i[1] === "int", d = parseInt(i[2] || "256");
    return se((!i[2] || i[2] === String(d)) && d % 8 === 0 && d !== 0 && d <= 256, "invalid number type", "type", a), r && (d = 256), u && (e = wE(e, d)), mt(eu(kr(e), d / 8));
  }
  if (i = a.match(BD), i) {
    const u = parseInt(i[1]);
    return se(String(u) === i[1] && u !== 0 && u <= 32, "invalid bytes type", "type", a), se(ug(e) === u, `invalid value for ${a}`, "value", e), r ? mt(vE(e, 32)) : e;
  }
  if (i = a.match(FD), i && Array.isArray(e)) {
    const u = i[1], d = parseInt(i[2] || String(e.length));
    se(d === e.length, `invalid array length for ${a}`, "value", e);
    const g = [];
    return e.forEach(function(b) {
      g.push(VC(u, b, !0));
    }), mt(vn(g));
  }
  se(!1, "invalid type", "type", a);
}
function _D(a, e) {
  se(a.length === e.length, "wrong number of values; expected ${ types.length }", "values", e);
  const r = [];
  return a.forEach(function(i, u) {
    r.push(VC(i, e[u]));
  }), Ge(vn(r));
}
function I8(a, e) {
  return xn(_D(a, e));
}
const WC = new Uint8Array(32);
WC.fill(0);
const UD = BigInt(-1), GC = BigInt(0), jC = BigInt(1), zD = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function HD(a) {
  const e = mt(a), r = e.length % 32;
  return r ? vn([e, WC.slice(r)]) : Ge(e);
}
const VD = Ud(jC, 32), WD = Ud(GC, 32), JA = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, N8 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function XA(a) {
  return function(e) {
    return se(typeof e == "string", `invalid domain value for ${JSON.stringify(a)}`, `domain.${a}`, e), e;
  };
}
const GD = {
  name: XA("name"),
  version: XA("version"),
  chainId: function(a) {
    const e = Qe(a, "domain.chainId");
    return se(e >= 0, "invalid chain ID", "domain.chainId", a), Number.isSafeInteger(e) ? Number(e) : by(e);
  },
  verifyingContract: function(a) {
    try {
      return Wt(a).toLowerCase();
    } catch {
    }
    se(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", a);
  },
  salt: function(a) {
    const e = mt(a, "domain.salt");
    return se(e.length === 32, 'invalid domain value "salt"', "domain.salt", a), Ge(e);
  }
};
function T5(a) {
  {
    const e = a.match(/^(u?)int(\d+)$/);
    if (e) {
      const r = e[1] === "", i = parseInt(e[2]);
      se(i % 8 === 0 && i !== 0 && i <= 256 && e[2] === String(i), "invalid numeric width", "type", a);
      const u = eg(zD, r ? i - 1 : i), d = r ? (u + jC) * UD : GC;
      return function(g) {
        const b = Qe(g, "value");
        return se(b >= d && b <= u, `value out-of-bounds for ${a}`, "value", b), Ud(r ? wE(b, 256) : b, 32);
      };
    }
  }
  {
    const e = a.match(/^bytes(\d+)$/);
    if (e) {
      const r = parseInt(e[1]);
      return se(r !== 0 && r <= 32 && e[1] === String(r), "invalid bytes width", "type", a), function(i) {
        const u = mt(i);
        return se(u.length === r, `invalid length for ${a}`, "value", i), HD(i);
      };
    }
  }
  switch (a) {
    case "address":
      return function(e) {
        return eu(Wt(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? VD : WD;
      };
    case "bytes":
      return function(e) {
        return xn(e);
      };
    case "string":
      return function(e) {
        return vg(e);
      };
  }
  return null;
}
function e9(a, e) {
  return `${a}(${e.map(({ name: r, type: i }) => i + " " + r).join(",")})`;
}
function P4(a) {
  const e = a.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return e ? {
    base: e[1],
    index: e[2] + e[4],
    array: {
      base: e[1],
      prefix: e[1] + e[2],
      count: e[5] ? parseInt(e[5]) : -1
    }
  } : { base: a };
}
var O4, Md, pv, I5, $C;
const jD = class Ns {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(e) {
    ye(this, I5), le(this, "primaryType"), ye(this, O4), ye(this, Md), ye(this, pv), Q(this, Md, /* @__PURE__ */ new Map()), Q(this, pv, /* @__PURE__ */ new Map());
    const r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), d = {};
    Object.keys(e).forEach((y) => {
      d[y] = e[y].map(({ name: k, type: S }) => {
        let { base: A, index: x } = P4(S);
        return A === "int" && !e.int && (A = "int256"), A === "uint" && !e.uint && (A = "uint256"), { name: k, type: A + (x || "") };
      }), r.set(y, /* @__PURE__ */ new Set()), i.set(y, []), u.set(y, /* @__PURE__ */ new Set());
    }), Q(this, O4, JSON.stringify(d));
    for (const y in d) {
      const k = /* @__PURE__ */ new Set();
      for (const S of d[y]) {
        se(!k.has(S.name), `duplicate variable name ${JSON.stringify(S.name)} in ${JSON.stringify(y)}`, "types", e), k.add(S.name);
        const A = P4(S.type).base;
        se(A !== y, `circular type reference to ${JSON.stringify(A)}`, "types", e), !T5(A) && (se(i.has(A), `unknown type ${JSON.stringify(A)}`, "types", e), i.get(A).push(y), r.get(y).add(A));
      }
    }
    const g = Array.from(i.keys()).filter((y) => i.get(y).length === 0);
    se(g.length !== 0, "missing primary type", "types", e), se(g.length === 1, `ambiguous primary types or unused types: ${g.map((y) => JSON.stringify(y)).join(", ")}`, "types", e), Ke(this, { primaryType: g[0] });
    function b(y, k) {
      se(!k.has(y), `circular type reference to ${JSON.stringify(y)}`, "types", e), k.add(y);
      for (const S of r.get(y))
        if (i.has(S)) {
          b(S, k);
          for (const A of k)
            u.get(A).add(S);
        }
      k.delete(y);
    }
    b(this.primaryType, /* @__PURE__ */ new Set());
    for (const [y, k] of u) {
      const S = Array.from(k);
      S.sort(), R(this, Md).set(y, e9(y, d[y]) + S.map((A) => e9(A, d[A])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(R(this, O4));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(e) {
    let r = R(this, pv).get(e);
    return r || (r = Oe(this, I5, $C).call(this, e), R(this, pv).set(e, r)), r;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(e) {
    const r = R(this, Md).get(e);
    return se(r, `unknown type: ${JSON.stringify(e)}`, "name", e), r;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(e, r) {
    return this.getEncoder(e)(r);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(e, r) {
    return xn(this.encodeData(e, r));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  /**
   *  @_ignore:
   */
  _visit(e, r, i) {
    if (T5(e))
      return i(e, r);
    const u = P4(e).array;
    if (u)
      return se(u.count === -1 || u.count === r.length, `array length mismatch; expected length ${u.count}`, "value", r), r.map((g) => this._visit(u.prefix, g, i));
    const d = this.types[e];
    if (d)
      return d.reduce((g, { name: b, type: y }) => (g[b] = this._visit(y, r[b], i), g), {});
    se(!1, `unknown type: ${e}`, "type", e);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(e, r) {
    return this._visit(this.primaryType, e, r);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(e) {
    return new Ns(e);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(e) {
    return Ns.from(e).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(e, r, i) {
    return Ns.from(r).hashStruct(e, i);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(e) {
    const r = [];
    for (const i in e) {
      if (e[i] == null)
        continue;
      const u = JA[i];
      se(u, `invalid typed-data domain key: ${JSON.stringify(i)}`, "domain", e), r.push({ name: i, type: u });
    }
    return r.sort((i, u) => N8.indexOf(i.name) - N8.indexOf(u.name)), Ns.hashStruct("EIP712Domain", { EIP712Domain: r }, e);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(e, r, i) {
    return vn([
      "0x1901",
      Ns.hashDomain(e),
      Ns.from(r).hash(i)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(e, r, i) {
    return xn(Ns.encode(e, r, i));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(e, r, i, u) {
    e = Object.assign({}, e);
    for (const b in e)
      e[b] == null && delete e[b];
    const d = {};
    e.verifyingContract && !ln(e.verifyingContract, 20) && (d[e.verifyingContract] = "0x");
    const g = Ns.from(r);
    g.visit(i, (b, y) => (b === "address" && !ln(y, 20) && (d[y] = "0x"), y));
    for (const b in d)
      d[b] = await u(b);
    return e.verifyingContract && d[e.verifyingContract] && (e.verifyingContract = d[e.verifyingContract]), i = g.visit(i, (b, y) => b === "address" && d[y] ? d[y] : y), { domain: e, value: i };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(e, r, i) {
    Ns.hashDomain(e);
    const u = {}, d = [];
    N8.forEach((y) => {
      const k = e[y];
      k != null && (u[y] = GD[y](k), d.push({ name: y, type: JA[y] }));
    });
    const g = Ns.from(r);
    r = g.types;
    const b = Object.assign({}, r);
    return se(b.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", r), b.EIP712Domain = d, g.encode(i), {
      types: b,
      domain: u,
      primaryType: g.primaryType,
      message: g.visit(i, (y, k) => {
        if (y.match(/^bytes(\d*)/))
          return Ge(mt(k));
        if (y.match(/^u?int/))
          return Qe(k).toString();
        switch (y) {
          case "address":
            return k.toLowerCase();
          case "bool":
            return !!k;
          case "string":
            return se(typeof k == "string", "invalid string", "value", k), k;
        }
        se(!1, "unsupported type", "type", y);
      })
    };
  }
};
O4 = /* @__PURE__ */ new WeakMap(), Md = /* @__PURE__ */ new WeakMap(), pv = /* @__PURE__ */ new WeakMap(), I5 = /* @__PURE__ */ new WeakSet(), $C = function(a) {
  {
    const i = T5(a);
    if (i)
      return i;
  }
  const e = P4(a).array;
  if (e) {
    const i = e.prefix, u = this.getEncoder(i);
    return (d) => {
      se(e.count === -1 || e.count === d.length, `array length mismatch; expected length ${e.count}`, "value", d);
      let g = d.map(u);
      return R(this, Md).has(i) && (g = g.map(xn)), xn(vn(g));
    };
  }
  const r = this.types[a];
  if (r) {
    const i = vg(R(this, Md).get(a));
    return (u) => {
      const d = r.map(({ name: g, type: b }) => {
        const y = this.getEncoder(b)(u[g]);
        return R(this, Md).has(b) ? xn(y) : y;
      });
      return d.unshift(i), vn(d);
    };
  }
  se(!1, `unknown type: ${a}`, "type", a);
};
let t9 = jD;
function Va(a) {
  const e = /* @__PURE__ */ new Set();
  return a.forEach((r) => e.add(r)), Object.freeze(e);
}
const $D = "external public payable override", QD = Va($D.split(" ")), QC = "constant external internal payable private public pure view override", ZD = Va(QC.split(" ")), ZC = "constructor error event fallback function receive struct", YC = Va(ZC.split(" ")), qC = "calldata memory storage payable indexed", YD = Va(qC.split(" ")), qD = "tuple returns", KD = [ZC, qC, qD, QC].join(" "), JD = Va(KD.split(" ")), XD = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, eB = new RegExp("^(\\s*)"), tB = new RegExp("^([0-9]+)"), nB = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), KC = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), JC = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var da, $l, R4, N5;
const XC = class eT {
  constructor(e) {
    ye(this, R4), ye(this, da), ye(this, $l), Q(this, da, 0), Q(this, $l, e.slice());
  }
  get offset() {
    return R(this, da);
  }
  get length() {
    return R(this, $l).length - R(this, da);
  }
  clone() {
    return new eT(R(this, $l));
  }
  reset() {
    Q(this, da, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(e) {
    const r = this.peek();
    if (r.type !== "KEYWORD" || !e.has(r.text))
      throw new Error(`expected keyword ${r.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(e) {
    if (this.peek().type !== e) {
      const r = this.peek();
      throw new Error(`expected ${e}; got ${r.type} ${JSON.stringify(r.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const r = Oe(this, R4, N5).call(this, R(this, da) + 1, e.match + 1);
    return Q(this, da, e.match + 1), r;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const r = [];
    for (; R(this, da) < e.match - 1; ) {
      const i = this.peek().linkNext;
      r.push(Oe(this, R4, N5).call(this, R(this, da) + 1, i)), Q(this, da, i);
    }
    return Q(this, da, e.match + 1), r;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (R(this, da) >= R(this, $l).length)
      throw new Error("out-of-bounds");
    return R(this, $l)[R(this, da)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(e) {
    const r = this.peekType("KEYWORD");
    return r != null && e.has(r) ? r : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(e) {
    if (this.length === 0)
      return null;
    const r = this.peek();
    return r.type === e ? r.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const e = this.peek();
    return Y4(this, da)._++, e;
  }
  toString() {
    const e = [];
    for (let r = R(this, da); r < R(this, $l).length; r++) {
      const i = R(this, $l)[r];
      e.push(`${i.type}:${i.text}`);
    }
    return `<TokenString ${e.join(" ")}>`;
  }
};
da = /* @__PURE__ */ new WeakMap(), $l = /* @__PURE__ */ new WeakMap(), R4 = /* @__PURE__ */ new WeakSet(), N5 = function(a = 0, e = 0) {
  return new XC(R(this, $l).slice(a, e).map((r) => Object.freeze(Object.assign({}, r, {
    match: r.match - a,
    linkBack: r.linkBack - a,
    linkNext: r.linkNext - a
  }))));
};
let zc = XC;
function Hd(a) {
  const e = [], r = (g) => {
    const b = d < a.length ? JSON.stringify(a[d]) : "$EOI";
    throw new Error(`invalid token ${b} at ${d}: ${g}`);
  };
  let i = [], u = [], d = 0;
  for (; d < a.length; ) {
    let g = a.substring(d), b = g.match(eB);
    b && (d += b[1].length, g = a.substring(d));
    const y = { depth: i.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: d, value: -1 };
    e.push(y);
    let k = XD[g[0]] || "";
    if (k) {
      if (y.type = k, y.text = g[0], d++, k === "OPEN_PAREN")
        i.push(e.length - 1), u.push(e.length - 1);
      else if (k == "CLOSE_PAREN")
        i.length === 0 && r("no matching open bracket"), y.match = i.pop(), e[y.match].match = e.length - 1, y.depth--, y.linkBack = u.pop(), e[y.linkBack].linkNext = e.length - 1;
      else if (k === "COMMA")
        y.linkBack = u.pop(), e[y.linkBack].linkNext = e.length - 1, u.push(e.length - 1);
      else if (k === "OPEN_BRACKET")
        y.type = "BRACKET";
      else if (k === "CLOSE_BRACKET") {
        let S = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          const A = e.pop().text;
          S = A + S, e[e.length - 1].value = yt(A);
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += S;
      }
      continue;
    }
    if (b = g.match(nB), b) {
      if (y.text = b[1], d += y.text.length, JD.has(y.text)) {
        y.type = "KEYWORD";
        continue;
      }
      if (y.text.match(JC)) {
        y.type = "TYPE";
        continue;
      }
      y.type = "ID";
      continue;
    }
    if (b = g.match(tB), b) {
      y.text = b[1], y.type = "NUMBER", d += y.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(g[0])} at position ${d}`);
  }
  return new zc(e.map((g) => Object.freeze(g)));
}
function n9(a, e) {
  let r = [];
  for (const i in e.keys())
    a.has(i) && r.push(i);
  if (r.length > 1)
    throw new Error(`conflicting types: ${r.join(", ")}`);
}
function kk(a, e) {
  if (e.peekKeyword(YC)) {
    const r = e.pop().text;
    if (r !== a)
      throw new Error(`expected ${a}, got ${r}`);
  }
  return e.popType("ID");
}
function Fc(a, e) {
  const r = /* @__PURE__ */ new Set();
  for (; ; ) {
    const i = a.peekType("KEYWORD");
    if (i == null || e && !e.has(i))
      break;
    if (a.pop(), r.has(i))
      throw new Error(`duplicate keywords: ${JSON.stringify(i)}`);
    r.add(i);
  }
  return Object.freeze(r);
}
function tT(a) {
  let e = Fc(a, ZD);
  return n9(e, Va("constant payable nonpayable".split(" "))), n9(e, Va("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
}
function Bc(a, e) {
  return a.popParams().map((r) => Wa.from(r, e));
}
function nT(a) {
  if (a.peekType("AT")) {
    if (a.pop(), a.peekType("NUMBER"))
      return Qe(a.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function wg(a) {
  if (a.length)
    throw new Error(`unexpected tokens at offset ${a.offset}: ${a.toString()}`);
}
const rB = new RegExp(/^(.*)\[([0-9]*)\]$/);
function r9(a) {
  const e = a.match(JC);
  if (se(e, "invalid type", "type", a), a === "uint")
    return "uint256";
  if (a === "int")
    return "int256";
  if (e[2]) {
    const r = parseInt(e[2]);
    se(r !== 0 && r <= 32, "invalid bytes length", "type", a);
  } else if (e[3]) {
    const r = parseInt(e[3]);
    se(r !== 0 && r <= 256 && r % 8 === 0, "invalid numeric width", "type", a);
  }
  return a;
}
const An = {}, co = Symbol.for("_ethers_internal"), a9 = "_ParamTypeInternal", o9 = "_ErrorInternal", i9 = "_EventInternal", s9 = "_ConstructorInternal", l9 = "_FallbackInternal", u9 = "_FunctionInternal", c9 = "_StructInternal";
var Lv, L4;
const aB = class Ps {
  /**
   *  @private
   */
  constructor(e, r, i, u, d, g, b, y) {
    if (ye(this, Lv), le(this, "name"), le(this, "type"), le(this, "baseType"), le(this, "indexed"), le(this, "components"), le(this, "arrayLength"), le(this, "arrayChildren"), tw(e, An, "ParamType"), Object.defineProperty(this, co, { value: a9 }), g && (g = Object.freeze(g.slice())), u === "array") {
      if (b == null || y == null)
        throw new Error("");
    } else if (b != null || y != null)
      throw new Error("");
    if (u === "tuple") {
      if (g == null)
        throw new Error("");
    } else if (g != null)
      throw new Error("");
    Ke(this, {
      name: r,
      type: i,
      baseType: u,
      indexed: d,
      components: g,
      arrayLength: b,
      arrayChildren: y
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json") {
      const i = this.name || "";
      if (this.isArray()) {
        const d = JSON.parse(this.arrayChildren.format("json"));
        return d.name = i, d.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(d);
      }
      const u = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: i
      };
      return typeof this.indexed == "boolean" && (u.indexed = this.indexed), this.isTuple() && (u.components = this.components.map((d) => JSON.parse(d.format(e)))), JSON.stringify(u);
    }
    let r = "";
    return this.isArray() ? (r += this.arrayChildren.format(e), r += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? r += "(" + this.components.map((i) => i.format(e)).join(e === "full" ? ", " : ",") + ")" : r += this.type, e !== "sighash" && (this.indexed === !0 && (r += " indexed"), e === "full" && this.name && (r += " " + this.name)), r;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(e, r) {
    if (this.isArray()) {
      if (!Array.isArray(e))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && e.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const i = this;
      return e.map((u) => i.arrayChildren.walk(u, r));
    }
    if (this.isTuple()) {
      if (!Array.isArray(e))
        throw new Error("invalid tuple value");
      if (e.length !== this.components.length)
        throw new Error("array is wrong length");
      const i = this;
      return e.map((u, d) => i.components[d].walk(u, r));
    }
    return r(this.type, e);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(e, r) {
    const i = [], u = [e];
    return Oe(this, Lv, L4).call(this, i, e, r, (d) => {
      u[0] = d;
    }), i.length && await Promise.all(i), u[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(e, r) {
    if (Ps.isParamType(e))
      return e;
    if (typeof e == "string")
      try {
        return Ps.from(Hd(e), r);
      } catch {
        se(!1, "invalid param type", "obj", e);
      }
    else if (e instanceof zc) {
      let b = "", y = "", k = null;
      Fc(e, Va(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (y = "tuple", k = e.popParams().map((D) => Ps.from(D)), b = `tuple(${k.map((D) => D.format()).join(",")})`) : (b = r9(e.popType("TYPE")), y = b);
      let S = null, A = null;
      for (; e.length && e.peekType("BRACKET"); ) {
        const D = e.pop();
        S = new Ps(An, "", b, y, null, k, A, S), A = D.value, b += D.text, y = "array", k = null;
      }
      let x = null;
      if (Fc(e, YD).has("indexed")) {
        if (!r)
          throw new Error("");
        x = !0;
      }
      const M = e.peekType("ID") ? e.pop().text : "";
      if (e.length)
        throw new Error("leftover tokens");
      return new Ps(An, M, b, y, x, k, A, S);
    }
    const i = e.name;
    se(!i || typeof i == "string" && i.match(KC), "invalid name", "obj.name", i);
    let u = e.indexed;
    u != null && (se(r, "parameter cannot be indexed", "obj.indexed", e.indexed), u = !!u);
    let d = e.type, g = d.match(rB);
    if (g) {
      const b = parseInt(g[2] || "-1"), y = Ps.from({
        type: g[1],
        components: e.components
      });
      return new Ps(An, i || "", d, "array", u, null, b, y);
    }
    if (d === "tuple" || d.startsWith(
      "tuple("
      /* fix: ) */
    ) || d.startsWith(
      "("
      /* fix: ) */
    )) {
      const b = e.components != null ? e.components.map((y) => Ps.from(y)) : null;
      return new Ps(An, i || "", d, "tuple", u, b, null, null);
    }
    return d = r9(e.type), new Ps(An, i || "", d, d, u, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(e) {
    return e && e[co] === a9;
  }
};
Lv = /* @__PURE__ */ new WeakSet(), L4 = function(a, e, r, i) {
  if (this.isArray()) {
    if (!Array.isArray(e))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && e.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const d = this.arrayChildren, g = e.slice();
    g.forEach((b, y) => {
      var k;
      Oe(k = d, Lv, L4).call(k, a, b, r, (S) => {
        g[y] = S;
      });
    }), i(g);
    return;
  }
  if (this.isTuple()) {
    const d = this.components;
    let g;
    if (Array.isArray(e))
      g = e.slice();
    else {
      if (e == null || typeof e != "object")
        throw new Error("invalid tuple value");
      g = d.map((b) => {
        if (!b.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(b.name in e))
          throw new Error(`missing value for component ${b.name}`);
        return e[b.name];
      });
    }
    if (g.length !== this.components.length)
      throw new Error("array is wrong length");
    g.forEach((b, y) => {
      var k;
      Oe(k = d[y], Lv, L4).call(k, a, b, r, (S) => {
        g[y] = S;
      });
    }), i(g);
    return;
  }
  const u = r(this.type, e);
  u.then ? a.push(async function() {
    i(await u);
  }()) : i(u);
};
let Wa = aB;
class kg {
  /**
   *  @private
   */
  constructor(e, r, i) {
    le(this, "type"), le(this, "inputs"), tw(e, An, "Fragment"), i = Object.freeze(i.slice()), Ke(this, { type: r, inputs: i });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(e) {
    if (typeof e == "string") {
      try {
        kg.from(JSON.parse(e));
      } catch {
      }
      return kg.from(Hd(e));
    }
    if (e instanceof zc)
      switch (e.peekKeyword(YC)) {
        case "constructor":
          return Dc.from(e);
        case "error":
          return so.from(e);
        case "event":
          return Jl.from(e);
        case "fallback":
        case "receive":
          return f9.from(e);
        case "function":
          return Xl.from(e);
        case "struct":
          return dg.from(e);
      }
    else if (typeof e == "object") {
      switch (e.type) {
        case "constructor":
          return Dc.from(e);
        case "error":
          return so.from(e);
        case "event":
          return Jl.from(e);
        case "fallback":
        case "receive":
          return f9.from(e);
        case "function":
          return Xl.from(e);
        case "struct":
          return dg.from(e);
      }
      Te(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    se(!1, "unsupported frgament object", "obj", e);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(e) {
    return Dc.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(e) {
    return so.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(e) {
    return Jl.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(e) {
    return Xl.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(e) {
    return dg.isFragment(e);
  }
}
class Ek extends kg {
  /**
   *  @private
   */
  constructor(e, r, i, u) {
    super(e, r, u), le(this, "name"), se(typeof i == "string" && i.match(KC), "invalid identifier", "name", i), u = Object.freeze(u.slice()), Ke(this, { name: i });
  }
}
function Gv(a, e) {
  return "(" + e.map((r) => r.format(a)).join(a === "full" ? ", " : ",") + ")";
}
class so extends Ek {
  /**
   *  @private
   */
  constructor(e, r, i) {
    super(e, "error", r, i), Object.defineProperty(this, co, { value: o9 });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return vg(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e)))
      });
    const r = [];
    return e !== "sighash" && r.push("error"), r.push(this.name + Gv(e, this.inputs)), r.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(e) {
    if (so.isFragment(e))
      return e;
    if (typeof e == "string")
      return so.from(Hd(e));
    if (e instanceof zc) {
      const r = kk("error", e), i = Bc(e);
      return wg(e), new so(An, r, i);
    }
    return new so(An, e.name, e.inputs ? e.inputs.map(Wa.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(e) {
    return e && e[co] === o9;
  }
}
class Jl extends Ek {
  /**
   *  @private
   */
  constructor(e, r, i, u) {
    super(e, "event", r, i), le(this, "anonymous"), Object.defineProperty(this, co, { value: i9 }), Ke(this, { anonymous: u });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return vg(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e)))
      });
    const r = [];
    return e !== "sighash" && r.push("event"), r.push(this.name + Gv(e, this.inputs)), e !== "sighash" && this.anonymous && r.push("anonymous"), r.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(e, r) {
    return r = (r || []).map((i) => Wa.from(i)), new Jl(An, e, r, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(e) {
    if (Jl.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Jl.from(Hd(e));
      } catch {
        se(!1, "invalid event fragment", "obj", e);
      }
    else if (e instanceof zc) {
      const r = kk("event", e), i = Bc(e, !0), u = !!Fc(e, Va(["anonymous"])).has("anonymous");
      return wg(e), new Jl(An, r, i, u);
    }
    return new Jl(An, e.name, e.inputs ? e.inputs.map((r) => Wa.from(r, !0)) : [], !!e.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(e) {
    return e && e[co] === i9;
  }
}
class Dc extends kg {
  /**
   *  @private
   */
  constructor(e, r, i, u, d) {
    super(e, r, i), le(this, "payable"), le(this, "gas"), Object.defineProperty(this, co, { value: s9 }), Ke(this, { payable: u, gas: d });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(e) {
    if (Te(e != null && e !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), e === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e)))
      });
    const r = [`constructor${Gv(e, this.inputs)}`];
    return this.payable && r.push("payable"), this.gas != null && r.push(`@${this.gas.toString()}`), r.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(e) {
    if (Dc.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Dc.from(Hd(e));
      } catch {
        se(!1, "invalid constuctor fragment", "obj", e);
      }
    else if (e instanceof zc) {
      Fc(e, Va(["constructor"]));
      const r = Bc(e), i = !!Fc(e, QD).has("payable"), u = nT(e);
      return wg(e), new Dc(An, "constructor", r, i, u);
    }
    return new Dc(An, "constructor", e.inputs ? e.inputs.map(Wa.from) : [], !!e.payable, e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(e) {
    return e && e[co] === s9;
  }
}
let f9 = class Lp extends kg {
  constructor(e, r, i) {
    super(e, "fallback", r), le(this, "payable"), Object.defineProperty(this, co, { value: l9 }), Ke(this, { payable: i });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(e) {
    const r = this.inputs.length === 0 ? "receive" : "fallback";
    if (e === "json") {
      const i = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: r, stateMutability: i });
    }
    return `${r}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(e) {
    if (Lp.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Lp.from(Hd(e));
      } catch {
        se(!1, "invalid fallback fragment", "obj", e);
      }
    else if (e instanceof zc) {
      const r = e.toString(), i = e.peekKeyword(Va(["fallback", "receive"]));
      if (se(i, "type must be fallback or receive", "obj", r), e.popKeyword(Va(["fallback", "receive"])) === "receive") {
        const g = Bc(e);
        return se(g.length === 0, "receive cannot have arguments", "obj.inputs", g), Fc(e, Va(["payable"])), wg(e), new Lp(An, [], !0);
      }
      let u = Bc(e);
      u.length ? se(u.length === 1 && u[0].type === "bytes", "invalid fallback inputs", "obj.inputs", u.map((g) => g.format("minimal")).join(", ")) : u = [Wa.from("bytes")];
      const d = tT(e);
      if (se(d === "nonpayable" || d === "payable", "fallback cannot be constants", "obj.stateMutability", d), Fc(e, Va(["returns"])).has("returns")) {
        const g = Bc(e);
        se(g.length === 1 && g[0].type === "bytes", "invalid fallback outputs", "obj.outputs", g.map((b) => b.format("minimal")).join(", "));
      }
      return wg(e), new Lp(An, u, d === "payable");
    }
    if (e.type === "receive")
      return new Lp(An, [], !0);
    if (e.type === "fallback") {
      const r = [Wa.from("bytes")], i = e.stateMutability === "payable";
      return new Lp(An, r, i);
    }
    se(!1, "invalid fallback description", "obj", e);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(e) {
    return e && e[co] === l9;
  }
};
class Xl extends Ek {
  /**
   *  @private
   */
  constructor(e, r, i, u, d, g) {
    super(e, "function", r, u), le(this, "constant"), le(this, "outputs"), le(this, "stateMutability"), le(this, "payable"), le(this, "gas"), Object.defineProperty(this, co, { value: u9 }), d = Object.freeze(d.slice()), Ke(this, { constant: i === "view" || i === "pure", gas: g, outputs: d, payable: i === "payable", stateMutability: i });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return vg(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
        outputs: this.outputs.map((i) => JSON.parse(i.format(e)))
      });
    const r = [];
    return e !== "sighash" && r.push("function"), r.push(this.name + Gv(e, this.inputs)), e !== "sighash" && (this.stateMutability !== "nonpayable" && r.push(this.stateMutability), this.outputs && this.outputs.length && (r.push("returns"), r.push(Gv(e, this.outputs))), this.gas != null && r.push(`@${this.gas.toString()}`)), r.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(e, r) {
    return r = (r || []).map((i) => Wa.from(i)), new Xl(An, e, "view", r, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(e) {
    if (Xl.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Xl.from(Hd(e));
      } catch {
        se(!1, "invalid function fragment", "obj", e);
      }
    else if (e instanceof zc) {
      const i = kk("function", e), u = Bc(e), d = tT(e);
      let g = [];
      Fc(e, Va(["returns"])).has("returns") && (g = Bc(e));
      const b = nT(e);
      return wg(e), new Xl(An, i, d, u, g, b);
    }
    let r = e.stateMutability;
    return r == null && (r = "payable", typeof e.constant == "boolean" ? (r = "view", e.constant || (r = "payable", typeof e.payable == "boolean" && !e.payable && (r = "nonpayable"))) : typeof e.payable == "boolean" && !e.payable && (r = "nonpayable")), new Xl(An, e.name, r, e.inputs ? e.inputs.map(Wa.from) : [], e.outputs ? e.outputs.map(Wa.from) : [], e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(e) {
    return e && e[co] === u9;
  }
}
class dg extends Ek {
  /**
   *  @private
   */
  constructor(e, r, i) {
    super(e, "struct", r, i), Object.defineProperty(this, co, { value: c9 });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(e) {
    if (typeof e == "string")
      try {
        return dg.from(Hd(e));
      } catch {
        se(!1, "invalid struct fragment", "obj", e);
      }
    else if (e instanceof zc) {
      const r = kk("struct", e), i = Bc(e);
      return wg(e), new dg(An, r, i);
    }
    return new dg(An, e.name, e.inputs ? e.inputs.map(Wa.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(e) {
    return e && e[co] === c9;
  }
}
const js = /* @__PURE__ */ new Map();
js.set(0, "GENERIC_PANIC");
js.set(1, "ASSERT_FALSE");
js.set(17, "OVERFLOW");
js.set(18, "DIVIDE_BY_ZERO");
js.set(33, "ENUM_RANGE_ERROR");
js.set(34, "BAD_STORAGE_DATA");
js.set(49, "STACK_UNDERFLOW");
js.set(50, "ARRAY_RANGE_ERROR");
js.set(65, "OUT_OF_MEMORY");
js.set(81, "UNINITIALIZED_FUNCTION_CALL");
const oB = new RegExp(/^bytes([0-9]*)$/), iB = new RegExp(/^(u?int)([0-9]*)$/);
let P8 = null, d9 = 1024;
function sB(a, e, r, i) {
  let u = "missing revert data", d = null;
  const g = null;
  let b = null;
  if (r) {
    u = "execution reverted";
    const k = mt(r);
    if (r = Ge(r), k.length === 0)
      u += " (no data present; likely require(false) occurred", d = "require(false)";
    else if (k.length % 32 !== 4)
      u += " (could not decode reason; invalid data length)";
    else if (Ge(k.slice(0, 4)) === "0x08c379a0")
      try {
        d = i.decode(["string"], k.slice(4))[0], b = {
          signature: "Error(string)",
          name: "Error",
          args: [d]
        }, u += `: ${JSON.stringify(d)}`;
      } catch {
        u += " (could not decode reason; invalid string data)";
      }
    else if (Ge(k.slice(0, 4)) === "0x4e487b71")
      try {
        const S = Number(i.decode(["uint256"], k.slice(4))[0]);
        b = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [S]
        }, d = `Panic due to ${js.get(S) || "UNKNOWN"}(${S})`, u += `: ${d}`;
      } catch {
        u += " (could not decode panic code)";
      }
    else
      u += " (unknown custom error)";
  }
  const y = {
    to: e.to ? Wt(e.to) : null,
    data: e.data || "0x"
  };
  return e.from && (y.from = Wt(e.from)), Pn(u, "CALL_EXCEPTION", {
    action: a,
    data: r,
    reason: d,
    transaction: y,
    invocation: g,
    revert: b
  });
}
var ag, Py;
const lB = class P5 {
  constructor() {
    ye(this, ag);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(e) {
    const r = e.map((i) => Oe(this, ag, Py).call(this, Wa.from(i)));
    return new T4(r, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(e, r) {
    Sx(r.length, e.length, "types/values length mismatch");
    const i = e.map((g) => Oe(this, ag, Py).call(this, Wa.from(g))), u = new T4(i, "_"), d = new p5();
    return u.encode(d, r), d.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(e, r, i) {
    const u = e.map((d) => Oe(this, ag, Py).call(this, Wa.from(d)));
    return new T4(u, "_").decode(new HO(r, i, d9));
  }
  static _setDefaultMaxInflation(e) {
    se(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), d9 = e;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return P8 == null && (P8 = new P5()), P8;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(e, r, i) {
    return sB(e, r, i, P5.defaultAbiCoder());
  }
};
ag = /* @__PURE__ */ new WeakSet(), Py = function(a) {
  if (a.isArray())
    return new EL(Oe(this, ag, Py).call(this, a.arrayChildren), a.arrayLength, a.name);
  if (a.isTuple())
    return new T4(a.components.map((r) => Oe(this, ag, Py).call(this, r)), a.name);
  switch (a.baseType) {
    case "address":
      return new wL(a.name);
    case "bool":
      return new SL(a.name);
    case "string":
      return new RL(a.name);
    case "bytes":
      return new AL(a.name);
    case "":
      return new TL(a.name);
  }
  let e = a.type.match(iB);
  if (e) {
    let r = parseInt(e[2] || "256");
    return se(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + e[1] + " bit length", "param", a), new OL(r / 8, e[1] === "int", a.name);
  }
  if (e = a.type.match(oB), e) {
    let r = parseInt(e[1]);
    return se(r !== 0 && r <= 32, "invalid bytes length", "param", a), new xL(r, a.name);
  }
  se(!1, "invalid type", "type", a.type);
};
let jv = lB;
function h4(a) {
  const e = lo(a);
  if (e.length > 31)
    throw new Error("bytes32 string must be less than 32 bytes");
  return vE(e, 32);
}
class uB {
  /**
   *  @_ignore:
   */
  constructor(e, r, i) {
    le(this, "fragment"), le(this, "name"), le(this, "signature"), le(this, "topic"), le(this, "args");
    const u = e.name, d = e.format();
    Ke(this, {
      fragment: e,
      name: u,
      signature: d,
      topic: r,
      args: i
    });
  }
}
class cB {
  /**
   *  @_ignore:
   */
  constructor(e, r, i, u) {
    le(this, "fragment"), le(this, "name"), le(this, "args"), le(this, "signature"), le(this, "selector"), le(this, "value");
    const d = e.name, g = e.format();
    Ke(this, {
      fragment: e,
      name: d,
      args: i,
      signature: g,
      selector: r,
      value: u
    });
  }
}
class fB {
  /**
   *  @_ignore:
   */
  constructor(e, r, i) {
    le(this, "fragment"), le(this, "name"), le(this, "args"), le(this, "signature"), le(this, "selector");
    const u = e.name, d = e.format();
    Ke(this, {
      fragment: e,
      name: u,
      args: i,
      signature: d,
      selector: r
    });
  }
}
class h9 {
  /**
   *  @_ignore:
   */
  constructor(e) {
    le(this, "hash"), le(this, "_isIndexed"), Ke(this, { hash: e, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const p9 = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, g9 = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (a) => `reverted with reason string ${JSON.stringify(a)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (a) => {
      let e = "unknown panic code";
      return a >= 0 && a <= 255 && p9[a.toString()] && (e = p9[a.toString()]), `reverted with panic code 0x${a.toString(16)} (${e})`;
    }
  }
};
var bc, Tc, Ic, Ba, Id, D4, B4;
const dB = class uy {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(e) {
    ye(this, Id), le(this, "fragments"), le(this, "deploy"), le(this, "fallback"), le(this, "receive"), ye(this, bc), ye(this, Tc), ye(this, Ic), ye(this, Ba);
    let r = [];
    typeof e == "string" ? r = JSON.parse(e) : r = e, Q(this, Ic, /* @__PURE__ */ new Map()), Q(this, bc, /* @__PURE__ */ new Map()), Q(this, Tc, /* @__PURE__ */ new Map());
    const i = [];
    for (const g of r)
      try {
        i.push(kg.from(g));
      } catch (b) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(g)}:`, b.message);
      }
    Ke(this, {
      fragments: Object.freeze(i)
    });
    let u = null, d = !1;
    Q(this, Ba, this.getAbiCoder()), this.fragments.forEach((g, b) => {
      let y;
      switch (g.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          Ke(this, { deploy: g });
          return;
        case "fallback":
          g.inputs.length === 0 ? d = !0 : (se(!u || g.payable !== u.payable, "conflicting fallback fragments", `fragments[${b}]`, g), u = g, d = u.payable);
          return;
        case "function":
          y = R(this, Ic);
          break;
        case "event":
          y = R(this, Tc);
          break;
        case "error":
          y = R(this, bc);
          break;
        default:
          return;
      }
      const k = g.format();
      y.has(k) || y.set(k, g);
    }), this.deploy || Ke(this, {
      deploy: Dc.from("constructor()")
    }), Ke(this, { fallback: u, receive: d });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(e) {
    const r = e ? "minimal" : "full";
    return this.fragments.map((i) => i.format(r));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const e = this.fragments.map((r) => r.format("json"));
    return JSON.stringify(e.map((r) => JSON.parse(r)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return jv.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(e) {
    const r = Oe(this, Id, D4).call(this, e, null, !1);
    return se(r, "no matching function", "key", e), r.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(e) {
    return !!Oe(this, Id, D4).call(this, e, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(e, r) {
    return Oe(this, Id, D4).call(this, e, r || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(e) {
    const r = Array.from(R(this, Ic).keys());
    r.sort((i, u) => i.localeCompare(u));
    for (let i = 0; i < r.length; i++) {
      const u = r[i];
      e(R(this, Ic).get(u), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(e) {
    const r = Oe(this, Id, B4).call(this, e, null, !1);
    return se(r, "no matching event", "key", e), r.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(e) {
    return !!Oe(this, Id, B4).call(this, e, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(e, r) {
    return Oe(this, Id, B4).call(this, e, r || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(e) {
    const r = Array.from(R(this, Tc).keys());
    r.sort((i, u) => i.localeCompare(u));
    for (let i = 0; i < r.length; i++) {
      const u = r[i];
      e(R(this, Tc).get(u), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(e, r) {
    if (ln(e)) {
      const i = e.toLowerCase();
      if (g9[i])
        return so.from(g9[i].signature);
      for (const u of R(this, bc).values())
        if (i === u.selector)
          return u;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const i = [];
      for (const [u, d] of R(this, bc))
        u.split(
          "("
          /* fix:) */
        )[0] === e && i.push(d);
      if (i.length === 0)
        return e === "Error" ? so.from("error Error(string)") : e === "Panic" ? so.from("error Panic(uint256)") : null;
      if (i.length > 1) {
        const u = i.map((d) => JSON.stringify(d.format())).join(", ");
        se(!1, `ambiguous error description (i.e. ${u})`, "name", e);
      }
      return i[0];
    }
    return e = so.from(e).format(), e === "Error(string)" ? so.from("error Error(string)") : e === "Panic(uint256)" ? so.from("error Panic(uint256)") : R(this, bc).get(e) || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(e) {
    const r = Array.from(R(this, bc).keys());
    r.sort((i, u) => i.localeCompare(u));
    for (let i = 0; i < r.length; i++) {
      const u = r[i];
      e(R(this, bc).get(u), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(e, r) {
    return R(this, Ba).decode(e, r);
  }
  _encodeParams(e, r) {
    return R(this, Ba).encode(e, r);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(e, r) {
    if (typeof e == "string") {
      const i = this.getError(e);
      se(i, "unknown error", "fragment", e), e = i;
    }
    return se(On(r, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", r), this._decodeParams(e.inputs, On(r, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(e, r) {
    if (typeof e == "string") {
      const i = this.getError(e);
      se(i, "unknown error", "fragment", e), e = i;
    }
    return vn([
      e.selector,
      this._encodeParams(e.inputs, r || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(e, r) {
    if (typeof e == "string") {
      const i = this.getFunction(e);
      se(i, "unknown function", "fragment", e), e = i;
    }
    return se(On(r, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", r), this._decodeParams(e.inputs, On(r, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(e, r) {
    if (typeof e == "string") {
      const i = this.getFunction(e);
      se(i, "unknown function", "fragment", e), e = i;
    }
    return vn([
      e.selector,
      this._encodeParams(e.inputs, r || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(e, r) {
    if (typeof e == "string") {
      const d = this.getFunction(e);
      se(d, "unknown function", "fragment", e), e = d;
    }
    let i = "invalid length for result data";
    const u = Ua(r);
    if (u.length % 32 === 0)
      try {
        return R(this, Ba).decode(e.outputs, u);
      } catch {
        i = "could not decode result data";
      }
    Te(!1, i, "BAD_DATA", {
      value: Ge(u),
      info: { method: e.name, signature: e.format() }
    });
  }
  makeError(e, r) {
    const i = mt(e, "data"), u = jv.getBuiltinCallException("call", r, i);
    if (u.message.startsWith("execution reverted (unknown custom error)")) {
      const g = Ge(i.slice(0, 4)), b = this.getError(g);
      if (b)
        try {
          const y = R(this, Ba).decode(b.inputs, i.slice(4));
          u.revert = {
            name: b.name,
            signature: b.format(),
            args: y
          }, u.reason = u.revert.signature, u.message = `execution reverted: ${u.reason}`;
        } catch {
          u.message = "execution reverted (coult not decode custom error)";
        }
    }
    const d = this.parseTransaction(r);
    return d && (u.invocation = {
      method: d.name,
      signature: d.signature,
      args: d.args
    }), u;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(e, r) {
    if (typeof e == "string") {
      const i = this.getFunction(e);
      se(i, "unknown function", "fragment", e), e = i;
    }
    return Ge(R(this, Ba).encode(e.outputs, r || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, r) {
    if (typeof e == "string") {
      const d = this.getEvent(e);
      se(d, "unknown event", "eventFragment", e), e = d;
    }
    Te(r.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", { count: r.length, expectedCount: e.inputs.length });
    const i = [];
    e.anonymous || i.push(e.topicHash);
    const u = (d, g) => d.type === "string" ? vg(g) : d.type === "bytes" ? xn(Ge(g)) : (d.type === "bool" && typeof g == "boolean" ? g = g ? "0x01" : "0x00" : d.type.match(/^u?int/) ? g = Ud(g) : d.type.match(/^bytes/) ? g = vE(g, 32) : d.type === "address" && R(this, Ba).encode(["address"], [g]), eu(Ge(g), 32));
    for (r.forEach((d, g) => {
      const b = e.inputs[g];
      if (!b.indexed) {
        se(d == null, "cannot filter non-indexed parameters; must be null", "contract." + b.name, d);
        return;
      }
      d == null ? i.push(null) : b.baseType === "array" || b.baseType === "tuple" ? se(!1, "filtering with tuples or arrays not supported", "contract." + b.name, d) : Array.isArray(d) ? i.push(d.map((y) => u(b, y))) : i.push(u(b, d));
    }); i.length && i[i.length - 1] === null; )
      i.pop();
    return i;
  }
  encodeEventLog(e, r) {
    if (typeof e == "string") {
      const g = this.getEvent(e);
      se(g, "unknown event", "eventFragment", e), e = g;
    }
    const i = [], u = [], d = [];
    return e.anonymous || i.push(e.topicHash), se(r.length === e.inputs.length, "event arguments/values mismatch", "values", r), e.inputs.forEach((g, b) => {
      const y = r[b];
      if (g.indexed)
        if (g.type === "string")
          i.push(vg(y));
        else if (g.type === "bytes")
          i.push(xn(y));
        else {
          if (g.baseType === "tuple" || g.baseType === "array")
            throw new Error("not implemented");
          i.push(R(this, Ba).encode([g.type], [y]));
        }
      else
        u.push(g), d.push(y);
    }), {
      data: R(this, Ba).encode(u, d),
      topics: i
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, r, i) {
    if (typeof e == "string") {
      const M = this.getEvent(e);
      se(M, "unknown event", "eventFragment", e), e = M;
    }
    if (i != null && !e.anonymous) {
      const M = e.topicHash;
      se(ln(i[0], 32) && i[0].toLowerCase() === M, "fragment/topic mismatch", "topics[0]", i[0]), i = i.slice(1);
    }
    const u = [], d = [], g = [];
    e.inputs.forEach((M, D) => {
      M.indexed ? M.type === "string" || M.type === "bytes" || M.baseType === "tuple" || M.baseType === "array" ? (u.push(Wa.from({ type: "bytes32", name: M.name })), g.push(!0)) : (u.push(M), g.push(!1)) : (d.push(M), g.push(!1));
    });
    const b = i != null ? R(this, Ba).decode(u, vn(i)) : null, y = R(this, Ba).decode(d, r, !0), k = [], S = [];
    let A = 0, x = 0;
    return e.inputs.forEach((M, D) => {
      let O = null;
      if (M.indexed)
        if (b == null)
          O = new h9(null);
        else if (g[D])
          O = new h9(b[x++]);
        else
          try {
            O = b[x++];
          } catch (T) {
            O = T;
          }
      else
        try {
          O = y[A++];
        } catch (T) {
          O = T;
        }
      k.push(O), S.push(M.name || null);
    }), X4.fromItems(k, S);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(e) {
    const r = mt(e.data, "tx.data"), i = Qe(e.value != null ? e.value : 0, "tx.value"), u = this.getFunction(Ge(r.slice(0, 4)));
    if (!u)
      return null;
    const d = R(this, Ba).decode(u.inputs, r.slice(4));
    return new cB(u, u.selector, d, i);
  }
  parseCallResult(e) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(e) {
    const r = this.getEvent(e.topics[0]);
    return !r || r.anonymous ? null : new uB(r, r.topicHash, this.decodeEventLog(r, e.data, e.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(e) {
    const r = Ge(e), i = this.getError(On(r, 0, 4));
    if (!i)
      return null;
    const u = R(this, Ba).decode(i.inputs, On(r, 4));
    return new fB(i, i.selector, u);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(e) {
    return e instanceof uy ? e : typeof e == "string" ? new uy(JSON.parse(e)) : typeof e.formatJson == "function" ? new uy(e.formatJson()) : typeof e.format == "function" ? new uy(e.format("json")) : new uy(e);
  }
};
bc = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakMap(), Ic = /* @__PURE__ */ new WeakMap(), Ba = /* @__PURE__ */ new WeakMap(), Id = /* @__PURE__ */ new WeakSet(), // Find a function definition by any means necessary (unless it is ambiguous)
D4 = function(a, e, r) {
  if (ln(a)) {
    const i = a.toLowerCase();
    for (const u of R(this, Ic).values())
      if (i === u.selector)
        return u;
    return null;
  }
  if (a.indexOf("(") === -1) {
    const i = [];
    for (const [u, d] of R(this, Ic))
      u.split(
        "("
        /* fix:) */
      )[0] === a && i.push(d);
    if (e) {
      const u = e.length > 0 ? e[e.length - 1] : null;
      let d = e.length, g = !0;
      uo.isTyped(u) && u.type === "overrides" && (g = !1, d--);
      for (let b = i.length - 1; b >= 0; b--) {
        const y = i[b].inputs.length;
        y !== d && (!g || y !== d - 1) && i.splice(b, 1);
      }
      for (let b = i.length - 1; b >= 0; b--) {
        const y = i[b].inputs;
        for (let k = 0; k < e.length; k++)
          if (uo.isTyped(e[k])) {
            if (k >= y.length) {
              if (e[k].type === "overrides")
                continue;
              i.splice(b, 1);
              break;
            }
            if (e[k].type !== y[k].baseType) {
              i.splice(b, 1);
              break;
            }
          }
      }
    }
    if (i.length === 1 && e && e.length !== i[0].inputs.length) {
      const u = e[e.length - 1];
      (u == null || Array.isArray(u) || typeof u != "object") && i.splice(0, 1);
    }
    if (i.length === 0)
      return null;
    if (i.length > 1 && r) {
      const u = i.map((d) => JSON.stringify(d.format())).join(", ");
      se(!1, `ambiguous function description (i.e. matches ${u})`, "key", a);
    }
    return i[0];
  }
  return R(this, Ic).get(Xl.from(a).format()) || null;
}, // Find an event definition by any means necessary (unless it is ambiguous)
B4 = function(a, e, r) {
  if (ln(a)) {
    const i = a.toLowerCase();
    for (const u of R(this, Tc).values())
      if (i === u.topicHash)
        return u;
    return null;
  }
  if (a.indexOf("(") === -1) {
    const i = [];
    for (const [u, d] of R(this, Tc))
      u.split(
        "("
        /* fix:) */
      )[0] === a && i.push(d);
    if (e) {
      for (let u = i.length - 1; u >= 0; u--)
        i[u].inputs.length < e.length && i.splice(u, 1);
      for (let u = i.length - 1; u >= 0; u--) {
        const d = i[u].inputs;
        for (let g = 0; g < e.length; g++)
          if (uo.isTyped(e[g]) && e[g].type !== d[g].baseType) {
            i.splice(u, 1);
            break;
          }
      }
    }
    if (i.length === 0)
      return null;
    if (i.length > 1 && r) {
      const u = i.map((d) => JSON.stringify(d.format())).join(", ");
      se(!1, `ambiguous event description (i.e. matches ${u})`, "key", a);
    }
    return i[0];
  }
  return R(this, Tc).get(Jl.from(a).format()) || null;
};
let Dp = dB;
const rT = BigInt(0);
function Oy(a) {
  return a ?? null;
}
function $n(a) {
  return a == null ? null : a.toString();
}
class m9 {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(e, r, i) {
    le(this, "gasPrice"), le(this, "maxFeePerGas"), le(this, "maxPriorityFeePerGas"), Ke(this, {
      gasPrice: Oy(e),
      maxFeePerGas: Oy(r),
      maxPriorityFeePerGas: Oy(i)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: e, maxFeePerGas: r, maxPriorityFeePerGas: i } = this;
    return {
      _type: "FeeData",
      gasPrice: $n(e),
      maxFeePerGas: $n(r),
      maxPriorityFeePerGas: $n(i)
    };
  }
}
function Sk(a) {
  const e = {};
  a.to && (e.to = a.to), a.from && (e.from = a.from), a.data && (e.data = Ge(a.data));
  const r = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const u of r)
    !(u in a) || a[u] == null || (e[u] = Qe(a[u], `request.${u}`));
  const i = "type,nonce".split(/,/);
  for (const u of i)
    !(u in a) || a[u] == null || (e[u] = yt(a[u], `request.${u}`));
  return a.accessList && (e.accessList = Pg(a.accessList)), "blockTag" in a && (e.blockTag = a.blockTag), "enableCcipRead" in a && (e.enableCcipRead = !!a.enableCcipRead), "customData" in a && (e.customData = a.customData), "blobVersionedHashes" in a && a.blobVersionedHashes && (e.blobVersionedHashes = a.blobVersionedHashes.slice()), "kzg" in a && (e.kzg = a.kzg), "blobs" in a && a.blobs && (e.blobs = a.blobs.map((u) => bE(u) ? Ge(u) : Object.assign({}, u))), e;
}
var Nd;
class hB {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(e, r) {
    le(this, "provider"), le(this, "number"), le(this, "hash"), le(this, "timestamp"), le(this, "parentHash"), le(this, "parentBeaconBlockRoot"), le(this, "nonce"), le(this, "difficulty"), le(this, "gasLimit"), le(this, "gasUsed"), le(this, "stateRoot"), le(this, "receiptsRoot"), le(this, "blobGasUsed"), le(this, "excessBlobGas"), le(this, "miner"), le(this, "prevRandao"), le(this, "extraData"), le(this, "baseFeePerGas"), ye(this, Nd), Q(this, Nd, e.transactions.map((i) => typeof i != "string" ? new ME(i, r) : i)), Ke(this, {
      provider: r,
      hash: Oy(e.hash),
      number: e.number,
      timestamp: e.timestamp,
      parentHash: e.parentHash,
      parentBeaconBlockRoot: e.parentBeaconBlockRoot,
      nonce: e.nonce,
      difficulty: e.difficulty,
      gasLimit: e.gasLimit,
      gasUsed: e.gasUsed,
      blobGasUsed: e.blobGasUsed,
      excessBlobGas: e.excessBlobGas,
      miner: e.miner,
      prevRandao: Oy(e.prevRandao),
      extraData: e.extraData,
      baseFeePerGas: Oy(e.baseFeePerGas),
      stateRoot: e.stateRoot,
      receiptsRoot: e.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return R(this, Nd).map((e) => typeof e == "string" ? e : e.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const e = R(this, Nd).slice();
    return e.length === 0 ? [] : (Te(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), e);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: e, difficulty: r, extraData: i, gasLimit: u, gasUsed: d, hash: g, miner: b, prevRandao: y, nonce: k, number: S, parentHash: A, parentBeaconBlockRoot: x, stateRoot: M, receiptsRoot: D, timestamp: O, transactions: T } = this;
    return {
      _type: "Block",
      baseFeePerGas: $n(e),
      difficulty: $n(r),
      extraData: i,
      gasLimit: $n(u),
      gasUsed: $n(d),
      blobGasUsed: $n(this.blobGasUsed),
      excessBlobGas: $n(this.excessBlobGas),
      hash: g,
      miner: b,
      prevRandao: y,
      nonce: k,
      number: S,
      parentHash: A,
      timestamp: O,
      parentBeaconBlockRoot: x,
      stateRoot: M,
      receiptsRoot: D,
      transactions: T
    };
  }
  [Symbol.iterator]() {
    let e = 0;
    const r = this.transactions;
    return {
      next: () => e < this.length ? {
        value: r[e++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return R(this, Nd).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(e) {
    let r;
    if (typeof e == "number")
      r = R(this, Nd)[e];
    else {
      const i = e.toLowerCase();
      for (const u of R(this, Nd))
        if (typeof u == "string") {
          if (u !== i)
            continue;
          r = u;
          break;
        } else {
          if (u.hash !== i)
            continue;
          r = u;
          break;
        }
    }
    if (r == null)
      throw new Error("no such tx");
    return typeof r == "string" ? await this.provider.getTransaction(r) : r;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(e) {
    const r = this.prefetchedTransactions;
    if (typeof e == "number")
      return r[e];
    e = e.toLowerCase();
    for (const i of r)
      if (i.hash === e)
        return i;
    se(!1, "no matching transaction", "indexOrHash", e);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return gB(this);
  }
}
Nd = /* @__PURE__ */ new WeakMap();
class aw {
  /**
   *  @_ignore:
   */
  constructor(e, r) {
    le(this, "provider"), le(this, "transactionHash"), le(this, "blockHash"), le(this, "blockNumber"), le(this, "removed"), le(this, "address"), le(this, "data"), le(this, "topics"), le(this, "index"), le(this, "transactionIndex"), this.provider = r;
    const i = Object.freeze(e.topics.slice());
    Ke(this, {
      transactionHash: e.transactionHash,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      removed: e.removed,
      address: e.address,
      data: e.data,
      topics: i,
      index: e.index,
      transactionIndex: e.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: e, blockHash: r, blockNumber: i, data: u, index: d, removed: g, topics: b, transactionHash: y, transactionIndex: k } = this;
    return {
      _type: "log",
      address: e,
      blockHash: r,
      blockNumber: i,
      data: u,
      index: d,
      removed: g,
      topics: b,
      transactionHash: y,
      transactionIndex: k
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    return Te(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.transactionHash);
    return Te(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const e = await this.provider.getTransactionReceipt(this.transactionHash);
    return Te(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return mB(this);
  }
}
var M4;
class aT {
  /**
   *  @_ignore:
   */
  constructor(e, r) {
    le(this, "provider"), le(this, "to"), le(this, "from"), le(this, "contractAddress"), le(this, "hash"), le(this, "index"), le(this, "blockHash"), le(this, "blockNumber"), le(this, "logsBloom"), le(this, "gasUsed"), le(this, "blobGasUsed"), le(this, "cumulativeGasUsed"), le(this, "gasPrice"), le(this, "blobGasPrice"), le(this, "type"), le(this, "status"), le(this, "root"), ye(this, M4), Q(this, M4, Object.freeze(e.logs.map((u) => new aw(u, r))));
    let i = rT;
    e.effectiveGasPrice != null ? i = e.effectiveGasPrice : e.gasPrice != null && (i = e.gasPrice), Ke(this, {
      provider: r,
      to: e.to,
      from: e.from,
      contractAddress: e.contractAddress,
      hash: e.hash,
      index: e.index,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      logsBloom: e.logsBloom,
      gasUsed: e.gasUsed,
      cumulativeGasUsed: e.cumulativeGasUsed,
      blobGasUsed: e.blobGasUsed,
      gasPrice: i,
      blobGasPrice: e.blobGasPrice,
      type: e.type,
      //byzantium: tx.byzantium,
      status: e.status,
      root: e.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return R(this, M4);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: e,
      from: r,
      contractAddress: i,
      hash: u,
      index: d,
      blockHash: g,
      blockNumber: b,
      logsBloom: y,
      logs: k,
      //byzantium, 
      status: S,
      root: A
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: g,
      blockNumber: b,
      //byzantium, 
      contractAddress: i,
      cumulativeGasUsed: $n(this.cumulativeGasUsed),
      from: r,
      gasPrice: $n(this.gasPrice),
      blobGasUsed: $n(this.blobGasUsed),
      blobGasPrice: $n(this.blobGasPrice),
      gasUsed: $n(this.gasUsed),
      hash: u,
      index: d,
      logs: k,
      logsBloom: y,
      root: A,
      status: S,
      to: e
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.length ? { value: this.logs[e++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.hash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return sT(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(e) {
    return Te(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), iT(this, e);
  }
}
M4 = /* @__PURE__ */ new WeakMap();
var Bp;
const pB = class oT {
  /**
   *  @_ignore:
   */
  constructor(e, r) {
    le(this, "provider"), le(this, "blockNumber"), le(this, "blockHash"), le(this, "index"), le(this, "hash"), le(this, "type"), le(this, "to"), le(this, "from"), le(this, "nonce"), le(this, "gasLimit"), le(this, "gasPrice"), le(this, "maxPriorityFeePerGas"), le(this, "maxFeePerGas"), le(this, "maxFeePerBlobGas"), le(this, "data"), le(this, "value"), le(this, "chainId"), le(this, "signature"), le(this, "accessList"), le(this, "blobVersionedHashes"), ye(this, Bp), this.provider = r, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null, Q(this, Bp, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: e, blockHash: r, index: i, hash: u, type: d, to: g, from: b, nonce: y, data: k, signature: S, accessList: A, blobVersionedHashes: x } = this;
    return {
      _type: "TransactionResponse",
      accessList: A,
      blockNumber: e,
      blockHash: r,
      blobVersionedHashes: x,
      chainId: $n(this.chainId),
      data: k,
      from: b,
      gasLimit: $n(this.gasLimit),
      gasPrice: $n(this.gasPrice),
      hash: u,
      maxFeePerGas: $n(this.maxFeePerGas),
      maxPriorityFeePerGas: $n(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: $n(this.maxFeePerBlobGas),
      nonce: y,
      signature: S,
      to: g,
      index: i,
      type: d,
      value: $n(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let e = this.blockNumber;
    if (e == null) {
      const i = await this.getTransaction();
      i && (e = i.blockNumber);
    }
    if (e == null)
      return null;
    const r = this.provider.getBlock(e);
    if (r == null)
      throw new Error("TODO");
    return r;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: e, blockNumber: r } = await _a({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return e == null || e.blockNumber == null ? 0 : r - e.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, r) {
    const i = e ?? 1, u = r ?? 0;
    let d = R(this, Bp), g = -1, b = d === -1;
    const y = async () => {
      if (b)
        return null;
      const { blockNumber: A, nonce: x } = await _a({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (x < this.nonce) {
        d = A;
        return;
      }
      if (b)
        return null;
      const M = await this.getTransaction();
      if (!(M && M.blockNumber != null))
        for (g === -1 && (g = d - 3, g < R(this, Bp) && (g = R(this, Bp))); g <= A; ) {
          if (b)
            return null;
          const D = await this.provider.getBlock(g, !0);
          if (D == null)
            return;
          for (const O of D)
            if (O === this.hash)
              return;
          for (let O = 0; O < D.length; O++) {
            const T = await D.getTransaction(O);
            if (T.from === this.from && T.nonce === this.nonce) {
              if (b)
                return null;
              const L = await this.provider.getTransactionReceipt(T.hash);
              if (L == null || A - L.blockNumber + 1 < i)
                return;
              let U = "replaced";
              T.data === this.data && T.to === this.to && T.value === this.value ? U = "repriced" : T.data === "0x" && T.from === T.to && T.value === rT && (U = "cancelled"), Te(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: U === "replaced" || U === "cancelled",
                reason: U,
                replacement: T.replaceableTransaction(d),
                hash: T.hash,
                receipt: L
              });
            }
          }
          g++;
        }
    }, k = (A) => {
      if (A == null || A.status !== 0)
        return A;
      Te(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: A.to,
          from: A.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: A
      });
    }, S = await this.provider.getTransactionReceipt(this.hash);
    if (i === 0)
      return k(S);
    if (S) {
      if (await S.confirmations() >= i)
        return k(S);
    } else if (await y(), i === 0)
      return null;
    return await new Promise((A, x) => {
      const M = [], D = () => {
        M.forEach((T) => T());
      };
      if (M.push(() => {
        b = !0;
      }), u > 0) {
        const T = setTimeout(() => {
          D(), x(Pn("wait for transaction timeout", "TIMEOUT"));
        }, u);
        M.push(() => {
          clearTimeout(T);
        });
      }
      const O = async (T) => {
        if (await T.confirmations() >= i) {
          D();
          try {
            A(k(T));
          } catch (L) {
            x(L);
          }
        }
      };
      if (M.push(() => {
        this.provider.off(this.hash, O);
      }), this.provider.on(this.hash, O), d >= 0) {
        const T = async () => {
          try {
            await y();
          } catch (L) {
            if (qr(L, "TRANSACTION_REPLACED")) {
              D(), x(L);
              return;
            }
          }
          b || this.provider.once("block", T);
        };
        M.push(() => {
          this.provider.off("block", T);
        }), this.provider.once("block", T);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return Te(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), sT(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(e) {
    return Te(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), Te(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), iT(this, e);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(e) {
    se(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
    const r = new oT(this, this.provider);
    return Q(r, Bp, e), r;
  }
};
Bp = /* @__PURE__ */ new WeakMap();
let ME = pB;
function gB(a) {
  return { orphan: "drop-block", hash: a.hash, number: a.number };
}
function iT(a, e) {
  return { orphan: "reorder-transaction", tx: a, other: e };
}
function sT(a) {
  return { orphan: "drop-transaction", tx: a };
}
function mB(a) {
  return { orphan: "drop-log", log: {
    transactionHash: a.transactionHash,
    blockHash: a.blockHash,
    blockNumber: a.blockNumber,
    address: a.address,
    data: a.data,
    topics: Object.freeze(a.topics.slice()),
    index: a.index
  } };
}
class FE extends aw {
  /**
   * @_ignore:
   */
  constructor(e, r, i) {
    super(e, e.provider), le(this, "interface"), le(this, "fragment"), le(this, "args");
    const u = r.decodeEventLog(i, e.data, e.topics);
    Ke(this, { args: u, fragment: i, interface: r });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class lT extends aw {
  /**
   * @_ignore:
   */
  constructor(e, r) {
    super(e, e.provider), le(this, "error"), Ke(this, { error: r });
  }
}
var gv;
class yB extends aT {
  /**
   *  @_ignore:
   */
  constructor(e, r, i) {
    super(i, r), ye(this, gv), Q(this, gv, e);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((e) => {
      const r = e.topics.length ? R(this, gv).getEvent(e.topics[0]) : null;
      if (r)
        try {
          return new FE(e, R(this, gv), r);
        } catch (i) {
          return new lT(e, i);
        }
      return e;
    });
  }
}
gv = /* @__PURE__ */ new WeakMap();
var F4;
class _E extends ME {
  /**
   *  @_ignore:
   */
  constructor(e, r, i) {
    super(i, r), ye(this, F4), Q(this, F4, e);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, r) {
    const i = await super.wait(e, r);
    return i == null ? null : new yB(R(this, F4), this.provider, i);
  }
}
F4 = /* @__PURE__ */ new WeakMap();
class uT extends Cx {
  /**
   *  @_event:
   */
  constructor(e, r, i, u) {
    super(e, r, i), le(this, "log"), Ke(this, { log: u });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class bB extends uT {
  /**
   *  @_ignore:
   */
  constructor(e, r, i, u, d) {
    super(e, r, i, new FE(d, e.interface, u));
    const g = e.interface.decodeEventLog(u, this.log.data, this.log.topics);
    Ke(this, { args: g, fragment: u });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const y9 = BigInt(0);
function cT(a) {
  return a && typeof a.call == "function";
}
function fT(a) {
  return a && typeof a.estimateGas == "function";
}
function Ak(a) {
  return a && typeof a.resolveName == "function";
}
function dT(a) {
  return a && typeof a.sendTransaction == "function";
}
function hT(a) {
  if (a != null) {
    if (Ak(a))
      return a;
    if (a.provider)
      return a.provider;
  }
}
var _4;
class vB {
  constructor(e, r, i) {
    if (ye(this, _4), le(this, "fragment"), Ke(this, { fragment: r }), r.inputs.length < i.length)
      throw new Error("too many arguments");
    const u = Eg(e.runner, "resolveName"), d = Ak(u) ? u : null;
    Q(this, _4, async function() {
      const g = await Promise.all(r.inputs.map((b, y) => i[y] == null ? null : b.walkAsync(i[y], (k, S) => k === "address" ? Array.isArray(S) ? Promise.all(S.map((A) => Ha(A, d))) : Ha(S, d) : S)));
      return e.interface.encodeFilterTopics(r, g);
    }());
  }
  getTopicFilter() {
    return R(this, _4);
  }
}
_4 = /* @__PURE__ */ new WeakMap();
function Eg(a, e) {
  return a == null ? null : typeof a[e] == "function" ? a : a.provider && typeof a.provider[e] == "function" ? a.provider : null;
}
function og(a) {
  return a == null ? null : a.provider || null;
}
async function pT(a, e) {
  const r = uo.dereference(a, "overrides");
  se(typeof r == "object", "invalid overrides parameter", "overrides", a);
  const i = Sk(r);
  return se(i.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", i.to), se(i.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", i.data), i.from && (i.from = i.from), i;
}
async function wB(a, e, r) {
  const i = Eg(a, "resolveName"), u = Ak(i) ? i : null;
  return await Promise.all(e.map((d, g) => d.walkAsync(r[g], (b, y) => (y = uo.dereference(y, b), b === "address" ? Ha(y, u) : y))));
}
function kB(a) {
  const e = async function(g) {
    const b = await pT(g, ["data"]);
    b.to = await a.getAddress(), b.from && (b.from = await Ha(b.from, hT(a.runner)));
    const y = a.interface, k = Qe(b.value || y9, "overrides.value") === y9, S = (b.data || "0x") === "0x";
    y.fallback && !y.fallback.payable && y.receive && !S && !k && se(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", g), se(y.fallback || S, "cannot send data to receive-only contract", "overrides.data", b.data);
    const A = y.receive || y.fallback && y.fallback.payable;
    return se(A || k, "cannot send value to non-payable fallback", "overrides.value", b.value), se(y.fallback || S, "cannot send data to receive-only contract", "overrides.data", b.data), b;
  }, r = async function(g) {
    const b = Eg(a.runner, "call");
    Te(cT(b), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const y = await e(g);
    try {
      return await b.call(y);
    } catch (k) {
      throw yE(k) && k.data ? a.interface.makeError(k.data, y) : k;
    }
  }, i = async function(g) {
    const b = a.runner;
    Te(dT(b), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const y = await b.sendTransaction(await e(g)), k = og(a.runner);
    return new _E(a.interface, k, y);
  }, u = async function(g) {
    const b = Eg(a.runner, "estimateGas");
    return Te(fT(b), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await b.estimateGas(await e(g));
  }, d = async (g) => await i(g);
  return Ke(d, {
    _contract: a,
    estimateGas: u,
    populateTransaction: e,
    send: i,
    staticCall: r
  }), d;
}
function EB(a, e) {
  const r = function(...k) {
    const S = a.interface.getFunction(e, k);
    return Te(S, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: k }
    }), S;
  }, i = async function(...k) {
    const S = r(...k);
    let A = {};
    if (S.inputs.length + 1 === k.length && (A = await pT(k.pop()), A.from && (A.from = await Ha(A.from, hT(a.runner)))), S.inputs.length !== k.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const x = await wB(a.runner, S.inputs, k);
    return Object.assign({}, A, await _a({
      to: a.getAddress(),
      data: a.interface.encodeFunctionData(S, x)
    }));
  }, u = async function(...k) {
    const S = await b(...k);
    return S.length === 1 ? S[0] : S;
  }, d = async function(...k) {
    const S = a.runner;
    Te(dT(S), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const A = await S.sendTransaction(await i(...k)), x = og(a.runner);
    return new _E(a.interface, x, A);
  }, g = async function(...k) {
    const S = Eg(a.runner, "estimateGas");
    return Te(fT(S), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await S.estimateGas(await i(...k));
  }, b = async function(...k) {
    const S = Eg(a.runner, "call");
    Te(cT(S), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const A = await i(...k);
    let x = "0x";
    try {
      x = await S.call(A);
    } catch (D) {
      throw yE(D) && D.data ? a.interface.makeError(D.data, A) : D;
    }
    const M = r(...k);
    return a.interface.decodeFunctionResult(M, x);
  }, y = async (...k) => r(...k).constant ? await u(...k) : await d(...k);
  return Ke(y, {
    name: a.interface.getFunctionName(e),
    _contract: a,
    _key: e,
    getFragment: r,
    estimateGas: g,
    populateTransaction: i,
    send: d,
    staticCall: u,
    staticCallResult: b
  }), Object.defineProperty(y, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const k = a.interface.getFunction(e);
      return Te(k, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), k;
    }
  }), y;
}
function SB(a, e) {
  const r = function(...u) {
    const d = a.interface.getEvent(e, u);
    return Te(d, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: u }
    }), d;
  }, i = function(...u) {
    return new vB(a, r(...u), u);
  };
  return Ke(i, {
    name: a.interface.getEventName(e),
    _contract: a,
    _key: e,
    getFragment: r
  }), Object.defineProperty(i, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const u = a.interface.getEvent(e);
      return Te(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), u;
    }
  }), i;
}
const xk = Symbol.for("_ethersInternal_contract"), gT = /* @__PURE__ */ new WeakMap();
function AB(a, e) {
  gT.set(a[xk], e);
}
function Bo(a) {
  return gT.get(a[xk]);
}
function xB(a) {
  return a && typeof a == "object" && "getTopicFilter" in a && typeof a.getTopicFilter == "function" && a.fragment;
}
async function UE(a, e) {
  let r, i = null;
  if (Array.isArray(e)) {
    const d = function(g) {
      if (ln(g, 32))
        return g;
      const b = a.interface.getEvent(g);
      return se(b, "unknown fragment", "name", g), b.topicHash;
    };
    r = e.map((g) => g == null ? null : Array.isArray(g) ? g.map(d) : d(g));
  } else e === "*" ? r = [null] : typeof e == "string" ? ln(e, 32) ? r = [e] : (i = a.interface.getEvent(e), se(i, "unknown fragment", "event", e), r = [i.topicHash]) : xB(e) ? r = await e.getTopicFilter() : "fragment" in e ? (i = e.fragment, r = [i.topicHash]) : se(!1, "unknown event name", "event", e);
  r = r.map((d) => {
    if (d == null)
      return null;
    if (Array.isArray(d)) {
      const g = Array.from(new Set(d.map((b) => b.toLowerCase())).values());
      return g.length === 1 ? g[0] : (g.sort(), g);
    }
    return d.toLowerCase();
  });
  const u = r.map((d) => d == null ? "null" : Array.isArray(d) ? d.join("|") : d).join("&");
  return { fragment: i, tag: u, topics: r };
}
async function mv(a, e) {
  const { subs: r } = Bo(a);
  return r.get((await UE(a, e)).tag) || null;
}
async function b9(a, e, r) {
  const i = og(a.runner);
  Te(i, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: e });
  const { fragment: u, tag: d, topics: g } = await UE(a, r), { addr: b, subs: y } = Bo(a);
  let k = y.get(d);
  if (!k) {
    const S = { address: b || a, topics: g }, A = (M) => {
      let D = u;
      if (D == null)
        try {
          D = a.interface.getEvent(M.topics[0]);
        } catch {
        }
      if (D) {
        const O = D, T = u ? a.interface.decodeEventLog(u, M.data, M.topics) : [];
        R5(a, r, T, (L) => new bB(a, L, r, O, M));
      } else
        R5(a, r, [], (O) => new uT(a, O, r, M));
    };
    let x = [];
    k = { tag: d, listeners: [], start: () => {
      x.length || x.push(i.on(S, A));
    }, stop: async () => {
      if (x.length == 0)
        return;
      let M = x;
      x = [], await Promise.all(M), i.off(S, A);
    } }, y.set(d, k);
  }
  return k;
}
let O5 = Promise.resolve();
async function CB(a, e, r, i) {
  await O5;
  const u = await mv(a, e);
  if (!u)
    return !1;
  const d = u.listeners.length;
  return u.listeners = u.listeners.filter(({ listener: g, once: b }) => {
    const y = Array.from(r);
    i && y.push(i(b ? null : g));
    try {
      g.call(a, ...y);
    } catch {
    }
    return !b;
  }), u.listeners.length === 0 && (u.stop(), Bo(a).subs.delete(u.tag)), d > 0;
}
async function R5(a, e, r, i) {
  try {
    await O5;
  } catch {
  }
  const u = CB(a, e, r, i);
  return O5 = u, await u;
}
const p4 = ["then"];
var mT;
mT = xk;
const TB = class U4 {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(e, r, i, u) {
    le(this, "target"), le(this, "interface"), le(this, "runner"), le(this, "filters"), le(this, mT), le(this, "fallback"), se(typeof e == "string" || mC(e), "invalid value for Contract target", "target", e), i == null && (i = null);
    const d = Dp.from(r);
    Ke(this, { target: e, runner: i, interface: d }), Object.defineProperty(this, xk, { value: {} });
    let g, b = null, y = null;
    if (u) {
      const A = og(i);
      y = new _E(this.interface, A, u);
    }
    let k = /* @__PURE__ */ new Map();
    if (typeof e == "string")
      if (ln(e))
        b = e, g = Promise.resolve(e);
      else {
        const A = Eg(i, "resolveName");
        if (!Ak(A))
          throw Pn("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        g = A.resolveName(e).then((x) => {
          if (x == null)
            throw Pn("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: e
            });
          return Bo(this).addr = x, x;
        });
      }
    else
      g = e.getAddress().then((A) => {
        if (A == null)
          throw new Error("TODO");
        return Bo(this).addr = A, A;
      });
    AB(this, { addrPromise: g, addr: b, deployTx: y, subs: k });
    const S = new Proxy({}, {
      get: (A, x, M) => {
        if (typeof x == "symbol" || p4.indexOf(x) >= 0)
          return Reflect.get(A, x, M);
        try {
          return this.getEvent(x);
        } catch (D) {
          if (!qr(D, "INVALID_ARGUMENT") || D.argument !== "key")
            throw D;
        }
      },
      has: (A, x) => p4.indexOf(x) >= 0 ? Reflect.has(A, x) : Reflect.has(A, x) || this.interface.hasEvent(String(x))
    });
    return Ke(this, { filters: S }), Ke(this, {
      fallback: d.receive || d.fallback ? kB(this) : null
    }), new Proxy(this, {
      get: (A, x, M) => {
        if (typeof x == "symbol" || x in A || p4.indexOf(x) >= 0)
          return Reflect.get(A, x, M);
        try {
          return A.getFunction(x);
        } catch (D) {
          if (!qr(D, "INVALID_ARGUMENT") || D.argument !== "key")
            throw D;
        }
      },
      has: (A, x) => typeof x == "symbol" || x in A || p4.indexOf(x) >= 0 ? Reflect.has(A, x) : A.interface.hasFunction(x)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(e) {
    return new U4(this.target, this.interface, e);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(e) {
    return new U4(e, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await Bo(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const e = og(this.runner);
    Te(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const r = await e.getCode(await this.getAddress());
    return r === "0x" ? null : r;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const e = this.deploymentTransaction();
    if (e)
      return await e.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const r = og(this.runner);
    return Te(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((i, u) => {
      const d = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return i(this);
          r.once("block", d);
        } catch (g) {
          u(g);
        }
      };
      d();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return Bo(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(e) {
    return typeof e != "string" && (e = e.format()), EB(this, e);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(e) {
    return typeof e != "string" && (e = e.format()), SB(this, e);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(e) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(e, r, i) {
    r == null && (r = 0), i == null && (i = "latest");
    const { addr: u, addrPromise: d } = Bo(this), g = u || await d, { fragment: b, topics: y } = await UE(this, e), k = { address: g, topics: y, fromBlock: r, toBlock: i }, S = og(this.runner);
    return Te(S, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await S.getLogs(k)).map((A) => {
      let x = b;
      if (x == null)
        try {
          x = this.interface.getEvent(A.topics[0]);
        } catch {
        }
      if (x)
        try {
          return new FE(A, this.interface, x);
        } catch (M) {
          return new lT(A, M);
        }
      return new aw(A, S);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(e, r) {
    const i = await b9(this, "on", e);
    return i.listeners.push({ listener: r, once: !1 }), i.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(e, r) {
    const i = await b9(this, "once", e);
    return i.listeners.push({ listener: r, once: !0 }), i.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(e, ...r) {
    return await R5(this, e, r, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(e) {
    if (e) {
      const u = await mv(this, e);
      return u ? u.listeners.length : 0;
    }
    const { subs: r } = Bo(this);
    let i = 0;
    for (const { listeners: u } of r.values())
      i += u.length;
    return i;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(e) {
    if (e) {
      const u = await mv(this, e);
      return u ? u.listeners.map(({ listener: d }) => d) : [];
    }
    const { subs: r } = Bo(this);
    let i = [];
    for (const { listeners: u } of r.values())
      i = i.concat(u.map(({ listener: d }) => d));
    return i;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(e, r) {
    const i = await mv(this, e);
    if (!i)
      return this;
    if (r) {
      const u = i.listeners.map(({ listener: d }) => d).indexOf(r);
      u >= 0 && i.listeners.splice(u, 1);
    }
    return (r == null || i.listeners.length === 0) && (i.stop(), Bo(this).subs.delete(i.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(e) {
    if (e) {
      const r = await mv(this, e);
      if (!r)
        return this;
      r.stop(), Bo(this).subs.delete(r.tag);
    } else {
      const { subs: r } = Bo(this);
      for (const { tag: i, stop: u } of r.values())
        u(), r.delete(i);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(e, r) {
    return await this.on(e, r);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(e, r) {
    return await this.off(e, r);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(e) {
    class r extends U4 {
      constructor(u, d = null) {
        super(u, e, d);
      }
    }
    return r;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(e, r, i) {
    return i == null && (i = null), new this(e, r, i);
  }
};
let IB = TB;
function NB() {
  return IB;
}
class Sg extends NB() {
}
function O8(a) {
  return a.match(/^ipfs:\/\/ipfs\//i) ? a = a.substring(12) : a.match(/^ipfs:\/\//i) ? a = a.substring(7) : se(!1, "unsupported IPFS format", "link", a), `https://gateway.ipfs.io/ipfs/${a}`;
}
class PB {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(e) {
    le(this, "name"), Ke(this, { name: e });
  }
  connect(e) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(e) {
    return !1;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(e, r) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(e, r) {
    throw new Error("unsupported coin");
  }
}
const yT = new RegExp("^(ipfs)://(.*)$", "i"), v9 = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  yT,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var Mp, Ry, Fp, cy, L5, bT;
const D5 = class B5 {
  constructor(e, r, i) {
    ye(this, Fp), le(this, "provider"), le(this, "address"), le(this, "name"), ye(this, Mp), ye(this, Ry), Ke(this, { provider: e, address: r, name: i }), Q(this, Mp, null), Q(this, Ry, new Sg(r, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], e));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return R(this, Mp) == null && Q(this, Mp, (async () => {
      try {
        return await R(this, Ry).supportsInterface("0x9061b923");
      } catch (e) {
        if (qr(e, "CALL_EXCEPTION"))
          return !1;
        throw Q(this, Mp, null), e;
      }
    })()), await R(this, Mp);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(e) {
    if (e == null && (e = 60), e === 60)
      try {
        const d = await Oe(this, Fp, cy).call(this, "addr(bytes32)");
        return d == null || d === n1 ? null : d;
      } catch (d) {
        if (qr(d, "CALL_EXCEPTION"))
          return null;
        throw d;
      }
    if (e >= 0 && e < 2147483648) {
      let d = e + 2147483648;
      const g = await Oe(this, Fp, cy).call(this, "addr(bytes32,uint)", [d]);
      if (ln(g, 20))
        return Wt(g);
    }
    let r = null;
    for (const d of this.provider.plugins)
      if (d instanceof PB && d.supportsCoinType(e)) {
        r = d;
        break;
      }
    if (r == null)
      return null;
    const i = await Oe(this, Fp, cy).call(this, "addr(bytes32,uint)", [e]);
    if (i == null || i === "0x")
      return null;
    const u = await r.decodeAddress(e, i);
    if (u != null)
      return u;
    Te(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${e})`,
      info: { coinType: e, data: i }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(e) {
    const r = await Oe(this, Fp, cy).call(this, "text(bytes32,string)", [e]);
    return r == null || r === "0x" ? null : r;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const e = await Oe(this, Fp, cy).call(this, "contenthash(bytes32)");
    if (e == null || e === "0x")
      return null;
    const r = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (r) {
      const u = r[1] === "e3010170" ? "ipfs" : "ipns", d = parseInt(r[4], 16);
      if (r[5].length === d * 2)
        return `${u}://${gO("0x" + r[2])}`;
    }
    const i = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (i && i[1].length === 64)
      return `bzz://${i[1]}`;
    Te(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: e }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const e = [{ type: "name", value: this.name }];
    try {
      const r = await this.getText("avatar");
      if (r == null)
        return e.push({ type: "!avatar", value: "" }), { url: null, linkage: e };
      e.push({ type: "avatar", value: r });
      for (let i = 0; i < v9.length; i++) {
        const u = r.match(v9[i]);
        if (u == null)
          continue;
        const d = u[1].toLowerCase();
        switch (d) {
          case "https":
          case "data":
            return e.push({ type: "url", value: r }), { linkage: e, url: r };
          case "ipfs": {
            const g = O8(r);
            return e.push({ type: "ipfs", value: r }), e.push({ type: "url", value: g }), { linkage: e, url: g };
          }
          case "erc721":
          case "erc1155": {
            const g = d === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            e.push({ type: d, value: r });
            const b = await this.getAddress();
            if (b == null)
              return e.push({ type: "!owner", value: "" }), { url: null, linkage: e };
            const y = (u[2] || "").split("/");
            if (y.length !== 2)
              return e.push({ type: `!${d}caip`, value: u[2] || "" }), { url: null, linkage: e };
            const k = y[1], S = new Sg(y[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (d === "erc721") {
              const O = await S.ownerOf(k);
              if (b !== O)
                return e.push({ type: "!owner", value: O }), { url: null, linkage: e };
              e.push({ type: "owner", value: O });
            } else if (d === "erc1155") {
              const O = await S.balanceOf(b, k);
              if (!O)
                return e.push({ type: "!balance", value: "0" }), { url: null, linkage: e };
              e.push({ type: "balance", value: O.toString() });
            }
            let A = await S[g](k);
            if (A == null || A === "0x")
              return e.push({ type: "!metadata-url", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata-url-base", value: A }), d === "erc1155" && (A = A.replace("{id}", Ud(k, 32).substring(2)), e.push({ type: "metadata-url-expanded", value: A })), A.match(/^ipfs:/i) && (A = O8(A)), e.push({ type: "metadata-url", value: A });
            let x = {};
            const M = await new Mc(A).send();
            M.assertOk();
            try {
              x = M.bodyJson;
            } catch {
              try {
                e.push({ type: "!metadata", value: M.bodyText });
              } catch {
                const O = M.body;
                return O && e.push({ type: "!metadata", value: Ge(O) }), { url: null, linkage: e };
              }
              return { url: null, linkage: e };
            }
            if (!x)
              return e.push({ type: "!metadata", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata", value: JSON.stringify(x) });
            let D = x.image;
            if (typeof D != "string")
              return e.push({ type: "!imageUrl", value: "" }), { url: null, linkage: e };
            if (!D.match(/^(https:\/\/|data:)/i)) {
              if (D.match(yT) == null)
                return e.push({ type: "!imageUrl-ipfs", value: D }), { url: null, linkage: e };
              e.push({ type: "imageUrl-ipfs", value: D }), D = O8(D);
            }
            return e.push({ type: "url", value: D }), { linkage: e, url: D };
          }
        }
      }
    } catch {
    }
    return { linkage: e, url: null };
  }
  static async getEnsAddress(e) {
    const r = await e.getNetwork(), i = r.getPlugin("org.ethers.plugins.network.Ens");
    return Te(i, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: r }
    }), i.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(e, r) {
    var i;
    let u = r;
    for (; ; ) {
      if (u === "" || u === "." || r !== "eth" && u === "eth")
        return null;
      const d = await Oe(i = B5, L5, bT).call(i, e, u);
      if (d != null) {
        const g = new B5(e, d, r);
        return u !== r && !await g.supportsWildcard() ? null : g;
      }
      u = u.split(".").slice(1).join(".");
    }
  }
};
Mp = /* @__PURE__ */ new WeakMap(), Ry = /* @__PURE__ */ new WeakMap(), Fp = /* @__PURE__ */ new WeakSet(), cy = async function(a, e) {
  e = (e || []).slice();
  const r = R(this, Ry).interface;
  e.unshift(C5(this.name));
  let i = null;
  await this.supportsWildcard() && (i = r.getFunction(a), Te(i, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: a }
  }), e = [
    mD(this.name, 255),
    r.encodeFunctionData(i, e)
  ], a = "resolve(bytes,bytes)"), e.push({
    enableCcipRead: !0
  });
  try {
    const u = await R(this, Ry)[a](...e);
    return i ? r.decodeFunctionResult(i, u)[0] : u;
  } catch (u) {
    if (!qr(u, "CALL_EXCEPTION"))
      throw u;
  }
  return null;
}, L5 = /* @__PURE__ */ new WeakSet(), bT = async function(a, e) {
  const r = await D5.getEnsAddress(a);
  try {
    const i = await new Sg(r, [
      "function resolver(bytes32) view returns (address)"
    ], a).resolver(C5(e), {
      enableCcipRead: !0
    });
    return i === n1 ? null : i;
  } catch (i) {
    throw i;
  }
  return null;
}, ye(D5, L5);
let w9 = D5;
const k9 = BigInt(0);
function Ot(a, e) {
  return function(r) {
    return r == null ? e : a(r);
  };
}
function Ck(a, e) {
  return (r) => {
    if (e && r == null)
      return null;
    if (!Array.isArray(r))
      throw new Error("not an array");
    return r.map((i) => a(i));
  };
}
function ow(a, e) {
  return (r) => {
    const i = {};
    for (const u in a) {
      let d = u;
      if (e && u in e && !(d in r)) {
        for (const g of e[u])
          if (g in r) {
            d = g;
            break;
          }
      }
      try {
        const g = a[u](r[d]);
        g !== void 0 && (i[u] = g);
      } catch (g) {
        const b = g instanceof Error ? g.message : "not-an-error";
        Te(!1, `invalid value for value.${u} (${b})`, "BAD_DATA", { value: r });
      }
    }
    return i;
  };
}
function OB(a) {
  switch (a) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  se(!1, `invalid boolean; ${JSON.stringify(a)}`, "value", a);
}
function Wy(a) {
  return se(ln(a, !0), "invalid data", "value", a), a;
}
function Yr(a) {
  return se(ln(a, 32), "invalid hash", "value", a), a;
}
const RB = ow({
  address: Wt,
  blockHash: Yr,
  blockNumber: yt,
  data: Wy,
  index: yt,
  removed: Ot(OB, !1),
  topics: Ck(Yr),
  transactionHash: Yr,
  transactionIndex: yt
}, {
  index: ["logIndex"]
});
function LB(a) {
  return RB(a);
}
const DB = ow({
  hash: Ot(Yr),
  parentHash: Yr,
  parentBeaconBlockRoot: Ot(Yr, null),
  number: yt,
  timestamp: yt,
  nonce: Ot(Wy),
  difficulty: Qe,
  gasLimit: Qe,
  gasUsed: Qe,
  stateRoot: Ot(Yr, null),
  receiptsRoot: Ot(Yr, null),
  blobGasUsed: Ot(Qe, null),
  excessBlobGas: Ot(Qe, null),
  miner: Ot(Wt),
  prevRandao: Ot(Yr, null),
  extraData: Wy,
  baseFeePerGas: Ot(Qe)
}, {
  prevRandao: ["mixHash"]
});
function BB(a) {
  const e = DB(a);
  return e.transactions = a.transactions.map((r) => typeof r == "string" ? r : vT(r)), e;
}
const MB = ow({
  transactionIndex: yt,
  blockNumber: yt,
  transactionHash: Yr,
  address: Wt,
  topics: Ck(Yr),
  data: Wy,
  index: yt,
  blockHash: Yr
}, {
  index: ["logIndex"]
});
function FB(a) {
  return MB(a);
}
const _B = ow({
  to: Ot(Wt, null),
  from: Ot(Wt, null),
  contractAddress: Ot(Wt, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: yt,
  root: Ot(Ge),
  gasUsed: Qe,
  blobGasUsed: Ot(Qe, null),
  logsBloom: Ot(Wy),
  blockHash: Yr,
  hash: Yr,
  logs: Ck(FB),
  blockNumber: yt,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: Qe,
  effectiveGasPrice: Ot(Qe),
  blobGasPrice: Ot(Qe, null),
  status: Ot(yt),
  type: Ot(yt, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function UB(a) {
  return _B(a);
}
function vT(a) {
  a.to && Qe(a.to) === k9 && (a.to = "0x0000000000000000000000000000000000000000");
  const e = ow({
    hash: Yr,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: Ot(yt, void 0),
    type: (r) => r === "0x" || r == null ? 0 : yt(r),
    accessList: Ot(Pg, null),
    blobVersionedHashes: Ot(Ck(Yr, !0), null),
    blockHash: Ot(Yr, null),
    blockNumber: Ot(yt, null),
    transactionIndex: Ot(yt, null),
    from: Wt,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: Ot(Qe),
    maxPriorityFeePerGas: Ot(Qe),
    maxFeePerGas: Ot(Qe),
    maxFeePerBlobGas: Ot(Qe, null),
    gasLimit: Qe,
    to: Ot(Wt, null),
    value: Qe,
    nonce: yt,
    data: Wy,
    creates: Ot(Wt, null),
    chainId: Ot(Qe, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(a);
  if (e.to == null && e.creates == null && (e.creates = bL(e)), (a.type === 1 || a.type === 2) && a.accessList == null && (e.accessList = []), a.signature ? e.signature = nu.from(a.signature) : e.signature = nu.from(a), e.chainId == null) {
    const r = e.signature.legacyChainId;
    r != null && (e.chainId = r);
  }
  return e.blockHash && Qe(e.blockHash) === k9 && (e.blockHash = null), e;
}
const zB = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class iw {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(e) {
    le(this, "name"), Ke(this, { name: e });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new iw(this.name);
  }
}
class Tk extends iw {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(e, r) {
    e == null && (e = 0), super(`org.ethers.network.plugins.GasCost#${e || 0}`), le(this, "effectiveBlock"), le(this, "txBase"), le(this, "txCreate"), le(this, "txDataZero"), le(this, "txDataNonzero"), le(this, "txAccessListStorageKey"), le(this, "txAccessListAddress");
    const i = { effectiveBlock: e };
    function u(d, g) {
      let b = (r || {})[d];
      b == null && (b = g), se(typeof b == "number", `invalud value for ${d}`, "costs", r), i[d] = b;
    }
    u("txBase", 21e3), u("txCreate", 32e3), u("txDataZero", 4), u("txDataNonzero", 16), u("txAccessListStorageKey", 1900), u("txAccessListAddress", 2400), Ke(this, i);
  }
  clone() {
    return new Tk(this.effectiveBlock, this);
  }
}
class Ik extends iw {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(e, r) {
    super("org.ethers.plugins.network.Ens"), le(this, "address"), le(this, "targetNetwork"), Ke(this, {
      address: e || zB,
      targetNetwork: r ?? 1
    });
  }
  clone() {
    return new Ik(this.address, this.targetNetwork);
  }
}
var z4, H4;
class HB extends iw {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(e, r) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"), ye(this, z4), ye(this, H4), Q(this, z4, e), Q(this, H4, r);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return R(this, z4);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return R(this, H4);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
z4 = /* @__PURE__ */ new WeakMap(), H4 = /* @__PURE__ */ new WeakMap();
const R8 = /* @__PURE__ */ new Map();
var yv, bv, _p;
const VB = class vv {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(e, r) {
    ye(this, yv), ye(this, bv), ye(this, _p), Q(this, yv, e), Q(this, bv, Qe(r)), Q(this, _p, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return R(this, yv);
  }
  set name(e) {
    Q(this, yv, e);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return R(this, bv);
  }
  set chainId(e) {
    Q(this, bv, Qe(e, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(e) {
    if (e == null)
      return !1;
    if (typeof e == "string") {
      try {
        return this.chainId === Qe(e);
      } catch {
      }
      return this.name === e;
    }
    if (typeof e == "number" || typeof e == "bigint") {
      try {
        return this.chainId === Qe(e);
      } catch {
      }
      return !1;
    }
    if (typeof e == "object") {
      if (e.chainId != null) {
        try {
          return this.chainId === Qe(e.chainId);
        } catch {
        }
        return !1;
      }
      return e.name != null ? this.name === e.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(R(this, _p).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(e) {
    if (R(this, _p).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return R(this, _p).set(e.name, e.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(e) {
    return R(this, _p).get(e) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(e) {
    return this.plugins.filter((r) => r.name.split("#")[0] === e);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const e = new vv(this.name, this.chainId);
    return this.plugins.forEach((r) => {
      e.attachPlugin(r.clone());
    }), e;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(e) {
    const r = this.getPlugin("org.ethers.plugins.network.GasCost") || new Tk();
    let i = r.txBase;
    if (e.to == null && (i += r.txCreate), e.data)
      for (let u = 2; u < e.data.length; u += 2)
        e.data.substring(u, u + 2) === "00" ? i += r.txDataZero : i += r.txDataNonzero;
    if (e.accessList) {
      const u = Pg(e.accessList);
      for (const d in u)
        i += r.txAccessListAddress + r.txAccessListStorageKey * u[d].storageKeys.length;
    }
    return i;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(e) {
    if (WB(), e == null)
      return vv.from("mainnet");
    if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
      const r = R8.get(e);
      if (r)
        return r();
      if (typeof e == "bigint")
        return new vv("unknown", e);
      se(!1, "unknown network", "network", e);
    }
    if (typeof e.clone == "function")
      return e.clone();
    if (typeof e == "object") {
      se(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
      const r = new vv(e.name, e.chainId);
      return (e.ensAddress || e.ensNetwork != null) && r.attachPlugin(new Ik(e.ensAddress, e.ensNetwork)), r;
    }
    se(!1, "invalid network", "network", e);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(e, r) {
    typeof e == "number" && (e = BigInt(e));
    const i = R8.get(e);
    i && se(!1, `conflicting network for ${JSON.stringify(i.name)}`, "nameOrChainId", e), R8.set(e, r);
  }
};
yv = /* @__PURE__ */ new WeakMap(), bv = /* @__PURE__ */ new WeakMap(), _p = /* @__PURE__ */ new WeakMap();
let Fd = VB;
function E9(a, e) {
  const r = String(a);
  if (!r.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${a}`);
  const i = r.split(".");
  if (i.length === 1 && i.push(""), i.length !== 2)
    throw new Error(`invalid gwei value: ${a}`);
  for (; i[1].length < e; )
    i[1] += "0";
  if (i[1].length > 9) {
    let u = BigInt(i[1].substring(0, 9));
    i[1].substring(9).match(/^0+$/) || u++, i[1] = u.toString();
  }
  return BigInt(i[0] + i[1]);
}
function S9(a) {
  return new HB(a, async (e, r, i) => {
    i.setHeader("User-Agent", "ethers");
    let u;
    try {
      const [d, g] = await Promise.all([
        i.send(),
        e()
      ]);
      u = d;
      const b = u.bodyJson.standard;
      return {
        gasPrice: g.gasPrice,
        maxFeePerGas: E9(b.maxFee, 9),
        maxPriorityFeePerGas: E9(b.maxPriorityFee, 9)
      };
    } catch (d) {
      Te(!1, `error encountered with polygon gas station (${JSON.stringify(i.url)})`, "SERVER_ERROR", { request: i, response: u, error: d });
    }
  });
}
let A9 = !1;
function WB() {
  if (A9)
    return;
  A9 = !0;
  function a(e, r, i) {
    const u = function() {
      const d = new Fd(e, r);
      return i.ensNetwork != null && d.attachPlugin(new Ik(null, i.ensNetwork)), d.attachPlugin(new Tk()), (i.plugins || []).forEach((g) => {
        d.attachPlugin(g);
      }), d;
    };
    Fd.register(e, u), Fd.register(r, u), i.altNames && i.altNames.forEach((d) => {
      Fd.register(d, u);
    });
  }
  a("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), a("ropsten", 3, { ensNetwork: 3 }), a("rinkeby", 4, { ensNetwork: 4 }), a("goerli", 5, { ensNetwork: 5 }), a("kovan", 42, { ensNetwork: 42 }), a("sepolia", 11155111, { ensNetwork: 11155111 }), a("holesky", 17e3, { ensNetwork: 17e3 }), a("classic", 61, {}), a("classicKotti", 6, {}), a("arbitrum", 42161, {
    ensNetwork: 1
  }), a("arbitrum-goerli", 421613, {}), a("arbitrum-sepolia", 421614, {}), a("base", 8453, { ensNetwork: 1 }), a("base-goerli", 84531, {}), a("base-sepolia", 84532, {}), a("bnb", 56, { ensNetwork: 1 }), a("bnbt", 97, {}), a("linea", 59144, { ensNetwork: 1 }), a("linea-goerli", 59140, {}), a("linea-sepolia", 59141, {}), a("matic", 137, {
    ensNetwork: 1,
    plugins: [
      S9("https://gasstation.polygon.technology/v2")
    ]
  }), a("matic-amoy", 80002, {}), a("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      S9("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), a("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), a("optimism-goerli", 420, {}), a("optimism-sepolia", 11155420, {}), a("xdai", 100, { ensNetwork: 1 });
}
function zE(a) {
  return JSON.parse(JSON.stringify(a));
}
var _d, _s, Zp, kc, Dv, ik;
class GB {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    ye(this, Dv), ye(this, _d), ye(this, _s), ye(this, Zp), ye(this, kc), Q(this, _d, e), Q(this, _s, null), Q(this, Zp, 4e3), Q(this, kc, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return R(this, Zp);
  }
  set pollingInterval(e) {
    Q(this, Zp, e);
  }
  start() {
    R(this, _s) || (Q(this, _s, R(this, _d)._setTimeout(Oe(this, Dv, ik).bind(this), R(this, Zp))), Oe(this, Dv, ik).call(this));
  }
  stop() {
    R(this, _s) && (R(this, _d)._clearTimeout(R(this, _s)), Q(this, _s, null));
  }
  pause(e) {
    this.stop(), e && Q(this, kc, -2);
  }
  resume() {
    this.start();
  }
}
_d = /* @__PURE__ */ new WeakMap(), _s = /* @__PURE__ */ new WeakMap(), Zp = /* @__PURE__ */ new WeakMap(), kc = /* @__PURE__ */ new WeakMap(), Dv = /* @__PURE__ */ new WeakSet(), ik = async function() {
  try {
    const a = await R(this, _d).getBlockNumber();
    if (R(this, kc) === -2) {
      Q(this, kc, a);
      return;
    }
    if (a !== R(this, kc)) {
      for (let e = R(this, kc) + 1; e <= a; e++) {
        if (R(this, _s) == null)
          return;
        await R(this, _d).emit("block", e);
      }
      Q(this, kc, a);
    }
  } catch {
  }
  R(this, _s) != null && Q(this, _s, R(this, _d)._setTimeout(Oe(this, Dv, ik).bind(this), R(this, Zp)));
};
var fy, dy, Up;
class HE {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    ye(this, fy), ye(this, dy), ye(this, Up), Q(this, fy, e), Q(this, Up, !1), Q(this, dy, (r) => {
      this._poll(r, R(this, fy));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(e, r) {
    throw new Error("sub-classes must override this");
  }
  start() {
    R(this, Up) || (Q(this, Up, !0), R(this, dy).call(this, -2), R(this, fy).on("block", R(this, dy)));
  }
  stop() {
    R(this, Up) && (Q(this, Up, !1), R(this, fy).off("block", R(this, dy)));
  }
  pause(e) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
fy = /* @__PURE__ */ new WeakMap(), dy = /* @__PURE__ */ new WeakMap(), Up = /* @__PURE__ */ new WeakMap();
var wv, Pd;
class jB extends HE {
  constructor(e, r) {
    super(e), ye(this, wv), ye(this, Pd), Q(this, wv, r), Q(this, Pd, -2);
  }
  pause(e) {
    e && Q(this, Pd, -2), super.pause(e);
  }
  async _poll(e, r) {
    const i = await r.getBlock(R(this, wv));
    i != null && (R(this, Pd) === -2 ? Q(this, Pd, i.number) : i.number > R(this, Pd) && (r.emit(R(this, wv), i.number), Q(this, Pd, i.number)));
  }
}
wv = /* @__PURE__ */ new WeakMap(), Pd = /* @__PURE__ */ new WeakMap();
var M5;
class $B extends HE {
  constructor(e, r) {
    super(e), ye(this, M5), Q(this, M5, zE(r));
  }
  async _poll(e, r) {
    throw new Error("@TODO");
  }
}
M5 = /* @__PURE__ */ new WeakMap();
var kv;
class QB extends HE {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(e, r) {
    super(e), ye(this, kv), Q(this, kv, r);
  }
  async _poll(e, r) {
    const i = await r.getTransactionReceipt(R(this, kv));
    i && r.emit(R(this, kv), i);
  }
}
kv = /* @__PURE__ */ new WeakMap();
var Dd, Bv, Ev, zp, Us, F5, wT;
class VE {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(e, r) {
    ye(this, F5), ye(this, Dd), ye(this, Bv), ye(this, Ev), ye(this, zp), ye(this, Us), Q(this, Dd, e), Q(this, Bv, zE(r)), Q(this, Ev, Oe(this, F5, wT).bind(this)), Q(this, zp, !1), Q(this, Us, -2);
  }
  start() {
    R(this, zp) || (Q(this, zp, !0), R(this, Us) === -2 && R(this, Dd).getBlockNumber().then((e) => {
      Q(this, Us, e);
    }), R(this, Dd).on("block", R(this, Ev)));
  }
  stop() {
    R(this, zp) && (Q(this, zp, !1), R(this, Dd).off("block", R(this, Ev)));
  }
  pause(e) {
    this.stop(), e && Q(this, Us, -2);
  }
  resume() {
    this.start();
  }
}
Dd = /* @__PURE__ */ new WeakMap(), Bv = /* @__PURE__ */ new WeakMap(), Ev = /* @__PURE__ */ new WeakMap(), zp = /* @__PURE__ */ new WeakMap(), Us = /* @__PURE__ */ new WeakMap(), F5 = /* @__PURE__ */ new WeakSet(), wT = async function(a) {
  if (R(this, Us) === -2)
    return;
  const e = zE(R(this, Bv));
  e.fromBlock = R(this, Us) + 1, e.toBlock = a;
  const r = await R(this, Dd).getLogs(e);
  if (r.length === 0) {
    R(this, Us) < a - 60 && Q(this, Us, a - 60);
    return;
  }
  for (const i of r)
    R(this, Dd).emit(R(this, Bv), i), Q(this, Us, i.blockNumber);
};
const ZB = BigInt(2), YB = 10;
function g4(a) {
  return a && typeof a.then == "function";
}
function V4(a, e) {
  return a + ":" + JSON.stringify(e, (r, i) => {
    if (i == null)
      return "null";
    if (typeof i == "bigint")
      return `bigint:${i.toString()}`;
    if (typeof i == "string")
      return i.toLowerCase();
    if (typeof i == "object" && !Array.isArray(i)) {
      const u = Object.keys(i);
      return u.sort(), u.reduce((d, g) => (d[g] = i[g], d), {});
    }
    return i;
  });
}
class kT {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(e) {
    le(this, "name"), Ke(this, { name: e });
  }
  start() {
  }
  stop() {
  }
  pause(e) {
  }
  resume() {
  }
}
function qB(a) {
  return JSON.parse(JSON.stringify(a));
}
function _5(a) {
  return a = Array.from(new Set(a).values()), a.sort(), a;
}
async function L8(a, e) {
  if (a == null)
    throw new Error("invalid event");
  if (Array.isArray(a) && (a = { topics: a }), typeof a == "string")
    switch (a) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: a, tag: a };
    }
  if (ln(a, 32)) {
    const r = a.toLowerCase();
    return { type: "transaction", tag: V4("tx", { hash: r }), hash: r };
  }
  if (a.orphan) {
    const r = a;
    return { type: "orphan", tag: V4("orphan", r), filter: qB(r) };
  }
  if (a.address || a.topics) {
    const r = a, i = {
      topics: (r.topics || []).map((u) => u == null ? null : Array.isArray(u) ? _5(u.map((d) => d.toLowerCase())) : u.toLowerCase())
    };
    if (r.address) {
      const u = [], d = [], g = (b) => {
        ln(b) ? u.push(b) : d.push((async () => {
          u.push(await Ha(b, e));
        })());
      };
      Array.isArray(r.address) ? r.address.forEach(g) : g(r.address), d.length && await Promise.all(d), i.address = _5(u.map((b) => b.toLowerCase()));
    }
    return { filter: i, tag: V4("event", i), type: "event" };
  }
  se(!1, "unknown ProviderEvent", "event", a);
}
function D8() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const KB = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var Fa, Hp, Ma, Sv, Ri, hy, Yp, Od, W4, Os, Av, Mv, Ut, Mo, U5, z5, xv, H5, Cv, G4;
class JB {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(e, r) {
    if (ye(this, Ut), ye(this, Fa), ye(this, Hp), ye(this, Ma), ye(this, Sv), ye(this, Ri), ye(this, hy), ye(this, Yp), ye(this, Od), ye(this, W4), ye(this, Os), ye(this, Av), ye(this, Mv), Q(this, Mv, Object.assign({}, KB, r || {})), e === "any")
      Q(this, hy, !0), Q(this, Ri, null);
    else if (e) {
      const i = Fd.from(e);
      Q(this, hy, !1), Q(this, Ri, Promise.resolve(i)), setTimeout(() => {
        this.emit("network", i, null);
      }, 0);
    } else
      Q(this, hy, !1), Q(this, Ri, null);
    Q(this, Od, -1), Q(this, Yp, /* @__PURE__ */ new Map()), Q(this, Fa, /* @__PURE__ */ new Map()), Q(this, Hp, /* @__PURE__ */ new Map()), Q(this, Ma, null), Q(this, Sv, !1), Q(this, W4, 1), Q(this, Os, /* @__PURE__ */ new Map()), Q(this, Av, !1);
  }
  get pollingInterval() {
    return R(this, Mv).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(R(this, Hp).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(e) {
    if (R(this, Hp).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return R(this, Hp).set(e.name, e.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(e) {
    return R(this, Hp).get(e) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return R(this, Av);
  }
  set disableCcipRead(e) {
    Q(this, Av, !!e);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(e, r, i) {
    if (this.disableCcipRead || i.length === 0 || e.to == null)
      return null;
    const u = e.to.toLowerCase(), d = r.toLowerCase(), g = [];
    for (let b = 0; b < i.length; b++) {
      const y = i[b], k = y.replace("{sender}", u).replace("{data}", d), S = new Mc(k);
      y.indexOf("{data}") === -1 && (S.body = { data: d, sender: u }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: S, index: b, urls: i });
      let A = "unknown error", x;
      try {
        x = await S.send();
      } catch (M) {
        g.push(M.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: S, result: { error: M } });
        continue;
      }
      try {
        const M = x.bodyJson;
        if (M.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: S, result: M }), M.data;
        M.message && (A = M.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: S, result: M });
      } catch {
      }
      Te(x.statusCode < 400 || x.statusCode >= 500, `response not found during CCIP fetch: ${A}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: e, info: { url: y, errorMessage: A } }), g.push(A);
    }
    Te(!1, `error encountered during CCIP fetch: ${g.map((b) => JSON.stringify(b)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: e,
      info: { urls: i, errorMessages: g }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(e, r) {
    return new hB(BB(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(e, r) {
    return new aw(LB(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(e, r) {
    return new aT(UB(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(e, r) {
    return new ME(vT(e), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    Te(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(e) {
    Te(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: e
    });
  }
  // State
  async getBlockNumber() {
    const e = yt(await Oe(this, Ut, Mo).call(this, { method: "getBlockNumber" }), "%response");
    return R(this, Od) >= 0 && Q(this, Od, e), e;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(e) {
    return Ha(e, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(e) {
    if (e == null)
      return "latest";
    switch (e) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return e;
    }
    if (ln(e))
      return ln(e, 32) ? e : by(e);
    if (typeof e == "bigint" && (e = yt(e, "blockTag")), typeof e == "number")
      return e >= 0 ? by(e) : R(this, Od) >= 0 ? by(R(this, Od) + e) : this.getBlockNumber().then((r) => by(r + e));
    se(!1, "invalid blockTag", "blockTag", e);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(e) {
    const r = (e.topics || []).map((y) => y == null ? null : Array.isArray(y) ? _5(y.map((k) => k.toLowerCase())) : y.toLowerCase()), i = "blockHash" in e ? e.blockHash : void 0, u = (y, k, S) => {
      let A;
      switch (y.length) {
        case 0:
          break;
        case 1:
          A = y[0];
          break;
        default:
          y.sort(), A = y;
      }
      if (i && (k != null || S != null))
        throw new Error("invalid filter");
      const x = {};
      return A && (x.address = A), r.length && (x.topics = r), k && (x.fromBlock = k), S && (x.toBlock = S), i && (x.blockHash = i), x;
    };
    let d = [];
    if (e.address)
      if (Array.isArray(e.address))
        for (const y of e.address)
          d.push(this._getAddress(y));
      else
        d.push(this._getAddress(e.address));
    let g;
    "fromBlock" in e && (g = this._getBlockTag(e.fromBlock));
    let b;
    return "toBlock" in e && (b = this._getBlockTag(e.toBlock)), d.filter((y) => typeof y != "string").length || g != null && typeof g != "string" || b != null && typeof b != "string" ? Promise.all([Promise.all(d), g, b]).then((y) => u(y[0], y[1], y[2])) : u(d, g, b);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(e) {
    const r = Sk(e), i = [];
    if (["to", "from"].forEach((u) => {
      if (r[u] == null)
        return;
      const d = Ha(r[u], this);
      g4(d) ? i.push(async function() {
        r[u] = await d;
      }()) : r[u] = d;
    }), r.blockTag != null) {
      const u = this._getBlockTag(r.blockTag);
      g4(u) ? i.push(async function() {
        r.blockTag = await u;
      }()) : r.blockTag = u;
    }
    return i.length ? async function() {
      return await Promise.all(i), r;
    }() : r;
  }
  async getNetwork() {
    if (R(this, Ri) == null) {
      const u = (async () => {
        try {
          const d = await this._detectNetwork();
          return this.emit("network", d, null), d;
        } catch (d) {
          throw R(this, Ri) === u && Q(this, Ri, null), d;
        }
      })();
      return Q(this, Ri, u), (await u).clone();
    }
    const e = R(this, Ri), [r, i] = await Promise.all([
      e,
      this._detectNetwork()
      // The actual connected network
    ]);
    return r.chainId !== i.chainId && (R(this, hy) ? (this.emit("network", i, r), R(this, Ri) === e && Q(this, Ri, Promise.resolve(i))) : Te(!1, `network changed: ${r.chainId} => ${i.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), r.clone();
  }
  async getFeeData() {
    const e = await this.getNetwork(), r = async () => {
      const { _block: u, gasPrice: d, priorityFee: g } = await _a({
        _block: Oe(this, Ut, H5).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const S = await Oe(this, Ut, Mo).call(this, { method: "getGasPrice" });
            return Qe(S, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const S = await Oe(this, Ut, Mo).call(this, { method: "getPriorityFee" });
            return Qe(S, "%response");
          } catch {
          }
          return null;
        })()
      });
      let b = null, y = null;
      const k = this._wrapBlock(u, e);
      return k && k.baseFeePerGas && (y = g ?? BigInt("1000000000"), b = k.baseFeePerGas * ZB + y), new m9(d, b, y);
    }, i = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (i) {
      const u = new Mc(i.url), d = await i.processFunc(r, this, u);
      return new m9(d.gasPrice, d.maxFeePerGas, d.maxPriorityFeePerGas);
    }
    return await r();
  }
  async estimateGas(e) {
    let r = this._getTransactionRequest(e);
    return g4(r) && (r = await r), Qe(await Oe(this, Ut, Mo).call(this, {
      method: "estimateGas",
      transaction: r
    }), "%response");
  }
  async call(e) {
    const { tx: r, blockTag: i } = await _a({
      tx: this._getTransactionRequest(e),
      blockTag: this._getBlockTag(e.blockTag)
    });
    return await Oe(this, Ut, z5).call(this, Oe(this, Ut, U5).call(this, r, i, e.enableCcipRead ? 0 : -1));
  }
  async getBalance(e, r) {
    return Qe(await Oe(this, Ut, xv).call(this, { method: "getBalance" }, e, r), "%response");
  }
  async getTransactionCount(e, r) {
    return yt(await Oe(this, Ut, xv).call(this, { method: "getTransactionCount" }, e, r), "%response");
  }
  async getCode(e, r) {
    return Ge(await Oe(this, Ut, xv).call(this, { method: "getCode" }, e, r));
  }
  async getStorage(e, r, i) {
    const u = Qe(r, "position");
    return Ge(await Oe(this, Ut, xv).call(this, { method: "getStorage", position: u }, e, i));
  }
  // Write
  async broadcastTransaction(e) {
    const { blockNumber: r, hash: i, network: u } = await _a({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: e
      }),
      network: this.getNetwork()
    }), d = HC.from(e);
    if (d.hash !== i)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(d, u).replaceableTransaction(r);
  }
  // Queries
  async getBlock(e, r) {
    const { network: i, params: u } = await _a({
      network: this.getNetwork(),
      params: Oe(this, Ut, H5).call(this, e, !!r)
    });
    return u == null ? null : this._wrapBlock(u, i);
  }
  async getTransaction(e) {
    const { network: r, params: i } = await _a({
      network: this.getNetwork(),
      params: Oe(this, Ut, Mo).call(this, { method: "getTransaction", hash: e })
    });
    return i == null ? null : this._wrapTransactionResponse(i, r);
  }
  async getTransactionReceipt(e) {
    const { network: r, params: i } = await _a({
      network: this.getNetwork(),
      params: Oe(this, Ut, Mo).call(this, { method: "getTransactionReceipt", hash: e })
    });
    if (i == null)
      return null;
    if (i.gasPrice == null && i.effectiveGasPrice == null) {
      const u = await Oe(this, Ut, Mo).call(this, { method: "getTransaction", hash: e });
      if (u == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      i.effectiveGasPrice = u.gasPrice;
    }
    return this._wrapTransactionReceipt(i, r);
  }
  async getTransactionResult(e) {
    const { result: r } = await _a({
      network: this.getNetwork(),
      result: Oe(this, Ut, Mo).call(this, { method: "getTransactionResult", hash: e })
    });
    return r == null ? null : Ge(r);
  }
  // Bloom-filter Queries
  async getLogs(e) {
    let r = this._getFilter(e);
    g4(r) && (r = await r);
    const { network: i, params: u } = await _a({
      network: this.getNetwork(),
      params: Oe(this, Ut, Mo).call(this, { method: "getLogs", filter: r })
    });
    return u.map((d) => this._wrapLog(d, i));
  }
  // ENS
  _getProvider(e) {
    Te(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(e) {
    return await w9.fromName(this, e);
  }
  async getAvatar(e) {
    const r = await this.getResolver(e);
    return r ? await r.getAvatar() : null;
  }
  async resolveName(e) {
    const r = await this.getResolver(e);
    return r ? await r.getAddress() : null;
  }
  async lookupAddress(e) {
    e = Wt(e);
    const r = C5(e.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const i = await w9.getEnsAddress(this), u = await new Sg(i, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(r);
      if (u == null || u === n1)
        return null;
      const d = await new Sg(u, [
        "function name(bytes32) view returns (string)"
      ], this).name(r);
      return await this.resolveName(d) !== e ? null : d;
    } catch (i) {
      if (qr(i, "BAD_DATA") && i.value === "0x" || qr(i, "CALL_EXCEPTION"))
        return null;
      throw i;
    }
    return null;
  }
  async waitForTransaction(e, r, i) {
    const u = r ?? 1;
    return u === 0 ? this.getTransactionReceipt(e) : new Promise(async (d, g) => {
      let b = null;
      const y = async (k) => {
        try {
          const S = await this.getTransactionReceipt(e);
          if (S != null && k - S.blockNumber + 1 >= u) {
            d(S), b && (clearTimeout(b), b = null);
            return;
          }
        } catch (S) {
          console.log("EEE", S);
        }
        this.once("block", y);
      };
      i != null && (b = setTimeout(() => {
        b != null && (b = null, this.off("block", y), g(Pn("timeout", "TIMEOUT", { reason: "timeout" })));
      }, i)), y(await this.getBlockNumber());
    });
  }
  async waitForBlock(e) {
    Te(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(e) {
    const r = R(this, Os).get(e);
    r && (r.timer && clearTimeout(r.timer), R(this, Os).delete(e));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(e, r) {
    r == null && (r = 0);
    const i = Y4(this, W4)._++, u = () => {
      R(this, Os).delete(i), e();
    };
    if (this.paused)
      R(this, Os).set(i, { timer: null, func: u, time: r });
    else {
      const d = setTimeout(u, r);
      R(this, Os).set(i, { timer: d, func: u, time: D8() });
    }
    return i;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(e) {
    for (const r of R(this, Fa).values())
      e(r.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(e) {
    switch (e.type) {
      case "debug":
      case "error":
      case "network":
        return new kT(e.type);
      case "block": {
        const r = new GB(this);
        return r.pollingInterval = this.pollingInterval, r;
      }
      case "safe":
      case "finalized":
        return new jB(this, e.type);
      case "event":
        return new VE(this, e.filter);
      case "transaction":
        return new QB(this, e.hash);
      case "orphan":
        return new $B(this, e.filter);
    }
    throw new Error(`unsupported event: ${e.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(e, r) {
    for (const i of R(this, Fa).values())
      if (i.subscriber === e) {
        i.started && i.subscriber.stop(), i.subscriber = r, i.started && r.start(), R(this, Ma) != null && r.pause(R(this, Ma));
        break;
      }
  }
  async on(e, r) {
    const i = await Oe(this, Ut, G4).call(this, e);
    return i.listeners.push({ listener: r, once: !1 }), i.started || (i.subscriber.start(), i.started = !0, R(this, Ma) != null && i.subscriber.pause(R(this, Ma))), this;
  }
  async once(e, r) {
    const i = await Oe(this, Ut, G4).call(this, e);
    return i.listeners.push({ listener: r, once: !0 }), i.started || (i.subscriber.start(), i.started = !0, R(this, Ma) != null && i.subscriber.pause(R(this, Ma))), this;
  }
  async emit(e, ...r) {
    const i = await Oe(this, Ut, Cv).call(this, e, r);
    if (!i || i.listeners.length === 0)
      return !1;
    const u = i.listeners.length;
    return i.listeners = i.listeners.filter(({ listener: d, once: g }) => {
      const b = new Cx(this, g ? null : d, e);
      try {
        d.call(this, ...r, b);
      } catch {
      }
      return !g;
    }), i.listeners.length === 0 && (i.started && i.subscriber.stop(), R(this, Fa).delete(i.tag)), u > 0;
  }
  async listenerCount(e) {
    if (e) {
      const i = await Oe(this, Ut, Cv).call(this, e);
      return i ? i.listeners.length : 0;
    }
    let r = 0;
    for (const { listeners: i } of R(this, Fa).values())
      r += i.length;
    return r;
  }
  async listeners(e) {
    if (e) {
      const i = await Oe(this, Ut, Cv).call(this, e);
      return i ? i.listeners.map(({ listener: u }) => u) : [];
    }
    let r = [];
    for (const { listeners: i } of R(this, Fa).values())
      r = r.concat(i.map(({ listener: u }) => u));
    return r;
  }
  async off(e, r) {
    const i = await Oe(this, Ut, Cv).call(this, e);
    if (!i)
      return this;
    if (r) {
      const u = i.listeners.map(({ listener: d }) => d).indexOf(r);
      u >= 0 && i.listeners.splice(u, 1);
    }
    return (!r || i.listeners.length === 0) && (i.started && i.subscriber.stop(), R(this, Fa).delete(i.tag)), this;
  }
  async removeAllListeners(e) {
    if (e) {
      const { tag: r, started: i, subscriber: u } = await Oe(this, Ut, G4).call(this, e);
      i && u.stop(), R(this, Fa).delete(r);
    } else
      for (const [r, { started: i, subscriber: u }] of R(this, Fa))
        i && u.stop(), R(this, Fa).delete(r);
    return this;
  }
  // Alias for "on"
  async addListener(e, r) {
    return await this.on(e, r);
  }
  // Alias for "off"
  async removeListener(e, r) {
    return this.off(e, r);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return R(this, Sv);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const e of R(this, Os).keys())
      this._clearTimeout(e);
    Q(this, Sv, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return R(this, Ma) != null;
  }
  set paused(e) {
    !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(e) {
    if (Q(this, Od, -1), R(this, Ma) != null) {
      if (R(this, Ma) == !!e)
        return;
      Te(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((r) => r.pause(e)), Q(this, Ma, !!e);
    for (const r of R(this, Os).values())
      r.timer && clearTimeout(r.timer), r.time = D8() - r.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (R(this, Ma) != null) {
      this._forEachSubscriber((e) => e.resume()), Q(this, Ma, null);
      for (const e of R(this, Os).values()) {
        let r = e.time;
        r < 0 && (r = 0), e.time = D8(), setTimeout(e.func, r);
      }
    }
  }
}
Fa = /* @__PURE__ */ new WeakMap(), Hp = /* @__PURE__ */ new WeakMap(), Ma = /* @__PURE__ */ new WeakMap(), Sv = /* @__PURE__ */ new WeakMap(), Ri = /* @__PURE__ */ new WeakMap(), hy = /* @__PURE__ */ new WeakMap(), Yp = /* @__PURE__ */ new WeakMap(), Od = /* @__PURE__ */ new WeakMap(), W4 = /* @__PURE__ */ new WeakMap(), Os = /* @__PURE__ */ new WeakMap(), Av = /* @__PURE__ */ new WeakMap(), Mv = /* @__PURE__ */ new WeakMap(), Ut = /* @__PURE__ */ new WeakSet(), Mo = async function(a) {
  const e = R(this, Mv).cacheTimeout;
  if (e < 0)
    return await this._perform(a);
  const r = V4(a.method, a);
  let i = R(this, Yp).get(r);
  return i || (i = this._perform(a), R(this, Yp).set(r, i), setTimeout(() => {
    R(this, Yp).get(r) === i && R(this, Yp).delete(r);
  }, e)), await i;
}, U5 = async function(a, e, r) {
  Te(r < YB, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, a, { blockTag: e, enableCcipRead: !0 })
  });
  const i = Sk(a);
  try {
    return Ge(await this._perform({ method: "call", transaction: i, blockTag: e }));
  } catch (u) {
    if (!this.disableCcipRead && yE(u) && u.data && r >= 0 && e === "latest" && i.to != null && On(u.data, 0, 4) === "0x556f1830") {
      const d = u.data, g = await Ha(i.to, this);
      let b;
      try {
        b = rM(On(u.data, 4));
      } catch (S) {
        Te(!1, S.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: i,
          info: { data: d }
        });
      }
      Te(b.sender.toLowerCase() === g.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: d,
        reason: "OffchainLookup",
        transaction: i,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: b.errorArgs
        }
      });
      const y = await this.ccipReadFetch(i, b.calldata, b.urls);
      Te(y != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: i,
        info: { data: u.data, errorArgs: b.errorArgs }
      });
      const k = {
        to: g,
        data: vn([b.selector, nM([y, b.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: k });
      try {
        const S = await Oe(this, Ut, U5).call(this, k, e, r + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, k), result: S }), S;
      } catch (S) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, k), error: S }), S;
      }
    }
    throw u;
  }
}, z5 = async function(a) {
  const { value: e } = await _a({
    network: this.getNetwork(),
    value: a
  });
  return e;
}, xv = async function(a, e, r) {
  let i = this._getAddress(e), u = this._getBlockTag(r);
  return (typeof i != "string" || typeof u != "string") && ([i, u] = await Promise.all([i, u])), await Oe(this, Ut, z5).call(this, Oe(this, Ut, Mo).call(this, Object.assign(a, { address: i, blockTag: u })));
}, H5 = async function(a, e) {
  if (ln(a, 32))
    return await Oe(this, Ut, Mo).call(this, {
      method: "getBlock",
      blockHash: a,
      includeTransactions: e
    });
  let r = this._getBlockTag(a);
  return typeof r != "string" && (r = await r), await Oe(this, Ut, Mo).call(this, {
    method: "getBlock",
    blockTag: r,
    includeTransactions: e
  });
}, Cv = async function(a, e) {
  let r = await L8(a, this);
  return r.type === "event" && e && e.length > 0 && e[0].removed === !0 && (r = await L8({ orphan: "drop-log", log: e[0] }, this)), R(this, Fa).get(r.tag) || null;
}, G4 = async function(a) {
  const e = await L8(a, this), r = e.tag;
  let i = R(this, Fa).get(r);
  return i || (i = { subscriber: this._getSubscriber(e), tag: r, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, R(this, Fa).set(r, i)), i;
};
function XB(a, e) {
  try {
    const r = V5(a, e);
    if (r)
      return K4(r);
  } catch {
  }
  return null;
}
function V5(a, e) {
  if (a === "0x")
    return null;
  try {
    const r = yt(On(a, e, e + 32)), i = yt(On(a, r, r + 32));
    return On(a, r + 32, r + 32 + i);
  } catch {
  }
  return null;
}
function x9(a) {
  const e = kr(a);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const r = new Uint8Array(32);
  return r.set(e, 32 - e.length), r;
}
function eM(a) {
  if (a.length % 32 === 0)
    return a;
  const e = new Uint8Array(Math.ceil(a.length / 32) * 32);
  return e.set(a), e;
}
const tM = new Uint8Array([]);
function nM(a) {
  const e = [];
  let r = 0;
  for (let i = 0; i < a.length; i++)
    e.push(tM), r += 32;
  for (let i = 0; i < a.length; i++) {
    const u = mt(a[i]);
    e[i] = x9(r), e.push(x9(u.length)), e.push(eM(u)), r += 32 + Math.ceil(u.length / 32) * 32;
  }
  return vn(e);
}
const C9 = "0x0000000000000000000000000000000000000000000000000000000000000000";
function rM(a) {
  const e = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  Te(ug(a) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const r = On(a, 0, 32);
  Te(On(r, 0, 12) === On(C9, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), e.sender = On(r, 12);
  try {
    const i = [], u = yt(On(a, 32, 64)), d = yt(On(a, u, u + 32)), g = On(a, u + 32);
    for (let b = 0; b < d; b++) {
      const y = XB(g, b * 32);
      if (y == null)
        throw new Error("abort");
      i.push(y);
    }
    e.urls = i;
  } catch {
    Te(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const i = V5(a, 64);
    if (i == null)
      throw new Error("abort");
    e.calldata = i;
  } catch {
    Te(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  Te(On(a, 100, 128) === On(C9, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), e.selector = On(a, 96, 100);
  try {
    const i = V5(a, 128);
    if (i == null)
      throw new Error("abort");
    e.extraData = i;
  } catch {
    Te(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((i) => e[i]), e;
}
function Q0(a, e) {
  if (a.provider)
    return a.provider;
  Te(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
}
async function T9(a, e) {
  let r = Sk(e);
  if (r.to != null && (r.to = Ha(r.to, a)), r.from != null) {
    const i = r.from;
    r.from = Promise.all([
      a.getAddress(),
      Ha(i, a)
    ]).then(([u, d]) => (se(u.toLowerCase() === d.toLowerCase(), "transaction from mismatch", "tx.from", d), u));
  } else
    r.from = a.getAddress();
  return await _a(r);
}
class ET {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(e) {
    le(this, "provider"), Ke(this, { provider: e || null });
  }
  async getNonce(e) {
    return Q0(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e);
  }
  async populateCall(e) {
    return await T9(this, e);
  }
  async populateTransaction(e) {
    const r = Q0(this, "populateTransaction"), i = await T9(this, e);
    i.nonce == null && (i.nonce = await this.getNonce("pending")), i.gasLimit == null && (i.gasLimit = await this.estimateGas(i));
    const u = await this.provider.getNetwork();
    if (i.chainId != null) {
      const g = Qe(i.chainId);
      se(g === u.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId);
    } else
      i.chainId = u.chainId;
    const d = i.maxFeePerGas != null || i.maxPriorityFeePerGas != null;
    if (i.gasPrice != null && (i.type === 2 || d) ? se(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (i.type === 0 || i.type === 1) && d && se(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (i.type === 2 || i.type == null) && i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
      i.type = 2;
    else if (i.type === 0 || i.type === 1) {
      const g = await r.getFeeData();
      Te(g.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), i.gasPrice == null && (i.gasPrice = g.gasPrice);
    } else {
      const g = await r.getFeeData();
      if (i.type == null)
        if (g.maxFeePerGas != null && g.maxPriorityFeePerGas != null)
          if (i.type = 2, i.gasPrice != null) {
            const b = i.gasPrice;
            delete i.gasPrice, i.maxFeePerGas = b, i.maxPriorityFeePerGas = b;
          } else
            i.maxFeePerGas == null && (i.maxFeePerGas = g.maxFeePerGas), i.maxPriorityFeePerGas == null && (i.maxPriorityFeePerGas = g.maxPriorityFeePerGas);
        else g.gasPrice != null ? (Te(!d, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
          operation: "populateTransaction"
        }), i.gasPrice == null && (i.gasPrice = g.gasPrice), i.type = 0) : Te(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
          operation: "signer.getFeeData"
        });
      else (i.type === 2 || i.type === 3) && (i.maxFeePerGas == null && (i.maxFeePerGas = g.maxFeePerGas), i.maxPriorityFeePerGas == null && (i.maxPriorityFeePerGas = g.maxPriorityFeePerGas));
    }
    return await _a(i);
  }
  async estimateGas(e) {
    return Q0(this, "estimateGas").estimateGas(await this.populateCall(e));
  }
  async call(e) {
    return Q0(this, "call").call(await this.populateCall(e));
  }
  async resolveName(e) {
    return await Q0(this, "resolveName").resolveName(e);
  }
  async sendTransaction(e) {
    const r = Q0(this, "sendTransaction"), i = await this.populateTransaction(e);
    delete i.from;
    const u = HC.from(i);
    return await r.broadcastTransaction(await this.signTransaction(u));
  }
}
var Tv, j4;
const aM = class ST extends ET {
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(e, r) {
    super(r), ye(this, Tv), le(this, "address"), Ke(this, { address: e });
  }
  async getAddress() {
    return this.address;
  }
  connect(e) {
    return new ST(this.address, e);
  }
  async signTransaction(e) {
    Oe(this, Tv, j4).call(this, "transactions", "signTransaction");
  }
  async signMessage(e) {
    Oe(this, Tv, j4).call(this, "messages", "signMessage");
  }
  async signTypedData(e, r, i) {
    Oe(this, Tv, j4).call(this, "typed-data", "signTypedData");
  }
};
Tv = /* @__PURE__ */ new WeakSet(), j4 = function(a, e) {
  Te(!1, `VoidSigner cannot sign ${a}`, "UNSUPPORTED_OPERATION", { operation: e });
};
let I9 = aM;
function oM(a) {
  return JSON.parse(JSON.stringify(a));
}
var ao, wc, ky, Vp, Ey, Fv, py, W5, G5;
class AT {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(e) {
    ye(this, py), ye(this, ao), ye(this, wc), ye(this, ky), ye(this, Vp), ye(this, Ey), ye(this, Fv), Q(this, ao, e), Q(this, wc, null), Q(this, ky, Oe(this, py, W5).bind(this)), Q(this, Vp, !1), Q(this, Ey, null), Q(this, Fv, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(e, r) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(e) {
    throw new Error("subclasses must override this");
  }
  start() {
    R(this, Vp) || (Q(this, Vp, !0), Oe(this, py, W5).call(this, -2));
  }
  stop() {
    R(this, Vp) && (Q(this, Vp, !1), Q(this, Fv, !0), Oe(this, py, G5).call(this), R(this, ao).off("block", R(this, ky)));
  }
  pause(e) {
    e && Oe(this, py, G5).call(this), R(this, ao).off("block", R(this, ky));
  }
  resume() {
    this.start();
  }
}
ao = /* @__PURE__ */ new WeakMap(), wc = /* @__PURE__ */ new WeakMap(), ky = /* @__PURE__ */ new WeakMap(), Vp = /* @__PURE__ */ new WeakMap(), Ey = /* @__PURE__ */ new WeakMap(), Fv = /* @__PURE__ */ new WeakMap(), py = /* @__PURE__ */ new WeakSet(), W5 = async function(a) {
  try {
    R(this, wc) == null && Q(this, wc, this._subscribe(R(this, ao)));
    let e = null;
    try {
      e = await R(this, wc);
    } catch (u) {
      if (!qr(u, "UNSUPPORTED_OPERATION") || u.operation !== "eth_newFilter")
        throw u;
    }
    if (e == null) {
      Q(this, wc, null), R(this, ao)._recoverSubscriber(this, this._recover(R(this, ao)));
      return;
    }
    const r = await R(this, ao).getNetwork();
    if (R(this, Ey) || Q(this, Ey, r), R(this, Ey).chainId !== r.chainId)
      throw new Error("chaid changed");
    if (R(this, Fv))
      return;
    const i = await R(this, ao).send("eth_getFilterChanges", [e]);
    await this._emitResults(R(this, ao), i);
  } catch (e) {
    console.log("@TODO", e);
  }
  R(this, ao).once("block", R(this, ky));
}, G5 = function() {
  const a = R(this, wc);
  a && (Q(this, wc, null), a.then((e) => {
    R(this, ao).destroyed || R(this, ao).send("eth_uninstallFilter", [e]);
  }));
};
var gy;
class iM extends AT {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(e, r) {
    super(e), ye(this, gy), Q(this, gy, oM(r));
  }
  _recover(e) {
    return new VE(e, R(this, gy));
  }
  async _subscribe(e) {
    return await e.send("eth_newFilter", [R(this, gy)]);
  }
  async _emitResults(e, r) {
    for (const i of r)
      e.emit(R(this, gy), e._wrapLog(i, e._network));
  }
}
gy = /* @__PURE__ */ new WeakMap();
class sM extends AT {
  async _subscribe(e) {
    return await e.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(e, r) {
    for (const i of r)
      e.emit("pending", i);
  }
}
const lM = "bigint,boolean,function,number,string,symbol".split(/,/g);
function $4(a) {
  if (a == null || lM.indexOf(typeof a) >= 0 || typeof a.getAddress == "function")
    return a;
  if (Array.isArray(a))
    return a.map($4);
  if (typeof a == "object")
    return Object.keys(a).reduce((e, r) => (e[r] = a[r], e), {});
  throw new Error(`should not happen: ${a} (${typeof a})`);
}
function uM(a) {
  return new Promise((e) => {
    setTimeout(e, a);
  });
}
function Z0(a) {
  return a && a.toLowerCase();
}
function N9(a) {
  return a && typeof a.pollingInterval == "number";
}
const xT = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class B8 extends ET {
  constructor(e, r) {
    super(e), le(this, "address"), r = Wt(r), Ke(this, { address: r });
  }
  connect(e) {
    Te(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(e) {
    return await this.populateCall(e);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(e) {
    const r = $4(e), i = [];
    if (r.from) {
      const d = r.from;
      i.push((async () => {
        const g = await Ha(d, this.provider);
        se(g != null && g.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), r.from = g;
      })());
    } else
      r.from = this.address;
    if (r.gasLimit == null && i.push((async () => {
      r.gasLimit = await this.provider.estimateGas({ ...r, from: this.address });
    })()), r.to != null) {
      const d = r.to;
      i.push((async () => {
        r.to = await Ha(d, this.provider);
      })());
    }
    i.length && await Promise.all(i);
    const u = this.provider.getRpcTransaction(r);
    return this.provider.send("eth_sendTransaction", [u]);
  }
  async sendTransaction(e) {
    const r = await this.provider.getBlockNumber(), i = await this.sendUncheckedTransaction(e);
    return await new Promise((u, d) => {
      const g = [1e3, 100];
      let b = 0;
      const y = async () => {
        try {
          const k = await this.provider.getTransaction(i);
          if (k != null) {
            u(k.replaceableTransaction(r));
            return;
          }
        } catch (k) {
          if (qr(k, "CANCELLED") || qr(k, "BAD_DATA") || qr(k, "NETWORK_ERROR") || qr(k, "UNSUPPORTED_OPERATION")) {
            k.info == null && (k.info = {}), k.info.sendTransactionHash = i, d(k);
            return;
          }
          if (qr(k, "INVALID_ARGUMENT") && (b++, k.info == null && (k.info = {}), k.info.sendTransactionHash = i, b > 10)) {
            d(k);
            return;
          }
          this.provider.emit("error", Pn("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: k }));
        }
        this.provider._setTimeout(() => {
          y();
        }, g.pop() || 4e3);
      };
      y();
    });
  }
  async signTransaction(e) {
    const r = $4(e);
    if (r.from) {
      const u = await Ha(r.from, this.provider);
      se(u != null && u.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), r.from = u;
    } else
      r.from = this.address;
    const i = this.provider.getRpcTransaction(r);
    return await this.provider.send("eth_signTransaction", [i]);
  }
  async signMessage(e) {
    const r = typeof e == "string" ? lo(e) : e;
    return await this.provider.send("personal_sign", [
      Ge(r),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(e, r, i) {
    const u = $4(i), d = await t9.resolveNames(e, r, u, async (g) => {
      const b = await Ha(g);
      return se(b != null, "TypedData does not support null address", "value", g), b;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(t9.getPayload(d.domain, r, d.value))
    ]);
  }
  async unlock(e) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      e,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(e) {
    const r = typeof e == "string" ? lo(e) : e;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      Ge(r)
    ]);
  }
}
var Ly, Iv, Bd, Nc, jl, Rs, Do, Q4, j5;
class cM extends JB {
  constructor(e, r) {
    super(e, r), ye(this, Q4), ye(this, Ly), ye(this, Iv), ye(this, Bd), ye(this, Nc), ye(this, jl), ye(this, Rs), ye(this, Do), Q(this, Iv, 1), Q(this, Ly, Object.assign({}, xT, r || {})), Q(this, Bd, []), Q(this, Nc, null), Q(this, Rs, null), Q(this, Do, null);
    {
      let u = null;
      const d = new Promise((g) => {
        u = g;
      });
      Q(this, jl, { promise: d, resolve: u });
    }
    const i = this._getOption("staticNetwork");
    typeof i == "boolean" ? (se(!i || e !== "any", "staticNetwork cannot be used on special network 'any'", "options", r), i && e != null && Q(this, Rs, Fd.from(e))) : i && (se(e == null || i.matches(e), "staticNetwork MUST match network object", "options", r), Q(this, Rs, i));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(e) {
    return R(this, Ly)[e];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return Te(R(this, Rs), "network is not available yet", "NETWORK_ERROR"), R(this, Rs);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(e) {
    if (e.method === "call" || e.method === "estimateGas") {
      let i = e.transaction;
      if (i && i.type != null && Qe(i.type) && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
        const u = await this.getFeeData();
        u.maxFeePerGas == null && u.maxPriorityFeePerGas == null && (e = Object.assign({}, e, {
          transaction: Object.assign({}, i, { type: void 0 })
        }));
      }
    }
    const r = this.getRpcRequest(e);
    return r != null ? await this.send(r.method, r.args) : super._perform(e);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const e = this._getOption("staticNetwork");
    if (e)
      if (e === !0) {
        if (R(this, Rs))
          return R(this, Rs);
      } else
        return e;
    return R(this, Do) ? await R(this, Do) : this.ready ? (Q(this, Do, (async () => {
      try {
        const r = Fd.from(Qe(await this.send("eth_chainId", [])));
        return Q(this, Do, null), r;
      } catch (r) {
        throw Q(this, Do, null), r;
      }
    })()), await R(this, Do)) : (Q(this, Do, (async () => {
      const r = {
        id: Y4(this, Iv)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: r });
      let i;
      try {
        i = (await this._send(r))[0], Q(this, Do, null);
      } catch (u) {
        throw Q(this, Do, null), this.emit("debug", { action: "receiveRpcError", error: u }), u;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: i }), "result" in i)
        return Fd.from(Qe(i.result));
      throw this.getRpcError(r, i);
    })()), await R(this, Do));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    R(this, jl) == null || R(this, jl).resolve == null || (R(this, jl).resolve(), Q(this, jl, null), (async () => {
      for (; R(this, Rs) == null && !this.destroyed; )
        try {
          Q(this, Rs, await this._detectNetwork());
        } catch (e) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", Pn("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: e } })), await uM(1e3);
        }
      Oe(this, Q4, j5).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (R(this, jl) != null)
      return await R(this, jl).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(e) {
    return e.type === "pending" ? new sM(this) : e.type === "event" ? this._getOption("polling") ? new VE(this, e.filter) : new iM(this, e.filter) : e.type === "orphan" && e.filter.orphan === "drop-log" ? new kT("orphan") : super._getSubscriber(e);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return R(this, jl) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(e) {
    const r = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((i) => {
      if (e[i] == null)
        return;
      let u = i;
      i === "gasLimit" && (u = "gas"), r[u] = by(Qe(e[i], `tx.${i}`));
    }), ["from", "to", "data"].forEach((i) => {
      e[i] != null && (r[i] = Ge(e[i]));
    }), e.accessList && (r.accessList = Pg(e.accessList)), e.blobVersionedHashes && (r.blobVersionedHashes = e.blobVersionedHashes.map((i) => i.toLowerCase())), r;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(e) {
    switch (e.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [Z0(e.address), e.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [Z0(e.address), e.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [Z0(e.address), e.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            Z0(e.address),
            "0x" + e.position.toString(16),
            e.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [e.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in e)
          return {
            method: "eth_getBlockByNumber",
            args: [e.blockTag, !!e.includeTransactions]
          };
        if ("blockHash" in e)
          return {
            method: "eth_getBlockByHash",
            args: [e.blockHash, !!e.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [e.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [e.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(e.transaction), e.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(e.transaction)]
        };
      case "getLogs":
        return e.filter && e.filter.address != null && (Array.isArray(e.filter.address) ? e.filter.address = e.filter.address.map(Z0) : e.filter.address = Z0(e.filter.address)), { method: "eth_getLogs", args: [e.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(e, r) {
    const { method: i } = e, { error: u } = r;
    if (i === "eth_estimateGas" && u.message) {
      const b = u.message;
      if (!b.match(/revert/i) && b.match(/insufficient funds/i))
        return Pn("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: e.params[0],
          info: { payload: e, error: u }
        });
    }
    if (i === "eth_call" || i === "eth_estimateGas") {
      const b = $5(u), y = jv.getBuiltinCallException(i === "eth_call" ? "call" : "estimateGas", e.params[0], b ? b.data : null);
      return y.info = { error: u, payload: e }, y;
    }
    const d = JSON.stringify(dM(u));
    if (typeof u.message == "string" && u.message.match(/user denied|ethers-user-denied/i))
      return Pn("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[i] || "unknown",
        reason: "rejected",
        info: { payload: e, error: u }
      });
    if (i === "eth_sendRawTransaction" || i === "eth_sendTransaction") {
      const b = e.params[0];
      if (d.match(/insufficient funds|base fee exceeds gas limit/i))
        return Pn("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: b,
          info: { error: u }
        });
      if (d.match(/nonce/i) && d.match(/too low/i))
        return Pn("nonce has already been used", "NONCE_EXPIRED", { transaction: b, info: { error: u } });
      if (d.match(/replacement transaction/i) && d.match(/underpriced/i))
        return Pn("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: b, info: { error: u } });
      if (d.match(/only replay-protected/i))
        return Pn("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: i,
          info: { transaction: b, info: { error: u } }
        });
    }
    let g = !!d.match(/the method .* does not exist/i);
    return g || u && u.details && u.details.startsWith("Unauthorized method:") && (g = !0), g ? Pn("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: { error: u, payload: e }
    }) : Pn("could not coalesce error", "UNKNOWN_ERROR", { error: u, payload: e });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(e, r) {
    if (this.destroyed)
      return Promise.reject(Pn("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e }));
    const i = Y4(this, Iv)._++, u = new Promise((d, g) => {
      R(this, Bd).push({
        resolve: d,
        reject: g,
        payload: { method: e, params: r, id: i, jsonrpc: "2.0" }
      });
    });
    return Oe(this, Q4, j5).call(this), u;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(e) {
    e == null && (e = 0);
    const r = this.send("eth_accounts", []);
    if (typeof e == "number") {
      const u = await r;
      if (e >= u.length)
        throw new Error("no such account");
      return new B8(this, u[e]);
    }
    const { accounts: i } = await _a({
      network: this.getNetwork(),
      accounts: r
    });
    e = Wt(e);
    for (const u of i)
      if (Wt(u) === e)
        return new B8(this, e);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((e) => new B8(this, e));
  }
  destroy() {
    R(this, Nc) && (clearTimeout(R(this, Nc)), Q(this, Nc, null));
    for (const { payload: e, reject: r } of R(this, Bd))
      r(Pn("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e.method }));
    Q(this, Bd, []), super.destroy();
  }
}
Ly = /* @__PURE__ */ new WeakMap(), Iv = /* @__PURE__ */ new WeakMap(), Bd = /* @__PURE__ */ new WeakMap(), Nc = /* @__PURE__ */ new WeakMap(), jl = /* @__PURE__ */ new WeakMap(), Rs = /* @__PURE__ */ new WeakMap(), Do = /* @__PURE__ */ new WeakMap(), Q4 = /* @__PURE__ */ new WeakSet(), j5 = function() {
  if (R(this, Nc))
    return;
  const a = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  Q(this, Nc, setTimeout(() => {
    Q(this, Nc, null);
    const e = R(this, Bd);
    for (Q(this, Bd, []); e.length; ) {
      const r = [e.shift()];
      for (; e.length && r.length !== R(this, Ly).batchMaxCount; )
        if (r.push(e.shift()), JSON.stringify(r.map((i) => i.payload)).length > R(this, Ly).batchMaxSize) {
          e.unshift(r.pop());
          break;
        }
      (async () => {
        const i = r.length === 1 ? r[0].payload : r.map((u) => u.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: i });
        try {
          const u = await this._send(i);
          this.emit("debug", { action: "receiveRpcResult", result: u });
          for (const { resolve: d, reject: g, payload: b } of r) {
            if (this.destroyed) {
              g(Pn("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: b.method }));
              continue;
            }
            const y = u.filter((k) => k.id === b.id)[0];
            if (y == null) {
              const k = Pn("missing response for request", "BAD_DATA", {
                value: u,
                info: { payload: b }
              });
              this.emit("error", k), g(k);
              continue;
            }
            if ("error" in y) {
              g(this.getRpcError(b, y));
              continue;
            }
            d(y.result);
          }
        } catch (u) {
          this.emit("debug", { action: "receiveRpcError", error: u });
          for (const { reject: d } of r)
            d(u);
        }
      })();
    }
  }, a));
};
var Wp;
class fM extends cM {
  constructor(e, r) {
    super(e, r), ye(this, Wp);
    let i = this._getOption("pollingInterval");
    i == null && (i = xT.pollingInterval), Q(this, Wp, i);
  }
  _getSubscriber(e) {
    const r = super._getSubscriber(e);
    return N9(r) && (r.pollingInterval = R(this, Wp)), r;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return R(this, Wp);
  }
  set pollingInterval(e) {
    if (!Number.isInteger(e) || e < 0)
      throw new Error("invalid interval");
    Q(this, Wp, e), this._forEachSubscriber((r) => {
      N9(r) && (r.pollingInterval = R(this, Wp));
    });
  }
}
Wp = /* @__PURE__ */ new WeakMap();
var Nv;
class sk extends fM {
  constructor(e, r, i) {
    e == null && (e = "http://localhost:8545"), super(r, i), ye(this, Nv), typeof e == "string" ? Q(this, Nv, new Mc(e)) : Q(this, Nv, e.clone());
  }
  _getConnection() {
    return R(this, Nv).clone();
  }
  async send(e, r) {
    return await this._start(), await super.send(e, r);
  }
  async _send(e) {
    const r = this._getConnection();
    r.body = JSON.stringify(e), r.setHeader("content-type", "application/json");
    const i = await r.send();
    i.assertOk();
    let u = i.bodyJson;
    return Array.isArray(u) || (u = [u]), u;
  }
}
Nv = /* @__PURE__ */ new WeakMap();
function $5(a) {
  if (a == null)
    return null;
  if (typeof a.message == "string" && a.message.match(/revert/i) && ln(a.data))
    return { message: a.message, data: a.data };
  if (typeof a == "object") {
    for (const e in a) {
      const r = $5(a[e]);
      if (r)
        return r;
    }
    return null;
  }
  if (typeof a == "string")
    try {
      return $5(JSON.parse(a));
    } catch {
    }
  return null;
}
function Q5(a, e) {
  if (a != null) {
    if (typeof a.message == "string" && e.push(a.message), typeof a == "object")
      for (const r in a)
        Q5(a[r], e);
    if (typeof a == "string")
      try {
        return Q5(JSON.parse(a), e);
      } catch {
      }
  }
}
function dM(a) {
  const e = [];
  return Q5(a, e), e;
}
const hM = "1.0.8";
let _i = class Z5 extends Error {
  constructor(e, r = {}) {
    var i;
    const u = r.cause instanceof Z5 ? r.cause.details : (i = r.cause) != null && i.message ? r.cause.message : r.details, d = r.cause instanceof Z5 && r.cause.docsPath || r.docsPath, g = [
      e || "An error occurred.",
      "",
      ...r.metaMessages ? [...r.metaMessages, ""] : [],
      ...d ? [`Docs: https://abitype.dev${d}`] : [],
      ...u ? [`Details: ${u}`] : [],
      `Version: abitype@${hM}`
    ].join(`
`);
    super(g), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), r.cause && (this.cause = r.cause), this.details = u, this.docsPath = d, this.metaMessages = r.metaMessages, this.shortMessage = e;
  }
};
function Vd(a, e) {
  var r;
  return (r = a.exec(e)) == null ? void 0 : r.groups;
}
const CT = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, TT = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, IT = /^\(.+?\).*?$/, NT = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function pM(a) {
  return NT.test(a);
}
function gM(a) {
  return Vd(NT, a);
}
const PT = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function mM(a) {
  return PT.test(a);
}
function yM(a) {
  return Vd(PT, a);
}
const OT = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function bM(a) {
  return OT.test(a);
}
function vM(a) {
  return Vd(OT, a);
}
const RT = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function LT(a) {
  return RT.test(a);
}
function wM(a) {
  return Vd(RT, a);
}
const DT = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function kM(a) {
  return DT.test(a);
}
function EM(a) {
  return Vd(DT, a);
}
const BT = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function SM(a) {
  return BT.test(a);
}
function AM(a) {
  return Vd(BT, a);
}
const xM = /^receive\(\) external payable$/;
function CM(a) {
  return xM.test(a);
}
const TM = /* @__PURE__ */ new Set(["indexed"]), Y5 = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class IM extends _i {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class NM extends _i {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [`Type "${e}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class PM extends _i {
  constructor({ param: e }) {
    super("Invalid ABI parameter.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class OM extends _i {
  constructor({ param: e, name: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `"${r}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class RM extends _i {
  constructor({ param: e, type: r, modifier: i }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${i}" not allowed${r ? ` in "${r}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class LM extends _i {
  constructor({ param: e, type: r, modifier: i }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${i}" not allowed${r ? ` in "${r}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${i}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class DM extends _i {
  constructor({ abiParameter: e }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(e, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
let r1 = class extends _i {
  constructor({ signature: e, type: r }) {
    super(`Invalid ${r} signature.`, {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
};
class BM extends _i {
  constructor({ signature: e }) {
    super("Unknown signature.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class MM extends _i {
  constructor({ signature: e }) {
    super("Invalid struct signature.", {
      details: e,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class FM extends _i {
  constructor({ type: e }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${e}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class _M extends _i {
  constructor({ current: e, depth: r }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${e.trim()}" has too many ${r > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${r}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function UM(a, e, r) {
  let i = "";
  if (r)
    for (const u of Object.entries(r)) {
      if (!u)
        continue;
      let d = "";
      for (const g of u[1])
        d += `[${g.type}${g.name ? `:${g.name}` : ""}]`;
      i += `(${u[0]}{${d}})`;
    }
  return e ? `${e}:${a}${i}` : a;
}
const M8 = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function zM(a, e = {}) {
  if (bM(a))
    return HM(a, e);
  if (mM(a))
    return VM(a, e);
  if (pM(a))
    return WM(a, e);
  if (kM(a))
    return GM(a, e);
  if (SM(a))
    return jM(a);
  if (CM(a))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new BM({ signature: a });
}
function HM(a, e = {}) {
  const r = vM(a);
  if (!r)
    throw new r1({ signature: a, type: "function" });
  const i = Hs(r.parameters), u = [], d = i.length;
  for (let b = 0; b < d; b++)
    u.push(Ag(i[b], {
      modifiers: Y5,
      structs: e,
      type: "function"
    }));
  const g = [];
  if (r.returns) {
    const b = Hs(r.returns), y = b.length;
    for (let k = 0; k < y; k++)
      g.push(Ag(b[k], {
        modifiers: Y5,
        structs: e,
        type: "function"
      }));
  }
  return {
    name: r.name,
    type: "function",
    stateMutability: r.stateMutability ?? "nonpayable",
    inputs: u,
    outputs: g
  };
}
function VM(a, e = {}) {
  const r = yM(a);
  if (!r)
    throw new r1({ signature: a, type: "event" });
  const i = Hs(r.parameters), u = [], d = i.length;
  for (let g = 0; g < d; g++)
    u.push(Ag(i[g], {
      modifiers: TM,
      structs: e,
      type: "event"
    }));
  return { name: r.name, type: "event", inputs: u };
}
function WM(a, e = {}) {
  const r = gM(a);
  if (!r)
    throw new r1({ signature: a, type: "error" });
  const i = Hs(r.parameters), u = [], d = i.length;
  for (let g = 0; g < d; g++)
    u.push(Ag(i[g], { structs: e, type: "error" }));
  return { name: r.name, type: "error", inputs: u };
}
function GM(a, e = {}) {
  const r = EM(a);
  if (!r)
    throw new r1({ signature: a, type: "constructor" });
  const i = Hs(r.parameters), u = [], d = i.length;
  for (let g = 0; g < d; g++)
    u.push(Ag(i[g], { structs: e, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: r.stateMutability ?? "nonpayable",
    inputs: u
  };
}
function jM(a) {
  const e = AM(a);
  if (!e)
    throw new r1({ signature: a, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: e.stateMutability ?? "nonpayable"
  };
}
const $M = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, QM = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, ZM = /^u?int$/;
function Ag(a, e) {
  var r, i;
  const u = UM(a, e?.type, e?.structs);
  if (M8.has(u))
    return M8.get(u);
  const d = IT.test(a), g = Vd(d ? QM : $M, a);
  if (!g)
    throw new PM({ param: a });
  if (g.name && qM(g.name))
    throw new OM({ param: a, name: g.name });
  const b = g.name ? { name: g.name } : {}, y = g.modifier === "indexed" ? { indexed: !0 } : {}, k = e?.structs ?? {};
  let S, A = {};
  if (d) {
    S = "tuple";
    const M = Hs(g.type), D = [], O = M.length;
    for (let T = 0; T < O; T++)
      D.push(Ag(M[T], { structs: k }));
    A = { components: D };
  } else if (g.type in k)
    S = "tuple", A = { components: k[g.type] };
  else if (ZM.test(g.type))
    S = `${g.type}256`;
  else if (S = g.type, e?.type !== "struct" && !MT(S))
    throw new NM({ type: S });
  if (g.modifier) {
    if (!((i = (r = e?.modifiers) == null ? void 0 : r.has) != null && i.call(r, g.modifier)))
      throw new RM({
        param: a,
        type: e?.type,
        modifier: g.modifier
      });
    if (Y5.has(g.modifier) && !KM(S, !!g.array))
      throw new LM({
        param: a,
        type: e?.type,
        modifier: g.modifier
      });
  }
  const x = {
    type: `${S}${g.array ?? ""}`,
    ...b,
    ...y,
    ...A
  };
  return M8.set(u, x), x;
}
function Hs(a, e = [], r = "", i = 0) {
  const u = a.trim().length;
  for (let d = 0; d < u; d++) {
    const g = a[d], b = a.slice(d + 1);
    switch (g) {
      case ",":
        return i === 0 ? Hs(b, [...e, r.trim()]) : Hs(b, e, `${r}${g}`, i);
      case "(":
        return Hs(b, e, `${r}${g}`, i + 1);
      case ")":
        return Hs(b, e, `${r}${g}`, i - 1);
      default:
        return Hs(b, e, `${r}${g}`, i);
    }
  }
  if (r === "")
    return e;
  if (i !== 0)
    throw new _M({ current: r, depth: i });
  return e.push(r.trim()), e;
}
function MT(a) {
  return a === "address" || a === "bool" || a === "function" || a === "string" || CT.test(a) || TT.test(a);
}
const YM = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function qM(a) {
  return a === "address" || a === "bool" || a === "function" || a === "string" || a === "tuple" || CT.test(a) || TT.test(a) || YM.test(a);
}
function KM(a, e) {
  return e || a === "bytes" || a === "string" || a === "tuple";
}
function JM(a) {
  const e = {}, r = a.length;
  for (let g = 0; g < r; g++) {
    const b = a[g];
    if (!LT(b))
      continue;
    const y = wM(b);
    if (!y)
      throw new r1({ signature: b, type: "struct" });
    const k = y.properties.split(";"), S = [], A = k.length;
    for (let x = 0; x < A; x++) {
      const M = k[x].trim();
      if (!M)
        continue;
      const D = Ag(M, {
        type: "struct"
      });
      S.push(D);
    }
    if (!S.length)
      throw new MM({ signature: b });
    e[y.name] = S;
  }
  const i = {}, u = Object.entries(e), d = u.length;
  for (let g = 0; g < d; g++) {
    const [b, y] = u[g];
    i[b] = FT(y, e);
  }
  return i;
}
const XM = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function FT(a, e, r = /* @__PURE__ */ new Set()) {
  const i = [], u = a.length;
  for (let d = 0; d < u; d++) {
    const g = a[d];
    if (IT.test(g.type))
      i.push(g);
    else {
      const b = Vd(XM, g.type);
      if (!(b != null && b.type))
        throw new DM({ abiParameter: g });
      const { array: y, type: k } = b;
      if (k in e) {
        if (r.has(k))
          throw new FM({ type: k });
        i.push({
          ...g,
          type: `tuple${y ?? ""}`,
          components: FT(e[k] ?? [], e, /* @__PURE__ */ new Set([...r, k]))
        });
      } else if (MT(k))
        i.push(g);
      else
        throw new IM({ type: k });
    }
  }
  return i;
}
function eF(a) {
  const e = JM(a), r = [], i = a.length;
  for (let u = 0; u < i; u++) {
    const d = a[u];
    LT(d) || r.push(zM(d, e));
  }
  return r;
}
const Nk = [
  "constructor()",
  "error AccessControlBadConfirmation()",
  "error AccessControlUnauthorizedAccount(address account, bytes32 neededRole)",
  "error AddressEmptyCode(address target)",
  "error DER_Split_Error()",
  "error ECDSAInvalidSignature()",
  "error ECDSAInvalidSignatureLength(uint256 length)",
  "error ECDSAInvalidSignatureS(bytes32 s)",
  "error ERC1967InvalidImplementation(address implementation)",
  "error ERC1967NonPayable()",
  "error FailedInnerCall()",
  "error InvalidInitialization()",
  "error NotInitializing()",
  "error UUPSUnauthorizedCallContext()",
  "error UUPSUnsupportedProxiableUUID(bytes32 slot)",
  "error expmod_Error()",
  "error k256Decompress_Invalid_Length_Error()",
  "error k256DeriveY_Invalid_Prefix_Error()",
  "error recoverV_Error()",
  "event GaslessTransaction(bytes32 indexed dataHash, bytes32 indexed hashedUsername, address indexed publicAddress)",
  "event Initialized(uint64 version)",
  "event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)",
  "event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)",
  "event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)",
  "event Upgraded(address indexed implementation)",
  "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
  "function UPGRADE_INTERFACE_VERSION() view returns (string)",
  "function addWallet((bytes32 credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) resp, bytes data) args)",
  "function addWalletPassword((bytes32 hashedUsername, bytes32 digest, bytes data) args)",
  "function createAccount((bytes32 hashedUsername, bytes credentialId, (uint8 kty, int8 alg, uint8 crv, uint256 x, uint256 y) pubkey, bytes32 optionalPassword, (uint8 walletType, bytes32 keypairSecret) wallet) args)",
  "function credentialIdsByUsername(bytes32 in_hashedUsername) view returns (bytes[] out_credentialIds)",
  "function encryptedTx(bytes32 nonce, bytes ciphertext, uint256 timestamp, bytes32 dataHash)",
  "function gaspayingAddress() view returns (address)",
  "function generateGaslessTx(bytes in_data, uint64 nonce, uint256 gasPrice, uint64 gasLimit, uint256 timestamp, bytes signature) view returns (bytes out_data)",
  "function getAccount(bytes32 in_username, uint8 walletType) view returns (address)",
  "function getRoleAdmin(bytes32 role) view returns (bytes32)",
  "function grantRole(bytes32 role, address account)",
  "function hasRole(bytes32 role, address account) view returns (bool)",
  "function hashUsage(bytes32) view returns (bool)",
  "function initialize(address _accountFactory, address _signer) payable",
  "function manageCredential((bytes32 credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) resp, bytes data) args)",
  "function manageCredentialPassword((bytes32 hashedUsername, bytes32 digest, bytes data) args)",
  "function personalization() view returns (bytes32)",
  "function proxiableUUID() view returns (bytes32)",
  "function proxyView(bytes32 in_credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) in_resp, uint8 walletType, bytes in_data) view returns (bytes out_data)",
  "function proxyViewPassword(bytes32 in_hashedUsername, uint8 walletType, bytes32 in_digest, bytes in_data) view returns (bytes out_data)",
  "function removeWallet((bytes32 credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) resp, bytes data) args)",
  "function removeWalletPassword((bytes32 hashedUsername, bytes32 digest, bytes data) args)",
  "function renounceRole(bytes32 role, address callerConfirmation)",
  "function revokeRole(bytes32 role, address account)",
  "function salt() view returns (bytes32)",
  "function setSigner(address _signer)",
  "function signer() view returns (address)",
  "function supportsInterface(bytes4 interfaceId) view returns (bool)",
  "function upgradeToAndCall(address newImplementation, bytes data) payable",
  "function userExists(bytes32 in_username) view returns (bool)",
  "function validateSignature(uint256 _gasPrice, uint64 _gasLimit, uint256 _timestamp, bytes32 _dataKeccak, bytes _signature) view returns (bytes32, bool)"
], U2 = [
  "error DER_Split_Error()",
  "error expmod_Error()",
  "error k256Decompress_Invalid_Length_Error()",
  "error k256DeriveY_Invalid_Prefix_Error()",
  "error recoverV_Error()",
  "function addressToBytes32(address _addr) pure returns (bytes32)",
  "function bytes32ToAddress(bytes32 _b) pure returns (address)",
  "function call(address in_contract, bytes in_data) returns (bytes out_data)",
  "function createWallet(bytes32 keypairSecret) returns (address)",
  "function exportPrivateKey(uint256 walletId) view returns (bytes32)",
  "function getWalletList() view returns (bytes32[])",
  "function init(address initialController, bytes32 keypairSecret)",
  "function isController(address who) view returns (bool)",
  "function modifyController(address who, bool status)",
  "function removeWallet(uint256 walletId)",
  "function sign(uint256 walletId, bytes32 digest) view returns ((bytes32 r, bytes32 s, uint256 v))",
  "function signEIP155(uint256 walletId, (uint64 nonce, uint256 gasPrice, uint64 gasLimit, address to, uint256 value, bytes data, uint256 chainId) txToSign) view returns (bytes)",
  "function staticcall(address in_contract, bytes in_data) view returns (bytes out_data)",
  "function transfer(address in_target, uint256 amount)",
  "function walletAddress(uint256 walletId) view returns (bytes32)"
], my = [
  {
    inputs: [
      { internalType: "string", name: "name", type: "string" },
      { internalType: "string", name: "symbol", type: "string" },
      { internalType: "address", name: "_receiver", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "spender", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "subtractedValue", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "addedValue", type: "uint256" }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "maxSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];
eF(Nk);
var Z4 = /* @__PURE__ */ ((a) => (a[a.CreateAccount = 0] = "CreateAccount", a[a.ManageCredential = 1] = "ManageCredential", a[a.ManageCredentialPassword = 2] = "ManageCredentialPassword", a[a.AddWallet = 3] = "AddWallet", a[a.AddWalletPassword = 4] = "AddWalletPassword", a))(Z4 || {});
function P9(a) {
  if (!Number.isSafeInteger(a) || a < 0)
    throw new Error("positive integer expected, got " + a);
}
function tF(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function Pk(a, ...e) {
  if (!tF(a))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(a.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + a.length);
}
function nF(a) {
  if (typeof a != "function" || typeof a.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  P9(a.outputLen), P9(a.blockLen);
}
function lk(a, e = !0) {
  if (a.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && a.finished)
    throw new Error("Hash#digest() has already been called");
}
function rF(a, e) {
  Pk(a);
  const r = e.outputLen;
  if (a.length < r)
    throw new Error("digestInto() expects output buffer of length at least " + r);
}
const Y0 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function F8(a) {
  return new DataView(a.buffer, a.byteOffset, a.byteLength);
}
function zl(a, e) {
  return a << 32 - e | a >>> e;
}
function aF(a) {
  if (typeof a != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof a);
  return new Uint8Array(new TextEncoder().encode(a));
}
function WE(a) {
  return typeof a == "string" && (a = aF(a)), Pk(a), a;
}
function oF(...a) {
  let e = 0;
  for (let i = 0; i < a.length; i++) {
    const u = a[i];
    Pk(u), e += u.length;
  }
  const r = new Uint8Array(e);
  for (let i = 0, u = 0; i < a.length; i++) {
    const d = a[i];
    r.set(d, u), u += d.length;
  }
  return r;
}
let _T = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function iF(a) {
  const e = (i) => a().update(WE(i)).digest(), r = a();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => a(), e;
}
function sF(a = 32) {
  if (Y0 && typeof Y0.getRandomValues == "function")
    return Y0.getRandomValues(new Uint8Array(a));
  if (Y0 && typeof Y0.randomBytes == "function")
    return Y0.randomBytes(a);
  throw new Error("crypto.getRandomValues must be defined");
}
function lF(a, e, r, i) {
  if (typeof a.setBigUint64 == "function")
    return a.setBigUint64(e, r, i);
  const u = BigInt(32), d = BigInt(4294967295), g = Number(r >> u & d), b = Number(r & d), y = i ? 4 : 0, k = i ? 0 : 4;
  a.setUint32(e + y, g, i), a.setUint32(e + k, b, i);
}
function uF(a, e, r) {
  return a & e ^ ~a & r;
}
function cF(a, e, r) {
  return a & e ^ a & r ^ e & r;
}
class fF extends _T {
  constructor(e, r, i, u) {
    super(), this.blockLen = e, this.outputLen = r, this.padOffset = i, this.isLE = u, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = F8(this.buffer);
  }
  update(e) {
    lk(this);
    const { view: r, buffer: i, blockLen: u } = this;
    e = WE(e);
    const d = e.length;
    for (let g = 0; g < d; ) {
      const b = Math.min(u - this.pos, d - g);
      if (b === u) {
        const y = F8(e);
        for (; u <= d - g; g += u)
          this.process(y, g);
        continue;
      }
      i.set(e.subarray(g, g + b), this.pos), this.pos += b, g += b, this.pos === u && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    lk(this), rF(e, this), this.finished = !0;
    const { buffer: r, view: i, blockLen: u, isLE: d } = this;
    let { pos: g } = this;
    r[g++] = 128, this.buffer.subarray(g).fill(0), this.padOffset > u - g && (this.process(i, 0), g = 0);
    for (let A = g; A < u; A++)
      r[A] = 0;
    lF(i, u - 8, BigInt(this.length * 8), d), this.process(i, 0);
    const b = F8(e), y = this.outputLen;
    if (y % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const k = y / 4, S = this.get();
    if (k > S.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let A = 0; A < k; A++)
      b.setUint32(4 * A, S[A], d);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const i = e.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: i, length: u, finished: d, destroyed: g, pos: b } = this;
    return e.length = u, e.pos = b, e.finished = d, e.destroyed = g, u % r && e.buffer.set(i), e;
  }
}
const dF = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), hd = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), pd = /* @__PURE__ */ new Uint32Array(64);
class hF extends fF {
  constructor() {
    super(64, 32, 8, !1), this.A = hd[0] | 0, this.B = hd[1] | 0, this.C = hd[2] | 0, this.D = hd[3] | 0, this.E = hd[4] | 0, this.F = hd[5] | 0, this.G = hd[6] | 0, this.H = hd[7] | 0;
  }
  get() {
    const { A: e, B: r, C: i, D: u, E: d, F: g, G: b, H: y } = this;
    return [e, r, i, u, d, g, b, y];
  }
  // prettier-ignore
  set(e, r, i, u, d, g, b, y) {
    this.A = e | 0, this.B = r | 0, this.C = i | 0, this.D = u | 0, this.E = d | 0, this.F = g | 0, this.G = b | 0, this.H = y | 0;
  }
  process(e, r) {
    for (let A = 0; A < 16; A++, r += 4)
      pd[A] = e.getUint32(r, !1);
    for (let A = 16; A < 64; A++) {
      const x = pd[A - 15], M = pd[A - 2], D = zl(x, 7) ^ zl(x, 18) ^ x >>> 3, O = zl(M, 17) ^ zl(M, 19) ^ M >>> 10;
      pd[A] = O + pd[A - 7] + D + pd[A - 16] | 0;
    }
    let { A: i, B: u, C: d, D: g, E: b, F: y, G: k, H: S } = this;
    for (let A = 0; A < 64; A++) {
      const x = zl(b, 6) ^ zl(b, 11) ^ zl(b, 25), M = S + x + uF(b, y, k) + dF[A] + pd[A] | 0, D = (zl(i, 2) ^ zl(i, 13) ^ zl(i, 22)) + cF(i, u, d) | 0;
      S = k, k = y, y = b, b = g + M | 0, g = d, d = u, u = i, i = M + D | 0;
    }
    i = i + this.A | 0, u = u + this.B | 0, d = d + this.C | 0, g = g + this.D | 0, b = b + this.E | 0, y = y + this.F | 0, k = k + this.G | 0, S = S + this.H | 0, this.set(i, u, d, g, b, y, k, S);
  }
  roundClean() {
    pd.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const pF = /* @__PURE__ */ iF(() => new hF());
class UT extends _T {
  constructor(e, r) {
    super(), this.finished = !1, this.destroyed = !1, nF(e);
    const i = WE(r);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const u = this.blockLen, d = new Uint8Array(u);
    d.set(i.length > u ? e.create().update(i).digest() : i);
    for (let g = 0; g < d.length; g++)
      d[g] ^= 54;
    this.iHash.update(d), this.oHash = e.create();
    for (let g = 0; g < d.length; g++)
      d[g] ^= 106;
    this.oHash.update(d), d.fill(0);
  }
  update(e) {
    return lk(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    lk(this), Pk(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: i, finished: u, destroyed: d, blockLen: g, outputLen: b } = this;
    return e = e, e.finished = u, e.destroyed = d, e.blockLen = g, e.outputLen = b, e.oHash = r._cloneInto(e.oHash), e.iHash = i._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const zT = (a, e, r) => new UT(a, e).update(r).digest();
zT.create = (a, e) => new UT(a, e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ok = /* @__PURE__ */ BigInt(0), Rk = /* @__PURE__ */ BigInt(1), gF = /* @__PURE__ */ BigInt(2);
function xg(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function sw(a) {
  if (!xg(a))
    throw new Error("Uint8Array expected");
}
function Gy(a, e) {
  if (typeof e != "boolean")
    throw new Error(a + " boolean expected, got " + e);
}
const mF = /* @__PURE__ */ Array.from({ length: 256 }, (a, e) => e.toString(16).padStart(2, "0"));
function Cg(a) {
  sw(a);
  let e = "";
  for (let r = 0; r < a.length; r++)
    e += mF[a[r]];
  return e;
}
function Sy(a) {
  const e = a.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function GE(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  return a === "" ? Ok : BigInt("0x" + a);
}
const gc = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function O9(a) {
  if (a >= gc._0 && a <= gc._9)
    return a - gc._0;
  if (a >= gc.A && a <= gc.F)
    return a - (gc.A - 10);
  if (a >= gc.a && a <= gc.f)
    return a - (gc.a - 10);
}
function jy(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  const e = a.length, r = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const i = new Uint8Array(r);
  for (let u = 0, d = 0; u < r; u++, d += 2) {
    const g = O9(a.charCodeAt(d)), b = O9(a.charCodeAt(d + 1));
    if (g === void 0 || b === void 0) {
      const y = a[d] + a[d + 1];
      throw new Error('hex string expected, got non-hex character "' + y + '" at index ' + d);
    }
    i[u] = g * 16 + b;
  }
  return i;
}
function hg(a) {
  return GE(Cg(a));
}
function jE(a) {
  return sw(a), GE(Cg(Uint8Array.from(a).reverse()));
}
function $y(a, e) {
  return jy(a.toString(16).padStart(e * 2, "0"));
}
function $E(a, e) {
  return $y(a, e).reverse();
}
function yF(a) {
  return jy(Sy(a));
}
function Bs(a, e, r) {
  let i;
  if (typeof e == "string")
    try {
      i = jy(e);
    } catch (d) {
      throw new Error(a + " must be hex string or Uint8Array, cause: " + d);
    }
  else if (xg(e))
    i = Uint8Array.from(e);
  else
    throw new Error(a + " must be hex string or Uint8Array");
  const u = i.length;
  if (typeof r == "number" && u !== r)
    throw new Error(a + " of length " + r + " expected, got " + u);
  return i;
}
function $v(...a) {
  let e = 0;
  for (let i = 0; i < a.length; i++) {
    const u = a[i];
    sw(u), e += u.length;
  }
  const r = new Uint8Array(e);
  for (let i = 0, u = 0; i < a.length; i++) {
    const d = a[i];
    r.set(d, u), u += d.length;
  }
  return r;
}
function bF(a, e) {
  if (a.length !== e.length)
    return !1;
  let r = 0;
  for (let i = 0; i < a.length; i++)
    r |= a[i] ^ e[i];
  return r === 0;
}
function vF(a) {
  if (typeof a != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(a));
}
const _8 = (a) => typeof a == "bigint" && Ok <= a;
function Lk(a, e, r) {
  return _8(a) && _8(e) && _8(r) && e <= a && a < r;
}
function pg(a, e, r, i) {
  if (!Lk(e, r, i))
    throw new Error("expected valid " + a + ": " + r + " <= n < " + i + ", got " + e);
}
function HT(a) {
  let e;
  for (e = 0; a > Ok; a >>= Rk, e += 1)
    ;
  return e;
}
function wF(a, e) {
  return a >> BigInt(e) & Rk;
}
function kF(a, e, r) {
  return a | (r ? Rk : Ok) << BigInt(e);
}
const QE = (a) => (gF << BigInt(a - 1)) - Rk, U8 = (a) => new Uint8Array(a), R9 = (a) => Uint8Array.from(a);
function VT(a, e, r) {
  if (typeof a != "number" || a < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let i = U8(a), u = U8(a), d = 0;
  const g = () => {
    i.fill(1), u.fill(0), d = 0;
  }, b = (...S) => r(u, i, ...S), y = (S = U8()) => {
    u = b(R9([0]), S), i = b(), S.length !== 0 && (u = b(R9([1]), S), i = b());
  }, k = () => {
    if (d++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let S = 0;
    const A = [];
    for (; S < e; ) {
      i = b();
      const x = i.slice();
      A.push(x), S += i.length;
    }
    return $v(...A);
  };
  return (S, A) => {
    g(), y(S);
    let x;
    for (; !(x = A(k())); )
      y();
    return g(), x;
  };
}
const EF = {
  bigint: (a) => typeof a == "bigint",
  function: (a) => typeof a == "function",
  boolean: (a) => typeof a == "boolean",
  string: (a) => typeof a == "string",
  stringOrUint8Array: (a) => typeof a == "string" || xg(a),
  isSafeInteger: (a) => Number.isSafeInteger(a),
  array: (a) => Array.isArray(a),
  field: (a, e) => e.Fp.isValid(a),
  hash: (a) => typeof a == "function" && Number.isSafeInteger(a.outputLen)
};
function lw(a, e, r = {}) {
  const i = (u, d, g) => {
    const b = EF[d];
    if (typeof b != "function")
      throw new Error("invalid validator function");
    const y = a[u];
    if (!(g && y === void 0) && !b(y, a))
      throw new Error("param " + String(u) + " is invalid. Expected " + d + ", got " + y);
  };
  for (const [u, d] of Object.entries(e))
    i(u, d, !1);
  for (const [u, d] of Object.entries(r))
    i(u, d, !0);
  return a;
}
const SF = () => {
  throw new Error("not implemented");
};
function q5(a) {
  const e = /* @__PURE__ */ new WeakMap();
  return (r, ...i) => {
    const u = e.get(r);
    if (u !== void 0)
      return u;
    const d = a(r, ...i);
    return e.set(r, d), d;
  };
}
const AF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange: pg,
  abool: Gy,
  abytes: sw,
  bitGet: wF,
  bitLen: HT,
  bitMask: QE,
  bitSet: kF,
  bytesToHex: Cg,
  bytesToNumberBE: hg,
  bytesToNumberLE: jE,
  concatBytes: $v,
  createHmacDrbg: VT,
  ensureBytes: Bs,
  equalBytes: bF,
  hexToBytes: jy,
  hexToNumber: GE,
  inRange: Lk,
  isBytes: xg,
  memoized: q5,
  notImplemented: SF,
  numberToBytesBE: $y,
  numberToBytesLE: $E,
  numberToHexUnpadded: Sy,
  numberToVarBytesBE: yF,
  utf8ToBytes: vF,
  validateObject: lw
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Kr = BigInt(0), Yn = BigInt(1), qp = /* @__PURE__ */ BigInt(2), xF = /* @__PURE__ */ BigInt(3), K5 = /* @__PURE__ */ BigInt(4), L9 = /* @__PURE__ */ BigInt(5), D9 = /* @__PURE__ */ BigInt(8);
function Bi(a, e) {
  const r = a % e;
  return r >= Kr ? r : e + r;
}
function CF(a, e, r) {
  if (e < Kr)
    throw new Error("invalid exponent, negatives unsupported");
  if (r <= Kr)
    throw new Error("invalid modulus");
  if (r === Yn)
    return Kr;
  let i = Yn;
  for (; e > Kr; )
    e & Yn && (i = i * a % r), a = a * a % r, e >>= Yn;
  return i;
}
function J5(a, e) {
  if (a === Kr)
    throw new Error("invert: expected non-zero number");
  if (e <= Kr)
    throw new Error("invert: expected positive modulus, got " + e);
  let r = Bi(a, e), i = e, u = Kr, d = Yn;
  for (; r !== Kr; ) {
    const g = i / r, b = i % r, y = u - d * g;
    i = r, r = b, u = d, d = y;
  }
  if (i !== Yn)
    throw new Error("invert: does not exist");
  return Bi(u, e);
}
function TF(a) {
  const e = (a - Yn) / qp;
  let r, i, u;
  for (r = a - Yn, i = 0; r % qp === Kr; r /= qp, i++)
    ;
  for (u = qp; u < a && CF(u, e, a) !== a - Yn; u++)
    if (u > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  if (i === 1) {
    const g = (a + Yn) / K5;
    return function(b, y) {
      const k = b.pow(y, g);
      if (!b.eql(b.sqr(k), y))
        throw new Error("Cannot find square root");
      return k;
    };
  }
  const d = (r + Yn) / qp;
  return function(g, b) {
    if (g.pow(b, e) === g.neg(g.ONE))
      throw new Error("Cannot find square root");
    let y = i, k = g.pow(g.mul(g.ONE, u), r), S = g.pow(b, d), A = g.pow(b, r);
    for (; !g.eql(A, g.ONE); ) {
      if (g.eql(A, g.ZERO))
        return g.ZERO;
      let x = 1;
      for (let D = g.sqr(A); x < y && !g.eql(D, g.ONE); x++)
        D = g.sqr(D);
      const M = g.pow(k, Yn << BigInt(y - x - 1));
      k = g.sqr(M), S = g.mul(S, M), A = g.mul(A, k), y = x;
    }
    return S;
  };
}
function IF(a) {
  if (a % K5 === xF) {
    const e = (a + Yn) / K5;
    return function(r, i) {
      const u = r.pow(i, e);
      if (!r.eql(r.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  if (a % D9 === L9) {
    const e = (a - L9) / D9;
    return function(r, i) {
      const u = r.mul(i, qp), d = r.pow(u, e), g = r.mul(i, d), b = r.mul(r.mul(g, qp), d), y = r.mul(g, r.sub(b, r.ONE));
      if (!r.eql(r.sqr(y), i))
        throw new Error("Cannot find square root");
      return y;
    };
  }
  return TF(a);
}
const NF = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function PF(a) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = NF.reduce((i, u) => (i[u] = "function", i), e);
  return lw(a, r);
}
function OF(a, e, r) {
  if (r < Kr)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === Kr)
    return a.ONE;
  if (r === Yn)
    return e;
  let i = a.ONE, u = e;
  for (; r > Kr; )
    r & Yn && (i = a.mul(i, u)), u = a.sqr(u), r >>= Yn;
  return i;
}
function RF(a, e) {
  const r = new Array(e.length), i = e.reduce((d, g, b) => a.is0(g) ? d : (r[b] = d, a.mul(d, g)), a.ONE), u = a.inv(i);
  return e.reduceRight((d, g, b) => a.is0(g) ? d : (r[b] = a.mul(d, r[b]), a.mul(d, g)), u), r;
}
function WT(a, e) {
  const r = e !== void 0 ? e : a.toString(2).length, i = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: i };
}
function GT(a, e, r = !1, i = {}) {
  if (a <= Kr)
    throw new Error("invalid field: expected ORDER > 0, got " + a);
  const { nBitLength: u, nByteLength: d } = WT(a, e);
  if (d > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let g;
  const b = Object.freeze({
    ORDER: a,
    isLE: r,
    BITS: u,
    BYTES: d,
    MASK: QE(u),
    ZERO: Kr,
    ONE: Yn,
    create: (y) => Bi(y, a),
    isValid: (y) => {
      if (typeof y != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof y);
      return Kr <= y && y < a;
    },
    is0: (y) => y === Kr,
    isOdd: (y) => (y & Yn) === Yn,
    neg: (y) => Bi(-y, a),
    eql: (y, k) => y === k,
    sqr: (y) => Bi(y * y, a),
    add: (y, k) => Bi(y + k, a),
    sub: (y, k) => Bi(y - k, a),
    mul: (y, k) => Bi(y * k, a),
    pow: (y, k) => OF(b, y, k),
    div: (y, k) => Bi(y * J5(k, a), a),
    // Same as above, but doesn't normalize
    sqrN: (y) => y * y,
    addN: (y, k) => y + k,
    subN: (y, k) => y - k,
    mulN: (y, k) => y * k,
    inv: (y) => J5(y, a),
    sqrt: i.sqrt || ((y) => (g || (g = IF(a)), g(b, y))),
    invertBatch: (y) => RF(b, y),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (y, k, S) => S ? k : y,
    toBytes: (y) => r ? $E(y, d) : $y(y, d),
    fromBytes: (y) => {
      if (y.length !== d)
        throw new Error("Field.fromBytes: expected " + d + " bytes, got " + y.length);
      return r ? jE(y) : hg(y);
    }
  });
  return Object.freeze(b);
}
function jT(a) {
  if (typeof a != "bigint")
    throw new Error("field order must be bigint");
  const e = a.toString(2).length;
  return Math.ceil(e / 8);
}
function $T(a) {
  const e = jT(a);
  return e + Math.ceil(e / 2);
}
function LF(a, e, r = !1) {
  const i = a.length, u = jT(e), d = $T(e);
  if (i < 16 || i < d || i > 1024)
    throw new Error("expected " + d + "-1024 bytes of input, got " + i);
  const g = r ? jE(a) : hg(a), b = Bi(g, e - Yn) + Yn;
  return r ? $E(b, u) : $y(b, u);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const B9 = BigInt(0), m4 = BigInt(1);
function z8(a, e) {
  const r = e.negate();
  return a ? r : e;
}
function QT(a, e) {
  if (!Number.isSafeInteger(a) || a <= 0 || a > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + a);
}
function H8(a, e) {
  QT(a, e);
  const r = Math.ceil(e / a) + 1, i = 2 ** (a - 1);
  return { windows: r, windowSize: i };
}
function DF(a, e) {
  if (!Array.isArray(a))
    throw new Error("array expected");
  a.forEach((r, i) => {
    if (!(r instanceof e))
      throw new Error("invalid point at index " + i);
  });
}
function BF(a, e) {
  if (!Array.isArray(a))
    throw new Error("array of scalars expected");
  a.forEach((r, i) => {
    if (!e.isValid(r))
      throw new Error("invalid scalar at index " + i);
  });
}
const V8 = /* @__PURE__ */ new WeakMap(), ZT = /* @__PURE__ */ new WeakMap();
function W8(a) {
  return ZT.get(a) || 1;
}
function MF(a, e) {
  return {
    constTimeNegate: z8,
    hasPrecomputes(r) {
      return W8(r) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(r, i, u = a.ZERO) {
      let d = r;
      for (; i > B9; )
        i & m4 && (u = u.add(d)), d = d.double(), i >>= m4;
      return u;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(r, i) {
      const { windows: u, windowSize: d } = H8(i, e), g = [];
      let b = r, y = b;
      for (let k = 0; k < u; k++) {
        y = b, g.push(y);
        for (let S = 1; S < d; S++)
          y = y.add(b), g.push(y);
        b = y.double();
      }
      return g;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(r, i, u) {
      const { windows: d, windowSize: g } = H8(r, e);
      let b = a.ZERO, y = a.BASE;
      const k = BigInt(2 ** r - 1), S = 2 ** r, A = BigInt(r);
      for (let x = 0; x < d; x++) {
        const M = x * g;
        let D = Number(u & k);
        u >>= A, D > g && (D -= S, u += m4);
        const O = M, T = M + Math.abs(D) - 1, L = x % 2 !== 0, U = D < 0;
        D === 0 ? y = y.add(z8(L, i[O])) : b = b.add(z8(U, i[T]));
      }
      return { p: b, f: y };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(r, i, u, d = a.ZERO) {
      const { windows: g, windowSize: b } = H8(r, e), y = BigInt(2 ** r - 1), k = 2 ** r, S = BigInt(r);
      for (let A = 0; A < g; A++) {
        const x = A * b;
        if (u === B9)
          break;
        let M = Number(u & y);
        if (u >>= S, M > b && (M -= k, u += m4), M === 0)
          continue;
        let D = i[x + Math.abs(M) - 1];
        M < 0 && (D = D.negate()), d = d.add(D);
      }
      return d;
    },
    getPrecomputes(r, i, u) {
      let d = V8.get(i);
      return d || (d = this.precomputeWindow(i, r), r !== 1 && V8.set(i, u(d))), d;
    },
    wNAFCached(r, i, u) {
      const d = W8(r);
      return this.wNAF(d, this.getPrecomputes(d, r, u), i);
    },
    wNAFCachedUnsafe(r, i, u, d) {
      const g = W8(r);
      return g === 1 ? this.unsafeLadder(r, i, d) : this.wNAFUnsafe(g, this.getPrecomputes(g, r, u), i, d);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(r, i) {
      QT(i, e), ZT.set(r, i), V8.delete(r);
    }
  };
}
function FF(a, e, r, i) {
  if (DF(r, a), BF(i, e), r.length !== i.length)
    throw new Error("arrays of points and scalars must have equal length");
  const u = a.ZERO, d = HT(BigInt(r.length)), g = d > 12 ? d - 3 : d > 4 ? d - 2 : d ? 2 : 1, b = (1 << g) - 1, y = new Array(b + 1).fill(u), k = Math.floor((e.BITS - 1) / g) * g;
  let S = u;
  for (let A = k; A >= 0; A -= g) {
    y.fill(u);
    for (let M = 0; M < i.length; M++) {
      const D = i[M], O = Number(D >> BigInt(A) & BigInt(b));
      y[O] = y[O].add(r[M]);
    }
    let x = u;
    for (let M = y.length - 1, D = u; M > 0; M--)
      D = D.add(y[M]), x = x.add(D);
    if (S = S.add(x), A !== 0)
      for (let M = 0; M < g; M++)
        S = S.double();
  }
  return S;
}
function YT(a) {
  return PF(a.Fp), lw(a, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...WT(a.n, a.nBitLength),
    ...a,
    p: a.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function M9(a) {
  a.lowS !== void 0 && Gy("lowS", a.lowS), a.prehash !== void 0 && Gy("prehash", a.prehash);
}
function _F(a) {
  const e = YT(a);
  lw(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: i, a: u } = e;
  if (r) {
    if (!i.eql(u, i.ZERO))
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: UF, hexToBytes: zF } = AF;
class HF extends Error {
  constructor(e = "") {
    super(e);
  }
}
const Ec = {
  // asn.1 DER encoding utils
  Err: HF,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (a, e) => {
      const { Err: r } = Ec;
      if (a < 0 || a > 256)
        throw new r("tlv.encode: wrong tag");
      if (e.length & 1)
        throw new r("tlv.encode: unpadded data");
      const i = e.length / 2, u = Sy(i);
      if (u.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const d = i > 127 ? Sy(u.length / 2 | 128) : "";
      return Sy(a) + d + u + e;
    },
    // v - value, l - left bytes (unparsed)
    decode(a, e) {
      const { Err: r } = Ec;
      let i = 0;
      if (a < 0 || a > 256)
        throw new r("tlv.encode: wrong tag");
      if (e.length < 2 || e[i++] !== a)
        throw new r("tlv.decode: wrong tlv");
      const u = e[i++], d = !!(u & 128);
      let g = 0;
      if (!d)
        g = u;
      else {
        const y = u & 127;
        if (!y)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (y > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const k = e.subarray(i, i + y);
        if (k.length !== y)
          throw new r("tlv.decode: length bytes not complete");
        if (k[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const S of k)
          g = g << 8 | S;
        if (i += y, g < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const b = e.subarray(i, i + g);
      if (b.length !== g)
        throw new r("tlv.decode: wrong value length");
      return { v: b, l: e.subarray(i + g) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(a) {
      const { Err: e } = Ec;
      if (a < Pc)
        throw new e("integer: negative integers are not allowed");
      let r = Sy(a);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new e("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(a) {
      const { Err: e } = Ec;
      if (a[0] & 128)
        throw new e("invalid signature integer: negative");
      if (a[0] === 0 && !(a[1] & 128))
        throw new e("invalid signature integer: unnecessary leading zero");
      return UF(a);
    }
  },
  toSig(a) {
    const { Err: e, _int: r, _tlv: i } = Ec, u = typeof a == "string" ? zF(a) : a;
    sw(u);
    const { v: d, l: g } = i.decode(48, u);
    if (g.length)
      throw new e("invalid signature: left bytes after parsing");
    const { v: b, l: y } = i.decode(2, d), { v: k, l: S } = i.decode(2, y);
    if (S.length)
      throw new e("invalid signature: left bytes after parsing");
    return { r: r.decode(b), s: r.decode(k) };
  },
  hexFromSig(a) {
    const { _tlv: e, _int: r } = Ec, i = e.encode(2, r.encode(a.r)), u = e.encode(2, r.encode(a.s)), d = i + u;
    return e.encode(48, d);
  }
}, Pc = BigInt(0), Br = BigInt(1);
BigInt(2);
const F9 = BigInt(3);
BigInt(4);
function VF(a) {
  const e = _F(a), { Fp: r } = e, i = GT(e.n, e.nBitLength), u = e.toBytes || ((O, T, L) => {
    const U = T.toAffine();
    return $v(Uint8Array.from([4]), r.toBytes(U.x), r.toBytes(U.y));
  }), d = e.fromBytes || ((O) => {
    const T = O.subarray(1), L = r.fromBytes(T.subarray(0, r.BYTES)), U = r.fromBytes(T.subarray(r.BYTES, 2 * r.BYTES));
    return { x: L, y: U };
  });
  function g(O) {
    const { a: T, b: L } = e, U = r.sqr(O), W = r.mul(U, O);
    return r.add(r.add(W, r.mul(O, T)), L);
  }
  if (!r.eql(r.sqr(e.Gy), g(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function b(O) {
    return Lk(O, Br, e.n);
  }
  function y(O) {
    const { allowedPrivateKeyLengths: T, nByteLength: L, wrapPrivateKey: U, n: W } = e;
    if (T && typeof O != "bigint") {
      if (xg(O) && (O = Cg(O)), typeof O != "string" || !T.includes(O.length))
        throw new Error("invalid private key");
      O = O.padStart(L * 2, "0");
    }
    let Z;
    try {
      Z = typeof O == "bigint" ? O : hg(Bs("private key", O, L));
    } catch {
      throw new Error("invalid private key, expected hex or " + L + " bytes, got " + typeof O);
    }
    return U && (Z = Bi(Z, W)), pg("private key", Z, Br, W), Z;
  }
  function k(O) {
    if (!(O instanceof x))
      throw new Error("ProjectivePoint expected");
  }
  const S = q5((O, T) => {
    const { px: L, py: U, pz: W } = O;
    if (r.eql(W, r.ONE))
      return { x: L, y: U };
    const Z = O.is0();
    T == null && (T = Z ? r.ONE : r.inv(W));
    const J = r.mul(L, T), Y = r.mul(U, T), X = r.mul(W, T);
    if (Z)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(X, r.ONE))
      throw new Error("invZ was invalid");
    return { x: J, y: Y };
  }), A = q5((O) => {
    if (O.is0()) {
      if (e.allowInfinityPoint && !r.is0(O.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: T, y: L } = O.toAffine();
    if (!r.isValid(T) || !r.isValid(L))
      throw new Error("bad point: x or y not FE");
    const U = r.sqr(L), W = g(T);
    if (!r.eql(U, W))
      throw new Error("bad point: equation left != right");
    if (!O.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class x {
    constructor(T, L, U) {
      if (this.px = T, this.py = L, this.pz = U, T == null || !r.isValid(T))
        throw new Error("x required");
      if (L == null || !r.isValid(L))
        throw new Error("y required");
      if (U == null || !r.isValid(U))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(T) {
      const { x: L, y: U } = T || {};
      if (!T || !r.isValid(L) || !r.isValid(U))
        throw new Error("invalid affine point");
      if (T instanceof x)
        throw new Error("projective point not allowed");
      const W = (Z) => r.eql(Z, r.ZERO);
      return W(L) && W(U) ? x.ZERO : new x(L, U, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(T) {
      const L = r.invertBatch(T.map((U) => U.pz));
      return T.map((U, W) => U.toAffine(L[W])).map(x.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(T) {
      const L = x.fromAffine(d(Bs("pointHex", T)));
      return L.assertValidity(), L;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(T) {
      return x.BASE.multiply(y(T));
    }
    // Multiscalar Multiplication
    static msm(T, L) {
      return FF(x, i, T, L);
    }
    // "Private method", don't use it directly
    _setWindowSize(T) {
      D.setWindowSize(this, T);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      A(this);
    }
    hasEvenY() {
      const { y: T } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(T);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(T) {
      k(T);
      const { px: L, py: U, pz: W } = this, { px: Z, py: J, pz: Y } = T, X = r.eql(r.mul(L, Y), r.mul(Z, W)), ee = r.eql(r.mul(U, Y), r.mul(J, W));
      return X && ee;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new x(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: T, b: L } = e, U = r.mul(L, F9), { px: W, py: Z, pz: J } = this;
      let Y = r.ZERO, X = r.ZERO, ee = r.ZERO, j = r.mul(W, W), ne = r.mul(Z, Z), ae = r.mul(J, J), he = r.mul(W, Z);
      return he = r.add(he, he), ee = r.mul(W, J), ee = r.add(ee, ee), Y = r.mul(T, ee), X = r.mul(U, ae), X = r.add(Y, X), Y = r.sub(ne, X), X = r.add(ne, X), X = r.mul(Y, X), Y = r.mul(he, Y), ee = r.mul(U, ee), ae = r.mul(T, ae), he = r.sub(j, ae), he = r.mul(T, he), he = r.add(he, ee), ee = r.add(j, j), j = r.add(ee, j), j = r.add(j, ae), j = r.mul(j, he), X = r.add(X, j), ae = r.mul(Z, J), ae = r.add(ae, ae), j = r.mul(ae, he), Y = r.sub(Y, j), ee = r.mul(ae, ne), ee = r.add(ee, ee), ee = r.add(ee, ee), new x(Y, X, ee);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(T) {
      k(T);
      const { px: L, py: U, pz: W } = this, { px: Z, py: J, pz: Y } = T;
      let X = r.ZERO, ee = r.ZERO, j = r.ZERO;
      const ne = e.a, ae = r.mul(e.b, F9);
      let he = r.mul(L, Z), Ie = r.mul(U, J), V = r.mul(W, Y), B = r.add(L, U), P = r.add(Z, J);
      B = r.mul(B, P), P = r.add(he, Ie), B = r.sub(B, P), P = r.add(L, W);
      let H = r.add(Z, Y);
      return P = r.mul(P, H), H = r.add(he, V), P = r.sub(P, H), H = r.add(U, W), X = r.add(J, Y), H = r.mul(H, X), X = r.add(Ie, V), H = r.sub(H, X), j = r.mul(ne, P), X = r.mul(ae, V), j = r.add(X, j), X = r.sub(Ie, j), j = r.add(Ie, j), ee = r.mul(X, j), Ie = r.add(he, he), Ie = r.add(Ie, he), V = r.mul(ne, V), P = r.mul(ae, P), Ie = r.add(Ie, V), V = r.sub(he, V), V = r.mul(ne, V), P = r.add(P, V), he = r.mul(Ie, P), ee = r.add(ee, he), he = r.mul(H, P), X = r.mul(B, X), X = r.sub(X, he), he = r.mul(B, Ie), j = r.mul(H, j), j = r.add(j, he), new x(X, ee, j);
    }
    subtract(T) {
      return this.add(T.negate());
    }
    is0() {
      return this.equals(x.ZERO);
    }
    wNAF(T) {
      return D.wNAFCached(this, T, x.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(T) {
      const { endo: L, n: U } = e;
      pg("scalar", T, Pc, U);
      const W = x.ZERO;
      if (T === Pc)
        return W;
      if (this.is0() || T === Br)
        return this;
      if (!L || D.hasPrecomputes(this))
        return D.wNAFCachedUnsafe(this, T, x.normalizeZ);
      let { k1neg: Z, k1: J, k2neg: Y, k2: X } = L.splitScalar(T), ee = W, j = W, ne = this;
      for (; J > Pc || X > Pc; )
        J & Br && (ee = ee.add(ne)), X & Br && (j = j.add(ne)), ne = ne.double(), J >>= Br, X >>= Br;
      return Z && (ee = ee.negate()), Y && (j = j.negate()), j = new x(r.mul(j.px, L.beta), j.py, j.pz), ee.add(j);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(T) {
      const { endo: L, n: U } = e;
      pg("scalar", T, Br, U);
      let W, Z;
      if (L) {
        const { k1neg: J, k1: Y, k2neg: X, k2: ee } = L.splitScalar(T);
        let { p: j, f: ne } = this.wNAF(Y), { p: ae, f: he } = this.wNAF(ee);
        j = D.constTimeNegate(J, j), ae = D.constTimeNegate(X, ae), ae = new x(r.mul(ae.px, L.beta), ae.py, ae.pz), W = j.add(ae), Z = ne.add(he);
      } else {
        const { p: J, f: Y } = this.wNAF(T);
        W = J, Z = Y;
      }
      return x.normalizeZ([W, Z])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(T, L, U) {
      const W = x.BASE, Z = (Y, X) => X === Pc || X === Br || !Y.equals(W) ? Y.multiplyUnsafe(X) : Y.multiply(X), J = Z(this, L).add(Z(T, U));
      return J.is0() ? void 0 : J;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(T) {
      return S(this, T);
    }
    isTorsionFree() {
      const { h: T, isTorsionFree: L } = e;
      if (T === Br)
        return !0;
      if (L)
        return L(x, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: T, clearCofactor: L } = e;
      return T === Br ? this : L ? L(x, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(T = !0) {
      return Gy("isCompressed", T), this.assertValidity(), u(x, this, T);
    }
    toHex(T = !0) {
      return Gy("isCompressed", T), Cg(this.toRawBytes(T));
    }
  }
  x.BASE = new x(e.Gx, e.Gy, r.ONE), x.ZERO = new x(r.ZERO, r.ONE, r.ZERO);
  const M = e.nBitLength, D = MF(x, e.endo ? Math.ceil(M / 2) : M);
  return {
    CURVE: e,
    ProjectivePoint: x,
    normPrivateKeyToScalar: y,
    weierstrassEquation: g,
    isWithinCurveOrder: b
  };
}
function WF(a) {
  const e = YT(a);
  return lw(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function GF(a) {
  const e = WF(a), { Fp: r, n: i } = e, u = r.BYTES + 1, d = 2 * r.BYTES + 1;
  function g(V) {
    return Bi(V, i);
  }
  function b(V) {
    return J5(V, i);
  }
  const { ProjectivePoint: y, normPrivateKeyToScalar: k, weierstrassEquation: S, isWithinCurveOrder: A } = VF({
    ...e,
    toBytes(V, B, P) {
      const H = B.toAffine(), G = r.toBytes(H.x), ie = $v;
      return Gy("isCompressed", P), P ? ie(Uint8Array.from([B.hasEvenY() ? 2 : 3]), G) : ie(Uint8Array.from([4]), G, r.toBytes(H.y));
    },
    fromBytes(V) {
      const B = V.length, P = V[0], H = V.subarray(1);
      if (B === u && (P === 2 || P === 3)) {
        const G = hg(H);
        if (!Lk(G, Br, r.ORDER))
          throw new Error("Point is not on curve");
        const ie = S(G);
        let ce;
        try {
          ce = r.sqrt(ie);
        } catch (Ce) {
          const Be = Ce instanceof Error ? ": " + Ce.message : "";
          throw new Error("Point is not on curve" + Be);
        }
        const xe = (ce & Br) === Br;
        return (P & 1) === 1 !== xe && (ce = r.neg(ce)), { x: G, y: ce };
      } else if (B === d && P === 4) {
        const G = r.fromBytes(H.subarray(0, r.BYTES)), ie = r.fromBytes(H.subarray(r.BYTES, 2 * r.BYTES));
        return { x: G, y: ie };
      } else {
        const G = u, ie = d;
        throw new Error("invalid Point, expected length of " + G + ", or uncompressed " + ie + ", got " + B);
      }
    }
  }), x = (V) => Cg($y(V, e.nByteLength));
  function M(V) {
    const B = i >> Br;
    return V > B;
  }
  function D(V) {
    return M(V) ? g(-V) : V;
  }
  const O = (V, B, P) => hg(V.slice(B, P));
  class T {
    constructor(B, P, H) {
      this.r = B, this.s = P, this.recovery = H, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(B) {
      const P = e.nByteLength;
      return B = Bs("compactSignature", B, P * 2), new T(O(B, 0, P), O(B, P, 2 * P));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(B) {
      const { r: P, s: H } = Ec.toSig(Bs("DER", B));
      return new T(P, H);
    }
    assertValidity() {
      pg("r", this.r, Br, i), pg("s", this.s, Br, i);
    }
    addRecoveryBit(B) {
      return new T(this.r, this.s, B);
    }
    recoverPublicKey(B) {
      const { r: P, s: H, recovery: G } = this, ie = Y(Bs("msgHash", B));
      if (G == null || ![0, 1, 2, 3].includes(G))
        throw new Error("recovery id invalid");
      const ce = G === 2 || G === 3 ? P + e.n : P;
      if (ce >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const xe = G & 1 ? "03" : "02", Ce = y.fromHex(xe + x(ce)), Be = b(ce), Pe = g(-ie * Be), Fe = g(H * Be), Xe = y.BASE.multiplyAndAddUnsafe(Ce, Pe, Fe);
      if (!Xe)
        throw new Error("point at infinify");
      return Xe.assertValidity(), Xe;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return M(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new T(this.r, g(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return jy(this.toDERHex());
    }
    toDERHex() {
      return Ec.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return jy(this.toCompactHex());
    }
    toCompactHex() {
      return x(this.r) + x(this.s);
    }
  }
  const L = {
    isValidPrivateKey(V) {
      try {
        return k(V), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: k,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const V = $T(e.n);
      return LF(e.randomBytes(V), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(V = 8, B = y.BASE) {
      return B._setWindowSize(V), B.multiply(BigInt(3)), B;
    }
  };
  function U(V, B = !0) {
    return y.fromPrivateKey(V).toRawBytes(B);
  }
  function W(V) {
    const B = xg(V), P = typeof V == "string", H = (B || P) && V.length;
    return B ? H === u || H === d : P ? H === 2 * u || H === 2 * d : V instanceof y;
  }
  function Z(V, B, P = !0) {
    if (W(V))
      throw new Error("first arg must be private key");
    if (!W(B))
      throw new Error("second arg must be public key");
    return y.fromHex(B).multiply(k(V)).toRawBytes(P);
  }
  const J = e.bits2int || function(V) {
    if (V.length > 8192)
      throw new Error("input is too large");
    const B = hg(V), P = V.length * 8 - e.nBitLength;
    return P > 0 ? B >> BigInt(P) : B;
  }, Y = e.bits2int_modN || function(V) {
    return g(J(V));
  }, X = QE(e.nBitLength);
  function ee(V) {
    return pg("num < 2^" + e.nBitLength, V, Pc, X), $y(V, e.nByteLength);
  }
  function j(V, B, P = ne) {
    if (["recovered", "canonical"].some((tt) => tt in P))
      throw new Error("sign() legacy options not supported");
    const { hash: H, randomBytes: G } = e;
    let { lowS: ie, prehash: ce, extraEntropy: xe } = P;
    ie == null && (ie = !0), V = Bs("msgHash", V), M9(P), ce && (V = Bs("prehashed msgHash", H(V)));
    const Ce = Y(V), Be = k(B), Pe = [ee(Be), ee(Ce)];
    if (xe != null && xe !== !1) {
      const tt = xe === !0 ? G(r.BYTES) : xe;
      Pe.push(Bs("extraEntropy", tt));
    }
    const Fe = $v(...Pe), Xe = Ce;
    function at(tt) {
      const Ye = J(tt);
      if (!A(Ye))
        return;
      const Ve = b(Ye), Je = y.BASE.multiply(Ye).toAffine(), _e = g(Je.x);
      if (_e === Pc)
        return;
      const rt = g(Ve * g(Xe + _e * Be));
      if (rt === Pc)
        return;
      let Gt = (Je.x === _e ? 0 : 2) | Number(Je.y & Br), Er = rt;
      return ie && M(rt) && (Er = D(rt), Gt ^= 1), new T(_e, Er, Gt);
    }
    return { seed: Fe, k2sig: at };
  }
  const ne = { lowS: e.lowS, prehash: !1 }, ae = { lowS: e.lowS, prehash: !1 };
  function he(V, B, P = ne) {
    const { seed: H, k2sig: G } = j(V, B, P), ie = e;
    return VT(ie.hash.outputLen, ie.nByteLength, ie.hmac)(H, G);
  }
  y.BASE._setWindowSize(8);
  function Ie(V, B, P, H = ae) {
    var G;
    const ie = V;
    B = Bs("msgHash", B), P = Bs("publicKey", P);
    const { lowS: ce, prehash: xe, format: Ce } = H;
    if (M9(H), "strict" in H)
      throw new Error("options.strict was renamed to lowS");
    if (Ce !== void 0 && Ce !== "compact" && Ce !== "der")
      throw new Error("format must be compact or der");
    const Be = typeof ie == "string" || xg(ie), Pe = !Be && !Ce && typeof ie == "object" && ie !== null && typeof ie.r == "bigint" && typeof ie.s == "bigint";
    if (!Be && !Pe)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let Fe, Xe;
    try {
      if (Pe && (Fe = new T(ie.r, ie.s)), Be) {
        try {
          Ce !== "compact" && (Fe = T.fromDER(ie));
        } catch (Gt) {
          if (!(Gt instanceof Ec.Err))
            throw Gt;
        }
        !Fe && Ce !== "der" && (Fe = T.fromCompact(ie));
      }
      Xe = y.fromHex(P);
    } catch {
      return !1;
    }
    if (!Fe || ce && Fe.hasHighS())
      return !1;
    xe && (B = e.hash(B));
    const { r: at, s: tt } = Fe, Ye = Y(B), Ve = b(tt), Je = g(Ye * Ve), _e = g(at * Ve), rt = (G = y.BASE.multiplyAndAddUnsafe(Xe, Je, _e)) == null ? void 0 : G.toAffine();
    return rt ? g(rt.x) === at : !1;
  }
  return {
    CURVE: e,
    getPublicKey: U,
    getSharedSecret: Z,
    sign: he,
    verify: Ie,
    ProjectivePoint: y,
    Signature: T,
    utils: L
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function jF(a) {
  return {
    hash: a,
    hmac: (e, ...r) => zT(a, e, oF(...r)),
    randomBytes: sF
  };
}
function $F(a, e) {
  const r = (i) => GF({ ...a, ...jF(i) });
  return { ...r(e), create: r };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const qT = GT(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")), QF = qT.create(BigInt("-3")), ZF = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), YF = $F({
  a: QF,
  // Equation params: a, b
  b: ZF,
  Fp: qT,
  // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n
  // Curve order, total count of valid points in the field
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  // Base (generator) point (x, y)
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: !1
}, pF), _9 = YF, _v = "embeddedWallet", Qv = 23294, Qy = 23295, tu = {
  EVM: 0,
  SUBSTRATE: 1
}, Sn = {
  SAPPHIRE_PROVIDER_NOT_INITIALIZED: "OAW_SAPPHIRE_PROVIDER_NOT_INITIALIZED",
  ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED: "OAW_ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED",
  NO_USERNAME: "OAW_NO_USERNAME",
  NO_PASSWORD: "OAW_NO_PASSWORD",
  NO_LOGIN_PROXY_DATA: "OAW_NO_LOGIN_PROXY_DATA",
  AUTHENTICATION_DATA_NOT_PROVIDED: "OAW_AUTHENTICATION_DATA_NOT_PROVIDED",
  CANT_GET_ACCOUNT_ADDRESS: "OAW_CANT_GET_ACCOUNT_ADDRESS",
  CANT_GET_ACCOUNT_WALLETS: "OAW_CANT_GET_ACCOUNT_WALLETS",
  NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID: "OAW_NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID",
  CROSS_CHAIN_PROVIDER_NOT_INITIALIZED: "OAW_CROSS_CHAIN_PROVIDER_NOT_INITIALIZED",
  OASIS_WALLET_NOT_INITIALIZED: "OAW_OASIS_WALLET_NOT_INITIALIZED",
  CANT_HASH_USERNAME: "OAW_CANT_HASH_USERNAME",
  CANT_GET_SIGNATURE: "CANT_GET_SIGNATURE",
  NO_APILLON_SESSION_TOKEN_CALLBACK: "NO_APILLON_SESSION_TOKEN_CALLBACK",
  INVALID_APILLON_SESSION_TOKEN: "INVALID_APILLON_SESSION_TOKEN",
  NO_APILLON_CLIENT_ID: "NO_APILLON_CLIENT_ID",
  CANT_GET_SIGNED_TX: "CANT_GET_SIGNED_TX",
  CHAIN_CHANGE_FAILED: "CHAIN_CHANGE_FAILED",
  XDOMAIN_NOT_INIT: "XDOMAIN_NOT_INIT",
  XDOMAIN_STOPPED: "XDOMAIN_STOPPED",
  XDOMAIN_BLOCKED: "XDOMAIN_BLOCKED",
  CANT_GET_WALLET_ADDRESS: "CANT_GET_WALLET_ADDRESS",
  WALLET_TITLE_UPDATE_FAILED: "WALLET_TITLE_UPDATE_FAILED"
}, uk = {
  [Sn.SAPPHIRE_PROVIDER_NOT_INITIALIZED]: "Sapphire provider not initialized",
  [Sn.ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED]: "Account manager contract not initialized",
  [Sn.NO_USERNAME]: "No username",
  [Sn.NO_PASSWORD]: "No password",
  [Sn.NO_LOGIN_PROXY_DATA]: "No login proxy data",
  [Sn.AUTHENTICATION_DATA_NOT_PROVIDED]: "Authentication data not provided",
  [Sn.CANT_GET_ACCOUNT_ADDRESS]: "Can't get account address",
  [Sn.NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID]: "Selected chain is not supported",
  [Sn.CROSS_CHAIN_PROVIDER_NOT_INITIALIZED]: "Cross chain provider not initialized",
  [Sn.OASIS_WALLET_NOT_INITIALIZED]: "Embedded wallet not initialized",
  [Sn.CANT_HASH_USERNAME]: "Can't hash username",
  [Sn.NO_APILLON_SESSION_TOKEN_CALLBACK]: "Session token callback must be provided",
  [Sn.INVALID_APILLON_SESSION_TOKEN]: "Session token is not valid",
  [Sn.NO_APILLON_CLIENT_ID]: "Client ID is not valid",
  [Sn.CANT_GET_SIGNED_TX]: "Could not get signed transaction",
  [Sn.CHAIN_CHANGE_FAILED]: "Failed to switch chain",
  [Sn.XDOMAIN_NOT_INIT]: "Passkey interface not initialized",
  [Sn.XDOMAIN_STOPPED]: "Passkey configuration stopped, window closed",
  [Sn.XDOMAIN_BLOCKED]: "Passkey configuration popup blocked, please allow browser popups to continue"
}, qF = {
  addWallet: {
    passkey: "addWallet",
    password: "addWalletPassword"
  },
  manageCredential: {
    passkey: "manageCredential",
    password: "manageCredentialPassword"
  }
}, U9 = {
  404130001: "Invalid wallet integration UUID",
  // EMBEDDED_WALLET_INTEGRATION_NOT_FOUND
  40313e4: "Domain not whitelisted for wallet usage",
  // EMBEDDED_WALLET_INTEGRATION_DOMAIN_NOT_WHITELISTED
  40013002: "Wallet usage limit reached",
  // MAX_NUMBER_OF_EMBEDDED_WALLET_SIGNATURES_REACHED
  40300001: "Invalid origin"
  // INVALID_ORIGIN
};
function z9(a) {
  if (typeof window < "u")
    return window[_v] = new tI(a), window[_v];
}
function KT() {
  if (typeof window < "u")
    return window[_v] || (window[_v] = new tI()), window[_v];
}
async function Fi(a = "") {
  var e, r;
  const i = await ((r = (e = KT()) == null ? void 0 : e.accountManagerContract) == null ? void 0 : r.salt());
  if (i)
    return PP(a, kr(i), 1e5, 32, "sha256");
}
function G8(a) {
  return [Qy, Qv].includes(a);
}
function He(a, e = "Error") {
  const r = new Error(e);
  throw r.name = Sn[a], r;
}
class KF extends sk {
  constructor(e, r) {
    super(e[0], r), le(this, "providers", []), le(this, "frs", []), le(this, "rpcUrls"), le(this, "lastIndex", -1), le(this, "error"), this.rpcUrls = e;
  }
  /**
   * Must override this.
   * Even if action is started with `send`, this connection gets used in background.
   */
  _getConnection() {
    return this.lastIndex < 0 || this.lastIndex > this.frs.length - 1 ? new Mc(this.rpcUrls[0]) : this.frs[this.lastIndex].clone();
  }
  /**
   * Switch through all specified rpc urls until one works, or throw error if none works
   */
  async send(e, r, i = 0) {
    if (this.lastIndex > -1 && (i = this.lastIndex), i >= this.rpcUrls.length) {
      const u = this.error;
      throw this.error = void 0, new Error(u);
    }
    try {
      if (i > this.providers.length - 1) {
        const d = new Mc(this.rpcUrls[i]);
        d.timeout = 15e3, this.providers.push(uO(new sk(d))), this.frs.push(d);
      }
      const u = await this.providers[i].send(e, r);
      return this.lastIndex = i, u;
    } catch (u) {
      return this.error = u, this.lastIndex > 0 ? (this.lastIndex = -1, this.send(e, r, 0)) : (this.lastIndex = -1, this.send(e, r, i + 1));
    }
  }
}
function H9() {
  const a = "https://localhost:5175";
  try {
    return new URL(a).hostname;
  } catch (e) {
    console.error(e);
  }
  return "passkey.apillon.io";
}
function JF() {
  var a = navigator.userAgent.toLowerCase();
  return a.indexOf("safari") != -1 && a.indexOf("chrome") === -1;
}
class y4 {
  constructor(e) {
    le(this, "abiCoder", jv.defaultAbiCoder()), this.wallet = e;
  }
  async getRegisterData(e) {
    e.username || He("NO_USERNAME"), e.password || He("NO_PASSWORD");
    const r = await Fi(e.username);
    if (!r) {
      He("CANT_HASH_USERNAME");
      return;
    }
    const i = this.generateNewKeypair();
    return {
      hashedUsername: r,
      credentialId: i.credentialId,
      pubkey: {
        kty: 2,
        // Elliptic Curve format
        alg: -7,
        // ES256 algorithm
        crv: 1,
        // P-256 curve
        x: i.decoded_x,
        y: i.decoded_y
      },
      optionalPassword: h4(e.password),
      wallet: {
        walletType: tu.EVM,
        keypairSecret: fg
      }
    };
  }
  async getProxyResponse(e, r) {
    if (!r.username) {
      He("NO_USERNAME");
      return;
    }
    if (!r.password) {
      He("NO_PASSWORD");
      return;
    }
    const i = await Fi(r.username);
    if (!i) {
      He("CANT_HASH_USERNAME");
      return;
    }
    const u = I8(
      ["bytes32", "bytes"],
      [h4(r.password), e]
    );
    return await this.wallet.accountManagerContract.proxyViewPassword(
      i,
      BigInt(tu.EVM),
      u,
      e
    );
  }
  async proxyWrite(e, r, i, u, d = !1) {
    if (!i.username) {
      He("NO_USERNAME");
      return;
    }
    if (!i.password) {
      He("NO_PASSWORD");
      return;
    }
    const g = await Fi(i.username);
    if (!g) {
      He("CANT_HASH_USERNAME");
      return;
    }
    const b = I8(
      ["bytes32", "bytes"],
      [h4(i.password), r]
    ), y = await this.wallet.signContractWrite({
      authData: i,
      strategy: "password",
      label: u,
      contractAddress: this.wallet.accountManagerAddress,
      contractAbi: Nk,
      contractFunctionName: e,
      contractFunctionValues: [
        {
          hashedUsername: g,
          digest: b,
          data: r
        }
      ],
      chainId: "https://testnet.sapphire.oasis.io".includes("testnet") ? Qy : Qv
    });
    if (y) {
      const { txHash: k } = await this.wallet.broadcastTransaction(
        y?.signedTxData,
        y?.chainId,
        u,
        `proxyWrite_${e}`
      );
      if (d || await this.wallet.waitForTxReceipt(k))
        return k;
    }
  }
  async getCredentials(e, r) {
    if (!(r.hashedUsername || await Fi(r.username))) {
      He("CANT_HASH_USERNAME");
      return;
    }
    return I8(
      ["bytes32", "bytes"],
      [h4(r.password), e]
    );
  }
  generateNewKeypair() {
    const e = _9.utils.randomPrivateKey(), r = _9.getPublicKey(e, !1), i = "0x" + Cg(r), u = this.abiCoder.encode(["string"], [i]), d = i.slice(4, i.length), g = BigInt("0x" + d.slice(0, 64)), b = BigInt("0x" + d.slice(64, d.length));
    return {
      credentialId: u,
      privateKey: e,
      decoded_x: g,
      decoded_y: b
    };
  }
}
function XF(a) {
  return a[0] << 24 | a[1] << 16 | a[2] << 8 | a[3];
}
function e_(a) {
  return a[0] << 8 | a[1];
}
function t_(a) {
  const e = px.decode(a), r = e[1];
  if (r == 2) {
    const i = {
      kty: r,
      alg: e[3],
      crv: e[-1],
      x: By(e[-2]),
      /** @type {Uint8Array} */
      y: By(e[-3])
    };
    if (!(i.alg == -7 && i.crv == 1) && // ES256 + P-256 (NIST)
    !(i.alg == -8 && i.crv == 6))
      throw new Error(`Unknown alg: ${i.alg}, crv: ${i.crv}`);
    return i;
  }
  throw new Error(`Unsupported kty: ${r}`);
}
function n_(a) {
  if (a.byteLength - a.byteOffset < 37)
    throw new Error("Attestation Object must be at least 37 bytes or longer");
  const e = a.slice(32, 33)[0], r = {
    rpIdHash: a.slice(0, 32),
    // 32 bytes, SHA256(rp.id), e.g. SHA256(b'localhost')
    flags: {
      //  1 byte
      UP: (e & 1) != 0,
      // Bit 0: User Present (UP) result
      // Bit 1: Reserved for future use (RFU1)
      UV: (e & 4) != 0,
      // Bit 2: User Verified (UV) result
      BE: (e & 8) != 0,
      // Bit 3: Backup Eligibility (BE)
      BS: (e & 16) != 0,
      // Bit 3: Backup State (BS)
      // Bit 5: Reserved for future use (RFU2)
      AT: (e & 64) != 0,
      // Bit 6: Attested credential data included (AT)
      ED: (e & 128) != 0
      // Bit 7: Extension data included (ED).
    },
    signCount: XF(a.slice(33, 37))
    //  4 bytes
  };
  if (r.flags.ED)
    throw new Error("Extension Data not supported!");
  if (r.flags.AT) {
    const i = e_(a.slice(53, 55));
    r.attestedCredentialData = {
      aaguid: a.slice(37, 53),
      // 16 bytes
      credentialId: a.slice(55, 55 + i),
      // vanillacbor.decodeOnlyFirst(buffer).byteLength;
      // https://www.w3.org/TR/webauthn-2/#sctn-encoded-credPubKey-examples
      credentialPublicKey: t_(a.slice(55 + i).buffer)
    };
  }
  return r;
}
function r_(a) {
  const e = px.decode(new Uint8Array(a).buffer).authData;
  return n_(e);
}
async function a_(a, e, r) {
  const i = await navigator.credentials.create({
    publicKey: {
      attestation: "none",
      challenge: r.buffer,
      pubKeyCredParams: [
        //{alg: -8, type: "public-key"},   // Ed25519
        { alg: -7, type: "public-key" }
        // ES256
        //{alg: -257, type: "public-key"}  // RS256
      ],
      rp: a,
      user: e
    }
  });
  if (!i)
    throw new Error("No PublicKeyCredential returned!");
  const u = i.response, d = new TextDecoder("utf-8").decode(u.clientDataJSON);
  return {
    id: new Uint8Array(i.rawId),
    cd: d,
    ad: r_(u.attestationObject)
  };
}
function o_(a) {
  return Object.entries(a).map(([e, r]) => {
    if (typeof r == "boolean")
      return {
        t: 1,
        k: e,
        v: r ? "true" : "false"
      };
    if (typeof r == "string")
      return {
        t: 0,
        k: e,
        v: r
      };
    throw new Error(`Incompatible value type! Key:${e} Value:${r}`);
  });
}
const i_ = new lg.Sequence({
  name: "sig",
  value: [
    new lg.Integer({
      name: "r"
    }),
    new lg.Integer({
      name: "s"
    })
  ]
});
async function s_(a, e, r) {
  e || (e = crypto.getRandomValues(new Uint8Array(32)));
  const i = await navigator.credentials.get({
    publicKey: {
      rpId: r,
      allowCredentials: a.map((S) => ({ id: S, type: "public-key" })),
      challenge: e
    }
  }), u = i.response, d = lg.verifySchema(u.signature, i_);
  if (!d.verified)
    throw new Error("Unable to decode ASN.1 signature!");
  const g = d.result, b = g.r.toBigInt(), y = g.s.toBigInt(), k = JSON.parse(new TextDecoder().decode(u.clientDataJSON));
  return {
    credentialIdHashed: xn(new Uint8Array(i.rawId)),
    challenge: e,
    resp: {
      authenticatorData: new Uint8Array(u.authenticatorData),
      clientDataTokens: o_(k),
      sigR: b,
      sigS: y
    }
  };
}
class b4 {
  constructor(e) {
    this.wallet = e;
  }
  async getRegisterData(e) {
    var r, i;
    if (!e.username) {
      He("NO_USERNAME");
      return;
    }
    if (e.hashedUsername || (e.hashedUsername = await Fi(e.username)), !e.hashedUsername) {
      He("CANT_HASH_USERNAME");
      return;
    }
    const u = {
      walletType: tu.EVM,
      keypairSecret: fg
    };
    if (((r = this.wallet.xdomain) == null ? void 0 : r.mode) === "popup") {
      const d = await ((i = this.wallet.xdomain) == null ? void 0 : i.create(e.hashedUsername, e.username));
      if (!d) {
        He("XDOMAIN_NOT_INIT");
        return;
      }
      return {
        hashedUsername: e.hashedUsername,
        credentialId: d.credentialId,
        pubkey: d.pubkey,
        optionalPassword: fg,
        wallet: u
      };
    } else {
      const d = await a_(
        {
          name: "Embedded Wallet Account",
          id: H9()
        },
        {
          id: e.hashedUsername,
          name: e.username,
          displayName: e.username
        },
        crypto.getRandomValues(new Uint8Array(32))
      );
      return {
        hashedUsername: e.hashedUsername,
        credentialId: d.id,
        pubkey: d.ad.attestedCredentialData.credentialPublicKey,
        optionalPassword: fg,
        wallet: u
      };
    }
  }
  async getProxyResponse(e, r) {
    var i, u;
    if (!r.username) {
      He("NO_USERNAME");
      return;
    }
    const d = r.hashedUsername || await Fi(r.username);
    if (!d) {
      He("CANT_HASH_USERNAME");
      return;
    }
    const g = await this.getPasskeyForMode(
      ((u = (i = this.wallet) == null ? void 0 : i.xdomain) == null ? void 0 : u.mode) || "standalone",
      d,
      e
    );
    if (!g) {
      He("XDOMAIN_NOT_INIT");
      return;
    }
    return await this.wallet.accountManagerContract.proxyView(
      g.credentialIdHashed,
      // @ts-expect-error AbiTypes
      g.resp,
      BigInt(tu.EVM),
      e
    );
  }
  async proxyWrite(e, r, i, u, d = !1) {
    var g, b;
    if (!i.username) {
      He("NO_USERNAME");
      return;
    }
    const y = i.hashedUsername || await Fi(i.username);
    if (!y) {
      He("CANT_HASH_USERNAME");
      return;
    }
    const k = await this.getPasskeyForMode(
      ((b = (g = this.wallet) == null ? void 0 : g.xdomain) == null ? void 0 : b.mode) || "standalone",
      y,
      r
    );
    if (!k) {
      He("XDOMAIN_NOT_INIT");
      return;
    }
    const S = await this.wallet.signContractWrite({
      authData: i,
      strategy: "passkey",
      label: u,
      contractAddress: this.wallet.accountManagerAddress,
      contractAbi: Nk,
      contractFunctionName: e,
      contractFunctionValues: [
        {
          credentialIdHashed: k.credentialIdHashed,
          resp: k.resp,
          data: r
        }
      ],
      chainId: "https://testnet.sapphire.oasis.io".includes("testnet") ? Qy : Qv
    });
    if (S) {
      const { txHash: A } = await this.wallet.broadcastTransaction(
        S?.signedTxData,
        S?.chainId,
        u,
        `proxyWrite_${e}`
      );
      if (d || await this.wallet.waitForTxReceipt(A))
        return A;
    }
  }
  async getPasskeyForMode(e, r, i) {
    var u;
    const d = await this.wallet.accountManagerContract.personalization(), g = (await this.wallet.accountManagerContract.credentialIdsByUsername(
      r
    )).map((y) => kr(y)), b = kr(
      zd(d + zd(i).slice(2))
    );
    if (["popup", "redirect", "iframe", "tab_form"].includes(e)) {
      const y = await ((u = this.wallet.xdomain) == null ? void 0 : u.get(g, b));
      return y ? {
        credentialIdHashed: y.credentials.credentialIdHashed,
        resp: y.credentials.resp
      } : void 0;
    } else {
      const y = await s_(g, b, H9());
      return {
        credentialIdHashed: y.credentialIdHashed,
        resp: y.resp
      };
    }
  }
}
const JT = "2.23.2";
let v4 = {
  getDocsUrl: ({ docsBaseUrl: a, docsPath: e = "", docsSlug: r }) => e ? `${a ?? "https://viem.sh"}${e}${r ? `#${r}` : ""}` : void 0,
  version: `viem@${JT}`
};
class Zv extends Error {
  constructor(e, r = {}) {
    var i, u;
    const d = r.cause instanceof Zv ? r.cause.details : (i = r.cause) != null && i.message ? r.cause.message : r.details, g = r.cause instanceof Zv && r.cause.docsPath || r.docsPath, b = (u = v4.getDocsUrl) == null ? void 0 : u.call(v4, { ...r, docsPath: g }), y = [
      e || "An error occurred.",
      "",
      ...r.metaMessages ? [...r.metaMessages, ""] : [],
      ...b ? [`Docs: ${b}`] : [],
      ...d ? [`Details: ${d}`] : [],
      ...v4.version ? [`Version: ${v4.version}`] : []
    ].join(`
`);
    super(y, r.cause ? { cause: r.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = d, this.docsPath = g, this.metaMessages = r.metaMessages, this.name = r.name ?? this.name, this.shortMessage = e, this.version = JT;
  }
  walk(e) {
    return XT(this, e);
  }
}
function XT(a, e) {
  return e != null && e(a) ? a : a && typeof a == "object" && "cause" in a && a.cause !== void 0 ? XT(a.cause, e) : e ? null : a;
}
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
const l_ = (a, e, r) => JSON.stringify(a, (i, u) => typeof u == "bigint" ? u.toString() : u, r), u_ = (a) => a;
class c_ extends Zv {
  constructor({ body: e, error: r, url: i }) {
    super("RPC Request failed.", {
      cause: r,
      details: r.message,
      metaMessages: [`URL: ${u_(i)}`, `Request body: ${l_(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = r.code, this.data = r.data;
  }
}
const f_ = -1;
class d_ extends Zv {
  constructor(e, { code: r, docsPath: i, metaMessages: u, name: d, shortMessage: g }) {
    super(g, {
      cause: e,
      docsPath: i,
      metaMessages: u || e?.metaMessages,
      name: d || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = d || e.name, this.code = e instanceof c_ ? e.code : r ?? f_;
  }
}
class eI extends d_ {
  constructor(e, r) {
    super(e, r), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = r.data;
  }
}
class h_ extends eI {
  constructor() {
    super(new Error(uk[Sn.OASIS_WALLET_NOT_INITIALIZED]), {
      code: 4900,
      shortMessage: "Disconnected"
    });
  }
}
class Dy extends eI {
  constructor() {
    super(new Error("Request rejected by user"), {
      code: 4001,
      shortMessage: "User Rejected Request"
    });
  }
}
class p_ {
  // monitor if popup was closed
  constructor(e, r = "redirect") {
    le(this, "src", "https://localhost:5175"), le(this, "promises", []), le(this, "lastEventId", 0), le(this, "iframe"), le(this, "iframeLoadPromise"), le(this, "isIframeLoaded", !1), le(this, "popup", null), le(this, "popupLoadPromise"), le(this, "isPopupLoaded", !1), le(this, "popupCheckInterval", null), this.clientId = e, this.mode = r, r !== "standalone" && r !== "iframe" && (window.addEventListener("message", this.onResponse.bind(this)), this.initIframe());
  }
  onResponse(e) {
    var r, i, u;
    if (((r = e?.data) == null ? void 0 : r.type) === "apillon_pk_response" || ((i = e?.data) == null ? void 0 : i.type) === "apillon_pk_error") {
      const d = this.promises.findIndex((g) => g.id === e.data.id);
      d > -1 && (e.data.type === "apillon_pk_response" ? this.promises[d].resolve(e.data.content) : this.promises[d].reject(e.data.content), this.promises.splice(d, 1)), this.popupCheckInterval && (clearInterval(this.popupCheckInterval), this.popupCheckInterval = null), this.popup && (this.popup.close(), this.popup = null), this.isPopupLoaded = !1, this.popupLoadPromise = void 0;
    } else ((u = e?.data) == null ? void 0 : u.type) === "apillon_pk_load" && (this.isPopupLoaded = !0, this.popupLoadPromise && (this.popupLoadPromise.resolve(), this.popupLoadPromise = void 0));
  }
  async initIframe() {
    if (!window) {
      He("XDOMAIN_NOT_INIT");
      return;
    }
    if (this.iframeLoadPromise && (await this.iframeLoadPromise, await new Promise((r) => setTimeout(r, 150)), this.iframe))
      return;
    const e = document.createElement("iframe");
    this.iframeLoadPromise = new Promise((r) => {
      e.addEventListener(
        "load",
        () => {
          this.isIframeLoaded = !0, r();
        },
        { once: !0 }
      );
    }), e.setAttribute("src", `${this.src}?clientId=${this.clientId}`), e.setAttribute("allow", `publickey-credentials-get ${this.src}`), e.style.pointerEvents = "none", e.style.width = "1px", e.style.height = "1px", e.style.overflow = "hidden", e.style.opacity = "0", this.iframe = e, document.body.appendChild(e), await this.iframeLoadPromise, await new Promise((r) => setTimeout(r, 150));
  }
  async openPopup(e) {
    if (this.popup && (this.popup.close(), this.popup = null), this.popupCheckInterval && (clearInterval(this.popupCheckInterval), this.popupCheckInterval = null), setTimeout(() => {
      this.popup = window.open(
        this.mode === "tab_form" ? `${this.src}?tab=1&${[
          `clientId=${this.clientId}`,
          `username=${encodeURIComponent(e || "")}`
        ].join("&")}` : `${this.src}?popup=1`,
        "_blank",
        this.mode === "tab_form" ? void 0 : [
          "width=400",
          "height=400",
          `left=${Math.round(window.innerWidth / 2 + window.screenX - 400 / 2)}`,
          `top=${Math.round(window.innerHeight / 2 + window.screenY - 400 / 2)}`,
          "location=no",
          "resizable=no"
        ].join(",")
      );
    }, 1), await new Promise((r) => setTimeout(r, 20)), !this.popup || this.popup.closed || typeof this.popup.closed > "u")
      return He("XDOMAIN_BLOCKED");
    try {
      this.popup.focus();
    } catch {
      return He("XDOMAIN_BLOCKED");
    }
    this.popupCheckInterval = setInterval(() => {
      var r, i;
      if ((r = this.popup) != null && r.closed) {
        for (const u of this.promises)
          u.reject(uk[Sn.XDOMAIN_STOPPED]);
        this.promises = [], this.popupLoadPromise && this.popupLoadPromise.reject(uk[Sn.XDOMAIN_STOPPED]), this.popupCheckInterval && (clearInterval(this.popupCheckInterval), this.popupCheckInterval = null), this.popup = null, this.popupLoadPromise = void 0, this.isPopupLoaded = !1;
      } else ((i = this.popup) == null ? void 0 : i.closed) === void 0 && this.popupCheckInterval && (clearInterval(this.popupCheckInterval), this.popupCheckInterval = null, this.popupLoadPromise = void 0, this.isPopupLoaded = !1);
    }, 500), await new Promise((r, i) => {
      if (this.isPopupLoaded)
        return r();
      this.popupLoadPromise = { resolve: r, reject: i };
    });
  }
  /**
   * Create credentials through popup window. Not available in iframe!
   */
  async create(e, r) {
    if (await this.openPopup(r), !this.popup)
      return He("XDOMAIN_NOT_INIT");
    const i = this.getEventId();
    return this.popup.postMessage(
      {
        type: "create_pk_credentials",
        id: i,
        content: {
          hashedUsername: e,
          username: r
        }
      },
      this.src
    ), new Promise((u, d) => {
      this.promises.push({
        id: i,
        resolve: u,
        reject: d
      });
    });
  }
  async createViaTab(e) {
    if (await this.openPopup(e), !this.popup)
      return He("XDOMAIN_NOT_INIT");
    const r = this.getEventId();
    return this.popup.postMessage(
      {
        type: "save_pk_event_id",
        id: r
      },
      this.src
    ), new Promise((i, u) => {
      this.promises.push({
        id: r,
        resolve: i,
        reject: u
      });
    });
  }
  /**
   * Get credentials -- always through iframe.
   */
  async get(e, r) {
    var i;
    if ((!this.iframe || !this.isIframeLoaded) && (await this.initIframe(), !this.iframe))
      return He("XDOMAIN_NOT_INIT");
    this.iframe.focus(), JF() && setTimeout(() => {
      var d, g;
      (g = (d = this.iframe) == null ? void 0 : d.contentWindow) == null || g.focus();
    }, 10), await new Promise((d) => setTimeout(d, 100));
    const u = this.getEventId();
    return (i = this.iframe.contentWindow) == null || i.postMessage(
      {
        type: "get_pk_credentials",
        id: u,
        content: {
          credentials: e,
          challenge: r
        }
      },
      this.src
    ), new Promise((d, g) => {
      this.promises.push({
        id: u,
        resolve: d,
        reject: g
      });
    });
  }
  /**
   * Gateway localStorage get
   * @param isSession Use sessionStorage instead of localStorage
   */
  async storageGet(e, r = !1) {
    var i;
    if ((!this.iframe || !this.isIframeLoaded) && (await this.initIframe(), !this.iframe))
      return He("XDOMAIN_NOT_INIT");
    await new Promise((d) => setTimeout(d, 100));
    const u = this.getEventId();
    return (i = this.iframe.contentWindow) == null || i.postMessage(
      {
        type: "storage_get",
        id: u,
        content: {
          key: e,
          isSession: r
        }
      },
      this.src
    ), new Promise((d, g) => {
      this.promises.push({
        id: u,
        resolve: d,
        reject: g
      });
    });
  }
  /**
   * Gateway localStorage set
   */
  storageSet(e, r, i = !1) {
    var u;
    if (!this.iframe)
      return He("XDOMAIN_NOT_INIT");
    const d = this.getEventId();
    (u = this.iframe.contentWindow) == null || u.postMessage(
      {
        type: "storage_set",
        id: d,
        content: { key: e, value: r, isSession: i }
      },
      this.src
    );
  }
  getEventId() {
    return this.lastEventId += 1, this.lastEventId;
  }
}
class tI {
  /**
   * Prepare sapphire provider and account manager (WebAuthn) contract.
   * Prepare data for available chains
   */
  constructor(e) {
    if (le(this, "sapphireProvider"), le(this, "sapphireChainId", 0), le(this, "accountManagerAddress"), le(this, "accountManagerContract"), le(this, "abiCoder", jv.defaultAbiCoder()), le(this, "events"), le(this, "apillonClientId"), le(this, "xdomain"), le(this, "defaultNetworkId", 0), le(this, "rpcUrls", {}), le(this, "rpcProviders", {}), le(this, "explorerUrls", {
      [Qv]: "https://explorer.oasis.io/mainnet/sapphire",
      [Qy]: "https://explorer.oasis.io/testnet/sapphire"
    }), le(this, "lastAccount", {
      contractAddress: "",
      username: "",
      authStrategy: "passkey",
      wallets: [],
      walletIndex: 0
    }), le(this, "waitForAccountResolver", null), this.sapphireProvider = new KF([
      "https://testnet.sapphire.oasis.io"
    ]), this.loadSapphireChainId(), this.accountManagerAddress = "0x8830d613c7Cd114cA6d71dd5cE0691622c626bCc", this.accountManagerContract = new Sg(
      this.accountManagerAddress,
      Nk,
      new I9(n1, this.sapphireProvider)
    ), this.defaultNetworkId = e?.defaultNetworkId || this.defaultNetworkId, e?.networks)
      for (const r of e.networks)
        this.rpcUrls[r.id] = r.rpcUrl, this.explorerUrls[r.id] = r.explorerUrl;
    this.events = BP(), this.apillonClientId = e?.clientId || "", this.xdomain = new p_(this.apillonClientId, e?.passkeyAuthMode || "redirect");
    try {
      this.getRpcProviderForChainId(this.defaultNetworkId) && this.events.emit("connect", { chainId: `0x${this.defaultNetworkId.toString(16)}` });
    } catch {
    }
  }
  // #region Auth utils
  /**
   * Check if `username` is already registered on accountManager
   */
  async userExists(e) {
    return this.sapphireProvider || He("SAPPHIRE_PROVIDER_NOT_INITIALIZED"), this.accountManagerContract || He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED"), await this.accountManagerContract.userExists(
      await Fi(e)
    ) || !1;
  }
  /**
   * Create new "wallet" for username.
   * Creates a new contract for each account on sapphire network.
   *
   * @param skipAccountWallets  Dont make another request for listing the wallets on account
   * @param origin  Add custom header for origin website
   */
  async register(e, r, i, u = !1, d) {
    if (!this.sapphireProvider)
      return He("SAPPHIRE_PROVIDER_NOT_INITIALIZED");
    if (!this.accountManagerContract)
      return He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED");
    let g;
    e === "password" ? g = await new y4(this).getRegisterData(r) : e === "passkey" && (g = await new b4(this).getRegisterData({
      ...r,
      hashedUsername: i
    }));
    const b = this.abiCoder.encode(
      ["tuple(bytes funcData, uint8 txType)"],
      [
        {
          funcData: this.abiCoder.encode(
            [
              // AccountManagerAbi createAccount
              "tuple(bytes32 hashedUsername, bytes credentialId, tuple(uint8 kty, int8 alg, uint8 crv, uint256 x, uint256 y) pubkey, bytes32 optionalPassword, tuple(uint8 walletType, bytes32 keypairSecret) wallet)"
            ],
            [g]
          ),
          txType: 0
        }
      ]
    ), y = (await this.sapphireProvider.getFeeData()).gasPrice, k = await this.sapphireProvider.getTransactionCount(
      await this.accountManagerContract.gaspayingAddress()
    ), S = await this.getApillonSignature(b, d);
    if (!S.signature)
      return He("CANT_GET_SIGNATURE");
    const A = await this.accountManagerContract.generateGaslessTx(
      b,
      k,
      S.gasPrice ? BigInt(S.gasPrice) : y,
      S.gasLimit ? BigInt(S.gasLimit) : 1000000n,
      BigInt(S.timestamp),
      S.signature
    ), x = await this.sapphireProvider.send("eth_sendRawTransaction", [A]);
    if (await this.waitForTxReceipt(x))
      return u ? "" : await this.finalizeAccountAuth(e, r);
  }
  /**
   * Check that credentials belong to some account.
   */
  async authenticate(e, r) {
    if (!this.sapphireProvider) {
      He("SAPPHIRE_PROVIDER_NOT_INITIALIZED");
      return;
    }
    if (!this.accountManagerContract) {
      He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED");
      return;
    }
    if (!r.username) {
      He("NO_USERNAME");
      return;
    }
    return await this.getAccountWallets({ authData: r, strategy: e, reload: !0 }), await this.finalizeAccountAuth(e, r);
  }
  /**
   * Return public address for username.
   */
  async getAccountAddress(e, r) {
    if (!this.sapphireProvider) {
      He("SAPPHIRE_PROVIDER_NOT_INITIALIZED");
      return;
    }
    if (!this.accountManagerContract) {
      He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED");
      return;
    }
    if (this.lastAccount.wallets.length || await this.getAccountWallets({ authData: r, strategy: e }), !(r != null && r.username)) {
      if (this.lastAccount.wallets.length > this.lastAccount.walletIndex)
        return this.lastAccount.wallets[this.lastAccount.walletIndex].address;
      He("NO_USERNAME");
      return;
    }
    if (this.lastAccount.wallets.length)
      return this.lastAccount.wallets.length > this.lastAccount.walletIndex ? this.lastAccount.wallets[this.lastAccount.walletIndex].address : (this.events.emit("dataUpdated", {
        name: "walletIndex",
        newValue: 0,
        oldValue: this.lastAccount.walletIndex
      }), this.lastAccount.walletIndex = 0, this.lastAccount.wallets[this.lastAccount.walletIndex].address);
    He("CANT_GET_ACCOUNT_ADDRESS");
  }
  async getAccountBalance(e, r = this.defaultNetworkId, i = 18) {
    var u;
    if (!r || !this.rpcUrls[r] && G8(r))
      return SA(await ((u = this.sapphireProvider) == null ? void 0 : u.getBalance(e)) || 0n, i);
    if (!this.rpcUrls[r])
      return "0";
    const d = this.rpcProviders[r] || new sk(this.rpcUrls[r]);
    return SA(await d.getBalance(e), i);
  }
  async getAccountPrivateKey(e = {}) {
    this.sapphireProvider || He("SAPPHIRE_PROVIDER_NOT_INITIALIZED"), e.strategy || (e.strategy = this.lastAccount.authStrategy), e.authData || (e.strategy === "passkey" && this.lastAccount.username ? e.authData = {
      username: this.lastAccount.username
    } : He("AUTHENTICATION_DATA_NOT_PROVIDED"));
    const r = new Dp(U2), i = r.encodeFunctionData("exportPrivateKey", [
      e.walletIndex || this.lastAccount.walletIndex
    ]), u = await this.getProxyForStrategy(
      e.strategy || this.lastAccount.authStrategy,
      i,
      e.authData
    );
    if (u) {
      const [d] = r.decodeFunctionResult("exportPrivateKey", u).toArray();
      return d;
    }
  }
  // #endregion
  // #region Account wallets
  /**
   * Get all wallets added on user's account. Requires authentication.
   * @param reload Ignore cache and get wallets from contract again
   */
  async getAccountWallets(e = {}) {
    if (!this.sapphireProvider) {
      He("SAPPHIRE_PROVIDER_NOT_INITIALIZED");
      return;
    }
    if (!this.accountManagerContract) {
      He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED");
      return;
    }
    if (!e.reload && this.lastAccount.wallets.length)
      return this.lastAccount.wallets;
    if (e.strategy || (e.strategy = this.lastAccount.authStrategy), !e.authData || !e.authData.username)
      if (e.strategy === "passkey" && this.lastAccount.username)
        e.authData = {
          username: this.lastAccount.username
        };
      else {
        He("AUTHENTICATION_DATA_NOT_PROVIDED");
        return;
      }
    if (!this.lastAccount.contractAddress) {
      const d = await Fi(e.authData.username);
      this.lastAccount.contractAddress = await this.accountManagerContract.getAccount(
        d,
        BigInt(tu.EVM)
      ), this.events.emit("dataUpdated", {
        name: "contractAddress",
        newValue: this.lastAccount.contractAddress,
        oldValue: ""
      });
    }
    const r = new Dp(U2), i = r.encodeFunctionData("getWalletList", []), u = await this.getProxyForStrategy(e.strategy, i, e.authData);
    if (u) {
      const [d] = r.decodeFunctionResult("getWalletList", u).toArray();
      if (Array.isArray(d) && d.length) {
        const g = d.map(
          (b, y) => ({
            walletType: tu.EVM,
            address: `0x${b.slice(-40)}`,
            index: y
          })
        ).filter((b) => !!b);
        return this.events.emit("dataUpdated", {
          name: "wallets",
          newValue: g,
          oldValue: this.lastAccount.wallets
        }), this.lastAccount.wallets = g, g;
      }
      He("CANT_GET_ACCOUNT_WALLETS");
    }
  }
  /**
   * Add new wallet or import from privateKey.
   * Returns tx hash on success.
   */
  async addAccountWallet(e) {
    if (!this.sapphireProvider) {
      He("SAPPHIRE_PROVIDER_NOT_INITIALIZED");
      return;
    }
    if (!this.accountManagerContract) {
      He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED");
      return;
    }
    if (e.strategy || (e.strategy = this.lastAccount.authStrategy), e.walletType || (e.walletType = tu.EVM), !e.authData)
      if (e.strategy === "passkey" && this.lastAccount.username)
        e.authData = {
          username: this.lastAccount.username
        };
      else {
        He("AUTHENTICATION_DATA_NOT_PROVIDED");
        return;
      }
    const r = this.abiCoder.encode(
      ["tuple(uint256 walletType, bytes32 keypairSecret)"],
      [
        {
          walletType: BigInt(e.walletType),
          keypairSecret: e.privateKey || fg
        }
      ]
    );
    let i = Z4.AddWallet, u = "";
    e.strategy === "passkey" ? (i = Z4.AddWallet, u = "tuple(bytes32 credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) resp, bytes data)") : e.strategy === "password" && (i = Z4.AddWalletPassword, u = "tuple(bytes32 hashedUsername, bytes32 digest, bytes data)");
    const d = await this.processGaslessMethod({
      label: e.privateKey ? "Import new account" : "Add new account",
      strategy: e.strategy,
      authData: e.authData,
      data: r,
      txType: i,
      funcDataTypes: u,
      funcDataValuesFormatter(g) {
        return g.credentials.passkey ? {
          ...g.credentials.passkey,
          data: r
        } : g.credentials.password ? {
          hashedUsername: g.hashedUsername,
          digest: g.credentials.password,
          data: r
        } : {};
      }
    });
    if (d)
      return d;
    He("CANT_GET_WALLET_ADDRESS");
  }
  // #endregion
  // #region Auth helpers
  /**
   * Handler for getting signature.
   *
   * The request is limited to whitelisted domains determined by client integration ID.
   */
  async getApillonSignature(e, r) {
    if (!this.apillonClientId)
      return He("NO_APILLON_CLIENT_ID"), { signature: "", gasLimit: 0, timestamp: 0 };
    const i = await (await fetch(
      "https://api-dev.apillon.io/embedded-wallet/signature",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          data: e,
          integration_uuid: this.apillonClientId,
          ...r ? { referrerDomain: r } : {}
        })
      }
    )).json();
    if (i.data)
      return {
        signature: i.data.signature,
        gasLimit: i.data.gasLimit || 0,
        gasPrice: i.data.gasPrice || 0,
        timestamp: i.data.timestamp
      };
    if (i.code && U9[i.code])
      throw new Error(U9[i.code]);
    return { signature: "", gasLimit: 0, timestamp: 0 };
  }
  setAccount(e) {
    typeof e.username < "u" && e.username !== this.lastAccount.username && (this.events.emit("dataUpdated", {
      name: "username",
      newValue: e.username,
      oldValue: this.lastAccount.username
    }), this.lastAccount.username = e.username), typeof e.walletIndex < "u" && e.walletIndex >= 0 && e.walletIndex !== this.lastAccount.walletIndex && (this.events.emit("dataUpdated", {
      name: "walletIndex",
      newValue: e.walletIndex,
      oldValue: this.lastAccount.walletIndex
    }), this.lastAccount.walletIndex = e.walletIndex), typeof e.strategy < "u" && e.strategy !== this.lastAccount.authStrategy && (this.events.emit("dataUpdated", {
      name: "authStrategy",
      newValue: e.strategy,
      oldValue: this.lastAccount.authStrategy
    }), this.lastAccount.authStrategy = e.strategy), typeof e.contractAddress < "u" && e.contractAddress !== this.lastAccount.contractAddress && (this.events.emit("dataUpdated", {
      name: "authStrategy",
      newValue: e.contractAddress,
      oldValue: this.lastAccount.contractAddress
    }), this.lastAccount.contractAddress = e.contractAddress), Array.isArray(e.wallets) && e.wallets.length !== this.lastAccount.wallets.length && (this.events.emit("dataUpdated", {
      name: "wallets",
      newValue: e.wallets,
      oldValue: this.lastAccount.wallets
    }), this.lastAccount.wallets = [...e.wallets]);
  }
  setWallets(e) {
    this.events.emit("dataUpdated", {
      name: "wallets",
      newValue: e,
      oldValue: this.lastAccount.wallets
    }), this.lastAccount.wallets = e;
  }
  /**
   * Get a wallet address for account and pass it to listeners.
   * Update the stored lastAccount.
   * This process includes getting all wallets (getAccountWallets) which requires authentication (when no cache is available).
   */
  async finalizeAccountAuth(e, r) {
    const i = await this.getAccountAddress(e, r);
    return i && this.waitForAccountResolver && (this.waitForAccountResolver(i), this.waitForAccountResolver = null), i && this.events.emit("accountsChanged", [i]), this.events.emit("dataUpdated", {
      name: "authStrategy",
      newValue: e,
      oldValue: this.lastAccount.authStrategy
    }), this.events.emit("dataUpdated", {
      name: "username",
      newValue: r.username,
      oldValue: this.lastAccount.username
    }), this.lastAccount.authStrategy = e, this.lastAccount.username = r.username, i;
  }
  /**
   * Create a promise and pass resolver to event `providerRequestAccounts`.
   * Once the promise resolves, return account address.
   */
  async waitForAccount() {
    return await new Promise((e) => {
      this.waitForAccountResolver = e, this.events.emit("providerRequestAccounts", e);
    });
  }
  // #endregion
  // #region Transactions
  async signMessage(e) {
    this.sapphireProvider || He("SAPPHIRE_PROVIDER_NOT_INITIALIZED"), e.strategy || (e.strategy = this.lastAccount.authStrategy), e.authData || (e.strategy === "passkey" && this.lastAccount.username ? e.authData = {
      username: this.lastAccount.username
    } : He("AUTHENTICATION_DATA_NOT_PROVIDED"));
    const r = new Dp(U2);
    let i = e.data || "";
    const u = e.message;
    if ((!i || e.mustConfirm) && (typeof e.message == "string" && !e.message.startsWith("0x") && (e.message = DD(e.message)), i = r.encodeFunctionData("sign", [
      e.walletIndex || this.lastAccount.walletIndex,
      e.message
    ]), e.mustConfirm))
      return await new Promise((g, b) => {
        this.events.emit("signatureRequest", {
          ...e,
          data: i,
          message: u,
          mustConfirm: !1,
          resolve: g,
          reject: b
        });
      });
    const d = await this.getProxyForStrategy(e.strategy, i, e.authData);
    if (d) {
      const [g] = r.decodeFunctionResult("sign", d).toArray();
      if (Array.isArray(g) && g.length > 2) {
        const b = nu.from({
          r: g[0],
          s: g[1],
          v: g[2]
        }).serialized;
        return e.resolve && e.resolve(b), b;
      }
    }
  }
  /**
   * Authenticate with selected auth strategy through sapphire "Account Manager",
   * then return signed tx data and chainId of tx.
   */
  async signPlainTransaction(e) {
    var r;
    const i = this.validateChainId(
      ((r = e?.tx) == null ? void 0 : r.chainId) && +e.tx.chainId.toString() || 0
    );
    if (await this.handleNetworkChange(i), e.tx.chainId = i, e.strategy || (e.strategy = this.lastAccount.authStrategy), e.walletIndex || (e.walletIndex = this.lastAccount.walletIndex), !e.authData)
      if (e.strategy === "passkey" && this.lastAccount.username)
        e.authData = {
          username: this.lastAccount.username
        };
      else
        return He("AUTHENTICATION_DATA_NOT_PROVIDED");
    if (e.tx.data || (e.tx.data = "0x"), e.tx.nonce || (e.tx.nonce = await this.getRpcProviderForChainId(i).getTransactionCount(
      this.lastAccount.wallets[this.lastAccount.walletIndex].address
    )), e.tx.type === "eip1559" && (e.tx.type = 2, e.tx.gasLimit = e.tx.gas), !e.tx.gasPrice) {
      const b = await this.getRpcProviderForChainId(e.tx.chainId).getFeeData();
      e.tx.gasPrice = b.gasPrice, b.maxPriorityFeePerGas && (e.tx.maxPriorityFeePerGas = b.maxPriorityFeePerGas), b.maxFeePerGas ? e.tx.maxFeePerGas = b.maxFeePerGas : e.tx.maxFeePerGas = BigInt(b.gasPrice || 0) * BigInt(2) + (b.maxPriorityFeePerGas || 0n);
    }
    if (!e.tx.gasLimit) {
      const b = await this.getRpcProviderForChainId(e.tx.chainId).estimateGas(e.tx);
      e.tx.gasLimit = b ? Math.floor(Number(b) * 1.01) : 1e6;
    }
    if ((e.tx.type === 2 && !e.tx.value || "value" in e.tx && (typeof e.tx.value > "u" || e.tx.value === null)) && (e.tx.value = 0n), e.mustConfirm)
      return await new Promise((b, y) => {
        this.events.emit("txApprove", {
          plain: { ...e, mustConfirm: !1, resolve: b, reject: y }
        });
      });
    const u = new Dp(U2), d = u.encodeFunctionData("signEIP155", [
      e.walletIndex || this.lastAccount.walletIndex,
      e.tx
    ]), g = await this.getProxyForStrategy(e.strategy, d, e.authData);
    if (g) {
      const [b] = u.decodeFunctionResult("signEIP155", g).toArray();
      return e.resolve && e.resolve({
        signedTxData: b,
        chainId: i
      }), {
        signedTxData: b,
        chainId: i
      };
    }
  }
  /**
   * Send raw transaction data to network.
   * If chainId is provided, the transaction is sent to that network (cross-chain).
   */
  async broadcastTransaction(e, r, i = "Transaction", u) {
    const d = this.getRpcProviderForChainId(r), g = await d.send("eth_sendRawTransaction", [e]), b = {
      hash: g,
      label: i,
      rawData: e,
      owner: this.lastAccount.wallets[this.lastAccount.walletIndex].address || "none",
      status: "pending",
      chainId: r || this.defaultNetworkId,
      explorerUrl: this.explorerUrls[r || this.defaultNetworkId] ? `${this.explorerUrls[r || this.defaultNetworkId]}/tx/${g}` : "",
      createdAt: Date.now(),
      internalLabel: u
    };
    return this.events.emit("txSubmitted", b), {
      txHash: g,
      ethProvider: d,
      txItem: b
    };
  }
  /**
   * Prepare tx and emit `txSubmitted` event (to show tx in tx history in UI e.g.)
   */
  submitTransaction(e, r, i, u = "Transaction", d) {
    const g = {
      hash: e,
      label: u,
      rawData: r || "",
      owner: this.lastAccount.wallets[this.lastAccount.walletIndex].address || "none",
      status: "pending",
      chainId: i || this.defaultNetworkId,
      explorerUrl: this.explorerUrls[i || this.defaultNetworkId] ? `${this.explorerUrls[i || this.defaultNetworkId]}/tx/${e}` : "",
      createdAt: Date.now(),
      internalLabel: d
    };
    return this.events.emit("txSubmitted", g), g;
  }
  /**
   * Get signed tx for making a contract write call.
   */
  async signContractWrite(e) {
    var r;
    const i = this.validateChainId(e.chainId);
    if (await this.handleNetworkChange(i), e.strategy || (e.strategy = this.lastAccount.authStrategy), e.walletIndex || (e.walletIndex = this.lastAccount.walletIndex), !e.authData)
      if (e.strategy === "passkey" && this.lastAccount.username)
        e.authData = {
          username: this.lastAccount.username
        };
      else {
        He("AUTHENTICATION_DATA_NOT_PROVIDED");
        return;
      }
    const u = (r = this.lastAccount.wallets[e.walletIndex]) == null ? void 0 : r.address;
    if (!u) {
      He("CANT_GET_ACCOUNT_ADDRESS");
      return;
    }
    if (e.mustConfirm)
      return await new Promise((S, A) => {
        this.events.emit("txApprove", {
          contractWrite: { ...e, mustConfirm: !1, resolve: S, reject: A }
        });
      });
    const d = new Dp(e.contractAbi).encodeFunctionData(
      e.contractFunctionName,
      e.contractFunctionValues
    ), g = await new I9(
      u,
      this.getRpcProviderForChainId(i)
    ).populateTransaction({
      from: u,
      to: e.contractAddress,
      value: 0,
      data: d
    });
    if (!g.gasPrice) {
      const S = await this.getRpcProviderForChainId(e.chainId).getFeeData();
      g.gasPrice = S.gasPrice || 2e10, S.maxPriorityFeePerGas && (g.maxPriorityFeePerGas = S.maxPriorityFeePerGas), S.maxFeePerGas ? g.maxFeePerGas = S.maxFeePerGas : g.maxFeePerGas = BigInt(S.gasPrice || 0) * BigInt(2) + (S.maxPriorityFeePerGas || 0n);
    }
    if (!g.gasLimit) {
      const S = await this.getRpcProviderForChainId(e.chainId).estimateGas(g);
      g.gasLimit = S ? Math.floor(Number(S) * 1.01) : 1e6;
    }
    const b = new Dp(U2), y = b.encodeFunctionData("signEIP155", [e.walletIndex, g]), k = await this.getProxyForStrategy(e.strategy, y, e.authData);
    if (k) {
      const [S] = b.decodeFunctionResult("signEIP155", k).toArray();
      return e.resolve && e.resolve({
        signedTxData: S,
        chainId: i
      }), {
        signedTxData: S,
        chainId: i
      };
    }
  }
  /**
   * Get result of contract read.
   * Utility function, this has nothing to do with Oasis.
   */
  async contractRead(e) {
    const r = this.validateChainId(e.chainId), i = this.getRpcProviderForChainId(r);
    await this.handleNetworkChange(r);
    const u = new Sg(e.contractAddress, e.contractAbi, i);
    return e.contractFunctionValues ? await u[e.contractFunctionName](...e.contractFunctionValues) : await u[e.contractFunctionName]();
  }
  /**
   * Call an `Account Manager` contract method with a gasless transaction.
   * This means that app owner (clientId) pays for the transaction fees instead of user.
   * These methods must be supported by `generateGaslessTx` method on the contract.
   * Supported methods are defined by `GaslessTxType`.
   * About
   * - get & confirm credentials
   * - calculate and format tx data (according to `funcDataTypes` and `funcDataValuesFormatter` params)
   * - broadcast the tx (marked with `label` from params)
   */
  async processGaslessMethod(e) {
    if (!this.sapphireProvider)
      return He("SAPPHIRE_PROVIDER_NOT_INITIALIZED");
    if (!this.accountManagerContract)
      return He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED");
    if (e.authData.hashedUsername || (e.authData.hashedUsername = await Fi(e.authData.username)), !e.authData.hashedUsername) {
      He("CANT_HASH_USERNAME");
      return;
    }
    const r = {
      [e.strategy]: await this.getCredentialsForStrategy(
        e.strategy,
        e.data,
        e.authData
      )
    }, i = e.funcDataValuesFormatter({
      credentials: r,
      hashedUsername: e.authData.hashedUsername
    }), u = this.abiCoder.encode(
      ["tuple(bytes funcData, uint8 txType)"],
      [
        {
          funcData: this.abiCoder.encode([e.funcDataTypes], [i]),
          txType: e.txType
        }
      ]
    ), d = (await this.sapphireProvider.getFeeData()).gasPrice, g = await this.sapphireProvider.getTransactionCount(
      await this.accountManagerContract.gaspayingAddress()
    ), b = await this.getApillonSignature(u);
    if (!b.signature)
      return He("CANT_GET_SIGNATURE");
    const y = await this.accountManagerContract.generateGaslessTx(
      u,
      g,
      b.gasPrice ? BigInt(b.gasPrice) : d,
      b.gasLimit ? BigInt(b.gasLimit) : 1000000n,
      BigInt(b.timestamp),
      b.signature
    ), k = await this.broadcastTransaction(
      y,
      this.sapphireChainId,
      e.label || "Gasless Transaction",
      e.internalLabel || `gasless_${e.txType}`
    );
    if (k.txHash)
      return k.txHash;
  }
  // #endregion
  // #region Helpers
  /**
   * Helper for triggering different auth strategies
   */
  async getProxyForStrategy(e, r, i) {
    if (this.accountManagerContract || He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED"), e === "password")
      return await new y4(this).getProxyResponse(r, i);
    if (e === "passkey")
      return await new b4(this).getProxyResponse(r, i);
  }
  /**
   * Use signContractWrite to invoke an account manager method and broadcast the tx
   * @returns txHash | undefined
   */
  async proxyWriteForStrategy(e, r, i, u, d, g = !1) {
    this.accountManagerContract || He("ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED");
    const b = qF[r][e];
    if (e === "password")
      return await new y4(this).proxyWrite(
        b,
        i,
        u,
        d,
        g
      );
    if (e === "passkey")
      return await new b4(this).proxyWrite(
        b,
        i,
        u,
        d,
        g
      );
  }
  async getCredentialsForStrategy(e, r, i) {
    var u;
    const d = i.hashedUsername || await Fi(i.username);
    if (e === "password")
      return await new y4(this).getCredentials(r, { ...i, hashedUsername: d });
    if (e === "passkey")
      return await new b4(this).getPasskeyForMode(
        ((u = this == null ? void 0 : this.xdomain) == null ? void 0 : u.mode) || "standalone",
        d,
        r
      );
  }
  /**
   * Helper for waiting for tx receipt
   */
  async waitForTxReceipt(e, r) {
    !r && !this.sapphireProvider && He("SAPPHIRE_PROVIDER_NOT_INITIALIZED");
    const i = 60;
    let u = 0;
    for (; ; ) {
      const d = await (r || this.sapphireProvider).getTransactionReceipt(e);
      if (d)
        return d;
      if (u += 1, u >= i)
        return;
      await new Promise((g) => setTimeout(g, 1e3));
    }
  }
  setDefaultNetworkId(e) {
    return this.rpcUrls[e] || e === Qv || e === Qy ? (this.events.emit("dataUpdated", {
      name: "defaultNetworkId",
      newValue: e,
      oldValue: this.defaultNetworkId
    }), this.events.emit("chainChanged", { chainId: `0x${e.toString(16)}` }), this.defaultNetworkId = e, !0) : !1;
  }
  /**
   * Send event requestChainChange, wait for it to resolve.
   * Throws error if chain was not changed.
   */
  async handleNetworkChange(e) {
    if (e && e !== this.defaultNetworkId) {
      if (!await new Promise(
        (r) => this.events.emit("requestChainChange", { chainId: e, resolve: r })
      ))
        return He("CHAIN_CHANGE_FAILED");
      this.setDefaultNetworkId(e);
    }
  }
  // Get sapphire chain id from connected provider
  async loadSapphireChainId() {
    return !this.sapphireChainId && this.sapphireProvider && (this.sapphireChainId = +(await this.sapphireProvider.getNetwork()).chainId.toString()), this.sapphireChainId;
  }
  /**
   * Check if rpc is configured for desired network ID.
   */
  validateChainId(e) {
    return (e && !G8(e) && !this.rpcUrls[e] || !e && this.defaultNetworkId && !this.rpcUrls[this.defaultNetworkId]) && He("NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID"), !e && this.defaultNetworkId && (e = this.defaultNetworkId), e;
  }
  /**
   * Get provider object for chainId.
   * If no chainId specified, use sapphire network rpc.
   */
  getRpcProviderForChainId(e) {
    if (!e || e && !this.rpcUrls[e] && G8(+e.toString()))
      return this.sapphireProvider || (this.events.emit("disconnect", { error: new h_() }), He("SAPPHIRE_PROVIDER_NOT_INITIALIZED")), this.sapphireProvider;
    {
      const r = this.rpcProviders[e] || new sk(this.rpcUrls[e]);
      return this.rpcProviders[e] = r, r || He("CROSS_CHAIN_PROVIDER_NOT_INITIALIZED"), r;
    }
  }
  getGaspayingAddress() {
    return this.accountManagerContract.gaspayingAddress();
  }
  // #endregion
}
const Uo = {
  WALLET_CONTEXT: "oaw_context",
  TRANSACTIONS_CONTEXT: "oaw_transactions",
  TOKENS_CONTEXT: "oaw_tokens",
  ERROR_LOG: "oaw_err",
  OTP_EXPIRATION: "oaw_otp_expire_time",
  WALLET_NAMES: "oaw_names"
};
function g_(a = 1e3) {
  return new Promise((e) => setTimeout(e, a));
}
function nI(a) {
  return !a || a.length <= 10 ? a : `${a.slice(0, 6)}...${a.slice(-4)}`;
}
function m_(a) {
  let e = localStorage.getItem(Uo.ERROR_LOG) || "";
  e.length > 64e3 && (e = e.slice(0, 56e3)), localStorage.setItem(
    Uo.ERROR_LOG,
    `${(/* @__PURE__ */ new Date()).toISOString().slice(0, -5)} ~ ${a}
` + e
  );
}
function Yv(a, e = "ETH", r = 4) {
  (r < 0 || r > 18) && (r = 5);
  let i = typeof a == "string" ? parseFloat(a) : a;
  const u = (typeof a != "string" ? a.toString() : a).match(
    new RegExp("(\\d+\\.\\d{" + r + "})(\\d)")
  );
  return u && (i = parseFloat(u[1])), `${i}${e ? ` ${e}` : ""}`;
}
function rI(a) {
  return Array.isArray(a) ? a.join(`
`) : Object.values(a).reduce((e, [r, i]) => {
  }, "");
}
const y_ = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2024.0.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20128%20128'%20style='enable-background:new%200%200%20128%20128;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{clip-path:url(%23SVGID_2_);}%20.st1{fill-rule:evenodd;clip-rule:evenodd;fill:%230089DB;}%20%3c/style%3e%3cg%3e%3cdefs%3e%3crect%20id='SVGID_1_'%20width='128'%20height='128'/%3e%3c/defs%3e%3cclipPath%20id='SVGID_2_'%3e%3cuse%20xlink:href='%23SVGID_1_'%20style='overflow:visible;'/%3e%3c/clipPath%3e%3cg%20class='st0'%3e%3cpath%20class='st1'%20d='M115,25.4C105.3,13,91.1,5.1,75.4,5.1C45,5.1,22.7,33.4,22.7,64c0,21.3,14.2,37.3,29.9,37.3%20c1.5,0,2.9-0.1,4.4-0.4C46.4,93.2,39.7,79.2,39.7,64c0-24.2,16.4-43.1,35.7-43.1c21.1,0,35.7,20.9,35.7,43.1%20c-0.1,16.4-5.9,32.7-16.2,44.7c-9,10.5-20.6,17.1-33.4,19.2c0,0,1.1,0.1,2.5,0.1c35.3,0,64-28.7,64-64%20C128,49.5,123.2,36.1,115,25.4z%20M105.3,64c0-21.3-14.2-37.3-29.9-37.3c-1.5,0-2.9,0.1-4.4,0.4C81.6,34.8,88.3,48.8,88.3,64%20c0,24.2-16.4,43.1-35.7,43.1c-21.1,0-35.7-20.9-35.7-43.1c0.1-16.4,5.9-32.7,16.2-44.7c9-10.5,20.6-17.1,33.4-19.2%20c0,0-1.1-0.1-2.5-0.1C28.7,0,0,28.7,0,64c0,14.5,4.8,27.9,13,38.6c9.7,12.4,23.9,20.2,39.6,20.2C83,122.9,105.3,94.6,105.3,64z'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e", aI = (a = 0, e) => ({
  username: "",
  walletIndex: 0,
  accountWallets: [],
  stagedWalletsCount: 0,
  // how many new wallets have been addedd, but are not in `accountWallets` yet
  isAccountWalletsStale: !1,
  contractAddress: "",
  privateKeys: {},
  authStrategy: "passkey",
  networkId: a,
  walletScreen: "main",
  walletScreenHistory: [],
  isOpen: !1,
  // is wallet modal displayed
  displayedError: "",
  displayedSuccess: "",
  displayedInfo: "",
  appProps: e,
  loadingWallets: !1
});
function b_(a, e) {
  switch (e.type) {
    case "setValue": {
      if (e.payload.key === "walletScreen") {
        const r = [...a.walletScreenHistory];
        return r.length > 1 && r[r.length - 2] === e.payload.value ? r.pop() : r.length > 0 && r[r.length - 1] === e.payload.value || r.push(e.payload.value), {
          ...a,
          walletScreenHistory: r,
          displayedError: "",
          [e.payload.key]: e.payload.value
        };
      }
      return {
        ...a,
        [e.payload.key]: e.payload.value
      };
    }
    case "setState":
      return {
        ...a,
        ...e.payload
      };
    case "setBalance": {
      const r = [...a.accountWallets], i = r.findIndex((u) => u.address === e.payload.address);
      return i > -1 && (r[i].balance = e.payload.balance || ""), {
        ...a,
        accountWallets: r
      };
    }
    case "reset":
      return aI(a.networkId, a.appProps);
    default:
      throw new Error("Unhandled action type." + JSON.stringify(e));
  }
}
const oI = Jv(void 0);
function v_({
  children: a,
  networks: e = [],
  defaultNetworkId: r = 0,
  ...i
}) {
  e = [
    {
      name: "Sapphire Testnet",
      id: Qy,
      rpcUrl: "https://testnet.sapphire.oasis.io",
      explorerUrl: "https://explorer.oasis.io/testnet/sapphire",
      imageUrl: y_,
      currencySymbol: "ROSE"
    },
    ...e
  ];
  const [u, d] = Xv(
    b_,
    aI(r || e[0].id, { ...i, defaultNetworkId: r })
  ), g = Rn(!1), [b, y] = Ct(!1), [k, S] = Ct(), A = Rn(void 0), x = Rn(void 0), M = e.reduce(
    (j, ne) => (j[ne.id] = ne, j),
    {}
  ), D = Kl(() => {
    if (!(u.walletIndex >= u.accountWallets.length))
      return u.accountWallets[u.walletIndex];
  }, [u.walletIndex, u.accountWallets]);
  Ln(() => {
    !k && !g.current && (g.current = !0, O());
  }, []), Ln(() => {
    var j;
    if (b && k) {
      const {
        walletScreen: ne,
        displayedError: ae,
        loadingWallets: he,
        privateKeys: Ie,
        appProps: V,
        walletScreenHistory: B,
        isOpen: P,
        ...H
      } = u;
      (j = k.xdomain) == null || j.storageSet(Uo.WALLET_CONTEXT, JSON.stringify(H));
    }
  }, [u]), Ln(() => {
    u.walletIndex < u.accountWallets.length && W([u.accountWallets[u.walletIndex].address]);
  }, [u.username, u.walletIndex, u.accountWallets.length]);
  async function O() {
    var j;
    let ne;
    if (e && e.length ? ne = z9({
      ...i,
      networks: e,
      defaultNetworkId: r
    }) : ne = z9(), ne) {
      S(ne);
      const ae = await ((j = ne.xdomain) == null ? void 0 : j.storageGet(Uo.WALLET_CONTEXT));
      let he = { ...u };
      if (ae)
        try {
          const Ie = JSON.parse(ae);
          he = { ...he, ...Ie }, d({ type: "setState", payload: Ie });
        } catch (Ie) {
          console.error("Cant parse global state localStorage", Ie);
        }
      he.networkId !== r && ne.setDefaultNetworkId(he.networkId), ne.setAccount({
        username: he.username,
        strategy: he.authStrategy,
        walletIndex: he.walletIndex,
        contractAddress: he.contractAddress
      }), ne.setWallets(he.accountWallets), await new Promise((Ie) => setTimeout(Ie, 10)), g.current = !1, y(!0);
    }
  }
  function T(j, ne) {
    d({ type: "setValue", payload: { key: j, value: ne } });
  }
  async function L(j, ne) {
    if (!u.loadingWallets) {
      T("loadingWallets", !0);
      try {
        const ae = await k?.getAccountWallets({
          strategy: j || u.authStrategy,
          authData: { username: ne || u.username },
          reload: !0
        }) || [];
        k?.setAccount({
          strategy: j || u.authStrategy,
          username: ne || u.username
        });
        const he = await U(ae, ne);
        return u.walletIndex < ae.length && k?.events.emit("accountsChanged", [ae[u.walletIndex].address]), T("loadingWallets", !1), T("isAccountWalletsStale", !1), T("displayedError", ""), W(
          ae.map((Ie) => Ie.address),
          he
        ), ae;
      } catch (ae) {
        console.error("loadAccountWallets", ae), Y(ae);
      }
      T("loadingWallets", !1);
    }
  }
  async function U(j, ne) {
    var ae, he;
    const { all: Ie, current: V } = await J(), B = {};
    ne = ne || u.username || k?.lastAccount.username || "-";
    const P = u.contractAddress || ((ae = k?.lastAccount) == null ? void 0 : ae.contractAddress) || "-", H = [];
    for (const G of j)
      H.push({
        ...G,
        balance: "0",
        title: V[G.address] || V[`${G.index}`] || ne
      }), !V[G.address] && V[`${G.index}`] && (B[G.address] = V[`${G.index}`]);
    return Object.keys(B).length && ((he = k?.xdomain) == null || he.storageSet(
      Uo.WALLET_NAMES,
      JSON.stringify({
        ...Ie,
        [P]: {
          ...V,
          ...B
        }
      })
    )), T("accountWallets", H), H;
  }
  async function W(j, ne = u.accountWallets) {
    if (await new Promise((ae) => setTimeout(ae, 50)), !j) {
      if (!(D != null && D.address))
        return;
      j = [D.address];
    }
    try {
      const ae = await Promise.all(
        j.map(async (Ie) => {
          const V = await k?.getAccountBalance(Ie);
          return {
            address: Ie,
            balance: V
          };
        })
      ), he = [...ne];
      return ae.forEach((Ie) => {
        const V = he.findIndex((B) => B.address === Ie.address);
        V > -1 && (he[V].balance = Ie.balance || "0");
      }), T("accountWallets", he), !0;
    } catch (ae) {
      console.error("Reloading balance", ae);
    }
  }
  async function Z(j, ne) {
    var ae;
    !ne && ne !== 0 && (ne = u.walletIndex);
    const { all: he, current: Ie } = await J();
    (ae = k?.xdomain) == null || ae.storageSet(
      Uo.WALLET_NAMES,
      JSON.stringify({
        ...he,
        [u.contractAddress]: {
          ...Ie,
          [ne > u.accountWallets.length - 1 ? `${ne}` : u.accountWallets[ne].address]: j
        }
      })
    );
    const V = u.accountWallets.findIndex((B) => B.index === ne);
    if (V > -1) {
      const B = [...u.accountWallets];
      B[V] = { ...B[V], title: j }, T("accountWallets", B);
    }
  }
  async function J() {
    var j, ne;
    const ae = await ((j = k?.xdomain) == null ? void 0 : j.storageGet(Uo.WALLET_NAMES)), he = u.contractAddress || ((ne = k?.lastAccount) == null ? void 0 : ne.contractAddress) || "-";
    let Ie = {}, V = {};
    if (ae)
      try {
        Ie = JSON.parse(ae), Ie[he] && (V = Ie[he]);
      } catch {
      }
    return { all: Ie, current: V };
  }
  function Y(j, ne) {
    var ae;
    let he = "";
    return j ? (console.error(ne ?? "", j), j != null && j.name && (he = uk[j.name]), !he && j != null && j.error && ((ae = j?.error) != null && ae.message ? he = j.error.message : typeof j.error == "string" && (he = j.error)), !he && j != null && j.details && (he = j.details), !he && j != null && j.message && (he = j.message), he.includes("message: ") && (he = he.split("message: ")[1]), m_(he), he && he !== "already known" && he !== "Request rejected by user" && j?.code !== 4001 && j?.name !== "NotAllowedError" && T("displayedError", he)) : T("displayedError", ""), he;
  }
  function X(j, ne = 1e4) {
    A.current && clearTimeout(A.current), T("displayedSuccess", j), A.current = setTimeout(() => {
      T("displayedSuccess", ""), A.current = void 0;
    }, ne);
  }
  function ee(j, ne = 1e4) {
    x.current && clearTimeout(x.current), T("displayedInfo", j), x.current = setTimeout(() => {
      T("displayedInfo", ""), x.current = void 0;
    }, ne);
  }
  return /* @__PURE__ */ C(
    oI.Provider,
    {
      value: {
        state: u,
        dispatch: d,
        networks: e,
        networksById: M,
        defaultNetworkId: r || 0,
        activeWallet: D,
        wallet: k,
        setWallet: S,
        initialized: b,
        loadAccountWallets: L,
        parseAccountWallets: U,
        reloadAccountBalances: W,
        saveAccountTitle: Z,
        handleError: Y,
        handleSuccess: X,
        handleInfo: ee,
        setStateValue: T,
        setScreen: (j) => T("walletScreen", j),
        goScreenBack: () => {
          u.walletScreenHistory.length > 1 ? T(
            "walletScreen",
            u.walletScreenHistory[u.walletScreenHistory.length - 2]
          ) : T("walletScreen", "main");
        }
      },
      children: a
    }
  );
}
function Et() {
  const a = ew(oI);
  if (a === void 0)
    throw new Error("useWalletContext usage must be wrapped with WalletContext provider.");
  return a;
}
const w_ = () => ({
  txs: {},
  pending: []
});
function k_(a, e) {
  switch (e.type) {
    case "setState":
      return {
        ...a,
        ...e.payload
      };
    case "addTx":
      return {
        ...a,
        txs: {
          ...a.txs,
          [e.payload.owner]: {
            ...a.txs[e.payload.owner],
            [e.payload.hash]: e.payload
          }
        }
        // pending: [...new Set([...state.pending, action.payload.hash])],
      };
    case "setTxStatus":
      return {
        ...a,
        txs: {
          ...a.txs,
          [e.payload.tx.owner]: {
            ...a.txs[e.payload.tx.owner],
            [e.payload.tx.hash]: {
              ...a.txs[e.payload.tx.owner][e.payload.tx.hash],
              status: e.payload.status
            }
          }
        },
        pending: e.payload.status === "pending" ? [.../* @__PURE__ */ new Set([...a.pending, e.payload.tx.hash])] : a.pending.filter((r) => r !== e.payload.tx.hash)
      };
    default:
      throw new Error("Unhandled action type." + JSON.stringify(e));
  }
}
const iI = Jv(void 0);
function E_({ children: a }) {
  const [e, r] = Xv(k_, w_()), i = Rn(!1), u = Rn(!1), {
    wallet: d,
    activeWallet: g,
    reloadAccountBalances: b,
    setStateValue: y,
    handleInfo: k
  } = Et();
  Ln(() => {
    d && !i.current && (i.current = !0, S());
  }, [d]), Ln(() => {
    var x;
    if (u.current && d) {
      const { pending: M, ...D } = e;
      (x = d.xdomain) == null || x.storageSet(Uo.TRANSACTIONS_CONTEXT, JSON.stringify(D));
    }
  }, [e]), Ln(() => {
    if (g && e.txs[g.address] && Object.keys(e.txs[g.address]).length)
      for (const x of Object.values(e.txs[g.address]))
        A(x);
  }, [g, e.txs]);
  async function S() {
    var x;
    const M = await ((x = d?.xdomain) == null ? void 0 : x.storageGet(Uo.TRANSACTIONS_CONTEXT));
    if (M)
      try {
        const D = JSON.parse(M);
        r({ type: "setState", payload: D });
      } catch (D) {
        console.error("Cant parse context state localStorage", D);
      }
    setTimeout(() => {
      u.current = !0;
    }, 100);
  }
  async function A(x, M = !1) {
    var D;
    if (!g)
      return;
    const O = x.hash, T = KT();
    if (!T)
      throw new Error("Wallet not initialized." + O);
    const L = T.getRpcProviderForChainId(x?.chainId);
    if (!L)
      throw new Error("Provider not initialized. " + O);
    const U = (D = e.txs[g.address]) == null ? void 0 : D[O];
    if (!U || U.status === "confirmed" || U.status === "failed" || e.pending.includes(O))
      return;
    if (Date.now() - U.createdAt > 15e3 && !await L.getTransaction(O)) {
      r({ type: "setTxStatus", payload: { tx: U, status: "failed" } });
      return;
    }
    const W = await L.getTransactionReceipt(O);
    if (W)
      W.status ? (r({
        type: "setTxStatus",
        payload: {
          tx: U,
          status: "confirmed"
        }
      }), V9(x) && (y("isAccountWalletsStale", !0), k("stale"))) : r({
        type: "setTxStatus",
        payload: {
          tx: U,
          status: "failed"
        }
      }), b(), T.events.emit("txDone", U);
    else {
      r({
        type: "setTxStatus",
        payload: {
          tx: U,
          status: "pending"
        }
      });
      const Z = M ? null : setTimeout(() => A(x), 16e3);
      L.once(O, (J) => {
        Z && clearTimeout(Z);
        const Y = J && !isNaN(J.status) && J.status === 0;
        b(), r({
          type: "setTxStatus",
          payload: {
            tx: U,
            status: Y ? "failed" : "confirmed"
          }
        }), !Y && V9(x) && (y("isAccountWalletsStale", !0), k("stale")), T.events.emit("txDone", U);
      });
    }
  }
  return /* @__PURE__ */ C(iI.Provider, { value: { state: e, dispatch: r, checkTransaction: A }, children: a });
}
function V9(a) {
  return a?.internalLabel && [
    "proxyWrite_addWallet",
    "proxyWrite_addWalletPassword",
    "proxyWrite_manageCredential",
    "proxyWrite_manageCredentialPassword",
    "gasless_3",
    // AddWallet
    "gasless_4",
    // AddWalletPassword
    "updateAccountWalletTitle"
  ].includes(a.internalLabel);
}
function sI() {
  const a = ew(iI);
  if (a === void 0)
    throw new Error(
      "useTransactionsContext usage must be wrapped with TransactionsContext provider."
    );
  return a;
}
function S_({ children: a }) {
  const [e, r] = Xv(x_, A_()), {
    wallet: i,
    handleError: u,
    state: { appProps: d, username: g },
    dispatch: b,
    loadAccountWallets: y,
    parseAccountWallets: k
  } = Et();
  function S(T, L) {
    r({ type: "setValue", payload: { key: T, value: L } });
  }
  async function A(T = !1, L) {
    if (L?.preventDefault(), !!e.username) {
      S("loading", !0), u();
      try {
        if (await i?.userExists(e.username)) {
          if (await i?.authenticate("passkey", { username: e.username }))
            return x({
              username: e.username,
              authStrategy: "passkey"
            }), !0;
        } else if (!T && await M())
          if (d.passkeyAuthMode === "tab_form") {
            if (!(i != null && i.xdomain))
              throw He("XDOMAIN_NOT_INIT");
            S("screen", "configuringPasskey");
            const U = await i.xdomain.createViaTab(e.username);
            U && U.username && (await y(U.authStrategy, U.username), x({ username: e.username, authStrategy: "passkey" }));
          } else ["redirect", "tab_form"].includes(d.passkeyAuthMode || "") ? O(e.username) : S("screen", "confirmCode");
      } catch (U) {
        u(U, "onAuth");
      }
      S("loading", !1);
    }
  }
  async function x({
    username: T,
    authStrategy: L
  }) {
    b({
      type: "setState",
      payload: {
        walletIndex: 0,
        username: T,
        authStrategy: L
        // networkId: defaultNetworkId || undefined,
      }
    }), await new Promise((U) => setTimeout(U, 50)), i != null && i.lastAccount.wallets && k(i?.lastAccount.wallets || []);
  }
  async function M() {
    var T;
    try {
      const L = await fetch(
        "https://api-dev.apillon.io/embedded-wallet/otp/generate",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            email: e.username
          })
        }
      );
      if (!L.ok || L.status >= 400)
        throw new Error("Could not send confirmation email");
      const { data: U } = await L.json();
      if (U != null && U.expireTime) {
        const W = new Date(U.expireTime).getTime() || 0;
        S("lastCodeExpiretime", W), (T = i?.xdomain) == null || T.storageSet(Uo.OTP_EXPIRATION, `${W}`, !0);
      }
      return !0;
    } catch (L) {
      u(L, "sendConfirmationEmail");
    }
  }
  async function D() {
    S("loading", !0), u();
    try {
      let T;
      if (d.passkeyAuthMode === "tab_form") {
        if (!(i != null && i.xdomain))
          throw He("XDOMAIN_NOT_INIT");
        if (T = await i.xdomain.createViaTab(e.username), !(T != null && T.username))
          throw new Error("Couldn't authenticate account. Please try again.");
        await y(T.authStrategy, T.username);
      } else {
        let L = e.hashedUsername;
        L || (L = await Fi(e.username), S("hashedUsername", L)), T = await i?.register("passkey", { username: e.username }, L);
      }
      T && x({ username: e.username, authStrategy: "passkey" });
    } catch (T) {
      u(T, "startRegister");
    }
    S("loading", !1);
  }
  function O(T) {
    const L = "https://localhost:5175";
    return !g && L ? (window.location.href = `${L}?${[
      `ref=${encodeURIComponent(window.location.origin + window.location.pathname)}`,
      `clientId=${d.clientId || i?.apillonClientId || ""}`,
      `username=${encodeURIComponent(T || "")}`
    ].join("&")}`, !0) : !1;
  }
  return /* @__PURE__ */ C(
    lI.Provider,
    {
      value: {
        state: e,
        dispatch: r,
        setStateValue: S,
        onAuth: A,
        setupUserInfo: x,
        sendConfirmationEmail: M,
        startRegister: D
      },
      children: a
    }
  );
}
const lI = Jv(void 0), A_ = () => ({
  loading: !1,
  username: "",
  hashedUsername: void 0,
  screen: "loginForm",
  lastCodeExpiretime: 0
  // get from /otp/generate and check before /otp/validate
});
function x_(a, e) {
  switch (e.type) {
    case "setState":
      return {
        ...a,
        ...e.payload
      };
    case "setValue":
      return e.payload.key === "username" ? {
        ...a,
        [e.payload.key]: e.payload.value,
        hashedUsername: void 0
      } : {
        ...a,
        [e.payload.key]: e.payload.value
      };
    default:
      throw new Error("Unhandled action type." + JSON.stringify(e));
  }
}
function uw() {
  const a = ew(lI);
  if (a === void 0)
    throw new Error("useAuthContext usage must be wrapped with TokensContext provider.");
  return a;
}
function uI(a) {
  var e, r, i = "";
  if (typeof a == "string" || typeof a == "number") i += a;
  else if (typeof a == "object") if (Array.isArray(a)) {
    var u = a.length;
    for (e = 0; e < u; e++) a[e] && (r = uI(a[e])) && (i && (i += " "), i += r);
  } else for (r in a) a[r] && (i && (i += " "), i += r);
  return i;
}
function bt() {
  for (var a, e, r = 0, i = "", u = arguments.length; r < u; r++) (a = arguments[r]) && (e = uI(a)) && (i && (i += " "), i += e);
  return i;
}
const cw = ({
  size: a = 36,
  fill: e = "#F0F2DA",
  className: r
}) => {
  const [i, u] = Ct(0);
  Ln(() => {
    const S = setInterval(() => {
      u((A) => A > 200 ? 0 : A + 1);
    }, 10);
    return () => clearInterval(S);
  }, []);
  const d = Kl(() => i < 30 ? "M110 140C126.569 140 140 126.569 140 110C140 93.4315 126.569 80 110 80C93.4315 80 80 93.4315 80 110C80 126.569 93.4315 140 110 140Z" : i < 40 || i < 95 ? "M50 140C66.5685 140 80 126.569 80 110C80 93.4315 66.5685 80 50 80C33.4315 80 20 93.4315 20 110C20 126.569 33.4315 140 50 140Z" : "", [i]), g = Kl(() => i < 95 ? "M110 140C126.569 140 140 126.569 140 110C140 93.4315 126.569 80 110 80C93.4315 80 80 93.4315 80 110C80 126.569 93.4315 140 110 140Z" : "", [i]), b = Kl(() => i < 30 ? "M110 140C126.569 140 140 126.569 140 110C140 93.4315 126.569 80 110 80C93.4315 80 80 93.4315 80 110C80 126.569 93.4315 140 110 140Z" : i < 40 || i < 95 ? "M170 140C186.569 140 200 126.569 200 110C200 93.4315 186.569 80 170 80C153.431 80 140 93.4315 140 110C140 126.569 153.431 140 170 140Z" : "", [i]), y = Kl(() => i < 98 ? "M110 88V133L92 110.5L110 88Z" : i < 120 ? "M110 35V185L50 110L110 35Z" : i < 130 ? "M110 50V170L50 110L110 50Z" : i < 140 ? "M110 35V185L50 110L110 35Z" : "M190 50V170L110 110L190 50Z", [i]), k = Kl(() => i < 98 ? "M110 133V88L128 110.5L110 133Z" : i < 120 ? "M110 185V35L170 110L110 185Z" : i < 130 ? "M110 170V50L170 110L110 170Z" : i < 140 ? "M110 185V35L170 110L110 185Z" : "M30 170V50L110 110L30 170Z", [i]);
  return /* @__PURE__ */ C("div", { className: bt("animation-loader", r), children: /* @__PURE__ */ Re(
    "svg",
    {
      width: a,
      height: a,
      viewBox: "0 0 220 220",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        /* @__PURE__ */ C("path", { d: b, fill: e }),
        /* @__PURE__ */ C("path", { d: g, fill: e }),
        /* @__PURE__ */ C("path", { d, fill: e }),
        /* @__PURE__ */ C("path", { d: y, fill: e }),
        /* @__PURE__ */ C("path", { d: k, fill: e })
      ]
    }
  ) });
}, C_ = "160px", T_ = "48px", I_ = "px-5 py-0.5", Dt = NP(
  ({
    blank: a = !1,
    self: e = !1,
    variant: r = "primary",
    minWidth: i = C_,
    minHeight: u = T_,
    paddingClass: d = I_,
    disabled: g = !1,
    loading: b = !1,
    type: y = "button",
    className: k,
    ...S
  }, A) => {
    const x = bt(
      d,
      k,
      "oaw-button relative inline-block rounded-lg text-sm font-bold border-b-[4px] border-t-[4px] border-x-0",
      {
        "bg-yellow text-dark border-b-yellow border-t-yellow": r === "primary",
        "bg-lightdark text-offwhite border-b-lightdark border-t-lightdark": r === "secondary",
        "transition-transform hover:border-b-blue/50 hover:translate-y-[-2px] focus:translate-y-px focus:border-b-yellow/50": !b && !g && ["primary", "secondary"].includes(r),
        "bg-transparent text-yellow border-t-transparent border-b-transparent shadow-[0_0_0_1px_#313442]": r === "ghost",
        "transition-transform hover:border-b-brightdark hover:translate-y-[-2px] focus:translate-y-px": !b && !g && r === "ghost",
        "opacity-60 grayscale": g
      }
    ), M = { minWidth: i, minHeight: u }, D = /* @__PURE__ */ Re(Yt, { children: [
      !!b && /* @__PURE__ */ Re(Yt, { children: [
        " ",
        /* @__PURE__ */ C(
          cw,
          {
            fill: r === "ghost" ? "#F9FF73" : "#141721",
            className: "absolute top-1/2 left-1/2 m-[-18px_0_0_-18px]"
          }
        )
      ] }),
      " ",
      !b && S.children
    ] });
    return (a || e) && typeof S.href == "string" ? /* @__PURE__ */ C(
      "a",
      {
        ref: A,
        href: S.href,
        target: a ? "_blank" : "_self",
        rel: "noreferrer",
        title: S.title,
        className: bt(x, "inline-flex items-center justify-center"),
        style: M,
        onClick: S.onClick,
        children: D
      }
    ) : /* @__PURE__ */ C(
      "button",
      {
        ref: A,
        type: y,
        disabled: b || g,
        className: x,
        style: M,
        ...S,
        children: D
      }
    );
  }
);
Dt.displayName = "Btn";
function Tg({
  label: a,
  className: e,
  disabled: r,
  ...i
}) {
  return /* @__PURE__ */ Re(hE, { children: [
    !!a && /* @__PURE__ */ C(pE, { className: "text-xs leading-relaxed font-bold mb-2 block", children: a }),
    /* @__PURE__ */ C(
      gE,
      {
        ...i,
        disabled: r,
        className: bt(
          "w-full px-5 py-3 text-sm",
          "rounded-lg border border-brightdark",
          "!outline-none bg-lightdark text-offwhite",
          "placeholder:text-lightgrey",
          {
            "hover:border-lightgrey focus:border-offwhite": !r
          },
          e
        )
      }
    )
  ] });
}
const a1 = ({
  title: a,
  description: e,
  header: r,
  className: i,
  titleClass: u,
  headerClass: d
}) => /* @__PURE__ */ Re("header", { className: bt("text-center mb-6", i), children: [
  !!r && /* @__PURE__ */ C("div", { className: bt("flex justify-center items-center mb-6", d), children: r }),
  /* @__PURE__ */ C("h2", { className: bt("mb-2", u), children: a }),
  !!e && /* @__PURE__ */ C("p", { className: "text-sm text-lightgrey", children: e })
] }), N_ = () => {
  const {
    state: { appProps: a }
  } = Et(), {
    state: { username: e, loading: r },
    setStateValue: i,
    onAuth: u
  } = uw();
  return /* @__PURE__ */ Re(Yt, { children: [
    /* @__PURE__ */ C(
      a1,
      {
        title: "Sign in or sign up",
        description: "Enter your email to set up your passkey"
      }
    ),
    /* @__PURE__ */ Re("form", { onSubmit: (d) => u(!1, d), children: [
      /* @__PURE__ */ C(
        Tg,
        {
          type: "email",
          placeholder: a.authFormPlaceholder,
          value: e,
          className: "w-full mb-6",
          onChange: (d) => i("username", d.target.value)
        }
      ),
      /* @__PURE__ */ C(Dt, { type: "submit", loading: r, className: "w-full", children: "Continue" })
    ] })
  ] });
};
function P_({ className: a }) {
  return /* @__PURE__ */ Re(
    "svg",
    {
      width: "137",
      height: "25",
      viewBox: "0 0 137 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: a,
      children: [
        /* @__PURE__ */ C("g", { clipPath: "url(#clip0_38_1212)", children: /* @__PURE__ */ C("g", { clipPath: "url(#clip1_38_1212)", children: /* @__PURE__ */ C(
          "path",
          {
            d: "M0 24.486V0.5L15.9907 12.493L0 24.486ZM15.9907 12.493L31.9813 24.486V0.5L15.9907 12.493ZM56.9828 19.8607H54.2244L52.9951 15.5252H47.8481L46.6188 19.8607H43.9763L48.7036 3.67615H52.2515L56.9808 19.8607H56.9828ZM52.5074 13.3925L50.5125 6.29662H50.3266L48.3318 13.3925H52.5054H52.5074ZM70.9526 13.8802C70.9526 15.951 70.5349 17.5121 69.7013 18.5635C68.8658 19.6149 67.7465 20.1405 66.3393 20.1405C65.4578 20.1405 64.7242 19.9347 64.1366 19.5269C63.5489 19.1171 63.0772 18.5495 62.7214 17.8219H62.5815V24.5H60.055V7.89569H62.5815V9.93649H62.7214C63.0772 9.21092 63.5489 8.64125 64.1366 8.23149C64.7242 7.82173 65.4578 7.61785 66.3393 7.61785C67.7465 7.61785 68.8658 8.14354 69.7013 9.19493C70.5368 10.2463 70.9526 11.8074 70.9526 13.8782V13.8802ZM68.2862 12.9068C68.2862 11.9333 68.0263 11.1518 67.5086 10.5641C66.9909 9.97647 66.2533 9.68264 65.2939 9.68264C64.9221 9.68264 64.5743 9.72862 64.2505 9.82256C63.9267 9.91651 63.6389 10.0544 63.393 10.2403C63.1452 10.4262 62.9493 10.6541 62.8014 10.9239C62.6535 11.1938 62.5815 11.5156 62.5815 11.8854V15.873C62.5815 16.2448 62.6555 16.5646 62.8014 16.8345C62.9473 17.1043 63.1452 17.3322 63.393 17.5181C63.6409 17.704 63.9267 17.8419 64.2505 17.9358C64.5743 18.0298 64.9221 18.0757 65.2939 18.0757C66.2514 18.0757 66.9909 17.7819 67.5086 17.1943C68.0263 16.6066 68.2862 15.8271 68.2862 14.8516V12.9048V12.9068ZM73.8769 19.8627H84.3108V17.7999H80.4851V7.89569H73.8769V9.95848H77.9585V17.7959H73.8769V19.8587V19.8627ZM80.567 5.32519C80.8229 5.06334 80.9488 4.73753 80.9488 4.35175V3.86404C80.9488 3.47826 80.8209 3.15245 80.567 2.89061C80.3111 2.62876 79.8594 2.49684 79.2098 2.49684C78.5602 2.49684 78.1324 2.62876 77.8766 2.89061C77.6207 3.15445 77.4948 3.47826 77.4948 3.86404V4.35175C77.4948 4.73753 77.6227 5.06334 77.8766 5.32519C78.1324 5.58903 78.5842 5.71896 79.2338 5.71896C79.8834 5.71896 80.3111 5.58703 80.567 5.32519ZM86.7874 19.8627H97.2453V17.7999H93.2796V2.70272H86.7874V4.76551H90.7531V17.7959H86.7874V19.8587V19.8627ZM99.7198 19.8627H110.178V17.7999H106.212V2.70272H99.7198V4.76551H103.686V17.7959H99.7198V19.8587V19.8627ZM123.11 13.8802C123.11 14.8396 122.978 15.7051 122.716 16.4767C122.453 17.2502 122.079 17.9058 121.591 18.4475C121.103 18.9892 120.51 19.407 119.806 19.6988C119.103 19.9926 118.311 20.1385 117.429 20.1385C116.548 20.1385 115.756 19.9906 115.053 19.6988C114.349 19.405 113.754 18.9872 113.268 18.4475C112.78 17.9058 112.406 17.2502 112.143 16.4767C111.879 15.7031 111.749 14.8376 111.749 13.8802C111.749 12.9228 111.881 12.0573 112.143 11.2837C112.404 10.5102 112.78 9.85454 113.268 9.31286C113.756 8.77118 114.349 8.35542 115.053 8.06159C115.756 7.76776 116.548 7.62185 117.429 7.62185C118.311 7.62185 119.103 7.76976 119.806 8.06159C120.51 8.35542 121.105 8.77317 121.591 9.31286C122.079 9.85454 122.453 10.5102 122.716 11.2837C122.978 12.0573 123.11 12.9228 123.11 13.8802ZM120.468 12.9767C120.468 11.8634 120.194 11.0259 119.644 10.4602C119.095 9.89652 118.357 9.61468 117.429 9.61468C116.502 9.61468 115.764 9.89652 115.215 10.4602C114.665 11.0239 114.391 11.8634 114.391 12.9767V14.7857C114.391 15.899 114.665 16.7365 115.215 17.3022C115.762 17.8659 116.502 18.1477 117.429 18.1477C118.357 18.1477 119.095 17.8659 119.644 17.3022C120.192 16.7385 120.468 15.899 120.468 14.7857V12.9767ZM128.873 19.8627V11.7454C128.873 11.4056 128.947 11.1038 129.093 10.842C129.239 10.5801 129.436 10.3622 129.684 10.1923C129.932 10.0224 130.21 9.89452 130.52 9.81057C130.83 9.72662 131.145 9.68264 131.471 9.68264C133.124 9.68264 133.952 10.6341 133.952 12.535V19.8627H136.478V12.1612C136.478 10.708 136.107 9.5867 135.365 8.79916C134.623 8.01162 133.65 7.61585 132.443 7.61585C131.947 7.61585 131.515 7.67781 131.143 7.80174C130.772 7.92567 130.448 8.09157 130.17 8.29945C129.892 8.50733 129.656 8.75518 129.462 9.04102C129.269 9.32685 129.111 9.62468 128.987 9.9345H128.871V7.89369H126.344V19.8587H128.871L128.873 19.8627Z",
            fill: "#F0F2DA"
          }
        ) }) }),
        /* @__PURE__ */ C("defs", { children: /* @__PURE__ */ C("clipPath", { id: "clip1_38_1212", children: /* @__PURE__ */ C("rect", { width: "137", height: "24", fill: "white", transform: "translate(0 0.5)" }) }) })
      ]
    }
  );
}
const cI = ({ className: a }) => /* @__PURE__ */ C(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: a,
    children: /* @__PURE__ */ C(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22ZM15.4856 7L11.9498 10.5358L8.414 7L7 8.414L10.5358 11.9498L7 15.4856L8.414 16.8996L11.9498 13.3638L15.4856 16.8996L16.8996 15.4856L13.3638 11.9498L16.8996 8.414L15.4856 7Z",
        fill: "currentColor"
      }
    )
  }
);
function ck({
  text: a,
  before: e,
  after: r,
  children: i,
  className: u,
  onDismiss: d
}) {
  return /* @__PURE__ */ Re(
    "div",
    {
      className: bt(
        "relative px-3 py-2 min-w-[320px] bg-primarydark group",
        "rounded-md overflow-hidden border border-solid border-brightdark",
        "flex justify-center items-start gap-2",
        u
      ),
      children: [
        e,
        i,
        !!a && /* @__PURE__ */ C(
          "div",
          {
            className: "min-w-0 overflow-auto -mr-3 pr-3 -my-2 py-2 text-offwhite text-sm font-normal break-words",
            style: { maxHeight: "120px" },
            children: a
          }
        ),
        r,
        !!d && /* @__PURE__ */ C(
          "button",
          {
            title: "Dismiss",
            className: bt(
              "oaw-button-plain absolute z-20 right-0.5 top-0.5",
              "!text-white/50 hover:!text-white",
              "opacity-0 group-hover:opacity-100"
            ),
            onClick: d,
            children: /* @__PURE__ */ C(
              "svg",
              {
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                className: "block w-4 h-4",
                children: /* @__PURE__ */ C(
                  "path",
                  {
                    fillRule: "evenodd",
                    clipRule: "evenodd",
                    d: "M12 10.6569L6.34317 5L4.92896 6.41421L10.5858 12.0711L4.92898 17.7279L6.3432 19.1421L12 13.4853L17.6569 19.1421L19.0711 17.7279L13.4143 12.0711L19.0711 6.41421L17.6569 5L12 10.6569Z",
                    fill: "currentColor"
                  }
                )
              }
            )
          }
        )
      ]
    }
  );
}
const fI = ({
  text: a,
  show: e,
  className: r
}) => {
  const { state: i, handleError: u } = Et();
  return !i.displayedError && !a || !e ? /* @__PURE__ */ C(Yt, {}) : /* @__PURE__ */ C(
    ck,
    {
      text: a || i.displayedError || "",
      before: /* @__PURE__ */ C(cI, { className: "shrink-0 text-pink" }),
      className: r,
      onDismiss: () => u()
    }
  );
}, O_ = () => {
  const {
    state: { loading: a },
    onAuth: e,
    startRegister: r
  } = uw();
  return /* @__PURE__ */ Re(Yt, { children: [
    /* @__PURE__ */ C(
      a1,
      {
        title: "Configuring passkey",
        description: "Please complete the passkey configuration with your browser.",
        header: a ? /* @__PURE__ */ C(cw, { size: 56 }) : /* @__PURE__ */ C(Yt, {})
      }
    ),
    /* @__PURE__ */ C(
      Dt,
      {
        variant: "ghost",
        disabled: a,
        className: "w-full",
        onClick: async () => {
          await e(!0) || r();
        },
        children: "Retry"
      }
    )
  ] });
};
function R_({ className: a }) {
  return /* @__PURE__ */ C("svg", { width: "56", height: "102", viewBox: "0 0 56 102", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: a, children: /* @__PURE__ */ Re("g", { id: "Group 125", children: [
    /* @__PURE__ */ C("path", { id: "Vector", d: "M40.4776 41.3721C40.3473 37.3287 39.7571 33.324 38.9268 29.4271C39.9118 30.7329 41.2713 31.6237 42.3866 32.8257C43.2577 33.7633 44.1613 34.7213 45.0182 35.6854C45.9503 36.7328 47.0819 37.8128 47.7881 39.029C48.0873 39.5456 48.5717 40.585 48.5228 41.0853C46.744 41.671 44.6844 41.488 42.8283 41.488C42.177 41.488 41.0861 41.5104 40.4776 41.3741V41.3721Z", fill: "#78DCE8" }),
    /* @__PURE__ */ C("path", { id: "Vector_2", d: "M12.0905 41.429C12.9819 38.6609 15.3814 36.5518 17.0889 34.3145C18.0943 32.9986 19.2198 31.6461 20.3066 30.4603C20.2598 32.8135 20.2476 35.2257 19.7612 37.524C19.6187 38.1992 19.4132 38.8501 19.3012 39.5314C19.2239 40.0012 19.2259 40.6419 19.0428 41.0263C16.9017 41.4778 14.2457 41.4229 12.0905 41.429Z", fill: "#78DCE8" }),
    /* @__PURE__ */ C("path", { id: "Vector_3", d: "M9.79209 50.1584C12.6679 50.1584 15.5395 50.0445 18.4112 50.0445C19.0157 50.6791 19.6609 50.7746 20.5686 50.677C21.1588 50.614 21.3196 50.2377 21.8019 50.0445C25.4795 48.5699 29.7047 49.8086 33.6672 49.8147C35.3931 49.8167 37.412 49.4587 39.0992 49.8716C39.5714 49.9875 39.4818 50.4472 40.0476 50.4472C40.4547 50.4472 40.8882 50.2926 40.996 49.8716C41.7552 49.6479 42.8094 49.7618 43.6052 49.7292C44.8976 49.6764 46.1451 49.6316 47.4334 49.7435C48.39 49.8248 49.3445 49.8147 50.3051 49.8147C50.3051 51.155 50.2705 52.4567 50.0874 53.7868C49.9612 54.7102 50.0019 55.7556 49.7047 56.6464C49.2794 57.9257 48.1071 58.6762 47.291 59.6952C46.7191 60.4091 46.4504 61.3915 45.8785 62.0464C44.8161 63.2647 44.8507 65.3718 44.2097 66.8504C44.0265 67.2714 43.5645 67.8877 43.306 68.3758C42.437 70.0131 41.8915 71.8578 41.051 73.5296C40.5951 74.4367 40.1413 75.3499 39.7546 76.2916C39.5571 76.7696 39.4249 77.3208 39.0992 77.7255C38.6718 78.2563 37.8537 78.5472 37.7763 79.3323C37.7051 80.0441 37.2797 80.5241 37.2594 81.2278C37.2065 82.9892 37.7926 84.482 38.4357 86.1376C38.7308 86.8962 38.9262 87.3803 38.9262 88.1755L38.5823 88.5783C37.4141 89.0399 36.0667 88.5966 34.9046 88.922C34.8192 88.5193 34.4996 88.1694 34.3877 87.8318C33.2378 87.8318 32.0899 87.8318 30.94 87.8318C30.9909 88.1572 31.0276 88.4928 31.113 88.8081C29.0208 89.3959 26.7312 89.4589 24.5617 89.1518C24.6003 88.7267 24.5311 88.1593 24.6756 87.7728C23.7761 87.7891 22.8908 88.0596 21.9749 88.0596C21.8304 88.3037 21.8874 88.6799 21.8019 88.9789C21.1649 89.0176 20.5299 88.9199 19.901 88.8488C19.5733 88.8121 19.0645 88.8793 18.8122 88.7491C19.1785 86.221 18.7084 83.2007 20.422 81.1119C20.2674 80.156 19.6771 79.0618 19.2823 78.1913C18.6636 76.8245 18.0917 75.5025 17.6745 74.0605C17.2023 72.4313 16.6202 71.03 15.8916 69.5127C15.2221 68.1175 15.0246 66.4192 14.5749 64.9406C14.3571 64.2247 13.891 63.5006 13.9277 62.7359C12.3076 60.2647 11.6808 57.0959 10.7955 54.3258C10.5003 53.4004 10.1279 52.4851 9.84705 51.5658C9.7575 51.2709 9.79209 50.4269 9.61707 50.3882L9.79006 50.1584H9.79209Z", fill: "#78DCE8" }),
    /* @__PURE__ */ C("path", { id: "Vector_4", d: "M36.5694 27.8774C33.5267 24.5926 32.2018 19.1988 32.2018 14.5535C25.5385 15.2877 29.4848 7.61184 32.8918 9.26945C32.8103 8.33997 32.6231 7.54879 32.2018 6.74338C30.1239 7.01388 28.9312 6.61931 27.1443 5.59424C26.2122 7.03219 22.1214 7.12574 21.6268 9.03962C20.6092 12.9752 22.0949 16.9473 22.3249 20.8686C22.4837 23.5696 23.0739 27.2001 21.3969 29.2523C22.6241 32.1139 21.1669 38.0935 21.1669 41.427C24.525 40.3633 29.3322 41.4982 32.8633 41.6691C34.6909 41.7565 36.374 41.5755 38.1752 41.6568C39.5388 38.5654 38.9974 30.499 36.5653 27.8753L36.5694 27.8774ZM25.7461 11.6633C24.3825 11.7243 24.529 8.36031 25.8804 9.15758V9.27148C26.3791 10.026 26.0025 10.9291 25.7461 11.6633Z", fill: "#78DCE8" }),
    /* @__PURE__ */ C("path", { id: "Vector_5", d: "M36.7999 15.2429C36.9159 12.127 33.4317 11.2199 30.9385 11.3378C29.6421 11.3989 28.2032 11.8016 28.9501 13.4043C29.697 15.007 31.3944 14.7873 32.7763 14.5778C34.1582 14.3683 35.5178 14.2076 36.7979 15.2408L36.7999 15.2429Z", fill: "#F9FF73" }),
    /* @__PURE__ */ C("path", { id: "Vector_6", d: "M21.7456 88.2325C21.7456 90.8888 21.5401 93.5308 21.5726 96.1565C18.528 96.1789 14.4412 96.309 11.6245 97.3199C12.349 97.7185 12.1272 98.3816 11.4006 98.7395C13.2099 100.182 17.4839 99.2683 19.3298 99.2561C19.7104 98.4426 20.5123 98.0602 21.3732 98.1151C21.5381 99.008 20.9275 99.6934 20.3658 100.291C21.6032 99.5409 23.3942 99.8724 24.3304 98.5687C27.3669 98.5687 30.4869 98.7009 33.4665 99.0853C34.5919 99.2317 35.8762 99.2134 36.9141 99.429C36.8429 98.2311 35.809 97.9463 34.8463 97.5334C36.0369 96.7036 37.6733 97.1999 37.95 98.5666C39.9893 98.2087 42.4072 98.648 44.3284 98.05C43.4594 97.9768 42.916 97.3077 42.7776 96.5002C40.9825 96.427 34.0078 97.8405 33.4746 95.6379C33.2385 94.6636 33.6883 92.7762 33.6333 91.6759C33.5703 90.4332 33.8206 89.2698 33.8145 88.0576C32.7236 88.0576 31.6307 88.0576 30.5398 88.0576C30.957 89.8779 32.2352 93.8542 31.4048 95.8148C30.7474 97.3687 28.0772 97.6067 26.5752 97.2284C22.4071 96.1789 24.4158 91.5742 24.3344 88.4034C23.5204 88.3668 22.574 88.1613 21.7477 88.2305L21.7456 88.2325Z", fill: "#F9FF73" }),
    /* @__PURE__ */ C("path", { id: "Vector_7", d: "M32.6624 4.4471C33.2872 5.03286 34.3068 5.48845 35.1901 5.82607C32.1638 6.97927 29.9209 7.38605 26.9149 5.82607C25.2888 6.97521 21.7821 6.84707 21.6274 9.50128C20.852 8.10604 21.084 6.42403 20.7075 4.90676C23.453 2.50679 26.1456 0.940705 29.9047 1.00172", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_8", d: "M25.232 9.15552C24.5278 9.8389 24.7679 10.9291 25.7102 11.4111C26.2028 11.045 26.3696 10.4796 26.2272 9.84297", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_9", d: "M31.7446 4.50407C31.0424 3.77391 30.9773 2.17122 30.7107 1.23157", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_10", d: "M21.916 10.0179C21.916 16.4185 24.0041 23.0428 22.433 29.1404", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_11", d: "M32.6055 15.8754C32.7255 19.7622 33.8612 25.1926 36.7431 28.1071", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_12", d: "M29.1572 12.2572C27.7733 9.44231 34.5974 8.45792 34.6747 11.0511", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_13", d: "M30.5376 11.7406C31.9399 11.0328 33.5395 11.169 34.8808 11.8707C36.6025 12.7717 36.572 14.2097 36.916 15.8754C36.7593 13.8741 32.1413 14.5575 30.8815 14.8422", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_14", d: "M32.9509 9.15552C32.9224 8.44773 32.668 7.77655 32.261 7.25995", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_15", d: "M21.5725 28.6238C19.8995 30.6088 19.9707 34.5505 19.8486 37.0705C19.696 40.2575 19.6553 43.4426 19.4965 46.6276C19.4518 47.5124 19.3744 50.8682 20.0196 50.5042", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_16", d: "M36.5699 26.9011C38.8331 32.1912 38.7375 39.2284 39.3216 45.092C39.4701 46.5808 39.8894 48.7286 39.289 50.1381C39.1262 50.0648 38.9837 49.9164 38.8107 49.8147", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_17", d: "M21.3996 50.5042C20.5428 47.4513 20.8827 43.1863 20.8827 39.9911C20.8827 36.562 20.73 33.2732 21.0557 30.0027", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_18", d: "M37.4331 27.5906C39.0572 29.5431 39.2302 33.3627 39.5009 35.7749C39.857 38.9355 39.855 42.0494 40.3252 45.1632C40.4778 46.172 40.9846 49.4751 40.1908 49.8147", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_19", d: "M12.2637 41.0283C13.5377 39.5395 14.6021 37.888 15.8803 36.3769C16.9182 35.1484 18.5179 33.8569 19.332 32.5878", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_20", d: "M39.501 30.0027C40.9216 31.7783 42.8408 33.1736 44.243 35.0061C45.6392 36.8284 47.6602 38.4901 48.1201 40.6846", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_21", d: "M21.5724 41.1992C24.5092 41.1992 27.3931 41.3721 30.3523 41.3721H34.4981C35.131 41.3721 35.764 41.3721 36.3989 41.3721C36.7266 41.3721 38.426 41.429 37.6058 41.3721", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_22", d: "M18.6417 41.1992C13.397 42.147 7.36253 40.5626 2.09132 42.0616C0.369527 43.9063 0.978057 48.1896 1.91833 50.3313C7.01248 49.4323 12.6785 49.9876 17.9518 49.9876", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_23", d: "M21.7456 49.8147C27.3974 49.8147 32.8416 49.8147 38.4669 49.8147", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_24", d: "M41.0539 49.4689C45.2138 49.7333 49.7402 49.1252 53.9836 49.1252C55.3268 46.5727 55.2291 43.0073 54.3275 40.5117C49.8562 40.9165 44.7396 41.9049 40.1909 41.3741", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_25", d: "M9.67627 50.675C10.4944 52.5828 9.94899 55.4831 10.7325 57.6369C11.4774 59.6871 12.5195 61.7962 13.2969 63.767", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_26", d: "M45.3621 63.4254C47.4421 59.3373 52.0315 55.1312 50.1896 50.1605", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_27", d: "M14.5043 51.3645C14.5043 55.7536 13.9223 59.8397 14.8116 64.1128C15.701 68.386 17.5307 73.0171 19.2016 77.3757C20.1561 79.8652 21.3304 82.8651 21.5726 85.4766", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_28", d: "M21.3993 87.7159C22.2378 88.0902 23.8395 88.2651 24.674 87.7159C24.6984 85.5885 25.0138 83.5099 25.0179 81.3418C25.024 79.375 24.4155 77.9493 23.811 76.1737", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_29", d: "M26.0537 81.5146C30.3989 81.5146 32.7435 81.354 35.1898 77.7235", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_30", d: "M30.5376 82.5478C31.1136 84.0997 31.0545 85.8142 31.0545 87.543C32.0884 87.7179 33.6332 87.9986 34.1582 87.3701C37.1317 83.8149 36.572 78.4882 40.6262 74.5059C40.6262 74.5059 42.2075 71.7398 42.6146 70.2307C43.1946 68.0768 43.6932 65.805 44.0718 63.6003C44.7638 59.5651 44.5033 55.2939 44.5033 51.1896", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_31", d: "M21.9161 88.922C22.2865 88.8813 22.6875 88.922 23.0619 88.9139C22.6162 89.1274 22.2153 89.5078 21.796 89.7539C22.3883 89.9207 22.9805 90.0569 23.5891 90.124C22.9907 90.2522 22.3761 90.4678 21.9263 90.783C22.486 90.8766 23.0457 91.0027 23.5931 91.1572C23.1067 91.3362 22.6345 91.56 22.142 91.682C22.4453 91.6698 22.7872 91.7308 23.0721 91.7125C22.604 91.8508 22.1441 92.1152 21.6353 92.1905C22.0382 92.3776 22.3109 92.8291 22.5959 93.0223C22.37 93.0996 22.1502 93.2013 21.9324 93.2765C22.2947 93.362 22.7282 93.5959 23.2451 93.5654C21.621 93.7667 22.142 94.5904 22.0911 95.8148", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_32", d: "M24.3122 95.2575C24.2532 93.1037 24.3977 90.8969 24.3895 88.7491", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_33", d: "M31.9743 88.5193C32.4607 88.8244 33.0856 88.7613 33.6371 88.8223C33.2748 88.981 32.88 89.0684 32.5381 89.2657C33.0062 89.5301 33.7267 89.5281 34.2517 89.644C33.6045 90.0488 32.7416 90.2501 32.1901 90.4332C32.6378 90.3864 33.0957 90.4657 33.4804 90.665C33.0896 90.7972 32.5279 90.8806 32.3101 91.2223C32.5442 91.2732 32.8454 91.3321 33.0449 91.4074C32.7477 91.5457 32.418 91.6637 32.1494 91.8101C32.4302 91.9789 32.8067 92.0298 33.0387 92.2555C32.65 92.3836 32.2532 92.5687 31.842 92.5789C32.477 92.587 33.0978 92.8108 33.7307 92.827C33.3094 93.0528 32.6175 93.0935 32.2857 93.4799C32.591 93.7708 32.9757 93.8785 33.3461 94.0555C32.9451 94.2467 32.3244 94.4399 32.9696 94.8772", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_34", d: "M31.284 95.5646C31.8539 93.246 30.9136 90.6671 31.2067 88.3668", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_35", d: "M11.5914 97.5375C10.6714 97.8405 10.2013 98.5015 9.82886 99.3151C10.4618 99.0405 11.1762 98.1253 11.8966 98.2432", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_36", d: "M11.2866 98.8575C11.657 99.5043 14.258 99.1646 14.9968 99.1646C16.2302 99.1646 17.4187 99.2419 18.6439 99.2419", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_37", d: "M20.7095 98.4731C19.5148 98.347 19.3805 100.086 19.4069 100.847C19.9198 100.503 20.3085 99.8052 20.8601 99.4656C21.2325 99.2358 22.3926 99.1585 22.012 98.4731", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_38", d: "M23.6216 98.3206C22.9214 99.187 21.8937 100.212 20.7865 100.312", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_39", d: "M18.7939 98.9327C19.1827 98.2778 20.4628 97.6697 21.2464 97.7084", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_40", d: "M24.0818 96.0243C24.6354 96.9782 24.9915 97.2243 26.2269 97.0961", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_41", d: "M23.9292 98.7029C24.5418 98.9653 25.7874 98.768 26.4569 98.7802", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_42", d: "M42.7773 96.5022C44.2814 96.4921 43.9802 96.4595 45.2684 97.21C45.7589 97.4948 46.3166 98.1049 46.3023 98.7029C45.7182 97.507 44.1776 98.1232 43.3146 97.5537", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_43", d: "M36.4942 98.2433C37.1984 98.3978 37.7825 99.5022 37.8741 100.157C37.6665 99.3883 38.1916 98.6765 37.6624 97.9951C37.1332 97.3138 36.1624 97.1836 35.4216 97.4785", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_44", d: "M44.4628 98.2432C43.7952 98.711 42.1406 98.3958 41.3224 98.3958C40.3944 98.3958 39.2485 98.1883 38.41 98.3958", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_45", d: "M31.2074 96.3293C30.9042 97.5476 29.2129 97.1714 28.065 97.1714C27.5562 97.1714 26.1642 97.4114 26.2252 98.0907", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_46", d: "M27.4523 98.5504C28.0425 99.1442 29.4712 98.8127 30.2385 98.7741C31.195 98.7273 32.1414 98.7802 33.1204 98.7802", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_47", d: "M33.0469 97.9382C33.5882 98.5504 33.7897 98.6907 34.6181 98.7782C35.3121 98.8493 36.0183 99.1788 36.7245 99.0873", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_48", d: "M34.3496 97.1714C34.5124 97.2385 34.7974 97.269 34.8869 97.2487", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_49", d: "M37.1847 81.6285C37.492 82.7614 37.4432 83.9878 37.7403 85.1614C38.0374 86.3349 38.764 87.5919 38.8698 88.7491C37.722 89.1234 36.2872 88.7369 35.1149 89.0562", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_50", d: "M30.5176 89.0563C29.561 89.518 27.6276 89.1295 26.5225 89.1336C26.0666 89.1336 25.6107 89.1336 25.1548 89.1336", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_51", d: "M21.2465 88.9037C20.4018 88.9037 19.543 88.6677 18.7187 88.7511C18.6109 87.6061 19.0952 86.2596 19.427 85.1695C19.7302 84.179 19.8849 83.2129 20.2512 82.2427", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_52", d: "M24.9242 77.8008C24.684 76.9262 24.395 76.0069 24.2343 75.1201", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_53", d: "M32.8173 79.3323C33.4543 78.2828 34.0282 77.095 34.2724 75.8869", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_54", d: "M42.6996 40.8168C42.61 39.3179 41.8855 37.9572 41.7043 36.5294", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_55", d: "M42.6249 36.4521C43.1052 37.7742 42.9627 39.4277 43.6201 40.6643", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_56", d: "M17.8762 40.7416C18.1428 39.6778 18.155 38.5633 18.7961 37.6013", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_57", d: "M27.2222 9.65379C26.7154 9.30193 26.2066 8.97855 25.6123 8.81177", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_58", d: "M23.6215 10.0362C23.7761 9.93041 24.4193 9.1616 24.5068 8.97449", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_59", d: "M24.9242 11.5677C25.5979 11.6572 26.0843 11.6572 26.764 11.4152", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_60", d: "M38.332 41.429C38.6739 42.5212 38.6394 44.0324 38.6394 45.2568C38.6394 46.6073 38.8693 47.8784 38.8693 49.2391", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_61", d: "M20.4043 49.776C20.4328 48.3381 20.097 46.8879 20.097 45.4114C20.097 44.1971 19.7408 42.33 20.1743 41.2765", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_62", d: "M18.9488 41.2765C18.7209 42.8405 18.2711 44.4392 18.4339 46.1049C18.5092 46.8696 18.499 47.6364 18.5662 48.3991C18.6334 49.1618 18.8939 49.8493 18.8735 50.5428", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_63", d: "M13.5093 51.6899C13.896 52.5665 13.4727 54.3299 13.432 55.3346C13.3933 56.2621 13.3546 57.1814 13.3546 58.1231", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_64", d: "M12.4366 51.6126C12.4366 54.7916 11.5635 58.9244 13.6618 61.5664", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_65", d: "M45.688 50.1584C45.688 52.359 45.458 54.4885 45.458 56.6668", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_66", d: "M47.1452 50.0831C47.6052 50.9516 47.2226 52.7923 47.2226 53.8316C47.2226 54.7854 47.2083 55.6519 46.9967 56.5814C46.6588 58.062 46.0116 60.1101 45.1548 61.3386", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_67", d: "M24.0435 73.4747C25.1465 71.089 23.8175 69.8829 23.1235 67.7311", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_68", d: "M34.8457 76.5744C35.8124 74.5547 35.1897 72.228 35.1897 70.0273", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_69", d: "M16.8019 51.997C16.7165 53.4451 17.7504 55.7698 17.0319 57.0512", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_70", d: "M33.1223 52.6865C33.1223 54.6004 33.1223 56.5143 33.1223 58.4302", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_71", d: "M42.5475 50.8479C42.4234 52.658 42.9647 54.4296 42.7775 56.2458C42.6371 57.6146 42.055 58.8858 41.8779 60.1712C41.5177 62.7766 41.6052 65.3881 41.1697 67.847", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_72", d: "M15.6539 57.5089C16.9341 62.1278 15.4972 66.525 17.9517 70.8328", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_73", d: "M33.3519 24.4319C33.5839 25.5689 34.1355 26.6387 34.7318 27.6475", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_74", d: "M23.929 26.2686C24.1121 28.5546 22.9195 30.5478 22.7791 32.6997", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_75", d: "M31.9746 15.2429C31.9746 15.2429 31.1605 15.9283 30.8247 16.1622", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_76", d: "M41.1678 34.5383C41.3795 34.9837 41.5342 35.4454 41.6278 35.9172", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_77", d: "M43.6969 37.2962V37.526", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_78", d: "M18.8717 35.9172C18.7089 36.1206 18.6295 36.3403 18.6417 36.6067", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_79", d: "M27.6066 5.36639C28.7137 5.06944 29.3487 4.43487 30.5943 4.56301", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_80", d: "M21.6293 6.28367C21.556 5.82605 21.4705 5.36232 21.3993 4.9047C22.7934 3.53997 25.079 2.73659 26.8008 2.1488", stroke: "#F0F2DA", strokeWidth: "0.5", strokeMiterlimit: "10" }),
    /* @__PURE__ */ C("path", { id: "Vector_81", d: "M22.205 9.15552C22.266 9.99754 22.4349 10.9738 22.4349 11.6816", stroke: "#141721", strokeWidth: "0.5", strokeMiterlimit: "10" })
  ] }) });
}
const L_ = () => {
  const { wallet: a, handleError: e } = Et(), {
    state: { loading: r, username: i, lastCodeExpiretime: u },
    setStateValue: d,
    startRegister: g,
    sendConfirmationEmail: b
  } = uw(), [y, k] = Ct(""), [S, A] = Ct(!1), [x, M] = Ct(!1), D = [
    Rn(null),
    Rn(null),
    Rn(null),
    Rn(null),
    Rn(null),
    Rn(null)
  ];
  Ln(() => {
    y.length === 6 && !/\s/.test(y) && U(y);
  }, [y]);
  function O(Z, J) {
    const Y = Z.target, X = D[J - 1], ee = D[J + 1], j = D.map((ne, ae) => y[ae] || " ");
    j[J] = Y.value, k(j.join("")), Y.select(), Y.value === "" ? X != null && X.current && X.current.focus() : ee != null && ee.current && ee.current.select();
  }
  function T(Z, J) {
    const Y = Z.target, X = D[J - 1];
    (Z.key === "Backspace" || Z.key === "Delete") && Y.value === "" && (Z.preventDefault(), k((ee) => ee.slice(0, J) + " " + ee.slice(J + 1)), X != null && X.current && X.current.focus());
  }
  function L(Z) {
    const J = Z.clipboardData.getData("text");
    J.length === 6 && (k(J), D.forEach((Y, X) => {
      Y != null && Y.current && (Y.current.value = J.charAt(X));
    }));
  }
  async function U(Z) {
    var J;
    d("loading", !0), e();
    try {
      const { data: Y } = await (await fetch(
        "https://api-dev.apillon.io/embedded-wallet/otp/validate",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            email: i,
            code: Z
          })
        }
      )).json();
      let X = u;
      if (X || (X = +(await ((J = a?.xdomain) == null ? void 0 : J.storageGet(Uo.OTP_EXPIRATION, !0)) || 0)), !Y && X && Date.now() > X)
        throw M(!0), new Error("Verification code is not valid.");
      if (!Y)
        throw new Error("Verification code is not valid.");
      d("screen", "codeSubmitted"), await new Promise((ee) => setTimeout(ee, 333)), d("screen", "configuringPasskey"), g();
    } catch (Y) {
      e(Y, "confirmEmail"), d("loading", !1);
    }
  }
  async function W() {
    d("loading", !0), e(), await b() && (A(!0), setTimeout(() => A(!1), 3e4)), d("loading", !1);
  }
  return /* @__PURE__ */ Re(Yt, { children: [
    /* @__PURE__ */ C(
      a1,
      {
        title: x ? "Code expired" : "Check your email",
        description: x ? "Please resend a confirmation code to your email." : "We have just sent a confirmation code to your email. Paste the code below to proceed with account creation.",
        header: x ? void 0 : /* @__PURE__ */ C(R_, { className: "mx-auto" }),
        titleClass: x ? "text-red" : ""
      }
    ),
    !!x && /* @__PURE__ */ C(
      Dt,
      {
        variant: "primary",
        disabled: r || S,
        className: "w-full mb-6",
        onClick: () => W(),
        children: "Send again"
      }
    ),
    /* @__PURE__ */ C("p", { className: "mb-6 font-bold text-center", children: "Enter the 6-digit code you received" }),
    /* @__PURE__ */ C("div", { className: "flex gap-2 mb-6 justify-center", children: [0, 1, 2, 3, 4, 5].map((Z) => /* @__PURE__ */ C(
      "input",
      {
        ref: D[Z],
        type: "text",
        maxLength: 1,
        autoFocus: Z === 0,
        disabled: r,
        className: "min-w-0 w-[3.25rem] h-16 px-2 text-center rounded-lg border border-brightdark font-bold focus:border-lightgrey",
        onFocus: (J) => J.target.select(),
        onKeyDown: (J) => T(J, Z),
        onPaste: (J) => L(J),
        onChange: (J) => O(J, Z)
      },
      Z
    )) }),
    /* @__PURE__ */ C("p", { className: "text-lightgrey text-xs mb-3 text-center", children: "Didn't receive an email?" }),
    !x && /* @__PURE__ */ C(
      Dt,
      {
        variant: "ghost",
        disabled: r || S,
        className: "w-full",
        onClick: () => W(),
        children: "Send again"
      }
    ),
    !!S && /* @__PURE__ */ C("p", { className: "mt-2", children: "Email sent!" })
  ] });
};
function D_({ className: a }) {
  return /* @__PURE__ */ Re("svg", { width: "64", height: "66", viewBox: "0 0 64 66", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: a, children: [
    /* @__PURE__ */ Re("g", { id: "Frame", clipPath: "url(#clip0_537_6327)", children: [
      /* @__PURE__ */ C("g", { id: "Layer_4", children: /* @__PURE__ */ C(
        "path",
        {
          id: "Vector",
          d: "M52.3179 7.37932C47.2442 2.92049 38.3411 -1.90145 32.1822 0.761356C28.6706 2.28017 24.5194 1.80383 20.8992 3.07667C17.9884 4.09962 15.1124 6.04401 12.4845 7.69557C6.94188 11.1744 3.29847 15.5747 1.96901 21.9193C-0.717032 34.7336 2.01553 49.7928 12.0465 58.6363C16.438 62.5095 23.6628 66.2265 29.5582 65.5822C43.0737 64.1103 55.8217 62.4939 61.9419 47.4033C66.8799 35.2177 62.6667 16.461 52.3217 7.37541L52.3179 7.37932ZM37.8721 35.5886C33.4496 39.7546 27.6124 43.4833 23.8644 47.9461C21.3023 43.823 17.3837 40.1372 14.6706 36.0415C16.4031 34.7414 17.4419 32.5315 19.0465 31.6335C21.0969 34.1167 24.6124 37.0059 26.0504 39.1299C30.1977 36.1001 32.7675 32.5783 36.5775 29.0761C39.8799 26.0424 44.062 23.4186 46.1861 19.2877C48.1008 20.7089 49.5659 22.9462 51 24.5782C46.4264 27.9477 42.0853 31.6139 37.8682 35.5925L37.8721 35.5886Z",
          fill: "#A9DC76"
        }
      ) }),
      /* @__PURE__ */ Re("g", { id: "Layer_2", children: [
        /* @__PURE__ */ C(
          "path",
          {
            id: "Vector_2",
            d: "M4.48853 32.0786C4.48853 45.5644 9.60868 56.3796 23.6203 60.7564C28.6281 62.3221 36.1823 63.1342 41.2715 61.4279C44.3839 60.3855 49.9265 57.5821 51.9963 55.1536C54.3916 52.3424 56.2831 47.825 57.8296 44.4789C59.9304 39.9459 58.942 33.5349 58.942 28.6115C58.942 23.2312 57.818 20.6113 54.9653 15.8206C52.5544 11.7757 48.38 10.6239 44.2133 8.72244C38.3877 6.05963 33.4304 4.59158 26.756 5.38027C18.225 6.3837 6.80248 14.6845 5.37612 23.4225",
            stroke: "black",
            strokeMiterlimit: "10"
          }
        ),
        /* @__PURE__ */ C(
          "path",
          {
            id: "Vector_3",
            d: "M58.4265 17.5854C56.6241 13.4546 54.3528 8.78491 50.4187 6.03621C45.942 2.91269 38.3373 1.46025 32.9342 1.43682C21.8141 1.38607 8.5505 6.27047 3.22104 16.6484C0.000111488 22.9188 -0.170431 29.978 0.531119 36.8927C1.6474 47.8797 7.04662 55.8759 16.2288 61.8887C22.5931 66.0547 30.0117 65.9922 37.4187 65.672C43.7133 65.4026 49.3567 62.1464 54.4342 58.4684C59.473 54.8178 60.1319 47.7508 61.8102 42.1792C63.4885 36.6077 63.0893 31.8755 62.1164 26.5812",
            stroke: "black",
            strokeMiterlimit: "10"
          }
        ),
        /* @__PURE__ */ C(
          "path",
          {
            id: "Vector_4",
            d: "M29.1978 45.8025C37.0661 38.9698 43.2482 30.7354 51.5738 25.0116C50.2327 23.4498 48.2909 21.5952 46.7715 20.174C43.2095 23.2937 41.1862 25.6168 37.7637 29.2479C34.787 32.4065 29.8296 37.127 26.3568 39.5282C25.1668 37.4783 20.8374 33.2538 19.1513 31.3641C17.8064 32.9492 16.1436 34.7726 14.6475 36.2016C17.5002 39.7507 26.0544 48.9026 25.756 48.602",
            stroke: "black",
            strokeMiterlimit: "10"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ C("defs", { children: /* @__PURE__ */ C("clipPath", { id: "clip0_537_6327", children: /* @__PURE__ */ C("rect", { width: "64", height: "66", fill: "white" }) }) })
  ] });
}
const B_ = () => {
  const {
    state: { loading: a },
    setStateValue: e,
    startRegister: r
  } = uw();
  return /* @__PURE__ */ Re(Yt, { children: [
    /* @__PURE__ */ C(
      a1,
      {
        title: "Email succesfully confirmed",
        description: "Passkey configuration can now start.",
        header: /* @__PURE__ */ C(D_, { className: "mx-auto" })
      }
    ),
    /* @__PURE__ */ C(
      Dt,
      {
        variant: "ghost",
        disabled: a,
        className: "w-full",
        onClick: () => {
          e("screen", "configuringPasskey"), r();
        },
        children: "Configure passkey"
      }
    )
  ] });
}, M_ = ({ className: a }) => {
  const {
    state: { screen: e }
  } = uw();
  function r() {
    switch (e) {
      case "confirmCode":
        return /* @__PURE__ */ C(L_, {});
      case "codeSubmitted":
        return /* @__PURE__ */ C(B_, {});
      case "configuringPasskey":
        return /* @__PURE__ */ C(O_, {});
      case "loginForm":
      default:
        return /* @__PURE__ */ C(N_, {});
    }
  }
  return /* @__PURE__ */ Re("div", { className: bt("p-8 sm:p-12", a), children: [
    /* @__PURE__ */ C("div", { className: "text-center mb-12", children: /* @__PURE__ */ C(P_, { className: "inline-block" }) }),
    r(),
    /* @__PURE__ */ C(fI, { show: !0, className: "mt-6" })
  ] });
}, F_ = "2.0.0-beta.0", __ = {
  version: F_
}, dI = 200, U_ = ({
  children: a,
  isOpen: e,
  isAuth: r = !1,
  setIsOpen: i
}) => /* @__PURE__ */ C(Yt, { children: /* @__PURE__ */ C(MP, { show: e, children: /* @__PURE__ */ Re(
  FP,
  {
    id: "oaw-wallet-widget",
    open: e,
    style: {
      position: "relative",
      zIndex: "10001"
    },
    onClose: () => i(!1),
    children: [
      /* @__PURE__ */ C(
        rA,
        {
          enter: "ease-out duration-300",
          enterFrom: "opacity-0",
          enterTo: "opacity-100",
          leave: "ease-in duration-200",
          leaveFrom: "opacity-100",
          leaveTo: "opacity-0",
          children: /* @__PURE__ */ C("div", { className: "fixed inset-0 bg-black/50", "aria-hidden": "true" })
        }
      ),
      /* @__PURE__ */ C(
        rA,
        {
          enter: "ease-out duration-300",
          enterFrom: "opacity-0 scale-95",
          enterTo: "opacity-100 scale-100",
          leave: "ease-in duration-200",
          leaveFrom: "opacity-100 scale-100",
          leaveTo: "opacity-0 scale-95",
          children: /* @__PURE__ */ C("div", { className: "fixed inset-0 w-screen overflow-y-auto p-4", children: /* @__PURE__ */ C("div", { className: "flex items-center justify-center min-h-full", children: /* @__PURE__ */ Re(
            _P,
            {
              className: bt(
                "relative min-w-[400px] w-full min-h-[380px] bg-dark border border-lightdark text-offwhite flex flex-col",
                r ? "max-w-[445px]" : "max-w-[400px]"
              ),
              children: [
                /* @__PURE__ */ C(
                  "button",
                  {
                    className: "flex absolute top-2 right-2 oaw-button-plain invisible",
                    onClick: () => i(!1),
                    children: /* @__PURE__ */ C(
                      "svg",
                      {
                        width: "24",
                        height: "24",
                        viewBox: "0 0 24 24",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: /* @__PURE__ */ C(
                          "path",
                          {
                            fillRule: "evenodd",
                            clipRule: "evenodd",
                            d: "M12 10.6569L6.34317 5L4.92896 6.41421L10.5858 12.0711L4.92898 17.7279L6.3432 19.1421L12 13.4853L17.6569 19.1421L19.0711 17.7279L13.4143 12.0711L19.0711 6.41421L17.6569 5L12 10.6569Z",
                            fill: "#9C9C95"
                          }
                        )
                      }
                    )
                  }
                ),
                a,
                /* @__PURE__ */ C("div", { className: "flex-grow" }),
                /* @__PURE__ */ C("p", { className: bt("text-xs px-8 text-center", r ? "pb-8 sm:pb-12" : "pb-6"), children: /* @__PURE__ */ C(
                  "a",
                  {
                    href: "https://apillon.io/",
                    target: "_blank",
                    className: "rounded-sm opacity-100 hover:opacity-80",
                    children: "Powered by ©Apillon"
                  }
                ) }),
                /* @__PURE__ */ C("p", { className: "text-darkgrey text-[10px] absolute bottom-1 right-1", children: __.version })
              ]
            }
          ) }) })
        }
      )
    ]
  }
) }) });
function z_({ children: a }) {
  const [e, r] = Xv(H_, pI()), {
    state: { walletScreenHistory: i },
    wallet: u,
    setStateValue: d,
    setScreen: g
  } = Et(), { dispatch: b } = sI();
  Ln(() => {
    const S = (O) => {
      var T;
      O.plain ? (y("txToConfirm", (T = O.plain) == null ? void 0 : T.tx), y("approveParams", O), d("isOpen", !0)) : O.contractWrite && (y("contractFunctionData", {
        chainId: O.contractWrite.chainId,
        contractAddress: O.contractWrite.contractAddress,
        contractFunctionName: O.contractWrite.contractFunctionName,
        contractFunctionValues: O.contractWrite.contractFunctionValues
      }), y("approveParams", O), d("isOpen", !0));
    }, A = (O) => {
      y("messageToSign", O.message), y("approveParams", { signature: O }), d("isOpen", !0);
    }, x = async (O) => {
      b({ type: "addTx", payload: O }), !(O.internalLabel && ["gasless_3", "gasless_4"].includes(O.internalLabel)) && (y("successInfo", {
        title: "Successfully sent",
        txHash: O.hash,
        explorerUrl: O.explorerUrl
      }), await new Promise((T) => setTimeout(T, dI * 2)), d("isOpen", !0));
    }, M = () => {
      d("isOpen", !0);
    }, D = (O) => {
      y("targetChain", O), d("isOpen", !0);
    };
    return u && (u.events.on("txApprove", S), u.events.on("signatureRequest", A), u.events.on("txSubmitted", x), u.events.on("providerRequestAccounts", M), u.events.on("requestChainChange", D)), () => {
      u && (u.events.off("txApprove", S), u.events.off("signatureRequest", A), u.events.off("txSubmitted", x), u.events.off("providerRequestAccounts", M), u.events.off("requestChainChange", D));
    };
  }, [u]), Ln(() => {
    (e.approveParams || e.targetChain || e.successInfo) && g("approve");
  }, [e.approveParams, e.targetChain, e.successInfo]);
  function y(S, A) {
    r({ type: "setValue", payload: { key: S, value: A } });
  }
  function k(S = !1) {
    var A, x, M, D, O, T, L, U;
    const W = i.filter((Z) => Z !== "approve");
    d("walletScreenHistory", W), W.length > 1 ? (S || (A = e.successInfo) != null && A.title || ((M = (x = e.approveParams) == null ? void 0 : x.contractWrite) != null && M.reject ? e.approveParams.contractWrite.reject(new Dy()) : (O = (D = e.approveParams) == null ? void 0 : D.plain) != null && O.reject ? e.approveParams.plain.reject(new Dy()) : (L = (T = e.approveParams) == null ? void 0 : T.signature) != null && L.reject ? e.approveParams.signature.reject(new Dy()) : (U = e?.targetChain) != null && U.resolve && e.targetChain.resolve(!1)), r({ type: "reset" }), d("walletScreen", "main")) : d("isOpen", !1);
  }
  return /* @__PURE__ */ C(
    hI.Provider,
    {
      value: {
        state: e,
        dispatch: r,
        setStateValue: y,
        onApproveDone: k
      },
      children: a
    }
  );
}
const hI = Jv(void 0), pI = () => ({
  txToConfirm: void 0,
  contractFunctionData: void 0,
  messageToSign: "",
  targetChain: void 0,
  approveParams: void 0,
  successInfo: void 0
});
function H_(a, e) {
  switch (e.type) {
    case "setState":
      return {
        ...a,
        ...e.payload
      };
    case "setValue":
      return {
        ...a,
        [e.payload.key]: e.payload.value
      };
    case "reset":
      return pI();
    default:
      throw new Error("Unhandled action type." + JSON.stringify(e));
  }
}
function Hc() {
  const a = ew(hI);
  if (a === void 0)
    throw new Error("useApproveContext usage must be wrapped with TokensContext provider.");
  return a;
}
const ZE = ({ className: a }) => /* @__PURE__ */ C(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: a,
    children: /* @__PURE__ */ C("g", { id: "Group", children: /* @__PURE__ */ C(
      "path",
      {
        id: "Vector",
        d: "M12 22C6.477 22 2 17.523 2 12C2 6.477 6.477 2 12 2C17.523 2 22 6.477 22 12C22 17.523 17.523 22 12 22ZM12 20C14.1217 20 16.1566 19.1571 17.6569 17.6569C19.1571 16.1566 20 14.1217 20 12C20 9.87827 19.1571 7.84344 17.6569 6.34315C16.1566 4.84285 14.1217 4 12 4C9.87827 4 7.84344 4.84285 6.34315 6.34315C4.84285 7.84344 4 9.87827 4 12C4 14.1217 4.84285 16.1566 6.34315 17.6569C7.84344 19.1571 9.87827 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z",
        fill: "currentColor"
      }
    ) })
  }
), gI = ({ text: a, className: e }) => /* @__PURE__ */ Re(
  "div",
  {
    className: bt("flex items-start justify-between gap-3 p-4 border border-solid", e),
    style: {
      borderImageSource: "linear-gradient(180deg, #F9FF73 0%, #78DCE8 20.31%, #F7AF39 39.58%, #FF6188 59.37%, #A9DC76 79.17%, #AB9DF2 100%)",
      borderImageSlice: 1
    },
    children: [
      /* @__PURE__ */ C("div", { className: "shrink-0", children: /* @__PURE__ */ C(ZE, { className: "text-offwhite" }) }),
      /* @__PURE__ */ C("div", { className: "text-sm font-normal text-offwhite", children: a })
    ]
  }
), Dk = ({
  doneAfterApprove: a = !0,
  doneAfterDecline: e = !0,
  className: r,
  onApprove: i,
  onDecline: u
}) => {
  const { handleError: d } = Et(), { onApproveDone: g } = Hc(), [b, y] = Ct(!1);
  return /* @__PURE__ */ C(Yt, { children: /* @__PURE__ */ Re("div", { className: bt("grid grid-cols-2 gap-2", r), children: [
    /* @__PURE__ */ C(
      Dt,
      {
        variant: "ghost",
        disabled: b,
        minWidth: "0",
        onClick: () => {
          u && u(), e && g();
        },
        children: "Cancel"
      }
    ),
    /* @__PURE__ */ C(
      Dt,
      {
        loading: b,
        minWidth: "0",
        onClick: async () => {
          if (!b) {
            y(!0), d();
            try {
              await i(), a && g(!0);
            } catch (k) {
              d(k) === "already known" && g();
            }
            y(!1);
          }
        },
        children: "Approve"
      }
    )
  ] }) });
}, Bk = ({ className: a }) => /* @__PURE__ */ C(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    className: a,
    children: /* @__PURE__ */ C(
      "path",
      {
        d: "M13.1714 12.0003L8.22168 7.05055L9.63589 5.63635L15.9999 12.0003L9.63589 18.3643L8.22168 16.95L13.1714 12.0003Z",
        fill: "currentColor"
      }
    )
  }
), ig = ({
  label: a,
  data: e,
  collapsable: r = !1,
  className: i
}) => {
  const [u, d] = Ct(!1), g = bt(
    "!flex items-center justify-between gap-6 w-full !min-h-[3rem]",
    "!rounded-md !px-4 !py-2 text-sm",
    "!bg-primarylight !text-offwhite"
  );
  return a = a.split(/(?=[A-Z])/).join(" ").toLowerCase().replace(/^\w/, (b) => b.toUpperCase()), r ? /* @__PURE__ */ Re("div", { className: i, children: [
    /* @__PURE__ */ Re(
      "button",
      {
        className: bt("oaw-button-plain", g, { "!rounded-b-none": u }),
        onClick: () => d((b) => !b),
        children: [
          /* @__PURE__ */ C("div", { className: "font-bold shrink-0", children: a }),
          /* @__PURE__ */ C(Bk, { className: u ? "-rotate-90" : "rotate-90" })
        ]
      }
    ),
    u && /* @__PURE__ */ C(
      "div",
      {
        className: bt(
          "px-4 py-2 rounded-b-md text-xs",
          "bg-primarybright text-lightgrey",
          "whitespace-pre-wrap break-all",
          "max-h-[220px] overflow-auto"
        ),
        children: e
      }
    )
  ] }) : /* @__PURE__ */ Re("div", { className: bt(g, i), children: [
    /* @__PURE__ */ C("div", { className: "font-bold shrink-0", children: a }),
    /* @__PURE__ */ C("div", { className: "font-normal min-w-0 truncate", title: typeof e == "string" ? e : "", children: e })
  ] });
}, V_ = () => {
  const { networksById: a, setStateValue: e } = Et(), {
    state: { targetChain: r },
    setStateValue: i
  } = Hc();
  if (!r)
    return /* @__PURE__ */ C(Yt, {});
  const u = r.chainId;
  return /* @__PURE__ */ Re("div", { className: "flex flex-col min-h-full pb-2", children: [
    /* @__PURE__ */ C("h3", { className: "my-6", children: "Switch chain" }),
    !!u && !!(a != null && a[u]) && /* @__PURE__ */ C(
      ig,
      {
        label: "Switch to",
        data: `${a[u].name} (chain ID: ${a[u].id})`,
        className: "mb-4"
      }
    ),
    /* @__PURE__ */ C(
      gI,
      {
        text: "You have to switch the network to continue with the transaction.",
        className: "mb-6"
      }
    ),
    /* @__PURE__ */ C("div", { className: "grow" }),
    /* @__PURE__ */ C(
      Dk,
      {
        onApprove: () => {
          r?.resolve(!0), i("targetChain", void 0), e("networkId", u);
        },
        onDecline: () => {
          r?.resolve(!1);
        }
      }
    )
  ] });
}, W_ = () => {
  const {
    wallet: a,
    state: { username: e, appProps: r },
    networksById: i
  } = Et(), {
    state: { contractFunctionData: u, approveParams: d }
  } = Hc();
  return u ? /* @__PURE__ */ Re("div", { className: "flex flex-col min-h-full pb-2", children: [
    /* @__PURE__ */ C("h3", { className: "my-6", children: "Contract Transaction" }),
    !!u.chainId && !!i[u.chainId] && /* @__PURE__ */ C(
      ig,
      {
        label: "Chain",
        data: `${u.chainId} (${i[u.chainId].name})`,
        className: "mb-4"
      }
    ),
    /* @__PURE__ */ C(
      ig,
      {
        label: "Contract address",
        data: u.contractAddress,
        className: "mb-4"
      }
    ),
    /* @__PURE__ */ C(
      ig,
      {
        label: "Contract function",
        data: u.contractFunctionName,
        className: "mb-4"
      }
    ),
    !!u.contractFunctionValues && !!u.contractFunctionValues.length && /* @__PURE__ */ C(
      ig,
      {
        label: "Contract function values",
        data: rI(u.contractFunctionValues),
        className: "mb-4",
        collapsable: !0
      }
    ),
    /* @__PURE__ */ C("div", { className: "grow" }),
    /* @__PURE__ */ C(
      Dk,
      {
        className: "mt-6",
        onApprove: async () => {
          if (d != null && d.contractWrite) {
            const g = await a?.signContractWrite({
              ...d.contractWrite,
              authData: { username: e }
            });
            if (r.broadcastAfterSign && g) {
              const { signedTxData: b, chainId: y } = g;
              await a?.broadcastTransaction(
                b,
                y,
                d.contractWrite.label || "Transaction"
              );
            }
          } else {
            const g = new Error("Embedded wallet approve");
            throw g.name = "no approve data", g;
          }
        }
      }
    )
  ] }) : /* @__PURE__ */ C(Yt, {});
}, G_ = () => ({
  list: {},
  selectedToken: "",
  // address
  exchangeRates: {}
  // token exchange rates (from some price api, eg. coingecko)
});
function j_(a, e) {
  var r;
  switch (e.type) {
    case "setState":
      return {
        ...a,
        ...e.payload
      };
    case "setValue":
      return {
        ...a,
        [e.payload.key]: e.payload.value
      };
    case "updateToken": {
      const i = [...((r = a.list[e.payload.owner]) == null ? void 0 : r[e.payload.chainId]) || []], u = i.findIndex((d) => d.address === e.payload.token.address);
      return u < 0 ? i.push(e.payload.token) : i[u] = e.payload.token, {
        ...a,
        list: {
          ...a.list,
          [e.payload.owner]: {
            ...a.list[e.payload.owner],
            [e.payload.chainId]: i
          }
        }
      };
    }
    default:
      throw new Error("Unhandled action type." + JSON.stringify(e));
  }
}
const mI = Jv(void 0);
function $_({ children: a }) {
  const [e, r] = Xv(j_, G_()), { state: i, wallet: u, activeWallet: d, networksById: g } = Et(), b = Rn(!1), y = Rn(!1), k = Rn({
    loading: !1,
    timeout: null
  }), S = Kl(
    () => {
      var L, U, W;
      return {
        address: "",
        name: `${(L = g?.[i.networkId]) == null ? void 0 : L.name} ETH`,
        symbol: ((U = g?.[i.networkId]) == null ? void 0 : U.currencySymbol) || "ETH",
        decimals: ((W = g?.[i.networkId]) == null ? void 0 : W.currencyDecimals) || 18,
        balance: d?.balance || ""
      };
    },
    [d?.balance, i.networkId]
  ), A = Kl(() => {
    var L, U;
    if (e.selectedToken) {
      const W = (U = (L = e.list) == null ? void 0 : L[i.contractAddress || ""]) == null ? void 0 : U[i.networkId];
      if (W) {
        const Z = W.find((J) => J.address === e.selectedToken);
        if (Z)
          return Z;
      }
    }
    return S;
  }, [
    S,
    e.selectedToken,
    e.list,
    i.contractAddress,
    i.networkId
  ]), x = Kl(() => e.exchangeRates[A.symbol] || 0, [A, e.exchangeRates]);
  Ln(() => {
    var L;
    b.current && u && ((L = u.xdomain) == null || L.storageSet(Uo.TOKENS_CONTEXT, JSON.stringify(e)));
  }, [e]), Ln(() => {
    u && !b.current && (b.current = !0, M(), O());
  }, [u]);
  async function M() {
    var L, U, W;
    const Z = await ((L = u?.xdomain) == null ? void 0 : L.storageGet(Uo.TOKENS_CONTEXT));
    if (Z)
      try {
        const J = JSON.parse(Z);
        r({ type: "setState", payload: J }), d && Array.isArray(
          (W = (U = J?.list) == null ? void 0 : U[i.contractAddress || ""]) == null ? void 0 : W[i.networkId]
        ) && J.list[i.contractAddress][i.networkId].forEach(
          async (Y) => {
            if (u) {
              const X = await u.contractRead({
                contractAddress: Y.address,
                contractAbi: my,
                contractFunctionName: "balanceOf",
                contractFunctionValues: [d.address]
              });
              X && r({
                type: "updateToken",
                payload: {
                  owner: i.contractAddress,
                  chainId: i.networkId,
                  token: {
                    ...Y,
                    balance: Pv.formatUnits(X, Y.decimals)
                  }
                }
              });
            }
          }
        );
      } catch (J) {
        console.error("Cant parse context state localStorage", J);
      }
    setTimeout(() => {
      y.current = !0;
    }, 100);
  }
  async function D(L) {
    if (u && d) {
      const [U, W, Z, J] = await Promise.all([
        u.contractRead({
          contractAddress: L,
          contractAbi: my,
          contractFunctionName: "name"
        }),
        u.contractRead({
          contractAddress: L,
          contractAbi: my,
          contractFunctionName: "symbol"
        }),
        u.contractRead({
          contractAddress: L,
          contractAbi: my,
          contractFunctionName: "decimals"
        }),
        u.contractRead({
          contractAddress: L,
          contractAbi: my,
          contractFunctionName: "balanceOf",
          contractFunctionValues: [d.address]
        })
      ]);
      if (W)
        return {
          address: L,
          name: U,
          symbol: W,
          decimals: Number(Z),
          balance: Pv.formatUnits(J, Z)
        };
    }
  }
  async function O() {
    if (!k.current.loading) {
      k.current.timeout && clearTimeout(k.current.timeout), k.current.loading = !0;
      try {
        const L = await fetch(
          "https://api-dev.apillon.io/embedded-wallet/evm-token-prices",
          { method: "GET" }
        );
        if (!L.ok || L.status >= 400)
          throw new Error("Could not load token exchange rates");
        const { data: U } = await L.json();
        U && r({ type: "setValue", payload: { key: "exchangeRates", value: U } });
      } catch (L) {
        console.error("loadExchangeRates", L);
      }
      k.current.loading = !1, k.current.timeout = setTimeout(() => O(), 5 * 6e4);
    }
  }
  function T(L) {
    var U, W;
    return {
      amount: Pv.formatUnits(
        L,
        ((U = g?.[i.networkId]) == null ? void 0 : U.currencyDecimals) || 18
      ),
      symbol: ((W = g?.[i.networkId]) == null ? void 0 : W.currencySymbol) || "ETH"
    };
  }
  return /* @__PURE__ */ C(
    mI.Provider,
    {
      value: {
        state: e,
        dispatch: r,
        nativeToken: S,
        selectedToken: A,
        currentExchangeRate: x,
        getTokenDetails: D,
        formatNativeBalance: T
      },
      children: a
    }
  );
}
function o1() {
  const a = ew(mI);
  if (a === void 0)
    throw new Error("useTokensContext usage must be wrapped with TokensContext provider.");
  return a;
}
const Q_ = [
  "data",
  "gasLimit",
  "nonce",
  "maxFeePerGas",
  "gasPrice",
  "maxFeePerBlobGas",
  "maxPriorityFeePerGas",
  "chain",
  // viem
  "blobs",
  // viem
  "accessList",
  // viem
  "authorizationList",
  // viem
  "nonceManager",
  // viem
  "type"
  // viem
], Z_ = () => {
  const {
    wallet: a,
    state: { username: e, appProps: r },
    networksById: i
  } = Et(), {
    state: { txToConfirm: u, approveParams: d }
  } = Hc();
  return u ? /* @__PURE__ */ Re("div", { className: "flex flex-col min-h-full pb-2", children: [
    /* @__PURE__ */ C("h3", { className: "my-6", children: "Approve Transaction" }),
    /* @__PURE__ */ C("div", { className: "flex flex-col gap-4 mb-6", children: Object.entries(u).filter(([g, b]) => g === "data" && b !== "0x" ? !0 : g === "value" && !b ? !1 : !Q_.includes(g)).map(([g, b]) => /* @__PURE__ */ C(
      ig,
      {
        label: g,
        data: g === "value" || g === "gas" ? /* @__PURE__ */ C(Y_, { value: b }) : g === "chainId" ? `${b}${i[b] ? ` (${i[b].name})` : ""}` : typeof b == "bigint" ? b.toString() : typeof b == "object" ? rI(b) : b,
        collapsable: typeof b == "object" || g === "data"
      },
      g
    )) }),
    /* @__PURE__ */ C("div", { className: "grow" }),
    /* @__PURE__ */ C(
      Dk,
      {
        onApprove: async () => {
          if (d != null && d.plain) {
            const g = await a?.signPlainTransaction({
              ...d.plain,
              authData: { username: e }
            });
            if (r.broadcastAfterSign && g) {
              const { signedTxData: b, chainId: y } = g;
              await a?.broadcastTransaction(
                b,
                y,
                d.plain.label || "Transaction"
              );
            }
          } else {
            const g = new Error("Embedded wallet approve");
            throw g.name = "no approve data", g;
          }
        }
      }
    )
  ] }) : /* @__PURE__ */ C(Yt, {});
}, Y_ = ({ value: a }) => {
  const { formatNativeBalance: e, currentExchangeRate: r } = o1(), i = e(a);
  return /* @__PURE__ */ Re("p", { className: "text-right", children: [
    /* @__PURE__ */ Re("span", { children: [
      i.amount,
      " ",
      i.symbol
    ] }),
    /* @__PURE__ */ C("br", {}),
    !!r && /* @__PURE__ */ Re("span", { className: "text-lightgrey", children: [
      "$",
      Yv(+i.amount * r, "", 2)
    ] })
  ] });
}, q_ = () => {
  const {
    wallet: a,
    state: { username: e }
  } = Et(), {
    state: { messageToSign: r, approveParams: i }
  } = Hc();
  return /* @__PURE__ */ Re("div", { className: "flex flex-col min-h-full pb-2", children: [
    /* @__PURE__ */ C("h3", { className: "my-6", children: "Sign Message" }),
    /* @__PURE__ */ C(ig, { label: "Signing", data: r, className: "mb-6" }),
    /* @__PURE__ */ C("div", { className: "grow" }),
    /* @__PURE__ */ C(
      Dk,
      {
        onApprove: async () => {
          if (i != null && i.signature)
            await a?.signMessage({
              ...i.signature,
              authData: { username: e }
            });
          else {
            const u = new Error("Embedded wallet approve");
            throw u.name = "no approve data", u;
          }
        }
      }
    )
  ] });
}, K_ = () => {
  const {
    state: { walletScreen: a }
  } = Et(), { state: e, onApproveDone: r } = Hc(), i = Rn(!1);
  return Ln(() => {
    i.current && a !== "approve" ? r() : a === "approve" && (i.current = !0);
  }, [a]), e.targetChain ? /* @__PURE__ */ C(V_, {}) : e.messageToSign ? /* @__PURE__ */ C(q_, {}) : e.txToConfirm ? /* @__PURE__ */ C(Z_, {}) : e.contractFunctionData ? /* @__PURE__ */ C(W_, {}) : /* @__PURE__ */ C(Yt, {});
};
function yI({ className: a }) {
  return /* @__PURE__ */ C(
    "svg",
    {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: a,
      children: /* @__PURE__ */ C("g", { id: "icons", children: /* @__PURE__ */ C(
        "path",
        {
          id: "Subtract",
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22ZM11 16.5681L18.2071 9.36099L16.7929 7.94678L11 13.7397L8.20712 10.9468L6.79291 12.361L11 16.5681Z",
          fill: "#A9DC76"
        }
      ) })
    }
  );
}
const J_ = () => {
  const {
    state: { walletScreen: a }
  } = Et(), {
    state: { successInfo: e },
    onApproveDone: r
  } = Hc(), i = Rn(!1);
  return Ln(() => {
    i.current && a !== "approve" ? r() : a === "approve" && (i.current = !0);
  }, [a]), e ? /* @__PURE__ */ Re("div", { className: "pt-12 pb-2", children: [
    /* @__PURE__ */ C(
      a1,
      {
        title: e.title,
        header: /* @__PURE__ */ C(yI, {}),
        titleClass: "text-xl",
        headerClass: "!mb-4",
        className: "!mb-4"
      }
    ),
    !!e.txHash && /* @__PURE__ */ Re("p", { className: "break-words text-sm text-center", children: [
      /* @__PURE__ */ C("span", { className: "text-lightgrey", children: "Transaction has been submitted with the following hash:" }),
      " ",
      /* @__PURE__ */ C("br", {}),
      /* @__PURE__ */ C("span", { className: "text-offwhite", children: e.txHash })
    ] }),
    /* @__PURE__ */ Re("div", { className: "mt-12", children: [
      /* @__PURE__ */ C(Dt, { variant: "ghost", href: e.explorerUrl, blank: !0, className: "w-full mb-3", children: "View on blockchain explorer" }),
      /* @__PURE__ */ C(Dt, { variant: "primary", className: "w-full", onClick: () => r(!0), children: "Close" })
    ] })
  ] }) : /* @__PURE__ */ C(Yt, {});
}, X_ = ({ className: a }) => /* @__PURE__ */ C(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: a,
    children: /* @__PURE__ */ C(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M15 10C15 12.7614 12.7614 15 10 15C7.23858 15 5 12.7614 5 10C5 7.23858 7.23858 5 10 5C12.7614 5 15 7.23858 15 10ZM13.8482 15.8483C12.744 16.5763 11.4215 17 10 17C6.13401 17 3 13.866 3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 11.7221 16.3781 13.299 15.3467 14.5183L20.4142 19.5858L19 21L13.8482 15.8483Z",
        fill: "currentColor"
      }
    )
  }
);
function YE(a, e) {
  Ln(() => {
    function r(i) {
      a.current && !a.current.contains(i.target) && e();
    }
    return document.addEventListener("mousedown", r), () => {
      document.removeEventListener("mousedown", r);
    };
  }, [a, e]);
}
function bI({
  disabled: a,
  className: e,
  inputClass: r,
  onChange: i,
  ...u
}) {
  const d = Rn(null), g = Rn(null), [b, y] = Ct(!1), [k, S] = Ct(!1);
  return YE(d, () => y(!1)), /* @__PURE__ */ C("div", { className: e, children: /* @__PURE__ */ Re("div", { ref: d, className: "relative", children: [
    /* @__PURE__ */ C(
      gE,
      {
        ref: g,
        placeholder: "Search",
        disabled: a,
        ...u,
        className: bt(
          "w-full px-11 py-2 text-sm font-normal",
          "rounded-[20px] border border-brightdark",
          "!outline-none bg-lightdark text-offwhite",
          "placeholder:text-lightgrey",
          {
            "border-offwhite": b && !a,
            "hover:border-lightgrey focus:border-offwhite": !a,
            "cursor-not-allowed !bg-transparent !text-darkgrey placeholder:!text-darkgrey": a
          },
          r
        ),
        onFocus: () => y(!0),
        onChange: (A) => {
          S(!!A.target.value), i?.(A.target.value);
        }
      }
    ),
    /* @__PURE__ */ C(
      X_,
      {
        className: bt("absolute left-3 top-1/2 -translate-y-1/2 text-darkgrey", {
          "!text-lightgrey": k
        })
      }
    ),
    /* @__PURE__ */ C(
      "button",
      {
        className: bt(
          "oaw-button-plain absolute right-3 top-1/2 !-translate-y-1/2 !rounded-full",
          {
            "!opacity-0": !b || !k
          }
        ),
        onClick: () => {
          g.current && (g.current.value = "", S(!1), i?.(""), g.current.focus());
        },
        children: /* @__PURE__ */ C(cI, { className: "inline-block text-darkgrey" })
      }
    )
  ] }) });
}
function eU() {
  const { state: a, dispatch: e, networks: r, wallet: i, setScreen: u } = Et(), [d, g] = Ct("");
  if (!Array.isArray(r) || !r.length)
    return /* @__PURE__ */ C(Yt, {});
  function b(y) {
    y !== a.networkId && (e({ type: "setValue", payload: { key: "networkId", value: y } }), i?.setDefaultNetworkId(y), u("main"));
  }
  return /* @__PURE__ */ Re("div", { children: [
    /* @__PURE__ */ C(bI, { value: d, onChange: (y) => g(y), className: "my-6" }),
    /* @__PURE__ */ C("div", { className: "flex flex-col gap-3", children: r.filter((y) => y.name.toLowerCase().includes(d.toLowerCase())).map((y) => /* @__PURE__ */ Re(
      "button",
      {
        disabled: y.id === a.networkId,
        className: bt(
          "oaw-button-plain !px-4 !py-[0.6875rem] !rounded-md !flex items-center gap-4 !bg-primarylight",
          "!border !border-solid border-transparent !transition-colors",
          "hover:border-darkgrey",
          {
            "!border-yellow !cursor-not-allowed": y.id === a.networkId
          }
        ),
        onClick: () => b(y.id),
        children: [
          /* @__PURE__ */ C(
            "img",
            {
              src: y?.imageUrl || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=",
              alt: y.name,
              className: "w-6 h-6 rounded-full"
            }
          ),
          /* @__PURE__ */ C("span", { className: "text-sm font-normal text-offwhite", children: y.name })
        ]
      },
      y.id
    )) })
  ] });
}
function Mk(a = "Copy", e = "Copied!") {
  const [r, i] = Ct(a);
  let u = null;
  function d(g) {
    navigator.clipboard.writeText(g), u && clearTimeout(u), i(e), u = setTimeout(() => i(a), 2e3);
  }
  return {
    text: r,
    onCopy: d
  };
}
function Fk({ className: a }) {
  return /* @__PURE__ */ C(
    "svg",
    {
      width: "15",
      height: "14",
      viewBox: "0 0 15 14",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: a,
      children: /* @__PURE__ */ C("g", { id: "icons", children: /* @__PURE__ */ C(
        "path",
        {
          id: "Vector",
          d: "M11.1296 12.25H4.71289V4.08334H11.1296V12.25ZM11.1296 2.91668H4.71289C4.40347 2.91668 4.10672 3.03959 3.88793 3.25839C3.66914 3.47718 3.54622 3.77392 3.54622 4.08334V12.25C3.54622 12.5594 3.66914 12.8562 3.88793 13.075C4.10672 13.2938 4.40347 13.4167 4.71289 13.4167H11.1296C11.439 13.4167 11.7357 13.2938 11.9545 13.075C12.1733 12.8562 12.2962 12.5594 12.2962 12.25V4.08334C12.2962 3.77392 12.1733 3.47718 11.9545 3.25839C11.7357 3.03959 11.439 2.91668 11.1296 2.91668ZM9.37956 0.583344H2.37956C2.07014 0.583344 1.77339 0.70626 1.5546 0.925052C1.33581 1.14384 1.21289 1.44059 1.21289 1.75001V9.91668H2.37956V1.75001H9.37956V0.583344Z",
          fill: "currentColor"
        }
      ) })
    }
  );
}
function _k() {
  return /* @__PURE__ */ C(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      height: "15px",
      viewBox: "0 -960 960 960",
      width: "15px",
      fill: "currentColor",
      children: /* @__PURE__ */ C("path", { d: "M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z" })
    }
  );
}
var X5 = { exports: {} }, tU = X5.exports, W9;
function nU() {
  return W9 || (W9 = 1, function(a, e) {
    (function(r, i) {
      a.exports = i();
    })(tU, function() {
      var r = 1e3, i = 6e4, u = 36e5, d = "millisecond", g = "second", b = "minute", y = "hour", k = "day", S = "week", A = "month", x = "quarter", M = "year", D = "date", O = "Invalid Date", T = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, L = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, U = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(V) {
        var B = ["th", "st", "nd", "rd"], P = V % 100;
        return "[" + V + (B[(P - 20) % 10] || B[P] || B[0]) + "]";
      } }, W = function(V, B, P) {
        var H = String(V);
        return !H || H.length >= B ? V : "" + Array(B + 1 - H.length).join(P) + V;
      }, Z = { s: W, z: function(V) {
        var B = -V.utcOffset(), P = Math.abs(B), H = Math.floor(P / 60), G = P % 60;
        return (B <= 0 ? "+" : "-") + W(H, 2, "0") + ":" + W(G, 2, "0");
      }, m: function V(B, P) {
        if (B.date() < P.date()) return -V(P, B);
        var H = 12 * (P.year() - B.year()) + (P.month() - B.month()), G = B.clone().add(H, A), ie = P - G < 0, ce = B.clone().add(H + (ie ? -1 : 1), A);
        return +(-(H + (P - G) / (ie ? G - ce : ce - G)) || 0);
      }, a: function(V) {
        return V < 0 ? Math.ceil(V) || 0 : Math.floor(V);
      }, p: function(V) {
        return { M: A, y: M, w: S, d: k, D, h: y, m: b, s: g, ms: d, Q: x }[V] || String(V || "").toLowerCase().replace(/s$/, "");
      }, u: function(V) {
        return V === void 0;
      } }, J = "en", Y = {};
      Y[J] = U;
      var X = "$isDayjsObject", ee = function(V) {
        return V instanceof he || !(!V || !V[X]);
      }, j = function V(B, P, H) {
        var G;
        if (!B) return J;
        if (typeof B == "string") {
          var ie = B.toLowerCase();
          Y[ie] && (G = ie), P && (Y[ie] = P, G = ie);
          var ce = B.split("-");
          if (!G && ce.length > 1) return V(ce[0]);
        } else {
          var xe = B.name;
          Y[xe] = B, G = xe;
        }
        return !H && G && (J = G), G || !H && J;
      }, ne = function(V, B) {
        if (ee(V)) return V.clone();
        var P = typeof B == "object" ? B : {};
        return P.date = V, P.args = arguments, new he(P);
      }, ae = Z;
      ae.l = j, ae.i = ee, ae.w = function(V, B) {
        return ne(V, { locale: B.$L, utc: B.$u, x: B.$x, $offset: B.$offset });
      };
      var he = function() {
        function V(P) {
          this.$L = j(P.locale, null, !0), this.parse(P), this.$x = this.$x || P.x || {}, this[X] = !0;
        }
        var B = V.prototype;
        return B.parse = function(P) {
          this.$d = function(H) {
            var G = H.date, ie = H.utc;
            if (G === null) return /* @__PURE__ */ new Date(NaN);
            if (ae.u(G)) return /* @__PURE__ */ new Date();
            if (G instanceof Date) return new Date(G);
            if (typeof G == "string" && !/Z$/i.test(G)) {
              var ce = G.match(T);
              if (ce) {
                var xe = ce[2] - 1 || 0, Ce = (ce[7] || "0").substring(0, 3);
                return ie ? new Date(Date.UTC(ce[1], xe, ce[3] || 1, ce[4] || 0, ce[5] || 0, ce[6] || 0, Ce)) : new Date(ce[1], xe, ce[3] || 1, ce[4] || 0, ce[5] || 0, ce[6] || 0, Ce);
              }
            }
            return new Date(G);
          }(P), this.init();
        }, B.init = function() {
          var P = this.$d;
          this.$y = P.getFullYear(), this.$M = P.getMonth(), this.$D = P.getDate(), this.$W = P.getDay(), this.$H = P.getHours(), this.$m = P.getMinutes(), this.$s = P.getSeconds(), this.$ms = P.getMilliseconds();
        }, B.$utils = function() {
          return ae;
        }, B.isValid = function() {
          return this.$d.toString() !== O;
        }, B.isSame = function(P, H) {
          var G = ne(P);
          return this.startOf(H) <= G && G <= this.endOf(H);
        }, B.isAfter = function(P, H) {
          return ne(P) < this.startOf(H);
        }, B.isBefore = function(P, H) {
          return this.endOf(H) < ne(P);
        }, B.$g = function(P, H, G) {
          return ae.u(P) ? this[H] : this.set(G, P);
        }, B.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, B.valueOf = function() {
          return this.$d.getTime();
        }, B.startOf = function(P, H) {
          var G = this, ie = !!ae.u(H) || H, ce = ae.p(P), xe = function(Ye, Ve) {
            var Je = ae.w(G.$u ? Date.UTC(G.$y, Ve, Ye) : new Date(G.$y, Ve, Ye), G);
            return ie ? Je : Je.endOf(k);
          }, Ce = function(Ye, Ve) {
            return ae.w(G.toDate()[Ye].apply(G.toDate("s"), (ie ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Ve)), G);
          }, Be = this.$W, Pe = this.$M, Fe = this.$D, Xe = "set" + (this.$u ? "UTC" : "");
          switch (ce) {
            case M:
              return ie ? xe(1, 0) : xe(31, 11);
            case A:
              return ie ? xe(1, Pe) : xe(0, Pe + 1);
            case S:
              var at = this.$locale().weekStart || 0, tt = (Be < at ? Be + 7 : Be) - at;
              return xe(ie ? Fe - tt : Fe + (6 - tt), Pe);
            case k:
            case D:
              return Ce(Xe + "Hours", 0);
            case y:
              return Ce(Xe + "Minutes", 1);
            case b:
              return Ce(Xe + "Seconds", 2);
            case g:
              return Ce(Xe + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, B.endOf = function(P) {
          return this.startOf(P, !1);
        }, B.$set = function(P, H) {
          var G, ie = ae.p(P), ce = "set" + (this.$u ? "UTC" : ""), xe = (G = {}, G[k] = ce + "Date", G[D] = ce + "Date", G[A] = ce + "Month", G[M] = ce + "FullYear", G[y] = ce + "Hours", G[b] = ce + "Minutes", G[g] = ce + "Seconds", G[d] = ce + "Milliseconds", G)[ie], Ce = ie === k ? this.$D + (H - this.$W) : H;
          if (ie === A || ie === M) {
            var Be = this.clone().set(D, 1);
            Be.$d[xe](Ce), Be.init(), this.$d = Be.set(D, Math.min(this.$D, Be.daysInMonth())).$d;
          } else xe && this.$d[xe](Ce);
          return this.init(), this;
        }, B.set = function(P, H) {
          return this.clone().$set(P, H);
        }, B.get = function(P) {
          return this[ae.p(P)]();
        }, B.add = function(P, H) {
          var G, ie = this;
          P = Number(P);
          var ce = ae.p(H), xe = function(Pe) {
            var Fe = ne(ie);
            return ae.w(Fe.date(Fe.date() + Math.round(Pe * P)), ie);
          };
          if (ce === A) return this.set(A, this.$M + P);
          if (ce === M) return this.set(M, this.$y + P);
          if (ce === k) return xe(1);
          if (ce === S) return xe(7);
          var Ce = (G = {}, G[b] = i, G[y] = u, G[g] = r, G)[ce] || 1, Be = this.$d.getTime() + P * Ce;
          return ae.w(Be, this);
        }, B.subtract = function(P, H) {
          return this.add(-1 * P, H);
        }, B.format = function(P) {
          var H = this, G = this.$locale();
          if (!this.isValid()) return G.invalidDate || O;
          var ie = P || "YYYY-MM-DDTHH:mm:ssZ", ce = ae.z(this), xe = this.$H, Ce = this.$m, Be = this.$M, Pe = G.weekdays, Fe = G.months, Xe = G.meridiem, at = function(Ve, Je, _e, rt) {
            return Ve && (Ve[Je] || Ve(H, ie)) || _e[Je].slice(0, rt);
          }, tt = function(Ve) {
            return ae.s(xe % 12 || 12, Ve, "0");
          }, Ye = Xe || function(Ve, Je, _e) {
            var rt = Ve < 12 ? "AM" : "PM";
            return _e ? rt.toLowerCase() : rt;
          };
          return ie.replace(L, function(Ve, Je) {
            return Je || function(_e) {
              switch (_e) {
                case "YY":
                  return String(H.$y).slice(-2);
                case "YYYY":
                  return ae.s(H.$y, 4, "0");
                case "M":
                  return Be + 1;
                case "MM":
                  return ae.s(Be + 1, 2, "0");
                case "MMM":
                  return at(G.monthsShort, Be, Fe, 3);
                case "MMMM":
                  return at(Fe, Be);
                case "D":
                  return H.$D;
                case "DD":
                  return ae.s(H.$D, 2, "0");
                case "d":
                  return String(H.$W);
                case "dd":
                  return at(G.weekdaysMin, H.$W, Pe, 2);
                case "ddd":
                  return at(G.weekdaysShort, H.$W, Pe, 3);
                case "dddd":
                  return Pe[H.$W];
                case "H":
                  return String(xe);
                case "HH":
                  return ae.s(xe, 2, "0");
                case "h":
                  return tt(1);
                case "hh":
                  return tt(2);
                case "a":
                  return Ye(xe, Ce, !0);
                case "A":
                  return Ye(xe, Ce, !1);
                case "m":
                  return String(Ce);
                case "mm":
                  return ae.s(Ce, 2, "0");
                case "s":
                  return String(H.$s);
                case "ss":
                  return ae.s(H.$s, 2, "0");
                case "SSS":
                  return ae.s(H.$ms, 3, "0");
                case "Z":
                  return ce;
              }
              return null;
            }(Ve) || ce.replace(":", "");
          });
        }, B.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, B.diff = function(P, H, G) {
          var ie, ce = this, xe = ae.p(H), Ce = ne(P), Be = (Ce.utcOffset() - this.utcOffset()) * i, Pe = this - Ce, Fe = function() {
            return ae.m(ce, Ce);
          };
          switch (xe) {
            case M:
              ie = Fe() / 12;
              break;
            case A:
              ie = Fe();
              break;
            case x:
              ie = Fe() / 3;
              break;
            case S:
              ie = (Pe - Be) / 6048e5;
              break;
            case k:
              ie = (Pe - Be) / 864e5;
              break;
            case y:
              ie = Pe / u;
              break;
            case b:
              ie = Pe / i;
              break;
            case g:
              ie = Pe / r;
              break;
            default:
              ie = Pe;
          }
          return G ? ie : ae.a(ie);
        }, B.daysInMonth = function() {
          return this.endOf(A).$D;
        }, B.$locale = function() {
          return Y[this.$L];
        }, B.locale = function(P, H) {
          if (!P) return this.$L;
          var G = this.clone(), ie = j(P, H, !0);
          return ie && (G.$L = ie), G;
        }, B.clone = function() {
          return ae.w(this.$d, this);
        }, B.toDate = function() {
          return new Date(this.valueOf());
        }, B.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, B.toISOString = function() {
          return this.$d.toISOString();
        }, B.toString = function() {
          return this.$d.toUTCString();
        }, V;
      }(), Ie = he.prototype;
      return ne.prototype = Ie, [["$ms", d], ["$s", g], ["$m", b], ["$H", y], ["$W", k], ["$M", A], ["$y", M], ["$D", D]].forEach(function(V) {
        Ie[V[1]] = function(B) {
          return this.$g(B, V[0], V[1]);
        };
      }), ne.extend = function(V, B) {
        return V.$i || (V(B, he, ne), V.$i = !0), ne;
      }, ne.locale = j, ne.isDayjs = ee, ne.unix = function(V) {
        return ne(1e3 * V);
      }, ne.en = Y[J], ne.Ls = Y, ne.p = {}, ne;
    });
  }(X5)), X5.exports;
}
var rU = nU();
const G9 = /* @__PURE__ */ mx(rU), vI = ({
  text: a,
  color: e = "#06080F",
  bg: r = "#78DCE8",
  className: i
}) => /* @__PURE__ */ C(
  "span",
  {
    className: bt(
      "font-sans text-[10px] font-bold text-center uppercase",
      {
        "px-2.5 py-1 min-h-6 rounded-full": !!r
      },
      i
    ),
    style: { backgroundColor: r, color: e },
    children: a
  }
);
function aU({ className: a }) {
  const { activeWallet: e } = Et(), { state: r } = sI();
  return !(e != null && e.address) || !r.txs[e.address] ? /* @__PURE__ */ C("p", { className: "text-sm text-lightgrey text-center", children: "No transactions" }) : /* @__PURE__ */ C("div", { className: a, children: /* @__PURE__ */ C("div", { className: "flex flex-col gap-2 pr-2", children: Object.values(r.txs[e.address]).sort((i, u) => (u.createdAt || 0) - (i.createdAt || 0)).map((i) => /* @__PURE__ */ C(oU, { tx: i }, i.hash)) }) });
}
function oU({ tx: a }) {
  const { text: e, onCopy: r } = Mk("", "+");
  return /* @__PURE__ */ Re("div", { className: "rounded-lg bg-primarylight px-4 py-2", children: [
    /* @__PURE__ */ Re("div", { className: "flex justify-between items-center mb-0.5", children: [
      /* @__PURE__ */ C("span", { className: "font-bold text-sm text-offwhite", children: /* @__PURE__ */ C(
        "a",
        {
          href: a.explorerUrl || "#",
          target: "_blank",
          title: "View on explorer",
          className: "rounded-sm",
          children: a.label
        }
      ) }),
      /* @__PURE__ */ C(
        vI,
        {
          text: a.status,
          bg: "",
          color: "",
          className: bt({
            "text-pink": a.status === "failed",
            "text-green": a.status === "confirmed",
            "text-orange": a.status === "pending"
          })
        }
      )
    ] }),
    /* @__PURE__ */ Re("div", { className: "flex justify-between items-end", children: [
      /* @__PURE__ */ Re(
        "button",
        {
          className: "text-xs inline-flex items-center oaw-button-plain gap-1",
          onClick: () => r(a.hash),
          children: [
            /* @__PURE__ */ Re("span", { title: a.hash, className: "text-xs text-ellipsis", children: [
              nI(a.hash),
              " "
            ] }),
            /* @__PURE__ */ C("span", { className: bt(["shrink-0 pl-0.5", { "text-green": e === "+" }]), children: e === "+" ? /* @__PURE__ */ C(_k, {}) : /* @__PURE__ */ C(Fk, { className: "text-lightgrey" }) })
          ]
        }
      ),
      /* @__PURE__ */ C("span", { title: new Date(a.createdAt).toISOString(), className: "text-xs text-lightgrey", children: G9(a.createdAt).format(
        a.createdAt > G9().startOf("day").valueOf() ? "HH:mm" : "MMM D, YYYY"
      ) })
    ] })
  ] });
}
const iU = ({ className: a }) => /* @__PURE__ */ C(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: a,
    children: /* @__PURE__ */ C(
      "path",
      {
        d: "M17.65 6.00381C16.2 4.55381 14.21 3.65381 12 3.65381C9.87827 3.65381 7.84344 4.49666 6.34315 5.99695C4.84285 7.49725 4 9.53208 4 11.6538C4 13.7755 4.84285 15.8104 6.34315 17.3107C7.84344 18.811 9.87827 19.6538 12 19.6538C15.73 19.6538 18.84 17.1038 19.73 13.6538H17.65C16.83 15.9838 14.61 17.6538 12 17.6538C10.4087 17.6538 8.88258 17.0217 7.75736 15.8965C6.63214 14.7712 6 13.2451 6 11.6538C6 10.0625 6.63214 8.53639 7.75736 7.41117C8.88258 6.28595 10.4087 5.65381 12 5.65381C13.66 5.65381 15.14 6.34381 16.22 7.43381L13 10.6538H20V3.65381L17.65 6.00381Z",
        fill: "currentColor"
      }
    )
  }
);
function sU() {
  const {
    state: { loadingWallets: a },
    loadAccountWallets: e
  } = Et();
  return /* @__PURE__ */ Re("div", { className: "flex items-center gap-2 w-full", children: [
    /* @__PURE__ */ C(ZE, { className: "shrink-0 text-blue" }),
    /* @__PURE__ */ C("span", { children: "Accounts are stale" }),
    /* @__PURE__ */ C("div", { className: "grow" }),
    /* @__PURE__ */ Re(
      "button",
      {
        className: "oaw-button-plain !inline-flex items-center gap-0.5 !text-yellow",
        onClick: () => e(),
        children: [
          /* @__PURE__ */ C("span", { className: "text-xs", children: a ? "..." : "Reload" }),
          /* @__PURE__ */ C(iU, { className: "w-4 h-4" })
        ]
      }
    )
  ] });
}
const qE = ({ text: a, className: e }) => {
  const { state: r, handleInfo: i } = Et();
  return !a && !r.displayedInfo ? /* @__PURE__ */ C(Yt, {}) : a === "stale" || r.displayedInfo === "stale" ? /* @__PURE__ */ C(
    ck,
    {
      className: bt("!justify-start", e),
      onDismiss: r.displayedInfo ? () => i("", 0) : void 0,
      children: /* @__PURE__ */ C(sU, {})
    }
  ) : /* @__PURE__ */ C(
    ck,
    {
      text: a || r.displayedInfo,
      before: /* @__PURE__ */ C(ZE, { className: "shrink-0 text-blue" }),
      className: e,
      onDismiss: () => i("", 0)
    }
  );
}, lU = () => {
  const {
    state: { isAccountWalletsStale: a },
    activeWallet: e,
    setScreen: r
  } = Et(), { selectedToken: i, currentExchangeRate: u } = o1(), d = [
    {
      title: "Transactions",
      content: /* @__PURE__ */ C(aU, {})
    },
    {
      title: "Tokens",
      content: /* @__PURE__ */ C(j9, {}),
      disabled: !0
    },
    {
      title: "NFTs",
      content: /* @__PURE__ */ C(j9, {}),
      disabled: !0
    }
  ];
  return /* @__PURE__ */ Re("div", { children: [
    !!a && /* @__PURE__ */ C(qE, { text: "stale", className: "mt-6 -mb-6" }),
    /* @__PURE__ */ Re("div", { className: "py-12", children: [
      /* @__PURE__ */ C("div", { className: "text-center mb-4", children: /* @__PURE__ */ Re("p", { className: "flex items-center justify-center gap-2", children: [
        /* @__PURE__ */ C("span", { className: "font-bold text-3xl", title: e?.balance || "0", children: Yv(e?.balance || "0", i.symbol) }),
        !!u && /* @__PURE__ */ Re("span", { className: "text-lightgrey text-xl font-light", children: [
          "($",
          Yv(+(e?.balance || 0) * u, "", 2),
          ")"
        ] })
      ] }) }),
      /* @__PURE__ */ Re("div", { className: "flex gap-4 justify-center", children: [
        /* @__PURE__ */ C(Dt, { minWidth: "0", minHeight: "40px", onClick: () => r("sendToken"), children: "Send" }),
        /* @__PURE__ */ C(Dt, { minWidth: "0", minHeight: "40px", onClick: () => r("accountDetails"), children: "Receive" }),
        /* @__PURE__ */ C(Dt, { minWidth: "0", minHeight: "40px", disabled: !0, children: "Buy" })
      ] })
    ] }),
    /* @__PURE__ */ Re(UP, { children: [
      /* @__PURE__ */ C("div", { className: "-mx-8 flex justify-center", children: /* @__PURE__ */ C(zP, { className: "flex rounded-full bg-brightdark mb-6", children: d.map((g) => /* @__PURE__ */ C(
        HP,
        {
          disabled: g.disabled,
          className: bt(
            "oaw-button-plain z-10",
            "!rounded-full !py-2 !px-6 text-sm font-normal text-lightgrey",
            "!border !border-solid !border-brightdark",
            "data-[selected]:bg-deepdark data-[selected]:text-offwhite data-[selected]:z-20",
            {
              "hover:!text-lightgrey !cursor-not-allowed": g.disabled
            }
          ),
          children: g.title
        },
        g.title
      )) }) }),
      /* @__PURE__ */ C(VP, { children: d.map((g) => /* @__PURE__ */ C(WP, { children: g.content }, g.title)) })
    ] })
  ] });
}, j9 = () => /* @__PURE__ */ Re("div", { className: "flex gap-4 justify-center", children: [
  /* @__PURE__ */ C("div", { className: "w-[125px] h-[144px] bg-primarybright rounded-lg" }),
  /* @__PURE__ */ C("div", { className: "w-[125px] h-[144px] bg-primarybright rounded-lg" })
] }), uU = "data:image/svg+xml,%3csvg%20width='16'%20height='12'%20viewBox='0%200%2016%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%20-9.53674e-07V12L8%206L0%20-9.53674e-07ZM8%206L16%20-9.53674e-07V12L8%206Z'%20fill='%23F0F2DA'/%3e%3c/svg%3e", cU = ({ className: a }) => /* @__PURE__ */ C(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: a,
    children: /* @__PURE__ */ C(
      "path",
      {
        d: "M12 3C10.9 3 10 3.9 10 5C10 6.1 10.9 7 12 7C13.1 7 14 6.1 14 5C14 3.9 13.1 3 12 3ZM12 17C10.9 17 10 17.9 10 19C10 20.1 10.9 21 12 21C13.1 21 14 20.1 14 19C14 17.9 13.1 17 12 17ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10Z",
        fill: "currentColor"
      }
    )
  }
), wI = ({ noChevron: a = !1, className: e }) => {
  const {
    state: { username: r },
    activeWallet: i,
    setScreen: u
  } = Et(), { text: d, onCopy: g } = Mk("", "+");
  return /* @__PURE__ */ Re("div", { className: bt("text-center", e), children: [
    /* @__PURE__ */ Re(
      "button",
      {
        className: "oaw-button-plain flex items-center gap-1 mb-1.5 min-w-0 !text-offwhite max-w-full mx-auto",
        title: i?.title || r,
        onClick: () => u("selectAccounts"),
        children: [
          /* @__PURE__ */ C("span", { className: "text-sm font-bold truncate", children: i?.title || r }),
          !a && /* @__PURE__ */ C(Bk, {})
        ]
      }
    ),
    !!i && /* @__PURE__ */ Re(
      "button",
      {
        title: i.address,
        className: "oaw-button-plain !pl-2 !pr-0.5 flex items-center min-w-0 !text-lightgrey mx-auto",
        onClick: () => g(i.address),
        children: [
          /* @__PURE__ */ C("span", { className: "truncate text-lightgrey text-xs w-[70px]", children: i.address }),
          /* @__PURE__ */ C("span", { className: bt(["shrink-0 pl-0.5", { "text-green": d === "+" }]), children: d === "+" ? /* @__PURE__ */ C(_k, {}) : /* @__PURE__ */ C(Fk, { className: "text-lightgrey" }) })
        ]
      }
    )
  ] });
}, fU = () => {
  const {
    state: { networkId: a },
    networksById: e,
    setScreen: r
  } = Et(), i = a && e[a] ? e[a] : null;
  return /* @__PURE__ */ Re("div", { className: "flex items-center justify-between gap-4 p-4", children: [
    /* @__PURE__ */ C("div", { className: "w-[72px] shrink-0", children: /* @__PURE__ */ Re(
      "button",
      {
        className: "oaw-button-plain !rounded-md !bg-deepdark flex items-center gap-2.5 !py-1 !px-2",
        title: i?.name,
        onClick: () => r("networks"),
        children: [
          /* @__PURE__ */ C(
            "img",
            {
              src: i?.imageUrl || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=",
              alt: i?.name,
              className: "w-5 h-5 rounded-full"
            }
          ),
          /* @__PURE__ */ C("span", { className: "text-offwhite", children: /* @__PURE__ */ C(Bk, {}) })
        ]
      }
    ) }),
    /* @__PURE__ */ C(wI, { className: "flex-1 min-w-0" }),
    /* @__PURE__ */ Re("div", { className: "w-[80px] flex items-center justify-end gap-2 -mr-2 shrink-0", children: [
      /* @__PURE__ */ Re(
        "button",
        {
          className: "oaw-button-plain !rounded-full !bg-deepdark relative w-8 h-8 shrink-0",
          title: "Account",
          onClick: () => r("accountDetails"),
          children: [
            /* @__PURE__ */ C("img", { src: uU, alt: "Account", className: "mx-auto" }),
            /* @__PURE__ */ C("span", { className: "w-2 h-2 rounded-full bg-green absolute bottom-0 right-0.5" })
          ]
        }
      ),
      /* @__PURE__ */ C(
        "button",
        {
          className: "oaw-button-plain !rounded-full !bg-transparent relative w-8 h-8 text-offwhite shrink-0",
          title: "Settings",
          onClick: () => r("menuDot"),
          children: /* @__PURE__ */ C(cU, { className: "mx-auto" })
        }
      )
    ] })
  ] });
}, dU = () => /* @__PURE__ */ C("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ C("g", { id: "icons", children: /* @__PURE__ */ C(
  "path",
  {
    id: "Vector",
    d: "M13.1067 8.07161L11.9283 6.89328L4.16667 14.6549V15.8333H5.345L13.1067 8.07161ZM14.285 6.89328L15.4633 5.71495L14.285 4.53661L13.1067 5.71495L14.285 6.89328ZM6.035 17.4999H2.5V13.9641L13.6958 2.76828C13.8521 2.61205 14.064 2.52429 14.285 2.52429C14.506 2.52429 14.7179 2.61205 14.8742 2.76828L17.2317 5.12578C17.3879 5.28205 17.4757 5.49398 17.4757 5.71495C17.4757 5.93592 17.3879 6.14784 17.2317 6.30411L6.03583 17.4999H6.035Z",
    fill: "#F0F2DA"
  }
) }) }), hU = ({ className: a }) => /* @__PURE__ */ C(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: a,
    children: /* @__PURE__ */ C("g", { id: "Group", children: /* @__PURE__ */ C(
      "path",
      {
        id: "Vector",
        d: "M9.99974 15.172L19.1917 5.979L20.6067 7.393L9.99974 18L3.63574 11.636L5.04974 10.222L9.99974 15.172Z",
        fill: "currentColor"
      }
    ) })
  }
), kI = ({ className: a }) => {
  const {
    state: { walletIndex: e },
    activeWallet: r,
    handleError: i,
    saveAccountTitle: u
  } = Et(), [d, g] = Ct(!1), [b, y] = Ct(r?.title || ""), [k, S] = Ct(!1), A = Rn(null);
  YE(A, () => g(!1));
  async function x() {
    if (b === r?.title) {
      g(!1);
      return;
    }
    if (!(k || !b)) {
      S(!0);
      try {
        await u(b, e), await g_(200), g(!1);
      } catch (M) {
        i(M);
      }
      S(!1);
    }
  }
  return r ? /* @__PURE__ */ Re("div", { className: bt("relative", a), children: [
    /* @__PURE__ */ Re(
      "button",
      {
        className: bt("oaw-button-plain !inline-flex items-center gap-2", {
          invisible: d
        }),
        title: "Edit account name",
        onClick: () => g(!0),
        children: [
          /* @__PURE__ */ C("span", { className: "text-sm font-bold text-offwhite", children: r.title }),
          /* @__PURE__ */ C(dU, {})
        ]
      }
    ),
    d && /* @__PURE__ */ Re(
      "form",
      {
        ref: A,
        className: "flex w-full items-center justify-center gap-2 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
        onSubmit: (M) => {
          M.preventDefault(), x();
        },
        children: [
          /* @__PURE__ */ C(
            Tg,
            {
              autoFocus: !0,
              value: b,
              placeholder: "Enter account name",
              disabled: k,
              onChange: (M) => y(M.target.value)
            }
          ),
          /* @__PURE__ */ C(
            "button",
            {
              type: "submit",
              className: "oaw-button-plain w-12 h-12 !rounded-sm !bg-green !text-deepdark !flex items-center justify-center",
              children: k ? /* @__PURE__ */ C(cw, { size: 36, fill: "currentColor" }) : /* @__PURE__ */ C(hU, {})
            }
          )
        ]
      }
    )
  ] }) : /* @__PURE__ */ C(Yt, {});
}, pU = ({ className: a }) => /* @__PURE__ */ C(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: a,
    children: /* @__PURE__ */ C(
      "path",
      {
        d: "M20.0002 10.6539V12.6539H8.00016L13.5002 18.1539L12.0802 19.5739L4.16016 11.6539L12.0802 3.73389L13.5002 5.15389L8.00016 10.6539H20.0002Z",
        fill: "#F0F2DA"
      }
    )
  }
), gU = ({ className: a }) => /* @__PURE__ */ Re(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: a,
    children: [
      /* @__PURE__ */ C("g", { clipPath: "url(#clip0_2748_6599)", children: /* @__PURE__ */ C(
        "path",
        {
          d: "M19 21H5C4.73478 21 4.48043 20.8947 4.29289 20.7071C4.10536 20.5196 4 20.2653 4 20V11H1L11.327 1.61204C11.5111 1.44452 11.7511 1.35168 12 1.35168C12.2489 1.35168 12.4889 1.44452 12.673 1.61204L23 11H20V20C20 20.2653 19.8946 20.5196 19.7071 20.7071C19.5196 20.8947 19.2652 21 19 21ZM6 19H18V9.15704L12 3.70304L6 9.15704V19ZM12 15C11.337 15 10.7011 14.7366 10.2322 14.2678C9.76339 13.799 9.5 13.1631 9.5 12.5C9.5 11.837 9.76339 11.2011 10.2322 10.7323C10.7011 10.2634 11.337 10 12 10C12.663 10 13.2989 10.2634 13.7678 10.7323C14.2366 11.2011 14.5 11.837 14.5 12.5C14.5 13.1631 14.2366 13.799 13.7678 14.2678C13.2989 14.7366 12.663 15 12 15Z",
          fill: "#F0F2DA"
        }
      ) }),
      /* @__PURE__ */ C("defs", { children: /* @__PURE__ */ C("clipPath", { id: "clip0_2748_6599", children: /* @__PURE__ */ C("rect", { width: "24", height: "24", fill: "white" }) }) })
    ]
  }
), mU = {
  networks: "Networks",
  transactions: "Transactions",
  sendToken: "Send",
  selectToken: "Select token",
  addToken: "Add token",
  accountDetails: "Account details",
  menuMore: "Settings & security",
  settingsGeneral: "General settings",
  exportPrivateKey: "Export private key",
  importAccount: "Import private key",
  selectAccounts: "Select account",
  addAccount: "Add new account"
}, yU = () => {
  const {
    state: { walletScreen: a },
    goScreenBack: e,
    dispatch: r
  } = Et(), i = mU[a];
  function u() {
    return a === "menuDot" ? /* @__PURE__ */ C(kI, {}) : /* @__PURE__ */ C("span", { className: "text-sm font-bold", children: i });
  }
  return /* @__PURE__ */ Re("div", { className: "flex items-center justify-between gap-4 p-4", children: [
    /* @__PURE__ */ C("div", { className: "w-8 shrink-0", children: /* @__PURE__ */ C(
      "button",
      {
        className: "oaw-button-plain !rounded-full !bg-transparent w-8 h-8",
        title: "Back",
        onClick: () => e(),
        children: /* @__PURE__ */ C(pU, { className: "inline-block" })
      }
    ) }),
    /* @__PURE__ */ C("div", { className: "flex-1 text-center min-w-0", children: u() }),
    /* @__PURE__ */ C("div", { className: "w-8 shrink-0", children: /* @__PURE__ */ C(
      "button",
      {
        className: "oaw-button-plain !rounded-full !bg-transparent w-8 h-8",
        title: "Home",
        onClick: () => {
          r({
            type: "setState",
            payload: { walletScreen: "main", walletScreenHistory: ["main"] }
          });
        },
        children: /* @__PURE__ */ C(gU, { className: "inline-block" })
      }
    ) })
  ] });
}, bU = () => {
  const {
    state: { walletScreen: a }
  } = Et(), e = a === "main" || a === "approve";
  return /* @__PURE__ */ C(
    "div",
    {
      className: bt(e ? "bg-lightdark" : "bg-deepdark"),
      style: {
        height: e ? "82px" : "64px",
        transition: "height 0.3s cubic-bezier(0.25,0.46,0.45,0.94)"
      },
      children: e ? /* @__PURE__ */ C(fU, {}) : /* @__PURE__ */ C(yU, {})
    }
  );
}, vU = () => /* @__PURE__ */ Re("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ C("g", { clipPath: "url(#clip0_2738_3598)", children: /* @__PURE__ */ C(
    "path",
    {
      d: "M8.33333 5V6.66667L4.16667 6.66667L4.16667 15.8333L13.3333 15.8333V11.6667H15V16.6667C15 16.8877 14.9122 17.0996 14.7559 17.2559C14.5996 17.4122 14.3877 17.5 14.1667 17.5H3.33333C3.11232 17.5 2.90036 17.4122 2.74408 17.2559C2.5878 17.0996 2.5 16.8877 2.5 16.6667L2.5 5.83333C2.5 5.61232 2.5878 5.40036 2.74408 5.24408C2.90036 5.0878 3.11232 5 3.33333 5L8.33333 5ZM17.5 2.5V9.16667L15.8333 9.16667L15.8333 5.34417L9.33917 11.8392L8.16083 10.6608L14.6542 4.16667H10.8333V2.5L17.5 2.5Z",
      fill: "#F0F2DA"
    }
  ) }),
  /* @__PURE__ */ C("defs", { children: /* @__PURE__ */ C("clipPath", { id: "clip0_2738_3598", children: /* @__PURE__ */ C("rect", { width: "20", height: "20", fill: "white" }) }) })
] }), wU = () => /* @__PURE__ */ Re("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ C("g", { clipPath: "url(#clip0_2738_3582)", children: /* @__PURE__ */ C(
    "path",
    {
      d: "M5 8.33331L5 16.6666H15.8333V8.33331L5 8.33331ZM15 6.66665L16.6667 6.66665C16.8877 6.66665 17.0996 6.75444 17.2559 6.91072C17.4122 7.067 17.5 7.27897 17.5 7.49998L17.5 17.5C17.5 17.721 17.4122 17.933 17.2559 18.0892C17.0996 18.2455 16.8877 18.3333 16.6667 18.3333L3.33333 18.3333C3.11232 18.3333 2.90036 18.2455 2.74408 18.0892C2.5878 17.933 2.5 17.721 2.5 17.5L2.5 7.49998C2.5 7.27897 2.5878 7.067 2.74408 6.91072C2.90036 6.75444 3.11232 6.66665 3.33333 6.66665H5V5.83331C5 4.50723 5.52678 3.23546 6.46447 2.29778C7.40215 1.3601 8.67392 0.833313 10 0.833313C11.3261 0.833313 12.5979 1.3601 13.5355 2.29778C14.4732 3.23546 15 4.50723 15 5.83331L15 6.66665ZM13.3333 6.66665L13.3333 5.83331C13.3333 4.94926 12.9821 4.10141 12.357 3.47629C11.7319 2.85117 10.8841 2.49998 10 2.49998C9.11594 2.49998 8.2681 2.85117 7.64298 3.47629C7.01786 4.10141 6.66667 4.94926 6.66667 5.83331V6.66665L13.3333 6.66665ZM5.83333 9.16665H7.5V10.8333H5.83333V9.16665ZM5.83333 11.6666H7.5V13.3333H5.83333V11.6666ZM5.83333 14.1666H7.5L7.5 15.8333H5.83333V14.1666Z",
      fill: "#F0F2DA"
    }
  ) }),
  /* @__PURE__ */ C("defs", { children: /* @__PURE__ */ C("clipPath", { id: "clip0_2738_3582", children: /* @__PURE__ */ C("rect", { width: "20", height: "20", fill: "white" }) }) })
] }), kU = () => /* @__PURE__ */ Re("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ C("g", { clipPath: "url(#clip0_2738_3576)", children: /* @__PURE__ */ C(
    "path",
    {
      d: "M10.0003 18.3334C5.39783 18.3334 1.66699 14.6025 1.66699 10C1.66699 5.39752 5.39783 1.66669 10.0003 1.66669C14.6028 1.66669 18.3337 5.39752 18.3337 10C18.3337 14.6025 14.6028 18.3334 10.0003 18.3334ZM5.84449 15.2134C7.02412 16.1564 8.49006 16.6691 10.0003 16.6667C11.642 16.6667 13.1445 16.0734 14.3062 15.09C13.7634 14.5331 13.1145 14.0908 12.3979 13.789C11.6812 13.4873 10.9113 13.3323 10.1337 13.3334C9.32748 13.3324 8.52991 13.4991 7.79155 13.8227C7.05318 14.1463 6.39014 14.6199 5.84449 15.2134ZM4.68033 14.0167C5.3807 13.2734 6.22588 12.6814 7.16377 12.2773C8.10167 11.8731 9.11239 11.6653 10.1337 11.6667C11.1184 11.6654 12.0936 11.8587 13.0034 12.2353C13.9133 12.612 14.7397 13.1647 15.4353 13.8617C16.1487 12.8576 16.57 11.6756 16.6525 10.4466C16.7349 9.21768 16.4753 7.98993 15.9024 6.89957C15.3295 5.80921 14.4658 4.89887 13.407 4.26956C12.3482 3.64024 11.1357 3.31655 9.90416 3.3344C8.67259 3.35224 7.47004 3.71092 6.42993 4.37065C5.38981 5.03038 4.55279 5.96536 4.01174 7.07186C3.47068 8.17835 3.24674 9.41311 3.36476 10.6391C3.48277 11.8652 3.93814 13.0345 4.68033 14.0175V14.0167ZM10.0003 10.8334C9.11627 10.8334 8.26842 10.4822 7.6433 9.85704C7.01818 9.23192 6.66699 8.38408 6.66699 7.50002C6.66699 6.61597 7.01818 5.76812 7.6433 5.143C8.26842 4.51788 9.11627 4.16669 10.0003 4.16669C10.8844 4.16669 11.7322 4.51788 12.3573 5.143C12.9825 5.76812 13.3337 6.61597 13.3337 7.50002C13.3337 8.38408 12.9825 9.23192 12.3573 9.85704C11.7322 10.4822 10.8844 10.8334 10.0003 10.8334ZM10.0003 9.16669C10.4424 9.16669 10.8663 8.99109 11.1788 8.67853C11.4914 8.36597 11.667 7.94205 11.667 7.50002C11.667 7.05799 11.4914 6.63407 11.1788 6.32151C10.8663 6.00895 10.4424 5.83335 10.0003 5.83335C9.5583 5.83335 9.13438 6.00895 8.82182 6.32151C8.50925 6.63407 8.33366 7.05799 8.33366 7.50002C8.33366 7.94205 8.50925 8.36597 8.82182 8.67853C9.13438 8.99109 9.5583 9.16669 10.0003 9.16669Z",
      fill: "#F0F2DA"
    }
  ) }),
  /* @__PURE__ */ C("defs", { children: /* @__PURE__ */ C("clipPath", { id: "clip0_2738_3576", children: /* @__PURE__ */ C("rect", { width: "20", height: "20", fill: "white" }) }) })
] }), Uk = ({
  title: a,
  description: e,
  icon: r,
  link: i,
  screen: u,
  disabled: d = !1,
  className: g,
  onClick: b
}) => {
  const { setScreen: y } = Et(), k = /* @__PURE__ */ Re(Yt, { children: [
    r,
    /* @__PURE__ */ Re("div", { className: "grow", children: [
      /* @__PURE__ */ C("p", { className: "text-sm font-normal text-offwhite", children: a }),
      e && /* @__PURE__ */ C("p", { className: "text-xs text-lightgrey", children: e })
    ] }),
    /* @__PURE__ */ C(Bk, {})
  ] }), S = bt(
    "oaw-button-plain !px-4 !py-[0.6875rem] !rounded-md !flex items-center gap-4 !bg-primarylight !text-left",
    "!border !border-solid border-transparent !transition-colors",
    "hover:border-darkgrey",
    {
      "opacity-60 grayscale pointer-events-none": d
    },
    g
  );
  return i ? /* @__PURE__ */ C(
    "a",
    {
      href: i,
      target: "_blank",
      rel: "noopener noreferrer",
      "aria-disabled": d,
      className: S,
      children: k
    }
  ) : u ? /* @__PURE__ */ C("button", { className: S, disabled: d, onClick: () => y(u), children: k }) : b ? /* @__PURE__ */ C("button", { className: S, disabled: d, onClick: b, children: k }) : /* @__PURE__ */ C(Yt, {});
}, EU = () => {
  const {
    state: { networkId: a },
    networksById: e,
    activeWallet: r,
    dispatch: i,
    wallet: u,
    setScreen: d
  } = Et(), g = e[a], b = [
    {
      title: "Account details",
      icon: /* @__PURE__ */ C(kU, {}),
      screen: "accountDetails"
    },
    {
      title: "Settings & security",
      icon: /* @__PURE__ */ C(wU, {}),
      screen: "menuMore"
    },
    {
      title: "View on Explorer",
      description: g.explorerUrl ? new URL(g.explorerUrl).hostname : void 0,
      icon: /* @__PURE__ */ C(vU, {}),
      link: g.explorerUrl && r != null && r.address ? `${g?.explorerUrl}/address/${r?.address}` : void 0,
      className: "mt-3"
    }
  ];
  return /* @__PURE__ */ Re("div", { className: "flex flex-col pt-10 pb-2 gap-3 min-h-full", children: [
    b.map((y, k) => /* @__PURE__ */ C(Uk, { ...y }, k)),
    /* @__PURE__ */ C("div", { className: "grow" }),
    /* @__PURE__ */ C(
      Dt,
      {
        variant: "ghost",
        className: "w-full",
        onClick: () => {
          i({ type: "reset" }), u?.setAccount({
            username: "",
            walletIndex: 0,
            contractAddress: "",
            strategy: "passkey",
            wallets: []
          }), d("main");
        },
        children: "Disconnect wallet"
      }
    )
  ] });
}, SU = () => {
  const { activeWallet: a, setScreen: e } = Et(), { text: r, onCopy: i } = Mk("", "+");
  return a ? /* @__PURE__ */ Re("div", { className: "pt-10", children: [
    /* @__PURE__ */ C(kI, { className: "mb-6 flex justify-center" }),
    /* @__PURE__ */ C("div", { className: "mb-6 text-center", children: /* @__PURE__ */ C(
      jP,
      {
        value: `ethereum:${a.address}`,
        size: 256,
        bgColor: "#F0F2DA",
        style: {
          height: "auto",
          maxWidth: "100%",
          width: "200px",
          margin: "0 auto",
          padding: "1rem",
          background: "#F0F2DA",
          borderRadius: "6px"
        },
        viewBox: "0 0 256 256"
      }
    ) }),
    /* @__PURE__ */ C("p", { className: "text-center text-xs text-lightgrey break-all mb-2", children: a.address }),
    /* @__PURE__ */ C("div", { className: "flex justify-center mb-6", children: /* @__PURE__ */ Re(
      "button",
      {
        className: "oaw-button-plain !inline-flex items-center gap-2 !text-yellow",
        onClick: () => i(a.address),
        children: [
          r === "+" ? /* @__PURE__ */ C(_k, {}) : /* @__PURE__ */ C(Fk, {}),
          /* @__PURE__ */ C("span", { className: "text-xs", children: "Copy address" })
        ]
      }
    ) }),
    /* @__PURE__ */ C(
      Dt,
      {
        variant: "ghost",
        className: "w-full",
        onClick: () => {
          e("exportPrivateKey");
        },
        children: "Export private key"
      }
    )
  ] }) : /* @__PURE__ */ C(Yt, {});
}, AU = () => /* @__PURE__ */ C("div", { className: "flex flex-col pt-10 gap-3 min-h-full", children: [
  // {
  //   title: 'General',
  //   screen: 'settingsGeneral' as const,
  // },
  {
    title: "Export private key",
    screen: "exportPrivateKey"
  },
  {
    title: "Import private key",
    screen: "importAccount"
  }
].map((a, e) => /* @__PURE__ */ C(Uk, { ...a }, e)) }), xU = ({
  text: a = "Hold to reveal",
  onComplete: e
}) => {
  const [r, i] = Ct(!1), [u, d] = Ct(0), g = 1500, b = 10, y = 24, k = 3, S = (y - k) / 2, A = S * 2 * Math.PI, x = A - u / 100 * A;
  return Ln(() => {
    let M;
    return r ? M = setInterval(() => {
      d((D) => {
        const O = D + b / g * 100;
        return O >= 100 ? (i(!1), setTimeout(() => e(), 10), 0) : O;
      });
    }, b) : d(0), () => {
      M && clearInterval(M);
    };
  }, [r, e]), /* @__PURE__ */ C(
    Dt,
    {
      variant: "primary",
      className: "w-full !inline-flex items-center justify-center gap-2.5",
      onMouseDown: () => i(!0),
      onMouseUp: () => i(!1),
      onMouseLeave: () => i(!1),
      onTouchStart: () => i(!0),
      onTouchEnd: () => i(!1),
      children: /* @__PURE__ */ Re("span", { className: "relative", children: [
        /* @__PURE__ */ Re(
          "svg",
          {
            width: y,
            height: y,
            className: bt("-rotate-90 absolute right-[calc(100%+10px)]", {
              invisible: !r
            }),
            children: [
              /* @__PURE__ */ C(
                "circle",
                {
                  cx: y / 2,
                  cy: y / 2,
                  r: S,
                  stroke: "#06080F",
                  strokeWidth: k - 1,
                  fill: "none"
                }
              ),
              /* @__PURE__ */ C(
                "circle",
                {
                  cx: y / 2,
                  cy: y / 2,
                  r: S,
                  stroke: "#F0F2DA",
                  strokeWidth: k,
                  fill: "none",
                  style: {
                    strokeDasharray: A,
                    strokeDashoffset: x,
                    transition: "stroke-dashoffset 10ms linear"
                  }
                }
              )
            ]
          }
        ),
        a
      ] })
    }
  );
}, CU = () => {
  const { state: a, dispatch: e, wallet: r, goScreenBack: i, activeWallet: u } = Et(), { text: d, onCopy: g } = Mk("", "+"), [b, y] = Ct(!1), [k, S] = Ct(!1);
  if (!(u != null && u.address))
    return /* @__PURE__ */ C(Yt, {});
  const A = !!a.privateKeys[u.address];
  return /* @__PURE__ */ Re("div", { className: "pt-10 pb-2 min-h-full flex flex-col", children: [
    /* @__PURE__ */ C(wI, { noChevron: !0, className: "mb-6" }),
    !A && /* @__PURE__ */ Re(Yt, { children: [
      /* @__PURE__ */ C(
        gI,
        {
          text: "Warning: Your private key protects your assets. Never share it to keep your account secure and prevent unauthorized access.",
          className: "mb-6"
        }
      ),
      /* @__PURE__ */ Re("div", { className: "grid grid-cols-2 gap-2", children: [
        /* @__PURE__ */ C(Dt, { variant: "ghost", onClick: () => i(), children: "Cancel" }),
        /* @__PURE__ */ C(
          Dt,
          {
            variant: "primary",
            loading: b,
            onClick: async () => {
              if (b)
                return;
              y(!0);
              const x = await r?.getAccountPrivateKey({
                strategy: "passkey",
                walletIndex: u.index
              });
              e({
                type: "setValue",
                payload: {
                  key: "privateKeys",
                  value: { ...a.privateKeys, [u.address]: x }
                }
              }), y(!1);
            },
            children: "Confirm"
          }
        )
      ] })
    ] }),
    !!A && /* @__PURE__ */ Re(Yt, { children: [
      /* @__PURE__ */ Re("div", { className: "text-sm text-center mb-6", children: [
        /* @__PURE__ */ C("p", { className: "font-bold mb-6", children: "Your private key provides full access to your wallet and funds." }),
        /* @__PURE__ */ C("p", { children: "Do not share this with anyone. Apillon Support will never request this, but phishers might." })
      ] }),
      !k && /* @__PURE__ */ C(
        xU,
        {
          text: "Hold to reveal private key",
          onComplete: () => S(!0)
        }
      ),
      !!k && /* @__PURE__ */ Re(
        "div",
        {
          className: bt(
            "flex flex-col items-center gap-2 text-center mb-6",
            "bg-deepdark p-4 rounded-md"
          ),
          children: [
            /* @__PURE__ */ C("p", { className: "text-xs text-offwhite font-bold", children: "Your private key" }),
            /* @__PURE__ */ C("p", { className: "text-xs text-lightgrey break-all", children: a.privateKeys[u.address] }),
            /* @__PURE__ */ C("div", { className: "flex justify-center", children: /* @__PURE__ */ Re(
              "button",
              {
                className: "oaw-button-plain !inline-flex items-center gap-2 !text-yellow",
                onClick: () => g(a.privateKeys[u.address]),
                children: [
                  d === "+" ? /* @__PURE__ */ C(_k, {}) : /* @__PURE__ */ C(Fk, {}),
                  /* @__PURE__ */ C("span", { className: "text-xs", children: "Copy key" })
                ]
              }
            ) })
          ]
        }
      ),
      /* @__PURE__ */ C("div", { className: "grow" }),
      !!k && /* @__PURE__ */ C(Dt, { variant: "ghost", className: "w-full", onClick: () => i(), children: "Done" })
    ] })
  ] });
};
function TU({
  label: a,
  options: e,
  style: r,
  className: i,
  ...u
}) {
  return /* @__PURE__ */ Re(hE, { children: [
    !!a && /* @__PURE__ */ C(pE, { className: "text-xs leading-relaxed font-bold mb-2 block", children: a }),
    /* @__PURE__ */ C(
      GP,
      {
        "aria-label": a,
        ...u,
        className: bt(
          "py-3 pl-5 pr-11",
          "bg-lightdark text-sm text-offwhite leading-relaxed",
          "rounded-lg border border-solid border-brightdark",
          i
        ),
        style: {
          appearance: "none",
          backgroundImage: `url('data:image/svg+xml;utf-8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 16L6 10H18L12 16Z" fill="%23F0F2DA"/></svg>')`,
          backgroundRepeat: "no-repeat",
          backgroundPosition: "calc(100% - 0.75rem) center",
          ...r
        },
        children: e.map((d) => /* @__PURE__ */ C("option", { value: d.value, disabled: !d.value, children: d.label }, d.value))
      }
    )
  ] });
}
function IU() {
  const {
    state: { accountWallets: a },
    wallet: e,
    goScreenBack: r,
    handleError: i,
    handleSuccess: u,
    saveAccountTitle: d
  } = Et(), [g, b] = Ct("pk"), [y, k] = Ct(""), [S, A] = Ct(""), [x, M] = Ct(!1), [D, O] = Ct(!1);
  async function T() {
    if (!(x || !S || !y)) {
      M(!0), i();
      try {
        await e?.addAccountWallet({
          privateKey: S.startsWith("0x") ? S : `0x${S}`
          // walletType??
        }), d(y, a[a.length - 1].index + 1), O(!0), u("Account imported. Wait for transaction to complete."), k(""), A("");
      } catch (L) {
        i(L);
      }
      M(!1);
    }
  }
  return /* @__PURE__ */ Re("div", { className: "pt-10 pb-2 min-h-full flex flex-col", children: [
    /* @__PURE__ */ C("p", { className: "text-sm font-normal mb-6 text-center", children: "Import your private key from an existing account" }),
    /* @__PURE__ */ C(
      TU,
      {
        value: g,
        options: [
          { label: "Select type", value: "" },
          { label: "Private Key", value: "pk" }
          // { label: 'JSON File', value: 'json' },
        ],
        className: "w-full mb-6",
        onChange: (L) => b(L.target.value)
      }
    ),
    /* @__PURE__ */ C(
      Tg,
      {
        value: S,
        placeholder: "Enter your private key string here",
        type: "password",
        className: "mb-6",
        onChange: (L) => A(L.target.value)
      }
    ),
    /* @__PURE__ */ C(
      Tg,
      {
        value: y,
        placeholder: "Enter name (for personal reference)",
        className: "mb-6",
        onChange: (L) => k(L.target.value)
      }
    ),
    /* @__PURE__ */ Re("div", { className: "grid grid-cols-2 gap-2", children: [
      /* @__PURE__ */ C(Dt, { variant: "ghost", onClick: () => r(), children: "Cancel" }),
      /* @__PURE__ */ C(Dt, { variant: "primary", loading: x, onClick: () => T(), children: "Import" })
    ] }),
    /* @__PURE__ */ C("div", { className: "grow" }),
    !!D && /* @__PURE__ */ C(Dt, { variant: "ghost", onClick: () => r(), children: "Done" })
  ] });
}
const NU = () => /* @__PURE__ */ C("div", { className: "pt-10", children: "General" }), PU = ({
  token: a,
  label: e,
  className: r,
  disabled: i,
  ...u
}) => {
  const { setScreen: d } = Et(), g = Rn(null), b = Rn(null), [y, k] = Ct(!1);
  return YE(g, () => k(!1)), /* @__PURE__ */ Re(hE, { children: [
    !!e && /* @__PURE__ */ C(pE, { className: "text-xs leading-relaxed font-bold mb-2 block", children: e }),
    /* @__PURE__ */ Re(
      "div",
      {
        ref: g,
        className: bt(
          "w-full px-5 py-3 text-sm cursor-text",
          "flex flex-col justify-end",
          "rounded-lg border border-brightdark",
          "!outline-none bg-lightdark",
          {
            "hover:border-lightgrey": !i,
            "!border-offwhite": y && !i
          },
          r
        ),
        onClick: () => {
          var S;
          return (S = b.current) == null ? void 0 : S.focus();
        },
        children: [
          /* @__PURE__ */ C(
            gE,
            {
              ref: b,
              type: "number",
              step: "0.01",
              ...u,
              disabled: i,
              autoComplete: "off",
              className: bt(
                "placeholder:text-lightgrey !outline-none text-offwhite text-right rounded-none"
              ),
              onFocus: () => k(!0)
            }
          ),
          /* @__PURE__ */ C("div", { className: "text-right", children: /* @__PURE__ */ C(
            "button",
            {
              type: "button",
              className: "oaw-button-plain !font-bold !text-offwhite",
              onClick: (S) => {
                S.stopPropagation(), d("selectToken");
              },
              children: a.symbol
            }
          ) })
        ]
      }
    )
  ] });
}, OU = () => {
  const { state: a, goScreenBack: e, wallet: r, handleError: i } = Et(), { selectedToken: u } = o1(), [d, g] = Ct(""), [b, y] = Ct(""), [k, S] = Ct(!1);
  async function A() {
    if (!k) {
      try {
        if (!d || !b)
          throw new Error("Address and amount are required");
        if (!r)
          throw new Error("Wallet not initialized");
        if (S(!0), i(), u.address) {
          const x = "Transfer ERC20 token", M = await r.signContractWrite({
            mustConfirm: !0,
            contractAbi: my,
            contractAddress: u.address,
            contractFunctionName: "transfer",
            contractFunctionValues: [
              d,
              Pv.parseUnits(b, u.decimals)
            ],
            label: x
          });
          return !a.appProps.broadcastAfterSign && M ? await r.broadcastTransaction(M.signedTxData, M.chainId, x) : M;
        } else {
          const x = "Transfer native token", M = await r.signPlainTransaction({
            mustConfirm: !0,
            strategy: "passkey",
            tx: {
              to: d,
              data: "0x",
              gasLimit: 1e6,
              value: Pv.parseEther(b)
            },
            label: x
          });
          return !a.appProps.broadcastAfterSign && M ? await r.broadcastTransaction(M.signedTxData, M.chainId, x) : M;
        }
      } catch (x) {
        i(x, "onTokensTransfer");
      }
      S(!1);
    }
  }
  return /* @__PURE__ */ Re(
    "form",
    {
      className: "pt-10",
      onSubmit: (x) => {
        x.preventDefault(), A();
      },
      children: [
        /* @__PURE__ */ C(
          Tg,
          {
            label: "Wallet",
            placeholder: "Paste wallet here",
            value: d,
            className: "w-full mb-4",
            onChange: (x) => g(x.target.value)
          }
        ),
        /* @__PURE__ */ C(
          PU,
          {
            value: b,
            token: u,
            label: "Amount",
            placeholder: "0",
            className: "w-full mb-4",
            onChange: (x) => y(x.target.value)
          }
        ),
        /* @__PURE__ */ C(
          Uk,
          {
            title: u.name,
            description: `Balance: ${u.balance} ${u.symbol}`,
            screen: "selectToken",
            className: "w-full mb-6"
          }
        ),
        /* @__PURE__ */ Re("div", { className: "grid grid-cols-2 gap-2", children: [
          /* @__PURE__ */ C(Dt, { variant: "ghost", type: "button", onClick: () => e(), children: "Cancel" }),
          /* @__PURE__ */ C(Dt, { type: "submit", loading: k, children: "Send" })
        ] })
      ]
    }
  );
}, RU = () => {
  const { state: a, setScreen: e, goScreenBack: r } = Et(), { state: i, dispatch: u, nativeToken: d } = o1(), g = Kl(() => {
    var b;
    return Array.isArray((b = i.list[a.contractAddress || ""]) == null ? void 0 : b[a.networkId]) ? [d, ...i.list[a.contractAddress || ""][a.networkId]] : [d];
  }, [i.list, a.networkId, a.contractAddress]);
  return /* @__PURE__ */ Re("div", { className: "pt-10 pb-2 min-h-full flex flex-col", children: [
    /* @__PURE__ */ C("div", { className: "flex flex-col gap-3 mb-6", children: g.map((b) => /* @__PURE__ */ C(
      Uk,
      {
        disabled: b.address === i.selectedToken,
        title: `Token: ${b.name}`,
        description: `Balance: ${b.balance} ${b.symbol}`,
        className: "w-full text-left",
        onClick: () => {
          u({
            type: "setValue",
            payload: { key: "selectedToken", value: b.address }
          }), r();
        }
      },
      b.address
    )) }),
    /* @__PURE__ */ C("div", { className: "grow" }),
    /* @__PURE__ */ C(Dt, { variant: "ghost", className: "w-full", onClick: () => e("addToken"), children: "Add token" })
  ] });
}, LU = () => {
  const {
    state: { networkId: a, contractAddress: e },
    handleError: r,
    goScreenBack: i
  } = Et(), { dispatch: u, getTokenDetails: d } = o1(), [g, b] = Ct(""), [y, k] = Ct(!1);
  return /* @__PURE__ */ C("div", { className: "pt-10", children: /* @__PURE__ */ Re(
    "form",
    {
      className: "mb-8",
      onSubmit: async (S) => {
        if (S.preventDefault(), !y) {
          if (!g) {
            console.error("No address");
            return;
          }
          k(!0), r();
          try {
            const A = await d(g);
            if (!A)
              throw new Error("Could not get token details");
            if (!e)
              throw new Error("Could not get user wallet address");
            u({
              type: "updateToken",
              payload: { owner: e, chainId: a, token: A }
            }), i();
          } catch (A) {
            r(A, "onTokensAdd");
          }
          k(!1);
        }
      },
      children: [
        /* @__PURE__ */ C(
          Tg,
          {
            placeholder: "Address of token to add",
            value: g,
            className: "w-full mb-6",
            onChange: (S) => b(S.target.value)
          }
        ),
        /* @__PURE__ */ C(Dt, { type: "submit", loading: y, className: "w-full", children: "Add" })
      ]
    }
  ) });
}, DU = () => {
  const {
    wallet: a,
    state: { accountWallets: e, walletIndex: r, isAccountWalletsStale: i, loadingWallets: u },
    dispatch: d,
    setScreen: g,
    reloadAccountBalances: b,
    goScreenBack: y,
    loadAccountWallets: k
  } = Et(), { selectedToken: S, currentExchangeRate: A } = o1(), [x, M] = Ct("");
  return Ln(() => {
    b(e.map((D) => D.address));
  }, []), /* @__PURE__ */ Re("div", { className: "pb-2 min-h-full flex flex-col", children: [
    !!i && /* @__PURE__ */ C(qE, { text: "stale", className: "mt-6" }),
    /* @__PURE__ */ C(bI, { value: x, onChange: (D) => M(D), className: "my-6" }),
    /* @__PURE__ */ C("div", { className: "flex flex-col gap-3 mb-6", children: e.filter((D) => D.title.toLowerCase().includes(x.toLowerCase())).map((D) => /* @__PURE__ */ Re(
      "button",
      {
        className: bt(
          "oaw-button-plain !bg-primarylight !px-3 !py-2 !rounded-md",
          "!border !border-solid border-brightdark hover:border-lightgrey !transition-colors",
          "!flex justify-between items-center",
          {
            "!border-yellow": D.index === r
          }
        ),
        onClick: () => {
          D.index !== r && (a?.setAccount({ walletIndex: D.index }), d({ type: "setValue", payload: { key: "walletIndex", value: D.index } }), y());
        },
        children: [
          /* @__PURE__ */ Re("div", { className: "text-left", children: [
            /* @__PURE__ */ C("p", { className: "text-sm font-bold text-offwhite mb-1.5", children: D.title }),
            /* @__PURE__ */ C("p", { title: D.address, className: "text-xs text-lightgrey", children: nI(D.address) })
          ] }),
          /* @__PURE__ */ Re("div", { className: "text-xs text-offwhite text-right", children: [
            /* @__PURE__ */ C("p", { children: A ? `$${Yv(+D.balance * A, "", 2)}` : /* @__PURE__ */ C(Yt, { children: " " }) }),
            /* @__PURE__ */ C("p", { children: Yv(D.balance, S.symbol) })
          ] })
        ]
      },
      D.address
    )) }),
    /* @__PURE__ */ C("div", { className: "grow" }),
    /* @__PURE__ */ C(Dt, { variant: "primary", className: "w-full mb-2", onClick: () => g("addAccount"), children: "Add new account" }),
    /* @__PURE__ */ C(Dt, { variant: "ghost", className: "w-full mb-2", onClick: () => g("importAccount"), children: "Import private key into new account" }),
    /* @__PURE__ */ C(
      Dt,
      {
        variant: "ghost",
        loading: u,
        className: "w-full",
        onClick: () => k(),
        children: "Reload accounts"
      }
    )
  ] });
}, BU = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_2738_1423)'%3e%3cpath%20d='M10%2020C15.5228%2020%2020%2015.5228%2020%2010C20%204.47715%2015.5228%200%2010%200C4.47715%200%200%204.47715%200%2010C0%2015.5228%204.47715%2020%2010%2020Z'%20fill='%23627EEA'/%3e%3cpath%20d='M9.99861%204.66663L9.92578%204.90973V11.9634L9.99861%2012.0348L13.3311%2010.0994L9.99861%204.66663Z'%20fill='%23C0CBF6'/%3e%3cpath%20d='M9.99963%204.66663L6.66699%2010.0994L9.99963%2012.0348V8.61116V4.66663Z'%20fill='white'/%3e%3cpath%20d='M9.99907%2012.6538L9.95801%2012.7029V15.2156L9.99907%2015.3333L13.3336%2010.7194L9.99907%2012.6538Z'%20fill='%23C0CBF6'/%3e%3cpath%20d='M9.99963%2015.3333V12.6538L6.66699%2010.7194L9.99963%2015.3333Z'%20fill='white'/%3e%3cpath%20d='M9.99902%2012.0387L13.3316%2010.1033L9.99902%208.61499V12.0387Z'%20fill='%238197EE'/%3e%3cpath%20d='M6.66699%2010.1033L9.99963%2012.0387V8.61499L6.66699%2010.1033Z'%20fill='%23C0CBF6'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_2738_1423'%3e%3crect%20width='20'%20height='20'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e", MU = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAqBQTFRF5gB6AAAA/v7+5gJ75gF65gB65gB65gR8/v3+/v395gB65gB6/vz95gB6/fL45gB6/vr85w2B+c3l/vn76BiH5gB66RuI5gB65gB69JnJ6BWF5wyA/fj76BOE5wh+6BeG/e/25gB65gV972Cs+tbp5gB65gB65wZ96SOM5gB69JTH5gB68XW36ieO5gB6843D+tLn6SGL5gB65gB65gB6/Ov0/ff6+MHe97HW5gB68Giw+tPo5gB65gB65gB65w+C/fX56zKU7Uig8XK15gB65gB65gB69ZvL7EKc/Ojy9q7V++Tw5gB66BGD5wl//fD35gB65gB6++Lv5gB69qzT5gB65gB65gB65gB65gB66R+K5gB6/Obx5gB65gB68oC98Gav6iaO5gB684bA5gB65gB65gB6+crj9JPG6R2J5gB65gB65gB6++Dv6zqY5gB65gB66i+S5gB6+cfh5gB65gB6716r5gB67ECb5gB6+9/u5gB65gB65gB65wp/5gB65gB66ziY6imP+93t5gB65gB68Gqx5gB65gB65gB65gB69JfI/O315gB65gB65gB65gB65gB6+s/m5gB65gB65gB65gB68G6z5gB65gB67ESd5gB65gB65gB65gB69JDF7lmo+L/d9qrS+Lzc5gB65gB68n675gB67Uae5gB66zWW7D6a+9rr5gB6/fb672Ou5gB67lOl84nB5gB68nu65gB68He49aHO+MLf5gB67DyZ5gB65gB66iyR8nm59qfR5gB6+MXg5gB67lWm84vC9aDN5gB65gB69qPP97XY7EGc9Z7M97ja72Gt+tjq7Uqh8oO+9qTP6zOV7k+j5gB671up7lGl7Uyi8Gyy84W/9tHl5gB697LX5gB6+vH25gB6Ha4khgAAAOB0Uk5T/wD///8C/v///wH9//r/Cv//////7f8P8P//////////Fv////X4///3/wT//83////FCb3/////Uv//1yrj///////Akoz//////8v////nMv/S/7I+yEO4/57/DfP///9G/9AtW////zryBv//Sxr/ff8mEv+P/zf/H+yB/wf5////d7D/2iKbTv//FITg1DT/VKTlJ/9ol/9Y3XOr//////+5Gf8c/0D///+7//+H//+i/8P///9l/6GA////6v+K////ba3///////////////+2////////Xv9q/2NWohVoAAAKmklEQVR4nOVb90MUxx6fPe644+hdAQVUiqBSVBBRsYCKICWKgooiiiiCXewRG3aNXbF3E2usscUaWxJjTExe8b33r7w97jh2dz6zO3tc3i/vw0/sfstnZ+a+35nvzBDBBfjXzFrz8Oq4A3ObiIj4Tgdmnnv46Ojgvq7YIvrEreErDm+dGOpNALxD048cLq20/nUETAuy8mb6It/t6Nln5LZYPRz4Cezc9rqTp7p3OzxD989f6m4CpprJJVzeHb1x4MhBkxsJ+M+qiOP3bsfUsiyuQclBoO/RdI2Ox4jPzVrrBgKmbX1c8W5HerXmeNQisKdQR9fT8L5T0yECq/LiO+LehrjnC1wmkLxvUEfd2zBuvtoPQoXAzq0ujT0avsvCXSEw4Sv3uLehzwrdBEzHO7nPPyGrD7O6gUHAf6Sbmr8N8WsYMQETiN3kXvc27Mf5ARLY4sbub0fheV4Cpcf+Cv+EDBrMR2DPbk6DXaPXr1t++WPiWHMHGNAESrn8G0O+7ZwdE+xjsfhk9K+dMbyL0UUGFIEtPO2f0DIgxmKQwKv/+JauPAyocaAkEMsx/hJOLY4yUAgOai7S1i1UBkUFAX+O39/0McC9DQFj5mhr31qrRsA0UtvCui+wextSe2vrPzKpEDiuHf/S8tn+DYbsQE0D8ffZBL7miP/j1fwbDLO1LTwtZRHYyTEAc/zUCfT/UtuGbCBKCCRv1dYlw9T9GwzDOIyMNEEC+3gS4DotAu84jDRVIwKruOZfc3zU/VvW81jpcx4QyOPRJB7Z6gS+SOCx4rmLJrCHOf8N/HZU7eLtlz3s/zWqNoHlkF3K/C5lwPhpD7qxbMYdVBIwsZYf5l5T7KZ/Smv939hZjcAPdpppp+3/9hjISpT9rAoC2xjrj8ffOZNOapi9QU4Gs9wHz85pFelS62yR2nU4TXp/LSfQFzeAx28F9OclVDVg/w0DHQPgpiRT7riO+6FfvYzALOx/xFCpA780x/OIlCm0+ykpEY7XXWRvg1MgA8/5UgL+6dD/BUVjn3K+ivh0utir/YVX8elPEc6Xo71kWj6z4UA4Vy8hMAvFII9DyrQ7Q/LWHPau+eabz2fPDnhzs3l5mNTHCIVaQC8PYL7n/HYCpnOI4iUq7I9SihjNCQlmapSdVOr5jUb2T1idBGpQ/SPtCtXNnZEdGqMoxdQQINZpi5PAZGQG5N0PfASSaM3tSG5ZG4GdJeDtbwG0mSo+At/TmkO/AXLHKh0EUBAyL6atWC7xEXhBqxo+g3jUGoxEAiY0Eb3sRRvJmM5HYCFovACUJbdaWwksABMx4xnwFSsj+QgEFgDlJCBYsrSVQBbogUnXgI0xfP6JcQxQ9gujBb3LbQSsaCLwMzDh1Z2TAHmBUvZ1ILjLRiB8JnjzBljI78JLIHADUB8PBHP7igRWgDAc+B5YoOIgGx+AekMELTd1sEjgX8DARzD53oF+ygykraT1ry0HgrNEAmgyfgp04iiUUVi4QOvDITRSJDARPAexLCZRh38yFoyCXkDuqkD80XJsGqVt+VmPfzGV0m14G4gNSSY1aDKozOhiDOAtwzjgQadE1AK+FwmcjDUqA3EQyqeqGPuMZwyQarIGPX4wVK7cg2u9I8f0HnIbQx8gqePkIXocmSr//kn6/ROSKF9EpcJMkkf6QeXbEs2AMSCE8CBkgDQt3oUyJ8g4+Dy6PRTGzOBY8mMUfdjhHExBOJDnkgNYt7fjh+wVxFjacMG4/Nm/o8RVildwEKN+9RWZy9CNuJAd4zfl7R8cpTc1FF1KypyS/4+7rNrRAdLE1O0aHZajJ/yyYM4JY89kQt3goENgdcD/DFP/7wnMJczKjDEyLKSoAz9Bp50vw8LYkSSUsIqjISkbimPeJ81jlnn4UDT8hyt+flemseaTQ8Q/iPWOknTA4hadiVgKj1+yHfOCK2lYYhxBc2IxDLWnsmu/ghk9HwKT2rNq0FgokktgaYDclWQRS9Bj1/xHv5VOi9B8xJaM4NJckY7zeQrAFCbtlRnBlfxl5BF6PDpDpmso0DElb0NvxYQkowVJvSJH0ePrFrmyITVar/+IWoUJSxUSKyeD0aEkelL6q860ZH5CmfgeiDWdJ31Xg+e9KG2f4foInKLrC9OA2G4TEVCJkCZg2IB/RgxM6k8ZsDQDud/FldER8LxKOQZEXNDh32M7rR+M2vCGSOA+eH4J7Aw26FibDaMbwJCP9I+KBEp70s9D0N7gS34CqKRfC7LK3IMigcpCYAFtzhVwj4IuaG8Rbej1sxUoBLRb2ggseA3kJdAdlNgMfwDBRa1FqvlgeRodA0yc5YwFxgFAuRisbmyFQpFALIoEKcBGf84VUiQaQajOPCS8lYB1P3g3HezL+MzjI9A7A+h+BIJ59kKlUA2iMaz1cRYphgPVTNB9vnWOWnE4mhUNA3UqFEwBBtKaUSgVbvZvK9ejYEhm02Zg0Z3G32nNe0hul3O/YAmanUfvpcxwbljQYSgbzepWL2jfsilDdi5TnTBDKeKR0LVrN6p3KQLFqERIbrVv2QhZaHVgHKEsu1dJ3iYk/tkr6cxPmZlvn5w81DJJOnVW1tiiqtDyIq5csmtWD+sk5hQ5Ax9nlcc4pzlIWkay+D1rDHF6UWxYRN2GAWyTSbpxmYVEiHmGLCsW5Dieh3TeQXWzIX92WyVtTrH0ud/foH/PctnO6dpcyKBboySvWhxDoNt1xjmagmb7WSZZjbBhOA7gZcnyzetyeF6dGIdlKqs8gS8Zx4jEZVSSvY1CgtqeeJ1lHOzxbTtj2UbAiptA/JzGIDuF7+w7Rurb9/fsnzvns31K1XCIlb/KBAUBYTDz8LZ54Ygfz6S0OOYTA1Gqbe+mEQ7a805mZib9yVwVh66iCAg3uE4wJ6DNEAkKeI60Ee+NAk1gAdcR7vWqDSBiIY+VO0sBAaG6iUN1tIZ/A8/6oWedgAjwnGQj32gRgCVpOTw3WiEBIRxNTxWIBCFIiuIcbRv9/AVMQCh9qq0NlhxS/KhtYchBgUVA+A9YIyiQ00PN/3vtqXvcPoFNwLpI+wOm0/MEJ/ZyHGh8JagQEOphwUSOsCeMg0RR97Q3djyXJasSECrRLp4CCVU9wL6iz95GjnqabAAiAkIsLpvJEdj9mWJXKWPxJ57N/YnUTQP6YPMSvIeigDntxcvTK2OuBQcEZMRcOVPVm6uamL6KcgeOdh/kYiDCIzI68fHCx4nRvBXd9Iu0N3S4fQlPL7iAifT3M473x8KTXR2E51V40wRfcKjkOd+qE8uU41+NgFC/UTsm6sLUV8nYE+uSi/Wf6HSTy9i9j+FH5ZpPzZ0OXfKSwvPqEqYblYtOlWvc1A1xG3H3axEQTBMmuqERvHNXqF25U7/sFruow9edVh9Xv/6pdd1vSwVesXDC9zUIfroICELd7y73g/frPZrmOa58JpeX6b5xasPcExM4Lr5yXXpNrt6ve5P56WQe99zXfq0Xd23Wcf3Nd9CiWD7DOi4++9flDeEakN67n+/hv4au5+q3NXzCogr129eeoRUb6yp12NR7+V1Yu2TfrrJjcMO55+ZNa7K21Os0qJdAK0yxEw4/31/RZ3NJqIiSzYUVt27cr9vJedlbjv8CTKPQ2jKwhAUAAAAASUVORK5CYII=", FU = [
  {
    type: tu.EVM,
    title: "EVM",
    description: "Ethereum, Arbitrum, Moonbeam etc",
    icon: BU
  },
  {
    type: tu.SUBSTRATE,
    title: "Substrate",
    description: "Polkadot, Kusama, Parachains",
    icon: MU,
    disabled: !0
  }
];
function _U() {
  const {
    state: { accountWallets: a, stagedWalletsCount: e },
    wallet: r,
    handleError: i,
    goScreenBack: u,
    handleSuccess: d,
    saveAccountTitle: g,
    setStateValue: b
  } = Et(), [y, k] = Ct(tu.EVM), [S, A] = Ct(""), [x, M] = Ct(!1);
  async function D() {
    if (!(x || !S)) {
      M(!0);
      try {
        await r?.addAccountWallet({ walletType: y }), g(
          S,
          a[a.length - 1].index + 1 + e
        ), b("stagedWalletsCount", e + 1), d("Account created. Wait for transaction to complete."), u();
      } catch (O) {
        i(O);
      }
      M(!1);
    }
  }
  return /* @__PURE__ */ C("div", { className: "pt-6", children: /* @__PURE__ */ Re(
    "form",
    {
      onSubmit: (O) => {
        O.preventDefault(), D();
      },
      children: [
        /* @__PURE__ */ C("p", { className: "mb-3 font-bold text-sm", children: "Select type" }),
        /* @__PURE__ */ C("div", { className: "flex flex-col gap-3 mb-6", children: FU.map((O) => /* @__PURE__ */ Re(
          "button",
          {
            type: "button",
            className: bt(
              "oaw-button-plain !bg-primarylight !px-3 !py-2 !rounded-md relative",
              "!border !border-solid border-brightdark hover:border-lightgrey !transition-colors",
              "!flex items-center gap-3",
              {
                "!border-yellow": y === O.type,
                "pointer-events-none": O.disabled
              }
            ),
            onClick: () => k(O.type),
            children: [
              !!O.disabled && /* @__PURE__ */ C("span", { className: "absolute inset-0 bg-primarylight/60", children: /* @__PURE__ */ C(vI, { text: "Coming soon", className: "absolute top-2 right-2" }) }),
              /* @__PURE__ */ C("img", { src: O.icon, alt: O.title, className: "w-10 h-10" }),
              /* @__PURE__ */ Re("div", { className: "text-left", children: [
                /* @__PURE__ */ C("p", { className: "text-sm font-bold text-offwhite mb-1", children: O.title }),
                /* @__PURE__ */ C("p", { className: "text-xs text-lightgrey", children: O.description })
              ] })
            ]
          },
          O.type
        )) }),
        /* @__PURE__ */ C(
          Tg,
          {
            label: "Account name",
            placeholder: "Enter name (for personal reference)",
            value: S,
            className: "w-full mb-6",
            onChange: (O) => A(O.target.value)
          }
        ),
        /* @__PURE__ */ C(Dt, { type: "submit", loading: x, className: "w-full", children: "Create account" })
      ]
    }
  ) });
}
const UU = ({ text: a, className: e }) => {
  const { state: r, handleSuccess: i } = Et();
  return !a && !r.displayedSuccess ? /* @__PURE__ */ C(Yt, {}) : /* @__PURE__ */ C(
    ck,
    {
      text: a || r.displayedSuccess,
      before: /* @__PURE__ */ C(yI, { className: "shrink-0" }),
      className: e,
      onDismiss: () => i("", 0)
    }
  );
}, zU = () => {
  const {
    state: { walletScreen: a }
  } = Et(), { state: e } = Hc();
  function r() {
    if (e.successInfo)
      return /* @__PURE__ */ C(J_, {});
    if (e.targetChain || e.txToConfirm || e.messageToSign || e.contractFunctionData)
      return /* @__PURE__ */ C(K_, {});
    switch (a) {
      case "approve":
        return /* @__PURE__ */ C(Yt, {});
      case "networks":
        return /* @__PURE__ */ C(eU, {});
      case "menuDot":
        return /* @__PURE__ */ C(EU, {});
      case "menuMore":
        return /* @__PURE__ */ C(AU, {});
      case "settingsGeneral":
        return /* @__PURE__ */ C(NU, {});
      case "accountDetails":
        return /* @__PURE__ */ C(SU, {});
      case "exportPrivateKey":
        return /* @__PURE__ */ C(CU, {});
      case "importAccount":
        return /* @__PURE__ */ C(IU, {});
      case "selectToken":
      case "sendToken":
      case "addToken":
        return /* @__PURE__ */ C(Yt, { children: (() => {
          switch (a) {
            case "sendToken":
              return /* @__PURE__ */ C(OU, {});
            case "addToken":
              return /* @__PURE__ */ C(LU, {});
            case "selectToken":
            default:
              return /* @__PURE__ */ C(RU, {});
          }
        })() });
      case "selectAccounts":
        return /* @__PURE__ */ C(DU, {});
      case "addAccount":
        return /* @__PURE__ */ C(_U, {});
      default:
        return /* @__PURE__ */ C(lU, {});
    }
  }
  return /* @__PURE__ */ Re("div", { className: "h-[635px] flex flex-col relative", children: [
    /* @__PURE__ */ C(bU, {}),
    /* @__PURE__ */ C("div", { className: "px-8 pb-4 grow overflow-y-auto", children: r() }),
    /* @__PURE__ */ Re("div", { className: "absolute z-10 -bottom-8 left-0 right-0 px-8 flex flex-col gap-2", children: [
      /* @__PURE__ */ C(UU, {}),
      /* @__PURE__ */ C(qE, {}),
      /* @__PURE__ */ C(fI, { show: !0 })
    ] })
  ] });
}, HU = () => {
  const { loadAccountWallets: a, state: e, dispatch: r, setScreen: i, wallet: u } = Et();
  return /* @__PURE__ */ Re("div", { className: "p-8 sm:p-12", children: [
    /* @__PURE__ */ C(
      a1,
      {
        title: "Accounts unavailable",
        description: "Please authenticate again to load your accounts.",
        header: /* @__PURE__ */ C(cw, { size: 56 })
      }
    ),
    /* @__PURE__ */ C(
      Dt,
      {
        variant: "primary",
        disabled: e.loadingWallets,
        className: "w-full mb-3",
        onClick: async () => {
          const d = await a();
          (!d || !d.length) && (r({ type: "reset" }), u?.setAccount({
            username: "",
            walletIndex: 0,
            contractAddress: "",
            strategy: "passkey",
            wallets: []
          }), i("main"));
        },
        children: "Authenticate"
      }
    ),
    /* @__PURE__ */ C(
      Dt,
      {
        variant: "ghost",
        disabled: e.loadingWallets,
        className: "w-full",
        onClick: () => {
          r({ type: "reset" }), u?.setAccount({
            username: "",
            walletIndex: 0,
            contractAddress: "",
            strategy: "passkey",
            wallets: []
          }), i("main");
        },
        children: "Cancel"
      }
    )
  ] });
};
function VU({ disableDefaultActivatorStyle: a = !1 }) {
  const {
    state: e,
    wallet: r,
    initialized: i,
    loadAccountWallets: u,
    reloadAccountBalances: d,
    dispatch: g,
    defaultNetworkId: b,
    setStateValue: y
  } = Et(), { state: k, dispatch: S } = Hc(), A = !!e.username;
  Ln(() => {
    const M = (O) => {
      y("isOpen", O);
    }, D = (O) => {
      O.name === "defaultNetworkId" ? (d(), y("networkId", O.newValue)) : O.name === "contractAddress" && y("contractAddress", O.newValue);
    };
    return r && i && (r.events.on("open", M), r.events.on("dataUpdated", D), setTimeout(() => {
      if (window.location.search) {
        const O = new URLSearchParams(window.location.search);
        if (O.has("username") && O.get("username")) {
          const T = {
            username: O.get("username") || "",
            authStrategy: O.get("authStrategy") || "passkey",
            networkId: b || void 0
          };
          g({
            type: "setState",
            payload: T
          }), setTimeout(() => {
            u(T.authStrategy, T.username);
            const L = new URL(window.location.href);
            L.searchParams.delete("username"), L.searchParams.delete("authStrategy"), window.history.replaceState(null, "", L.toString());
          }, 50);
        } else {
          const T = new URL(window.location.href);
          T.searchParams.delete("username"), T.searchParams.delete("authStrategy"), window.history.replaceState(null, "", T.toString());
        }
      }
    }, 200)), () => {
      r && (r.events.off("open", M), r.events.off("dataUpdated", D));
    };
  }, [r, d, i]), Ln(() => {
    e.isOpen ? (y("walletScreenHistory", ["main"]), d()) : (setTimeout(() => {
      var M, D, O, T, L, U, W, Z, J;
      ((M = k.targetChain) == null ? void 0 : M.chainId) !== e.networkId && (D = k.targetChain) != null && D.resolve && k.targetChain.resolve(!1), (O = k.successInfo) != null && O.title || ((L = (T = k.approveParams) == null ? void 0 : T.contractWrite) != null && L.reject ? k.approveParams.contractWrite.reject(new Dy()) : (W = (U = k.approveParams) == null ? void 0 : U.plain) != null && W.reject ? k.approveParams.plain.reject(new Dy()) : (J = (Z = k.approveParams) == null ? void 0 : Z.signature) != null && J.reject && k.approveParams.signature.reject(new Dy())), S({ type: "reset" }), y("displayedError", ""), y("walletScreen", "main"), y("walletScreenHistory", []);
    }, dI), r && r.waitForAccountResolver && (r.waitForAccountResolver(""), r.waitForAccountResolver = null));
  }, [e.isOpen]);
  function x() {
    return A ? e.accountWallets.length ? /* @__PURE__ */ C(zU, {}) : /* @__PURE__ */ C(HU, {}) : /* @__PURE__ */ C(S_, { children: /* @__PURE__ */ C(M_, {}) });
  }
  return /* @__PURE__ */ Re("div", { children: [
    /* @__PURE__ */ C(U_, { isOpen: e.isOpen, isAuth: !A, setIsOpen: (M) => y("isOpen", M), children: x() }),
    /* @__PURE__ */ C(
      "button",
      {
        id: "oaw-wallet-widget-btn",
        className: a ? void 0 : "oaw-btn-default-style",
        onClick: () => y("isOpen", !0),
        children: e.loadingWallets || !i ? /* @__PURE__ */ C(cw, { fill: "#06080F", className: "loader" }) : A ? "Open wallet" : "Sign in"
      }
    )
  ] });
}
function WU(a) {
  let e = { ...a };
  return e || (e = { clientId: "" }), e.passkeyAuthMode || (e.passkeyAuthMode = "redirect"), e.authFormPlaceholder || (e.authFormPlaceholder = "your email"), /* @__PURE__ */ C(v_, { ...e, children: /* @__PURE__ */ C(E_, { children: /* @__PURE__ */ C(z_, { children: /* @__PURE__ */ C($_, { children: /* @__PURE__ */ C(VU, { ...e }) }) }) }) });
}
function GU(a, e) {
  if (typeof document > "u") {
    console.error("Cannot initialize embedded wallet app UI");
    return;
  }
  let r = null;
  r = document.querySelector(a), r || (r = document.createElement("div"), r.id = "embedded-wallet", r.setAttribute("style", "display: none;"), document.body.appendChild(r)), e || (e = { clientId: "" }), aO.createRoot(r).render(
    /* @__PURE__ */ C(dE.StrictMode, { children: /* @__PURE__ */ C(WU, { ...e }) })
  );
}
function SW({ className: a, ...e }) {
  const r = Rn(!1);
  return Ln(() => {
    setTimeout(() => {
      r.current || (r.current = !0, GU("#embedded-wallet-activator-react", e));
    }, 5);
  }, []), /* @__PURE__ */ C("div", { id: "embedded-wallet-activator-react", className: a });
}
const jU = "6.13.5";
function $9(a, e, r) {
  for (let i in e) {
    let u = e[i];
    Object.defineProperty(a, i, { enumerable: !0, value: u, writable: !1 });
  }
}
function Ay(a) {
  if (a == null)
    return "null";
  if (Array.isArray(a))
    return "[ " + a.map(Ay).join(", ") + " ]";
  if (a instanceof Uint8Array) {
    const e = "0123456789abcdef";
    let r = "0x";
    for (let i = 0; i < a.length; i++)
      r += e[a[i] >> 4], r += e[a[i] & 15];
    return r;
  }
  if (typeof a == "object" && typeof a.toJSON == "function")
    return Ay(a.toJSON());
  switch (typeof a) {
    case "boolean":
    case "symbol":
      return a.toString();
    case "bigint":
      return BigInt(a).toString();
    case "number":
      return a.toString();
    case "string":
      return JSON.stringify(a);
    case "object": {
      const e = Object.keys(a);
      return e.sort(), "{ " + e.map((r) => `${Ay(r)}: ${Ay(a[r])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function $U(a, e, r) {
  let i = a;
  {
    const d = [];
    if (r) {
      if ("message" in r || "code" in r || "name" in r)
        throw new Error(`value will overwrite populated values: ${Ay(r)}`);
      for (const g in r) {
        if (g === "shortMessage")
          continue;
        const b = r[g];
        d.push(g + "=" + Ay(b));
      }
    }
    d.push(`code=${e}`), d.push(`version=${jU}`), d.length && (a += " (" + d.join(", ") + ")");
  }
  let u;
  switch (e) {
    case "INVALID_ARGUMENT":
      u = new TypeError(a);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      u = new RangeError(a);
      break;
    default:
      u = new Error(a);
  }
  return $9(u, { code: e }), r && Object.assign(u, r), u.shortMessage == null && $9(u, { shortMessage: i }), u;
}
function KE(a, e, r, i) {
  if (!a)
    throw $U(e, r, i);
}
function Vs(a, e, r, i) {
  KE(a, e, "INVALID_ARGUMENT", { argument: r, value: i });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((a, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "é".normalize("NFD") !== "é")
      throw new Error("broken");
    a.push(e);
  } catch {
  }
  return a;
}, []);
function QU(a, e, r) {
  if (a instanceof Uint8Array)
    return a;
  if (typeof a == "string" && a.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const i = new Uint8Array((a.length - 2) / 2);
    let u = 2;
    for (let d = 0; d < i.length; d++)
      i[d] = parseInt(a.substring(u, u + 2), 16), u += 2;
    return i;
  }
  Vs(!1, "invalid BytesLike value", e || "value", a);
}
function JE(a, e) {
  return QU(a, e);
}
const Q9 = "0123456789abcdef";
function EI(a) {
  const e = JE(a);
  let r = "0x";
  for (let i = 0; i < e.length; i++) {
    const u = e[i];
    r += Q9[(u & 240) >> 4] + Q9[u & 15];
  }
  return r;
}
const ZU = BigInt(0);
BigInt(1);
const eE = 9007199254740991;
function YU(a, e) {
  switch (typeof a) {
    case "bigint":
      return a;
    case "number":
      return Vs(Number.isInteger(a), "underflow", e || "value", a), Vs(a >= -9007199254740991 && a <= eE, "overflow", e || "value", a), BigInt(a);
    case "string":
      try {
        if (a === "")
          throw new Error("empty string");
        return a[0] === "-" && a[1] !== "-" ? -BigInt(a.substring(1)) : BigInt(a);
      } catch (r) {
        Vs(!1, `invalid BigNumberish string: ${r.message}`, e || "value", a);
      }
  }
  Vs(!1, "invalid BigNumberish value", e || "value", a);
}
function qU(a, e) {
  const r = YU(a, e);
  return KE(r >= ZU, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: a
  }), r;
}
function SI(a, e) {
  switch (typeof a) {
    case "bigint":
      return Vs(a >= -9007199254740991 && a <= eE, "overflow", e || "value", a), Number(a);
    case "number":
      return Vs(Number.isInteger(a), "underflow", e || "value", a), Vs(a >= -9007199254740991 && a <= eE, "overflow", e || "value", a), a;
    case "string":
      try {
        if (a === "")
          throw new Error("empty string");
        return SI(BigInt(a), e);
      } catch (r) {
        Vs(!1, `invalid numeric string: ${r.message}`, e || "value", a);
      }
  }
  Vs(!1, "invalid numeric value", e || "value", a);
}
function AI(a, e) {
  let r = qU(a, "value").toString(16);
  {
    const i = SI(e, "width");
    for (KE(i * 2 >= r.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: a
    }); r.length < i * 2; )
      r = "0" + r;
  }
  return "0x" + r;
}
BigInt(0);
BigInt(58);
BigInt(-1);
BigInt(0);
BigInt(1);
BigInt(5);
let j8 = "0000";
for (; j8.length < 80; )
  j8 += j8;
const Z9 = globalThis || void 0 || self;
function fk(a) {
  if (!Number.isSafeInteger(a) || a < 0)
    throw new Error(`Wrong positive integer: ${a}`);
}
function XE(a, ...e) {
  if (!(a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(a.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${a.length}`);
}
function KU(a) {
  if (typeof a != "function" || typeof a.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  fk(a.outputLen), fk(a.blockLen);
}
function Zy(a, e = !0) {
  if (a.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && a.finished)
    throw new Error("Hash#digest() has already been called");
}
function xI(a, e) {
  XE(a);
  const r = e.outputLen;
  if (a.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const $8 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const CI = (a) => a instanceof Uint8Array, JU = (a) => new Uint32Array(a.buffer, a.byteOffset, Math.floor(a.byteLength / 4)), Q8 = (a) => new DataView(a.buffer, a.byteOffset, a.byteLength), Hl = (a, e) => a << 32 - e | a >>> e, XU = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!XU)
  throw new Error("Non little-endian hardware is not supported");
function ez(a) {
  if (typeof a != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof a}`);
  return new Uint8Array(new TextEncoder().encode(a));
}
function zk(a) {
  if (typeof a == "string" && (a = ez(a)), !CI(a))
    throw new Error(`expected Uint8Array, got ${typeof a}`);
  return a;
}
function tz(...a) {
  const e = new Uint8Array(a.reduce((i, u) => i + u.length, 0));
  let r = 0;
  return a.forEach((i) => {
    if (!CI(i))
      throw new Error("Uint8Array expected");
    e.set(i, r), r += i.length;
  }), e;
}
let e7 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function t7(a) {
  const e = (i) => a().update(zk(i)).digest(), r = a();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => a(), e;
}
function nz(a = 32) {
  if ($8 && typeof $8.getRandomValues == "function")
    return $8.getRandomValues(new Uint8Array(a));
  throw new Error("crypto.getRandomValues must be defined");
}
let TI = class extends e7 {
  constructor(a, e) {
    super(), this.finished = !1, this.destroyed = !1, KU(a);
    const r = zk(e);
    if (this.iHash = a.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, u = new Uint8Array(i);
    u.set(r.length > i ? a.create().update(r).digest() : r);
    for (let d = 0; d < u.length; d++)
      u[d] ^= 54;
    this.iHash.update(u), this.oHash = a.create();
    for (let d = 0; d < u.length; d++)
      u[d] ^= 106;
    this.oHash.update(u), u.fill(0);
  }
  update(a) {
    return Zy(this), this.iHash.update(a), this;
  }
  digestInto(a) {
    Zy(this), XE(a, this.outputLen), this.finished = !0, this.iHash.digestInto(a), this.oHash.update(a), this.oHash.digestInto(a), this.destroy();
  }
  digest() {
    const a = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(a), a;
  }
  _cloneInto(a) {
    a || (a = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: e, iHash: r, finished: i, destroyed: u, blockLen: d, outputLen: g } = this;
    return a = a, a.finished = i, a.destroyed = u, a.blockLen = d, a.outputLen = g, a.oHash = e._cloneInto(a.oHash), a.iHash = r._cloneInto(a.iHash), a;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const II = (a, e, r) => new TI(a, e).update(r).digest();
II.create = (a, e) => new TI(a, e);
function rz(a, e, r, i) {
  if (typeof a.setBigUint64 == "function")
    return a.setBigUint64(e, r, i);
  const u = BigInt(32), d = BigInt(4294967295), g = Number(r >> u & d), b = Number(r & d), y = i ? 4 : 0, k = i ? 0 : 4;
  a.setUint32(e + y, g, i), a.setUint32(e + k, b, i);
}
class NI extends e7 {
  constructor(e, r, i, u) {
    super(), this.blockLen = e, this.outputLen = r, this.padOffset = i, this.isLE = u, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Q8(this.buffer);
  }
  update(e) {
    Zy(this);
    const { view: r, buffer: i, blockLen: u } = this;
    e = zk(e);
    const d = e.length;
    for (let g = 0; g < d; ) {
      const b = Math.min(u - this.pos, d - g);
      if (b === u) {
        const y = Q8(e);
        for (; u <= d - g; g += u)
          this.process(y, g);
        continue;
      }
      i.set(e.subarray(g, g + b), this.pos), this.pos += b, g += b, this.pos === u && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Zy(this), xI(e, this), this.finished = !0;
    const { buffer: r, view: i, blockLen: u, isLE: d } = this;
    let { pos: g } = this;
    r[g++] = 128, this.buffer.subarray(g).fill(0), this.padOffset > u - g && (this.process(i, 0), g = 0);
    for (let A = g; A < u; A++)
      r[A] = 0;
    rz(i, u - 8, BigInt(this.length * 8), d), this.process(i, 0);
    const b = Q8(e), y = this.outputLen;
    if (y % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const k = y / 4, S = this.get();
    if (k > S.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let A = 0; A < k; A++)
      b.setUint32(4 * A, S[A], d);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const i = e.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: i, length: u, finished: d, destroyed: g, pos: b } = this;
    return e.length = u, e.pos = b, e.finished = d, e.destroyed = g, u % r && e.buffer.set(i), e;
  }
}
const az = (a, e, r) => a & e ^ ~a & r, oz = (a, e, r) => a & e ^ a & r ^ e & r, iz = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), gd = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), md = /* @__PURE__ */ new Uint32Array(64);
let sz = class extends NI {
  constructor() {
    super(64, 32, 8, !1), this.A = gd[0] | 0, this.B = gd[1] | 0, this.C = gd[2] | 0, this.D = gd[3] | 0, this.E = gd[4] | 0, this.F = gd[5] | 0, this.G = gd[6] | 0, this.H = gd[7] | 0;
  }
  get() {
    const { A: a, B: e, C: r, D: i, E: u, F: d, G: g, H: b } = this;
    return [a, e, r, i, u, d, g, b];
  }
  // prettier-ignore
  set(a, e, r, i, u, d, g, b) {
    this.A = a | 0, this.B = e | 0, this.C = r | 0, this.D = i | 0, this.E = u | 0, this.F = d | 0, this.G = g | 0, this.H = b | 0;
  }
  process(a, e) {
    for (let S = 0; S < 16; S++, e += 4)
      md[S] = a.getUint32(e, !1);
    for (let S = 16; S < 64; S++) {
      const A = md[S - 15], x = md[S - 2], M = Hl(A, 7) ^ Hl(A, 18) ^ A >>> 3, D = Hl(x, 17) ^ Hl(x, 19) ^ x >>> 10;
      md[S] = D + md[S - 7] + M + md[S - 16] | 0;
    }
    let { A: r, B: i, C: u, D: d, E: g, F: b, G: y, H: k } = this;
    for (let S = 0; S < 64; S++) {
      const A = Hl(g, 6) ^ Hl(g, 11) ^ Hl(g, 25), x = k + A + az(g, b, y) + iz[S] + md[S] | 0, M = (Hl(r, 2) ^ Hl(r, 13) ^ Hl(r, 22)) + oz(r, i, u) | 0;
      k = y, y = b, b = g, g = d + x | 0, d = u, u = i, i = r, r = x + M | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, u = u + this.C | 0, d = d + this.D | 0, g = g + this.E | 0, b = b + this.F | 0, y = y + this.G | 0, k = k + this.H | 0, this.set(r, i, u, d, g, b, y, k);
  }
  roundClean() {
    md.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const PI = /* @__PURE__ */ t7(() => new sz()), w4 = /* @__PURE__ */ BigInt(2 ** 32 - 1), tE = /* @__PURE__ */ BigInt(32);
function OI(a, e = !1) {
  return e ? { h: Number(a & w4), l: Number(a >> tE & w4) } : { h: Number(a >> tE & w4) | 0, l: Number(a & w4) | 0 };
}
function RI(a, e = !1) {
  let r = new Uint32Array(a.length), i = new Uint32Array(a.length);
  for (let u = 0; u < a.length; u++) {
    const { h: d, l: g } = OI(a[u], e);
    [r[u], i[u]] = [d, g];
  }
  return [r, i];
}
const lz = (a, e) => BigInt(a >>> 0) << tE | BigInt(e >>> 0), uz = (a, e, r) => a >>> r, cz = (a, e, r) => a << 32 - r | e >>> r, fz = (a, e, r) => a >>> r | e << 32 - r, dz = (a, e, r) => a << 32 - r | e >>> r, hz = (a, e, r) => a << 64 - r | e >>> r - 32, pz = (a, e, r) => a >>> r - 32 | e << 64 - r, gz = (a, e) => e, mz = (a, e) => a, LI = (a, e, r) => a << r | e >>> 32 - r, DI = (a, e, r) => e << r | a >>> 32 - r, BI = (a, e, r) => e << r - 32 | a >>> 64 - r, MI = (a, e, r) => a << r - 32 | e >>> 64 - r;
function yz(a, e, r, i) {
  const u = (e >>> 0) + (i >>> 0);
  return { h: a + r + (u / 2 ** 32 | 0) | 0, l: u | 0 };
}
const bz = (a, e, r) => (a >>> 0) + (e >>> 0) + (r >>> 0), vz = (a, e, r, i) => e + r + i + (a / 2 ** 32 | 0) | 0, wz = (a, e, r, i) => (a >>> 0) + (e >>> 0) + (r >>> 0) + (i >>> 0), kz = (a, e, r, i, u) => e + r + i + u + (a / 2 ** 32 | 0) | 0, Ez = (a, e, r, i, u) => (a >>> 0) + (e >>> 0) + (r >>> 0) + (i >>> 0) + (u >>> 0), Sz = (a, e, r, i, u, d) => e + r + i + u + d + (a / 2 ** 32 | 0) | 0, gt = {
  fromBig: OI,
  split: RI,
  toBig: lz,
  shrSH: uz,
  shrSL: cz,
  rotrSH: fz,
  rotrSL: dz,
  rotrBH: hz,
  rotrBL: pz,
  rotr32H: gz,
  rotr32L: mz,
  rotlSH: LI,
  rotlSL: DI,
  rotlBH: BI,
  rotlBL: MI,
  add: yz,
  add3L: bz,
  add3H: vz,
  add4L: wz,
  add4H: kz,
  add5H: Sz,
  add5L: Ez
}, [Az, xz] = gt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((a) => BigInt(a))), yd = /* @__PURE__ */ new Uint32Array(80), bd = /* @__PURE__ */ new Uint32Array(80);
class Cz extends NI {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: r, Bh: i, Bl: u, Ch: d, Cl: g, Dh: b, Dl: y, Eh: k, El: S, Fh: A, Fl: x, Gh: M, Gl: D, Hh: O, Hl: T } = this;
    return [e, r, i, u, d, g, b, y, k, S, A, x, M, D, O, T];
  }
  // prettier-ignore
  set(e, r, i, u, d, g, b, y, k, S, A, x, M, D, O, T) {
    this.Ah = e | 0, this.Al = r | 0, this.Bh = i | 0, this.Bl = u | 0, this.Ch = d | 0, this.Cl = g | 0, this.Dh = b | 0, this.Dl = y | 0, this.Eh = k | 0, this.El = S | 0, this.Fh = A | 0, this.Fl = x | 0, this.Gh = M | 0, this.Gl = D | 0, this.Hh = O | 0, this.Hl = T | 0;
  }
  process(e, r) {
    for (let W = 0; W < 16; W++, r += 4)
      yd[W] = e.getUint32(r), bd[W] = e.getUint32(r += 4);
    for (let W = 16; W < 80; W++) {
      const Z = yd[W - 15] | 0, J = bd[W - 15] | 0, Y = gt.rotrSH(Z, J, 1) ^ gt.rotrSH(Z, J, 8) ^ gt.shrSH(Z, J, 7), X = gt.rotrSL(Z, J, 1) ^ gt.rotrSL(Z, J, 8) ^ gt.shrSL(Z, J, 7), ee = yd[W - 2] | 0, j = bd[W - 2] | 0, ne = gt.rotrSH(ee, j, 19) ^ gt.rotrBH(ee, j, 61) ^ gt.shrSH(ee, j, 6), ae = gt.rotrSL(ee, j, 19) ^ gt.rotrBL(ee, j, 61) ^ gt.shrSL(ee, j, 6), he = gt.add4L(X, ae, bd[W - 7], bd[W - 16]), Ie = gt.add4H(he, Y, ne, yd[W - 7], yd[W - 16]);
      yd[W] = Ie | 0, bd[W] = he | 0;
    }
    let { Ah: i, Al: u, Bh: d, Bl: g, Ch: b, Cl: y, Dh: k, Dl: S, Eh: A, El: x, Fh: M, Fl: D, Gh: O, Gl: T, Hh: L, Hl: U } = this;
    for (let W = 0; W < 80; W++) {
      const Z = gt.rotrSH(A, x, 14) ^ gt.rotrSH(A, x, 18) ^ gt.rotrBH(A, x, 41), J = gt.rotrSL(A, x, 14) ^ gt.rotrSL(A, x, 18) ^ gt.rotrBL(A, x, 41), Y = A & M ^ ~A & O, X = x & D ^ ~x & T, ee = gt.add5L(U, J, X, xz[W], bd[W]), j = gt.add5H(ee, L, Z, Y, Az[W], yd[W]), ne = ee | 0, ae = gt.rotrSH(i, u, 28) ^ gt.rotrBH(i, u, 34) ^ gt.rotrBH(i, u, 39), he = gt.rotrSL(i, u, 28) ^ gt.rotrBL(i, u, 34) ^ gt.rotrBL(i, u, 39), Ie = i & d ^ i & b ^ d & b, V = u & g ^ u & y ^ g & y;
      L = O | 0, U = T | 0, O = M | 0, T = D | 0, M = A | 0, D = x | 0, { h: A, l: x } = gt.add(k | 0, S | 0, j | 0, ne | 0), k = b | 0, S = y | 0, b = d | 0, y = g | 0, d = i | 0, g = u | 0;
      const B = gt.add3L(ne, he, V);
      i = gt.add3H(B, j, ae, Ie), u = B | 0;
    }
    ({ h: i, l: u } = gt.add(this.Ah | 0, this.Al | 0, i | 0, u | 0)), { h: d, l: g } = gt.add(this.Bh | 0, this.Bl | 0, d | 0, g | 0), { h: b, l: y } = gt.add(this.Ch | 0, this.Cl | 0, b | 0, y | 0), { h: k, l: S } = gt.add(this.Dh | 0, this.Dl | 0, k | 0, S | 0), { h: A, l: x } = gt.add(this.Eh | 0, this.El | 0, A | 0, x | 0), { h: M, l: D } = gt.add(this.Fh | 0, this.Fl | 0, M | 0, D | 0), { h: O, l: T } = gt.add(this.Gh | 0, this.Gl | 0, O | 0, T | 0), { h: L, l: U } = gt.add(this.Hh | 0, this.Hl | 0, L | 0, U | 0), this.set(i, u, d, g, b, y, k, S, A, x, M, D, O, T, L, U);
  }
  roundClean() {
    yd.fill(0), bd.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const Tz = /* @__PURE__ */ t7(() => new Cz());
function Iz() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof Z9 < "u")
    return Z9;
  throw new Error("unable to locate global object");
}
const Y9 = Iz();
Y9.crypto || Y9.msCrypto;
function Nz(a) {
  switch (a) {
    case "sha256":
      return PI.create();
    case "sha512":
      return Tz.create();
  }
  Vs(!1, "invalid hashing algorithm name", "algorithm", a);
}
const [FI, _I, UI] = [[], [], []], Pz = /* @__PURE__ */ BigInt(0), z2 = /* @__PURE__ */ BigInt(1), Oz = /* @__PURE__ */ BigInt(2), Rz = /* @__PURE__ */ BigInt(7), Lz = /* @__PURE__ */ BigInt(256), Dz = /* @__PURE__ */ BigInt(113);
for (let a = 0, e = z2, r = 1, i = 0; a < 24; a++) {
  [r, i] = [i, (2 * r + 3 * i) % 5], FI.push(2 * (5 * i + r)), _I.push((a + 1) * (a + 2) / 2 % 64);
  let u = Pz;
  for (let d = 0; d < 7; d++)
    e = (e << z2 ^ (e >> Rz) * Dz) % Lz, e & Oz && (u ^= z2 << (z2 << /* @__PURE__ */ BigInt(d)) - z2);
  UI.push(u);
}
const [Bz, Mz] = /* @__PURE__ */ RI(UI, !0), q9 = (a, e, r) => r > 32 ? BI(a, e, r) : LI(a, e, r), K9 = (a, e, r) => r > 32 ? MI(a, e, r) : DI(a, e, r);
function Fz(a, e = 24) {
  const r = new Uint32Array(10);
  for (let i = 24 - e; i < 24; i++) {
    for (let g = 0; g < 10; g++)
      r[g] = a[g] ^ a[g + 10] ^ a[g + 20] ^ a[g + 30] ^ a[g + 40];
    for (let g = 0; g < 10; g += 2) {
      const b = (g + 8) % 10, y = (g + 2) % 10, k = r[y], S = r[y + 1], A = q9(k, S, 1) ^ r[b], x = K9(k, S, 1) ^ r[b + 1];
      for (let M = 0; M < 50; M += 10)
        a[g + M] ^= A, a[g + M + 1] ^= x;
    }
    let u = a[2], d = a[3];
    for (let g = 0; g < 24; g++) {
      const b = _I[g], y = q9(u, d, b), k = K9(u, d, b), S = FI[g];
      u = a[S], d = a[S + 1], a[S] = y, a[S + 1] = k;
    }
    for (let g = 0; g < 50; g += 10) {
      for (let b = 0; b < 10; b++)
        r[b] = a[g + b];
      for (let b = 0; b < 10; b++)
        a[g + b] ^= ~r[(b + 2) % 10] & r[(b + 4) % 10];
    }
    a[0] ^= Bz[i], a[1] ^= Mz[i];
  }
  r.fill(0);
}
let _z = class zI extends e7 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, r, i, u = !1, d = 24) {
    if (super(), this.blockLen = e, this.suffix = r, this.outputLen = i, this.enableXOF = u, this.rounds = d, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, fk(i), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = JU(this.state);
  }
  keccak() {
    Fz(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Zy(this);
    const { blockLen: r, state: i } = this;
    e = zk(e);
    const u = e.length;
    for (let d = 0; d < u; ) {
      const g = Math.min(r - this.pos, u - d);
      for (let b = 0; b < g; b++)
        i[this.pos++] ^= e[d++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: r, pos: i, blockLen: u } = this;
    e[i] ^= r, r & 128 && i === u - 1 && this.keccak(), e[u - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Zy(this, !1), XE(e), this.finish();
    const r = this.state, { blockLen: i } = this;
    for (let u = 0, d = e.length; u < d; ) {
      this.posOut >= i && this.keccak();
      const g = Math.min(i - this.posOut, d - u);
      e.set(r.subarray(this.posOut, this.posOut + g), u), this.posOut += g, u += g;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return fk(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (xI(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: r, suffix: i, outputLen: u, rounds: d, enableXOF: g } = this;
    return e || (e = new zI(r, i, u, g, d)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = d, e.suffix = i, e.outputLen = u, e.enableXOF = g, e.destroyed = this.destroyed, e;
  }
};
const Uz = (a, e, r) => t7(() => new _z(e, a, r)), zz = /* @__PURE__ */ Uz(1, 136, 256 / 8);
let HI = !1;
const VI = function(a) {
  return zz(a);
};
let WI = VI;
function Hk(a) {
  const e = JE(a, "data");
  return EI(WI(e));
}
Hk._ = VI;
Hk.lock = function() {
  HI = !0;
};
Hk.register = function(a) {
  if (HI)
    throw new TypeError("keccak256 is locked");
  WI = a;
};
Object.freeze(Hk);
const GI = function(a) {
  return Nz("sha256").update(a).digest();
};
let jI = GI, $I = !1;
function fw(a) {
  const e = JE(a, "data");
  return EI(jI(e));
}
fw._ = GI;
fw.lock = function() {
  $I = !0;
};
fw.register = function(a) {
  if ($I)
    throw new Error("sha256 is locked");
  jI = a;
};
Object.freeze(fw);
Object.freeze(fw);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const QI = BigInt(0), Vk = BigInt(1), Hz = BigInt(2), Wk = (a) => a instanceof Uint8Array, Vz = /* @__PURE__ */ Array.from({ length: 256 }, (a, e) => e.toString(16).padStart(2, "0"));
function Yy(a) {
  if (!Wk(a))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let r = 0; r < a.length; r++)
    e += Vz[a[r]];
  return e;
}
function ZI(a) {
  const e = a.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function n7(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  return BigInt(a === "" ? "0" : `0x${a}`);
}
function qy(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  const e = a.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(e / 2);
  for (let i = 0; i < r.length; i++) {
    const u = i * 2, d = a.slice(u, u + 2), g = Number.parseInt(d, 16);
    if (Number.isNaN(g) || g < 0)
      throw new Error("Invalid byte sequence");
    r[i] = g;
  }
  return r;
}
function gg(a) {
  return n7(Yy(a));
}
function r7(a) {
  if (!Wk(a))
    throw new Error("Uint8Array expected");
  return n7(Yy(Uint8Array.from(a).reverse()));
}
function Ky(a, e) {
  return qy(a.toString(16).padStart(e * 2, "0"));
}
function a7(a, e) {
  return Ky(a, e).reverse();
}
function Wz(a) {
  return qy(ZI(a));
}
function Ms(a, e, r) {
  let i;
  if (typeof e == "string")
    try {
      i = qy(e);
    } catch (d) {
      throw new Error(`${a} must be valid hex string, got "${e}". Cause: ${d}`);
    }
  else if (Wk(e))
    i = Uint8Array.from(e);
  else
    throw new Error(`${a} must be hex string or Uint8Array`);
  const u = i.length;
  if (typeof r == "number" && u !== r)
    throw new Error(`${a} expected ${r} bytes, got ${u}`);
  return i;
}
function qv(...a) {
  const e = new Uint8Array(a.reduce((i, u) => i + u.length, 0));
  let r = 0;
  return a.forEach((i) => {
    if (!Wk(i))
      throw new Error("Uint8Array expected");
    e.set(i, r), r += i.length;
  }), e;
}
function Gz(a, e) {
  if (a.length !== e.length)
    return !1;
  for (let r = 0; r < a.length; r++)
    if (a[r] !== e[r])
      return !1;
  return !0;
}
function jz(a) {
  if (typeof a != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof a}`);
  return new Uint8Array(new TextEncoder().encode(a));
}
function $z(a) {
  let e;
  for (e = 0; a > QI; a >>= Vk, e += 1)
    ;
  return e;
}
function Qz(a, e) {
  return a >> BigInt(e) & Vk;
}
const Zz = (a, e, r) => a | (r ? Vk : QI) << BigInt(e), o7 = (a) => (Hz << BigInt(a - 1)) - Vk, Z8 = (a) => new Uint8Array(a), J9 = (a) => Uint8Array.from(a);
function YI(a, e, r) {
  if (typeof a != "number" || a < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let i = Z8(a), u = Z8(a), d = 0;
  const g = () => {
    i.fill(1), u.fill(0), d = 0;
  }, b = (...S) => r(u, i, ...S), y = (S = Z8()) => {
    u = b(J9([0]), S), i = b(), S.length !== 0 && (u = b(J9([1]), S), i = b());
  }, k = () => {
    if (d++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let S = 0;
    const A = [];
    for (; S < e; ) {
      i = b();
      const x = i.slice();
      A.push(x), S += i.length;
    }
    return qv(...A);
  };
  return (S, A) => {
    g(), y(S);
    let x;
    for (; !(x = A(k())); )
      y();
    return g(), x;
  };
}
const Yz = {
  bigint: (a) => typeof a == "bigint",
  function: (a) => typeof a == "function",
  boolean: (a) => typeof a == "boolean",
  string: (a) => typeof a == "string",
  stringOrUint8Array: (a) => typeof a == "string" || a instanceof Uint8Array,
  isSafeInteger: (a) => Number.isSafeInteger(a),
  array: (a) => Array.isArray(a),
  field: (a, e) => e.Fp.isValid(a),
  hash: (a) => typeof a == "function" && Number.isSafeInteger(a.outputLen)
};
function dw(a, e, r = {}) {
  const i = (u, d, g) => {
    const b = Yz[d];
    if (typeof b != "function")
      throw new Error(`Invalid validator "${d}", expected function`);
    const y = a[u];
    if (!(g && y === void 0) && !b(y, a))
      throw new Error(`Invalid param ${String(u)}=${y} (${typeof y}), expected ${d}`);
  };
  for (const [u, d] of Object.entries(e))
    i(u, d, !1);
  for (const [u, d] of Object.entries(r))
    i(u, d, !0);
  return a;
}
const qz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: Qz,
  bitLen: $z,
  bitMask: o7,
  bitSet: Zz,
  bytesToHex: Yy,
  bytesToNumberBE: gg,
  bytesToNumberLE: r7,
  concatBytes: qv,
  createHmacDrbg: YI,
  ensureBytes: Ms,
  equalBytes: Gz,
  hexToBytes: qy,
  hexToNumber: n7,
  numberToBytesBE: Ky,
  numberToBytesLE: a7,
  numberToHexUnpadded: ZI,
  numberToVarBytesBE: Wz,
  utf8ToBytes: jz,
  validateObject: dw
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ur = BigInt(0), qn = BigInt(1), Kp = BigInt(2), Kz = BigInt(3), nE = BigInt(4), X9 = BigInt(5), ex = BigInt(8);
BigInt(9);
BigInt(16);
function io(a, e) {
  const r = a % e;
  return r >= Ur ? r : e + r;
}
function Jz(a, e, r) {
  if (r <= Ur || e < Ur)
    throw new Error("Expected power/modulo > 0");
  if (r === qn)
    return Ur;
  let i = qn;
  for (; e > Ur; )
    e & qn && (i = i * a % r), a = a * a % r, e >>= qn;
  return i;
}
function Ni(a, e, r) {
  let i = a;
  for (; e-- > Ur; )
    i *= i, i %= r;
  return i;
}
function rE(a, e) {
  if (a === Ur || e <= Ur)
    throw new Error(`invert: expected positive integers, got n=${a} mod=${e}`);
  let r = io(a, e), i = e, u = Ur, d = qn;
  for (; r !== Ur; ) {
    const g = i / r, b = i % r, y = u - d * g;
    i = r, r = b, u = d, d = y;
  }
  if (i !== qn)
    throw new Error("invert: does not exist");
  return io(u, e);
}
function Xz(a) {
  const e = (a - qn) / Kp;
  let r, i, u;
  for (r = a - qn, i = 0; r % Kp === Ur; r /= Kp, i++)
    ;
  for (u = Kp; u < a && Jz(u, e, a) !== a - qn; u++)
    ;
  if (i === 1) {
    const g = (a + qn) / nE;
    return function(b, y) {
      const k = b.pow(y, g);
      if (!b.eql(b.sqr(k), y))
        throw new Error("Cannot find square root");
      return k;
    };
  }
  const d = (r + qn) / Kp;
  return function(g, b) {
    if (g.pow(b, e) === g.neg(g.ONE))
      throw new Error("Cannot find square root");
    let y = i, k = g.pow(g.mul(g.ONE, u), r), S = g.pow(b, d), A = g.pow(b, r);
    for (; !g.eql(A, g.ONE); ) {
      if (g.eql(A, g.ZERO))
        return g.ZERO;
      let x = 1;
      for (let D = g.sqr(A); x < y && !g.eql(D, g.ONE); x++)
        D = g.sqr(D);
      const M = g.pow(k, qn << BigInt(y - x - 1));
      k = g.sqr(M), S = g.mul(S, M), A = g.mul(A, k), y = x;
    }
    return S;
  };
}
function eH(a) {
  if (a % nE === Kz) {
    const e = (a + qn) / nE;
    return function(r, i) {
      const u = r.pow(i, e);
      if (!r.eql(r.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  if (a % ex === X9) {
    const e = (a - X9) / ex;
    return function(r, i) {
      const u = r.mul(i, Kp), d = r.pow(u, e), g = r.mul(i, d), b = r.mul(r.mul(g, Kp), d), y = r.mul(g, r.sub(b, r.ONE));
      if (!r.eql(r.sqr(y), i))
        throw new Error("Cannot find square root");
      return y;
    };
  }
  return Xz(a);
}
const tH = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function nH(a) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = tH.reduce((i, u) => (i[u] = "function", i), e);
  return dw(a, r);
}
function rH(a, e, r) {
  if (r < Ur)
    throw new Error("Expected power > 0");
  if (r === Ur)
    return a.ONE;
  if (r === qn)
    return e;
  let i = a.ONE, u = e;
  for (; r > Ur; )
    r & qn && (i = a.mul(i, u)), u = a.sqr(u), r >>= qn;
  return i;
}
function aH(a, e) {
  const r = new Array(e.length), i = e.reduce((d, g, b) => a.is0(g) ? d : (r[b] = d, a.mul(d, g)), a.ONE), u = a.inv(i);
  return e.reduceRight((d, g, b) => a.is0(g) ? d : (r[b] = a.mul(d, r[b]), a.mul(d, g)), u), r;
}
function qI(a, e) {
  const r = e !== void 0 ? e : a.toString(2).length, i = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: i };
}
function oH(a, e, r = !1, i = {}) {
  if (a <= Ur)
    throw new Error(`Expected Field ORDER > 0, got ${a}`);
  const { nBitLength: u, nByteLength: d } = qI(a, e);
  if (d > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const g = eH(a), b = Object.freeze({
    ORDER: a,
    BITS: u,
    BYTES: d,
    MASK: o7(u),
    ZERO: Ur,
    ONE: qn,
    create: (y) => io(y, a),
    isValid: (y) => {
      if (typeof y != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof y}`);
      return Ur <= y && y < a;
    },
    is0: (y) => y === Ur,
    isOdd: (y) => (y & qn) === qn,
    neg: (y) => io(-y, a),
    eql: (y, k) => y === k,
    sqr: (y) => io(y * y, a),
    add: (y, k) => io(y + k, a),
    sub: (y, k) => io(y - k, a),
    mul: (y, k) => io(y * k, a),
    pow: (y, k) => rH(b, y, k),
    div: (y, k) => io(y * rE(k, a), a),
    // Same as above, but doesn't normalize
    sqrN: (y) => y * y,
    addN: (y, k) => y + k,
    subN: (y, k) => y - k,
    mulN: (y, k) => y * k,
    inv: (y) => rE(y, a),
    sqrt: i.sqrt || ((y) => g(b, y)),
    invertBatch: (y) => aH(b, y),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (y, k, S) => S ? k : y,
    toBytes: (y) => r ? a7(y, d) : Ky(y, d),
    fromBytes: (y) => {
      if (y.length !== d)
        throw new Error(`Fp.fromBytes: expected ${d}, got ${y.length}`);
      return r ? r7(y) : gg(y);
    }
  });
  return Object.freeze(b);
}
function KI(a) {
  if (typeof a != "bigint")
    throw new Error("field order must be bigint");
  const e = a.toString(2).length;
  return Math.ceil(e / 8);
}
function JI(a) {
  const e = KI(a);
  return e + Math.ceil(e / 2);
}
function iH(a, e, r = !1) {
  const i = a.length, u = KI(e), d = JI(e);
  if (i < 16 || i < d || i > 1024)
    throw new Error(`expected ${d}-1024 bytes of input, got ${i}`);
  const g = r ? gg(a) : r7(a), b = io(g, e - qn) + qn;
  return r ? a7(b, u) : Ky(b, u);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sH = BigInt(0), Y8 = BigInt(1);
function lH(a, e) {
  const r = (u, d) => {
    const g = d.negate();
    return u ? g : d;
  }, i = (u) => {
    const d = Math.ceil(e / u) + 1, g = 2 ** (u - 1);
    return { windows: d, windowSize: g };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(u, d) {
      let g = a.ZERO, b = u;
      for (; d > sH; )
        d & Y8 && (g = g.add(b)), b = b.double(), d >>= Y8;
      return g;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(u, d) {
      const { windows: g, windowSize: b } = i(d), y = [];
      let k = u, S = k;
      for (let A = 0; A < g; A++) {
        S = k, y.push(S);
        for (let x = 1; x < b; x++)
          S = S.add(k), y.push(S);
        k = S.double();
      }
      return y;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(u, d, g) {
      const { windows: b, windowSize: y } = i(u);
      let k = a.ZERO, S = a.BASE;
      const A = BigInt(2 ** u - 1), x = 2 ** u, M = BigInt(u);
      for (let D = 0; D < b; D++) {
        const O = D * y;
        let T = Number(g & A);
        g >>= M, T > y && (T -= x, g += Y8);
        const L = O, U = O + Math.abs(T) - 1, W = D % 2 !== 0, Z = T < 0;
        T === 0 ? S = S.add(r(W, d[L])) : k = k.add(r(Z, d[U]));
      }
      return { p: k, f: S };
    },
    wNAFCached(u, d, g, b) {
      const y = u._WINDOW_SIZE || 1;
      let k = d.get(u);
      return k || (k = this.precomputeWindow(u, y), y !== 1 && d.set(u, b(k))), this.wNAF(y, k, g);
    }
  };
}
function XI(a) {
  return nH(a.Fp), dw(a, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...qI(a.n, a.nBitLength),
    ...a,
    p: a.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function uH(a) {
  const e = XI(a);
  dw(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: i, a: u } = e;
  if (r) {
    if (!i.eql(u, i.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: cH, hexToBytes: fH } = qz, sg = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(a = "") {
      super(a);
    }
  },
  _parseInt(a) {
    const { Err: e } = sg;
    if (a.length < 2 || a[0] !== 2)
      throw new e("Invalid signature integer tag");
    const r = a[1], i = a.subarray(2, r + 2);
    if (!r || i.length !== r)
      throw new e("Invalid signature integer: wrong length");
    if (i[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (i[0] === 0 && !(i[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: cH(i), l: a.subarray(r + 2) };
  },
  toSig(a) {
    const { Err: e } = sg, r = typeof a == "string" ? fH(a) : a;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let i = r.length;
    if (i < 2 || r[0] != 48)
      throw new e("Invalid signature tag");
    if (r[1] !== i - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: u, l: d } = sg._parseInt(r.subarray(2)), { d: g, l: b } = sg._parseInt(d);
    if (b.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: u, s: g };
  },
  hexFromSig(a) {
    const e = (k) => Number.parseInt(k[0], 16) & 8 ? "00" + k : k, r = (k) => {
      const S = k.toString(16);
      return S.length & 1 ? `0${S}` : S;
    }, i = e(r(a.s)), u = e(r(a.r)), d = i.length / 2, g = u.length / 2, b = r(d), y = r(g);
    return `30${r(g + d + 4)}02${y}${u}02${b}${i}`;
  }
}, Oc = BigInt(0), Di = BigInt(1);
BigInt(2);
const tx = BigInt(3);
BigInt(4);
function dH(a) {
  const e = uH(a), { Fp: r } = e, i = e.toBytes || ((D, O, T) => {
    const L = O.toAffine();
    return qv(Uint8Array.from([4]), r.toBytes(L.x), r.toBytes(L.y));
  }), u = e.fromBytes || ((D) => {
    const O = D.subarray(1), T = r.fromBytes(O.subarray(0, r.BYTES)), L = r.fromBytes(O.subarray(r.BYTES, 2 * r.BYTES));
    return { x: T, y: L };
  });
  function d(D) {
    const { a: O, b: T } = e, L = r.sqr(D), U = r.mul(L, D);
    return r.add(r.add(U, r.mul(D, O)), T);
  }
  if (!r.eql(r.sqr(e.Gy), d(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function g(D) {
    return typeof D == "bigint" && Oc < D && D < e.n;
  }
  function b(D) {
    if (!g(D))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function y(D) {
    const { allowedPrivateKeyLengths: O, nByteLength: T, wrapPrivateKey: L, n: U } = e;
    if (O && typeof D != "bigint") {
      if (D instanceof Uint8Array && (D = Yy(D)), typeof D != "string" || !O.includes(D.length))
        throw new Error("Invalid key");
      D = D.padStart(T * 2, "0");
    }
    let W;
    try {
      W = typeof D == "bigint" ? D : gg(Ms("private key", D, T));
    } catch {
      throw new Error(`private key must be ${T} bytes, hex or bigint, not ${typeof D}`);
    }
    return L && (W = io(W, U)), b(W), W;
  }
  const k = /* @__PURE__ */ new Map();
  function S(D) {
    if (!(D instanceof A))
      throw new Error("ProjectivePoint expected");
  }
  class A {
    constructor(O, T, L) {
      if (this.px = O, this.py = T, this.pz = L, O == null || !r.isValid(O))
        throw new Error("x required");
      if (T == null || !r.isValid(T))
        throw new Error("y required");
      if (L == null || !r.isValid(L))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(O) {
      const { x: T, y: L } = O || {};
      if (!O || !r.isValid(T) || !r.isValid(L))
        throw new Error("invalid affine point");
      if (O instanceof A)
        throw new Error("projective point not allowed");
      const U = (W) => r.eql(W, r.ZERO);
      return U(T) && U(L) ? A.ZERO : new A(T, L, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(O) {
      const T = r.invertBatch(O.map((L) => L.pz));
      return O.map((L, U) => L.toAffine(T[U])).map(A.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(O) {
      const T = A.fromAffine(u(Ms("pointHex", O)));
      return T.assertValidity(), T;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(O) {
      return A.BASE.multiply(y(O));
    }
    // "Private method", don't use it directly
    _setWindowSize(O) {
      this._WINDOW_SIZE = O, k.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !r.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: O, y: T } = this.toAffine();
      if (!r.isValid(O) || !r.isValid(T))
        throw new Error("bad point: x or y not FE");
      const L = r.sqr(T), U = d(O);
      if (!r.eql(L, U))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: O } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(O);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(O) {
      S(O);
      const { px: T, py: L, pz: U } = this, { px: W, py: Z, pz: J } = O, Y = r.eql(r.mul(T, J), r.mul(W, U)), X = r.eql(r.mul(L, J), r.mul(Z, U));
      return Y && X;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new A(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: O, b: T } = e, L = r.mul(T, tx), { px: U, py: W, pz: Z } = this;
      let J = r.ZERO, Y = r.ZERO, X = r.ZERO, ee = r.mul(U, U), j = r.mul(W, W), ne = r.mul(Z, Z), ae = r.mul(U, W);
      return ae = r.add(ae, ae), X = r.mul(U, Z), X = r.add(X, X), J = r.mul(O, X), Y = r.mul(L, ne), Y = r.add(J, Y), J = r.sub(j, Y), Y = r.add(j, Y), Y = r.mul(J, Y), J = r.mul(ae, J), X = r.mul(L, X), ne = r.mul(O, ne), ae = r.sub(ee, ne), ae = r.mul(O, ae), ae = r.add(ae, X), X = r.add(ee, ee), ee = r.add(X, ee), ee = r.add(ee, ne), ee = r.mul(ee, ae), Y = r.add(Y, ee), ne = r.mul(W, Z), ne = r.add(ne, ne), ee = r.mul(ne, ae), J = r.sub(J, ee), X = r.mul(ne, j), X = r.add(X, X), X = r.add(X, X), new A(J, Y, X);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(O) {
      S(O);
      const { px: T, py: L, pz: U } = this, { px: W, py: Z, pz: J } = O;
      let Y = r.ZERO, X = r.ZERO, ee = r.ZERO;
      const j = e.a, ne = r.mul(e.b, tx);
      let ae = r.mul(T, W), he = r.mul(L, Z), Ie = r.mul(U, J), V = r.add(T, L), B = r.add(W, Z);
      V = r.mul(V, B), B = r.add(ae, he), V = r.sub(V, B), B = r.add(T, U);
      let P = r.add(W, J);
      return B = r.mul(B, P), P = r.add(ae, Ie), B = r.sub(B, P), P = r.add(L, U), Y = r.add(Z, J), P = r.mul(P, Y), Y = r.add(he, Ie), P = r.sub(P, Y), ee = r.mul(j, B), Y = r.mul(ne, Ie), ee = r.add(Y, ee), Y = r.sub(he, ee), ee = r.add(he, ee), X = r.mul(Y, ee), he = r.add(ae, ae), he = r.add(he, ae), Ie = r.mul(j, Ie), B = r.mul(ne, B), he = r.add(he, Ie), Ie = r.sub(ae, Ie), Ie = r.mul(j, Ie), B = r.add(B, Ie), ae = r.mul(he, B), X = r.add(X, ae), ae = r.mul(P, B), Y = r.mul(V, Y), Y = r.sub(Y, ae), ae = r.mul(V, he), ee = r.mul(P, ee), ee = r.add(ee, ae), new A(Y, X, ee);
    }
    subtract(O) {
      return this.add(O.negate());
    }
    is0() {
      return this.equals(A.ZERO);
    }
    wNAF(O) {
      return M.wNAFCached(this, k, O, (T) => {
        const L = r.invertBatch(T.map((U) => U.pz));
        return T.map((U, W) => U.toAffine(L[W])).map(A.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(O) {
      const T = A.ZERO;
      if (O === Oc)
        return T;
      if (b(O), O === Di)
        return this;
      const { endo: L } = e;
      if (!L)
        return M.unsafeLadder(this, O);
      let { k1neg: U, k1: W, k2neg: Z, k2: J } = L.splitScalar(O), Y = T, X = T, ee = this;
      for (; W > Oc || J > Oc; )
        W & Di && (Y = Y.add(ee)), J & Di && (X = X.add(ee)), ee = ee.double(), W >>= Di, J >>= Di;
      return U && (Y = Y.negate()), Z && (X = X.negate()), X = new A(r.mul(X.px, L.beta), X.py, X.pz), Y.add(X);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(O) {
      b(O);
      let T = O, L, U;
      const { endo: W } = e;
      if (W) {
        const { k1neg: Z, k1: J, k2neg: Y, k2: X } = W.splitScalar(T);
        let { p: ee, f: j } = this.wNAF(J), { p: ne, f: ae } = this.wNAF(X);
        ee = M.constTimeNegate(Z, ee), ne = M.constTimeNegate(Y, ne), ne = new A(r.mul(ne.px, W.beta), ne.py, ne.pz), L = ee.add(ne), U = j.add(ae);
      } else {
        const { p: Z, f: J } = this.wNAF(T);
        L = Z, U = J;
      }
      return A.normalizeZ([L, U])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(O, T, L) {
      const U = A.BASE, W = (J, Y) => Y === Oc || Y === Di || !J.equals(U) ? J.multiplyUnsafe(Y) : J.multiply(Y), Z = W(this, T).add(W(O, L));
      return Z.is0() ? void 0 : Z;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(O) {
      const { px: T, py: L, pz: U } = this, W = this.is0();
      O == null && (O = W ? r.ONE : r.inv(U));
      const Z = r.mul(T, O), J = r.mul(L, O), Y = r.mul(U, O);
      if (W)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(Y, r.ONE))
        throw new Error("invZ was invalid");
      return { x: Z, y: J };
    }
    isTorsionFree() {
      const { h: O, isTorsionFree: T } = e;
      if (O === Di)
        return !0;
      if (T)
        return T(A, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: O, clearCofactor: T } = e;
      return O === Di ? this : T ? T(A, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(O = !0) {
      return this.assertValidity(), i(A, this, O);
    }
    toHex(O = !0) {
      return Yy(this.toRawBytes(O));
    }
  }
  A.BASE = new A(e.Gx, e.Gy, r.ONE), A.ZERO = new A(r.ZERO, r.ONE, r.ZERO);
  const x = e.nBitLength, M = lH(A, e.endo ? Math.ceil(x / 2) : x);
  return {
    CURVE: e,
    ProjectivePoint: A,
    normPrivateKeyToScalar: y,
    weierstrassEquation: d,
    isWithinCurveOrder: g
  };
}
function hH(a) {
  const e = XI(a);
  return dw(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function pH(a) {
  const e = hH(a), { Fp: r, n: i } = e, u = r.BYTES + 1, d = 2 * r.BYTES + 1;
  function g(B) {
    return Oc < B && B < r.ORDER;
  }
  function b(B) {
    return io(B, i);
  }
  function y(B) {
    return rE(B, i);
  }
  const { ProjectivePoint: k, normPrivateKeyToScalar: S, weierstrassEquation: A, isWithinCurveOrder: x } = dH({
    ...e,
    toBytes(B, P, H) {
      const G = P.toAffine(), ie = r.toBytes(G.x), ce = qv;
      return H ? ce(Uint8Array.from([P.hasEvenY() ? 2 : 3]), ie) : ce(Uint8Array.from([4]), ie, r.toBytes(G.y));
    },
    fromBytes(B) {
      const P = B.length, H = B[0], G = B.subarray(1);
      if (P === u && (H === 2 || H === 3)) {
        const ie = gg(G);
        if (!g(ie))
          throw new Error("Point is not on curve");
        const ce = A(ie);
        let xe = r.sqrt(ce);
        const Ce = (xe & Di) === Di;
        return (H & 1) === 1 !== Ce && (xe = r.neg(xe)), { x: ie, y: xe };
      } else if (P === d && H === 4) {
        const ie = r.fromBytes(G.subarray(0, r.BYTES)), ce = r.fromBytes(G.subarray(r.BYTES, 2 * r.BYTES));
        return { x: ie, y: ce };
      } else
        throw new Error(`Point of length ${P} was invalid. Expected ${u} compressed bytes or ${d} uncompressed bytes`);
    }
  }), M = (B) => Yy(Ky(B, e.nByteLength));
  function D(B) {
    const P = i >> Di;
    return B > P;
  }
  function O(B) {
    return D(B) ? b(-B) : B;
  }
  const T = (B, P, H) => gg(B.slice(P, H));
  class L {
    constructor(P, H, G) {
      this.r = P, this.s = H, this.recovery = G, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(P) {
      const H = e.nByteLength;
      return P = Ms("compactSignature", P, H * 2), new L(T(P, 0, H), T(P, H, 2 * H));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(P) {
      const { r: H, s: G } = sg.toSig(Ms("DER", P));
      return new L(H, G);
    }
    assertValidity() {
      if (!x(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!x(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(P) {
      return new L(this.r, this.s, P);
    }
    recoverPublicKey(P) {
      const { r: H, s: G, recovery: ie } = this, ce = X(Ms("msgHash", P));
      if (ie == null || ![0, 1, 2, 3].includes(ie))
        throw new Error("recovery id invalid");
      const xe = ie === 2 || ie === 3 ? H + e.n : H;
      if (xe >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Ce = ie & 1 ? "03" : "02", Be = k.fromHex(Ce + M(xe)), Pe = y(xe), Fe = b(-ce * Pe), Xe = b(G * Pe), at = k.BASE.multiplyAndAddUnsafe(Be, Fe, Xe);
      if (!at)
        throw new Error("point at infinify");
      return at.assertValidity(), at;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return D(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new L(this.r, b(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return qy(this.toDERHex());
    }
    toDERHex() {
      return sg.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return qy(this.toCompactHex());
    }
    toCompactHex() {
      return M(this.r) + M(this.s);
    }
  }
  const U = {
    isValidPrivateKey(B) {
      try {
        return S(B), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: S,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const B = JI(e.n);
      return iH(e.randomBytes(B), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(B = 8, P = k.BASE) {
      return P._setWindowSize(B), P.multiply(BigInt(3)), P;
    }
  };
  function W(B, P = !0) {
    return k.fromPrivateKey(B).toRawBytes(P);
  }
  function Z(B) {
    const P = B instanceof Uint8Array, H = typeof B == "string", G = (P || H) && B.length;
    return P ? G === u || G === d : H ? G === 2 * u || G === 2 * d : B instanceof k;
  }
  function J(B, P, H = !0) {
    if (Z(B))
      throw new Error("first arg must be private key");
    if (!Z(P))
      throw new Error("second arg must be public key");
    return k.fromHex(P).multiply(S(B)).toRawBytes(H);
  }
  const Y = e.bits2int || function(B) {
    const P = gg(B), H = B.length * 8 - e.nBitLength;
    return H > 0 ? P >> BigInt(H) : P;
  }, X = e.bits2int_modN || function(B) {
    return b(Y(B));
  }, ee = o7(e.nBitLength);
  function j(B) {
    if (typeof B != "bigint")
      throw new Error("bigint expected");
    if (!(Oc <= B && B < ee))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return Ky(B, e.nByteLength);
  }
  function ne(B, P, H = ae) {
    if (["recovered", "canonical"].some((Ye) => Ye in H))
      throw new Error("sign() legacy options not supported");
    const { hash: G, randomBytes: ie } = e;
    let { lowS: ce, prehash: xe, extraEntropy: Ce } = H;
    ce == null && (ce = !0), B = Ms("msgHash", B), xe && (B = Ms("prehashed msgHash", G(B)));
    const Be = X(B), Pe = S(P), Fe = [j(Pe), j(Be)];
    if (Ce != null) {
      const Ye = Ce === !0 ? ie(r.BYTES) : Ce;
      Fe.push(Ms("extraEntropy", Ye));
    }
    const Xe = qv(...Fe), at = Be;
    function tt(Ye) {
      const Ve = Y(Ye);
      if (!x(Ve))
        return;
      const Je = y(Ve), _e = k.BASE.multiply(Ve).toAffine(), rt = b(_e.x);
      if (rt === Oc)
        return;
      const Gt = b(Je * b(at + rt * Pe));
      if (Gt === Oc)
        return;
      let Er = (_e.x === rt ? 0 : 2) | Number(_e.y & Di), Ga = Gt;
      return ce && D(Gt) && (Ga = O(Gt), Er ^= 1), new L(rt, Ga, Er);
    }
    return { seed: Xe, k2sig: tt };
  }
  const ae = { lowS: e.lowS, prehash: !1 }, he = { lowS: e.lowS, prehash: !1 };
  function Ie(B, P, H = ae) {
    const { seed: G, k2sig: ie } = ne(B, P, H), ce = e;
    return YI(ce.hash.outputLen, ce.nByteLength, ce.hmac)(G, ie);
  }
  k.BASE._setWindowSize(8);
  function V(B, P, H, G = he) {
    const ie = B;
    if (P = Ms("msgHash", P), H = Ms("publicKey", H), "strict" in G)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: ce, prehash: xe } = G;
    let Ce, Be;
    try {
      if (typeof ie == "string" || ie instanceof Uint8Array)
        try {
          Ce = L.fromDER(ie);
        } catch (Je) {
          if (!(Je instanceof sg.Err))
            throw Je;
          Ce = L.fromCompact(ie);
        }
      else if (typeof ie == "object" && typeof ie.r == "bigint" && typeof ie.s == "bigint") {
        const { r: Je, s: _e } = ie;
        Ce = new L(Je, _e);
      } else
        throw new Error("PARSE");
      Be = k.fromHex(H);
    } catch (Je) {
      if (Je.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (ce && Ce.hasHighS())
      return !1;
    xe && (P = e.hash(P));
    const { r: Pe, s: Fe } = Ce, Xe = X(P), at = y(Fe), tt = b(Xe * at), Ye = b(Pe * at), Ve = k.BASE.multiplyAndAddUnsafe(Be, tt, Ye)?.toAffine();
    return Ve ? b(Ve.x) === Pe : !1;
  }
  return {
    CURVE: e,
    getPublicKey: W,
    getSharedSecret: J,
    sign: Ie,
    verify: V,
    ProjectivePoint: k,
    Signature: L,
    utils: U
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function gH(a) {
  return {
    hash: a,
    hmac: (e, ...r) => II(a, e, tz(...r)),
    randomBytes: nz
  };
}
function mH(a, e) {
  const r = (i) => pH({ ...a, ...gH(i) });
  return Object.freeze({ ...r(e), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const eN = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), nx = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), yH = BigInt(1), aE = BigInt(2), rx = (a, e) => (a + e / aE) / e;
function bH(a) {
  const e = eN, r = BigInt(3), i = BigInt(6), u = BigInt(11), d = BigInt(22), g = BigInt(23), b = BigInt(44), y = BigInt(88), k = a * a * a % e, S = k * k * a % e, A = Ni(S, r, e) * S % e, x = Ni(A, r, e) * S % e, M = Ni(x, aE, e) * k % e, D = Ni(M, u, e) * M % e, O = Ni(D, d, e) * D % e, T = Ni(O, b, e) * O % e, L = Ni(T, y, e) * T % e, U = Ni(L, b, e) * O % e, W = Ni(U, r, e) * S % e, Z = Ni(W, g, e) * D % e, J = Ni(Z, i, e) * k % e, Y = Ni(J, aE, e);
  if (!oE.eql(oE.sqr(Y), a))
    throw new Error("Cannot find square root");
  return Y;
}
const oE = oH(eN, void 0, void 0, { sqrt: bH }), vH = mH({
  a: BigInt(0),
  b: BigInt(7),
  Fp: oE,
  n: nx,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (a) => {
      const e = nx, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), i = -yH * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), u = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), d = r, g = BigInt("0x100000000000000000000000000000000"), b = rx(d * a, e), y = rx(-i * a, e);
      let k = io(a - b * r - y * u, e), S = io(-b * i - y * d, e);
      const A = k > g, x = S > g;
      if (A && (k = e - k), x && (S = e - S), k > g || S > g)
        throw new Error("splitScalar: Endomorphism failed, k=" + a);
      return { k1neg: A, k1: k, k2neg: x, k2: S };
    }
  }
}, PI);
BigInt(0);
vH.ProjectivePoint;
BigInt(0);
BigInt(1);
BigInt(2);
BigInt(27);
BigInt(28);
BigInt(35);
BigInt(0);
BigInt(36);
(function() {
  const a = {};
  for (let e = 0; e < 36; e++) {
    const r = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    a[r] = BigInt(e);
  }
  return a;
})();
BigInt(0);
BigInt(1);
BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const wH = new Uint8Array(32);
wH.fill(0);
BigInt(0);
BigInt(2);
BigInt(27);
BigInt(28);
BigInt(35);
BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const kH = new Uint8Array(32);
kH.fill(0);
BigInt(-1);
const EH = BigInt(0), SH = BigInt(1);
BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
AI(SH, 32);
AI(EH, 32);
function hw(a) {
  const e = /* @__PURE__ */ new Set();
  return a.forEach((r) => e.add(r)), Object.freeze(e);
}
const AH = "external public payable override";
hw(AH.split(" "));
const tN = "constant external internal payable private public pure view override";
hw(tN.split(" "));
const nN = "constructor error event fallback function receive struct";
hw(nN.split(" "));
const rN = "calldata memory storage payable indexed";
hw(rN.split(" "));
const xH = "tuple returns", CH = [nN, rN, xH, tN].join(" ");
hw(CH.split(" "));
const ru = /* @__PURE__ */ new Map();
ru.set(0, "GENERIC_PANIC");
ru.set(1, "ASSERT_FALSE");
ru.set(17, "OVERFLOW");
ru.set(18, "DIVIDE_BY_ZERO");
ru.set(33, "ENUM_RANGE_ERROR");
ru.set(34, "BAD_STORAGE_DATA");
ru.set(49, "STACK_UNDERFLOW");
ru.set(50, "ARRAY_RANGE_ERROR");
ru.set(65, "OUT_OF_MEMORY");
ru.set(81, "UNINITIALIZED_FUNCTION_CALL");
BigInt(0);
BigInt(0);
Promise.resolve();
BigInt(0);
BigInt(2);
const TH = "1.0.8";
let Ui = class iE extends Error {
  constructor(e, r = {}) {
    const i = r.cause instanceof iE ? r.cause.details : r.cause?.message ? r.cause.message : r.details, u = r.cause instanceof iE && r.cause.docsPath || r.docsPath, d = [
      e || "An error occurred.",
      "",
      ...r.metaMessages ? [...r.metaMessages, ""] : [],
      ...u ? [`Docs: https://abitype.dev${u}`] : [],
      ...i ? [`Details: ${i}`] : [],
      `Version: abitype@${TH}`
    ].join(`
`);
    super(d), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), r.cause && (this.cause = r.cause), this.details = i, this.docsPath = u, this.metaMessages = r.metaMessages, this.shortMessage = e;
  }
};
function Wd(a, e) {
  return a.exec(e)?.groups;
}
const aN = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, oN = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, iN = /^\(.+?\).*?$/, sN = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function IH(a) {
  return sN.test(a);
}
function NH(a) {
  return Wd(sN, a);
}
const lN = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function PH(a) {
  return lN.test(a);
}
function OH(a) {
  return Wd(lN, a);
}
const uN = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function RH(a) {
  return uN.test(a);
}
function LH(a) {
  return Wd(uN, a);
}
const cN = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function fN(a) {
  return cN.test(a);
}
function DH(a) {
  return Wd(cN, a);
}
const dN = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function BH(a) {
  return dN.test(a);
}
function MH(a) {
  return Wd(dN, a);
}
const hN = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function FH(a) {
  return hN.test(a);
}
function _H(a) {
  return Wd(hN, a);
}
const UH = /^receive\(\) external payable$/;
function zH(a) {
  return UH.test(a);
}
const HH = /* @__PURE__ */ new Set(["indexed"]), sE = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class VH extends Ui {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class WH extends Ui {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [`Type "${e}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class GH extends Ui {
  constructor({ param: e }) {
    super("Invalid ABI parameter.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class jH extends Ui {
  constructor({ param: e, name: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `"${r}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class $H extends Ui {
  constructor({ param: e, type: r, modifier: i }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${i}" not allowed${r ? ` in "${r}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class QH extends Ui {
  constructor({ param: e, type: r, modifier: i }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${i}" not allowed${r ? ` in "${r}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${i}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class ZH extends Ui {
  constructor({ abiParameter: e }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(e, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class i1 extends Ui {
  constructor({ signature: e, type: r }) {
    super(`Invalid ${r} signature.`, {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class YH extends Ui {
  constructor({ signature: e }) {
    super("Unknown signature.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class qH extends Ui {
  constructor({ signature: e }) {
    super("Invalid struct signature.", {
      details: e,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class KH extends Ui {
  constructor({ type: e }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${e}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class JH extends Ui {
  constructor({ current: e, depth: r }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${e.trim()}" has too many ${r > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${r}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function XH(a, e, r) {
  let i = "";
  if (r)
    for (const u of Object.entries(r)) {
      if (!u)
        continue;
      let d = "";
      for (const g of u[1])
        d += `[${g.type}${g.name ? `:${g.name}` : ""}]`;
      i += `(${u[0]}{${d}})`;
    }
  return e ? `${e}:${a}${i}` : a;
}
const q8 = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function eV(a, e = {}) {
  if (RH(a))
    return tV(a, e);
  if (PH(a))
    return nV(a, e);
  if (IH(a))
    return rV(a, e);
  if (BH(a))
    return aV(a, e);
  if (FH(a))
    return oV(a);
  if (zH(a))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new YH({ signature: a });
}
function tV(a, e = {}) {
  const r = LH(a);
  if (!r)
    throw new i1({ signature: a, type: "function" });
  const i = Ws(r.parameters), u = [], d = i.length;
  for (let b = 0; b < d; b++)
    u.push(Ig(i[b], {
      modifiers: sE,
      structs: e,
      type: "function"
    }));
  const g = [];
  if (r.returns) {
    const b = Ws(r.returns), y = b.length;
    for (let k = 0; k < y; k++)
      g.push(Ig(b[k], {
        modifiers: sE,
        structs: e,
        type: "function"
      }));
  }
  return {
    name: r.name,
    type: "function",
    stateMutability: r.stateMutability ?? "nonpayable",
    inputs: u,
    outputs: g
  };
}
function nV(a, e = {}) {
  const r = OH(a);
  if (!r)
    throw new i1({ signature: a, type: "event" });
  const i = Ws(r.parameters), u = [], d = i.length;
  for (let g = 0; g < d; g++)
    u.push(Ig(i[g], {
      modifiers: HH,
      structs: e,
      type: "event"
    }));
  return { name: r.name, type: "event", inputs: u };
}
function rV(a, e = {}) {
  const r = NH(a);
  if (!r)
    throw new i1({ signature: a, type: "error" });
  const i = Ws(r.parameters), u = [], d = i.length;
  for (let g = 0; g < d; g++)
    u.push(Ig(i[g], { structs: e, type: "error" }));
  return { name: r.name, type: "error", inputs: u };
}
function aV(a, e = {}) {
  const r = MH(a);
  if (!r)
    throw new i1({ signature: a, type: "constructor" });
  const i = Ws(r.parameters), u = [], d = i.length;
  for (let g = 0; g < d; g++)
    u.push(Ig(i[g], { structs: e, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: r.stateMutability ?? "nonpayable",
    inputs: u
  };
}
function oV(a) {
  const e = _H(a);
  if (!e)
    throw new i1({ signature: a, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: e.stateMutability ?? "nonpayable"
  };
}
const iV = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, sV = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, lV = /^u?int$/;
function Ig(a, e) {
  const r = XH(a, e?.type, e?.structs);
  if (q8.has(r))
    return q8.get(r);
  const i = iN.test(a), u = Wd(i ? sV : iV, a);
  if (!u)
    throw new GH({ param: a });
  if (u.name && cV(u.name))
    throw new jH({ param: a, name: u.name });
  const d = u.name ? { name: u.name } : {}, g = u.modifier === "indexed" ? { indexed: !0 } : {}, b = e?.structs ?? {};
  let y, k = {};
  if (i) {
    y = "tuple";
    const A = Ws(u.type), x = [], M = A.length;
    for (let D = 0; D < M; D++)
      x.push(Ig(A[D], { structs: b }));
    k = { components: x };
  } else if (u.type in b)
    y = "tuple", k = { components: b[u.type] };
  else if (lV.test(u.type))
    y = `${u.type}256`;
  else if (y = u.type, e?.type !== "struct" && !pN(y))
    throw new WH({ type: y });
  if (u.modifier) {
    if (!e?.modifiers?.has?.(u.modifier))
      throw new $H({
        param: a,
        type: e?.type,
        modifier: u.modifier
      });
    if (sE.has(u.modifier) && !fV(y, !!u.array))
      throw new QH({
        param: a,
        type: e?.type,
        modifier: u.modifier
      });
  }
  const S = {
    type: `${y}${u.array ?? ""}`,
    ...d,
    ...g,
    ...k
  };
  return q8.set(r, S), S;
}
function Ws(a, e = [], r = "", i = 0) {
  const u = a.trim().length;
  for (let d = 0; d < u; d++) {
    const g = a[d], b = a.slice(d + 1);
    switch (g) {
      case ",":
        return i === 0 ? Ws(b, [...e, r.trim()]) : Ws(b, e, `${r}${g}`, i);
      case "(":
        return Ws(b, e, `${r}${g}`, i + 1);
      case ")":
        return Ws(b, e, `${r}${g}`, i - 1);
      default:
        return Ws(b, e, `${r}${g}`, i);
    }
  }
  if (r === "")
    return e;
  if (i !== 0)
    throw new JH({ current: r, depth: i });
  return e.push(r.trim()), e;
}
function pN(a) {
  return a === "address" || a === "bool" || a === "function" || a === "string" || aN.test(a) || oN.test(a);
}
const uV = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function cV(a) {
  return a === "address" || a === "bool" || a === "function" || a === "string" || a === "tuple" || aN.test(a) || oN.test(a) || uV.test(a);
}
function fV(a, e) {
  return e || a === "bytes" || a === "string" || a === "tuple";
}
function dV(a) {
  const e = {}, r = a.length;
  for (let g = 0; g < r; g++) {
    const b = a[g];
    if (!fN(b))
      continue;
    const y = DH(b);
    if (!y)
      throw new i1({ signature: b, type: "struct" });
    const k = y.properties.split(";"), S = [], A = k.length;
    for (let x = 0; x < A; x++) {
      const M = k[x].trim();
      if (!M)
        continue;
      const D = Ig(M, {
        type: "struct"
      });
      S.push(D);
    }
    if (!S.length)
      throw new qH({ signature: b });
    e[y.name] = S;
  }
  const i = {}, u = Object.entries(e), d = u.length;
  for (let g = 0; g < d; g++) {
    const [b, y] = u[g];
    i[b] = gN(y, e);
  }
  return i;
}
const hV = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function gN(a, e, r = /* @__PURE__ */ new Set()) {
  const i = [], u = a.length;
  for (let d = 0; d < u; d++) {
    const g = a[d];
    if (iN.test(g.type))
      i.push(g);
    else {
      const b = Wd(hV, g.type);
      if (!b?.type)
        throw new ZH({ abiParameter: g });
      const { array: y, type: k } = b;
      if (k in e) {
        if (r.has(k))
          throw new KH({ type: k });
        i.push({
          ...g,
          type: `tuple${y ?? ""}`,
          components: gN(e[k] ?? [], e, /* @__PURE__ */ new Set([...r, k]))
        });
      } else if (pN(k))
        i.push(g);
      else
        throw new VH({ type: k });
    }
  }
  return i;
}
function pV(a) {
  const e = dV(a), r = [], i = a.length;
  for (let u = 0; u < i; u++) {
    const d = a[u];
    fN(d) || r.push(eV(d, e));
  }
  return r;
}
const gV = [
  "constructor()",
  "error AccessControlBadConfirmation()",
  "error AccessControlUnauthorizedAccount(address account, bytes32 neededRole)",
  "error AddressEmptyCode(address target)",
  "error DER_Split_Error()",
  "error ECDSAInvalidSignature()",
  "error ECDSAInvalidSignatureLength(uint256 length)",
  "error ECDSAInvalidSignatureS(bytes32 s)",
  "error ERC1967InvalidImplementation(address implementation)",
  "error ERC1967NonPayable()",
  "error FailedInnerCall()",
  "error InvalidInitialization()",
  "error NotInitializing()",
  "error UUPSUnauthorizedCallContext()",
  "error UUPSUnsupportedProxiableUUID(bytes32 slot)",
  "error expmod_Error()",
  "error k256Decompress_Invalid_Length_Error()",
  "error k256DeriveY_Invalid_Prefix_Error()",
  "error recoverV_Error()",
  "event GaslessTransaction(bytes32 indexed dataHash, bytes32 indexed hashedUsername, address indexed publicAddress)",
  "event Initialized(uint64 version)",
  "event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)",
  "event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)",
  "event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)",
  "event Upgraded(address indexed implementation)",
  "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
  "function UPGRADE_INTERFACE_VERSION() view returns (string)",
  "function addWallet((bytes32 credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) resp, bytes data) args)",
  "function addWalletPassword((bytes32 hashedUsername, bytes32 digest, bytes data) args)",
  "function createAccount((bytes32 hashedUsername, bytes credentialId, (uint8 kty, int8 alg, uint8 crv, uint256 x, uint256 y) pubkey, bytes32 optionalPassword, (uint8 walletType, bytes32 keypairSecret) wallet) args)",
  "function credentialIdsByUsername(bytes32 in_hashedUsername) view returns (bytes[] out_credentialIds)",
  "function encryptedTx(bytes32 nonce, bytes ciphertext, uint256 timestamp, bytes32 dataHash)",
  "function gaspayingAddress() view returns (address)",
  "function generateGaslessTx(bytes in_data, uint64 nonce, uint256 gasPrice, uint64 gasLimit, uint256 timestamp, bytes signature) view returns (bytes out_data)",
  "function getAccount(bytes32 in_username, uint8 walletType) view returns (address)",
  "function getRoleAdmin(bytes32 role) view returns (bytes32)",
  "function grantRole(bytes32 role, address account)",
  "function hasRole(bytes32 role, address account) view returns (bool)",
  "function hashUsage(bytes32) view returns (bool)",
  "function initialize(address _accountFactory, address _signer) payable",
  "function manageCredential((bytes32 credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) resp, bytes data) args)",
  "function manageCredentialPassword((bytes32 hashedUsername, bytes32 digest, bytes data) args)",
  "function personalization() view returns (bytes32)",
  "function proxiableUUID() view returns (bytes32)",
  "function proxyView(bytes32 in_credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) in_resp, uint8 walletType, bytes in_data) view returns (bytes out_data)",
  "function proxyViewPassword(bytes32 in_hashedUsername, uint8 walletType, bytes32 in_digest, bytes in_data) view returns (bytes out_data)",
  "function removeWallet((bytes32 credentialIdHashed, (bytes authenticatorData, (uint8 t, string k, string v)[] clientDataTokens, uint256 sigR, uint256 sigS) resp, bytes data) args)",
  "function removeWalletPassword((bytes32 hashedUsername, bytes32 digest, bytes data) args)",
  "function renounceRole(bytes32 role, address callerConfirmation)",
  "function revokeRole(bytes32 role, address account)",
  "function salt() view returns (bytes32)",
  "function setSigner(address _signer)",
  "function signer() view returns (address)",
  "function supportsInterface(bytes4 interfaceId) view returns (bool)",
  "function upgradeToAndCall(address newImplementation, bytes data) payable",
  "function userExists(bytes32 in_username) view returns (bool)",
  "function validateSignature(uint256 _gasPrice, uint64 _gasLimit, uint256 _timestamp, bytes32 _dataKeccak, bytes _signature) view returns (bytes32, bool)"
];
pV(gV);
function ax(a) {
  if (!Number.isSafeInteger(a) || a < 0)
    throw new Error("positive integer expected, got " + a);
}
function mV(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function Gk(a, ...e) {
  if (!mV(a))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(a.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + a.length);
}
function yV(a) {
  if (typeof a != "function" || typeof a.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  ax(a.outputLen), ax(a.blockLen);
}
function dk(a, e = !0) {
  if (a.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && a.finished)
    throw new Error("Hash#digest() has already been called");
}
function bV(a, e) {
  Gk(a);
  const r = e.outputLen;
  if (a.length < r)
    throw new Error("digestInto() expects output buffer of length at least " + r);
}
const q0 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function K8(a) {
  return new DataView(a.buffer, a.byteOffset, a.byteLength);
}
function Vl(a, e) {
  return a << 32 - e | a >>> e;
}
function vV(a) {
  if (typeof a != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof a);
  return new Uint8Array(new TextEncoder().encode(a));
}
function i7(a) {
  return typeof a == "string" && (a = vV(a)), Gk(a), a;
}
function wV(...a) {
  let e = 0;
  for (let i = 0; i < a.length; i++) {
    const u = a[i];
    Gk(u), e += u.length;
  }
  const r = new Uint8Array(e);
  for (let i = 0, u = 0; i < a.length; i++) {
    const d = a[i];
    r.set(d, u), u += d.length;
  }
  return r;
}
let mN = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function kV(a) {
  const e = (i) => a().update(i7(i)).digest(), r = a();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => a(), e;
}
function EV(a = 32) {
  if (q0 && typeof q0.getRandomValues == "function")
    return q0.getRandomValues(new Uint8Array(a));
  if (q0 && typeof q0.randomBytes == "function")
    return q0.randomBytes(a);
  throw new Error("crypto.getRandomValues must be defined");
}
function SV(a, e, r, i) {
  if (typeof a.setBigUint64 == "function")
    return a.setBigUint64(e, r, i);
  const u = BigInt(32), d = BigInt(4294967295), g = Number(r >> u & d), b = Number(r & d), y = i ? 4 : 0, k = i ? 0 : 4;
  a.setUint32(e + y, g, i), a.setUint32(e + k, b, i);
}
function AV(a, e, r) {
  return a & e ^ ~a & r;
}
function xV(a, e, r) {
  return a & e ^ a & r ^ e & r;
}
class CV extends mN {
  constructor(e, r, i, u) {
    super(), this.blockLen = e, this.outputLen = r, this.padOffset = i, this.isLE = u, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = K8(this.buffer);
  }
  update(e) {
    dk(this);
    const { view: r, buffer: i, blockLen: u } = this;
    e = i7(e);
    const d = e.length;
    for (let g = 0; g < d; ) {
      const b = Math.min(u - this.pos, d - g);
      if (b === u) {
        const y = K8(e);
        for (; u <= d - g; g += u)
          this.process(y, g);
        continue;
      }
      i.set(e.subarray(g, g + b), this.pos), this.pos += b, g += b, this.pos === u && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    dk(this), bV(e, this), this.finished = !0;
    const { buffer: r, view: i, blockLen: u, isLE: d } = this;
    let { pos: g } = this;
    r[g++] = 128, this.buffer.subarray(g).fill(0), this.padOffset > u - g && (this.process(i, 0), g = 0);
    for (let A = g; A < u; A++)
      r[A] = 0;
    SV(i, u - 8, BigInt(this.length * 8), d), this.process(i, 0);
    const b = K8(e), y = this.outputLen;
    if (y % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const k = y / 4, S = this.get();
    if (k > S.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let A = 0; A < k; A++)
      b.setUint32(4 * A, S[A], d);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const i = e.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: i, length: u, finished: d, destroyed: g, pos: b } = this;
    return e.length = u, e.pos = b, e.finished = d, e.destroyed = g, u % r && e.buffer.set(i), e;
  }
}
const TV = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), vd = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), wd = /* @__PURE__ */ new Uint32Array(64);
class IV extends CV {
  constructor() {
    super(64, 32, 8, !1), this.A = vd[0] | 0, this.B = vd[1] | 0, this.C = vd[2] | 0, this.D = vd[3] | 0, this.E = vd[4] | 0, this.F = vd[5] | 0, this.G = vd[6] | 0, this.H = vd[7] | 0;
  }
  get() {
    const { A: e, B: r, C: i, D: u, E: d, F: g, G: b, H: y } = this;
    return [e, r, i, u, d, g, b, y];
  }
  // prettier-ignore
  set(e, r, i, u, d, g, b, y) {
    this.A = e | 0, this.B = r | 0, this.C = i | 0, this.D = u | 0, this.E = d | 0, this.F = g | 0, this.G = b | 0, this.H = y | 0;
  }
  process(e, r) {
    for (let A = 0; A < 16; A++, r += 4)
      wd[A] = e.getUint32(r, !1);
    for (let A = 16; A < 64; A++) {
      const x = wd[A - 15], M = wd[A - 2], D = Vl(x, 7) ^ Vl(x, 18) ^ x >>> 3, O = Vl(M, 17) ^ Vl(M, 19) ^ M >>> 10;
      wd[A] = O + wd[A - 7] + D + wd[A - 16] | 0;
    }
    let { A: i, B: u, C: d, D: g, E: b, F: y, G: k, H: S } = this;
    for (let A = 0; A < 64; A++) {
      const x = Vl(b, 6) ^ Vl(b, 11) ^ Vl(b, 25), M = S + x + AV(b, y, k) + TV[A] + wd[A] | 0, D = (Vl(i, 2) ^ Vl(i, 13) ^ Vl(i, 22)) + xV(i, u, d) | 0;
      S = k, k = y, y = b, b = g + M | 0, g = d, d = u, u = i, i = M + D | 0;
    }
    i = i + this.A | 0, u = u + this.B | 0, d = d + this.C | 0, g = g + this.D | 0, b = b + this.E | 0, y = y + this.F | 0, k = k + this.G | 0, S = S + this.H | 0, this.set(i, u, d, g, b, y, k, S);
  }
  roundClean() {
    wd.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const NV = /* @__PURE__ */ kV(() => new IV());
class yN extends mN {
  constructor(e, r) {
    super(), this.finished = !1, this.destroyed = !1, yV(e);
    const i = i7(r);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const u = this.blockLen, d = new Uint8Array(u);
    d.set(i.length > u ? e.create().update(i).digest() : i);
    for (let g = 0; g < d.length; g++)
      d[g] ^= 54;
    this.iHash.update(d), this.oHash = e.create();
    for (let g = 0; g < d.length; g++)
      d[g] ^= 106;
    this.oHash.update(d), d.fill(0);
  }
  update(e) {
    return dk(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    dk(this), Gk(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: i, finished: u, destroyed: d, blockLen: g, outputLen: b } = this;
    return e = e, e.finished = u, e.destroyed = d, e.blockLen = g, e.outputLen = b, e.oHash = r._cloneInto(e.oHash), e.iHash = i._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const bN = (a, e, r) => new yN(a, e).update(r).digest();
bN.create = (a, e) => new yN(a, e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const jk = /* @__PURE__ */ BigInt(0), $k = /* @__PURE__ */ BigInt(1), PV = /* @__PURE__ */ BigInt(2);
function Ng(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function pw(a) {
  if (!Ng(a))
    throw new Error("Uint8Array expected");
}
function Jy(a, e) {
  if (typeof e != "boolean")
    throw new Error(a + " boolean expected, got " + e);
}
const OV = /* @__PURE__ */ Array.from({ length: 256 }, (a, e) => e.toString(16).padStart(2, "0"));
function Xy(a) {
  pw(a);
  let e = "";
  for (let r = 0; r < a.length; r++)
    e += OV[a[r]];
  return e;
}
function xy(a) {
  const e = a.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function s7(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  return a === "" ? jk : BigInt("0x" + a);
}
const mc = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function ox(a) {
  if (a >= mc._0 && a <= mc._9)
    return a - mc._0;
  if (a >= mc.A && a <= mc.F)
    return a - (mc.A - 10);
  if (a >= mc.a && a <= mc.f)
    return a - (mc.a - 10);
}
function e1(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  const e = a.length, r = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const i = new Uint8Array(r);
  for (let u = 0, d = 0; u < r; u++, d += 2) {
    const g = ox(a.charCodeAt(d)), b = ox(a.charCodeAt(d + 1));
    if (g === void 0 || b === void 0) {
      const y = a[d] + a[d + 1];
      throw new Error('hex string expected, got non-hex character "' + y + '" at index ' + d);
    }
    i[u] = g * 16 + b;
  }
  return i;
}
function mg(a) {
  return s7(Xy(a));
}
function l7(a) {
  return pw(a), s7(Xy(Uint8Array.from(a).reverse()));
}
function t1(a, e) {
  return e1(a.toString(16).padStart(e * 2, "0"));
}
function u7(a, e) {
  return t1(a, e).reverse();
}
function RV(a) {
  return e1(xy(a));
}
function Fs(a, e, r) {
  let i;
  if (typeof e == "string")
    try {
      i = e1(e);
    } catch (d) {
      throw new Error(a + " must be hex string or Uint8Array, cause: " + d);
    }
  else if (Ng(e))
    i = Uint8Array.from(e);
  else
    throw new Error(a + " must be hex string or Uint8Array");
  const u = i.length;
  if (typeof r == "number" && u !== r)
    throw new Error(a + " of length " + r + " expected, got " + u);
  return i;
}
function Kv(...a) {
  let e = 0;
  for (let i = 0; i < a.length; i++) {
    const u = a[i];
    pw(u), e += u.length;
  }
  const r = new Uint8Array(e);
  for (let i = 0, u = 0; i < a.length; i++) {
    const d = a[i];
    r.set(d, u), u += d.length;
  }
  return r;
}
function LV(a, e) {
  if (a.length !== e.length)
    return !1;
  let r = 0;
  for (let i = 0; i < a.length; i++)
    r |= a[i] ^ e[i];
  return r === 0;
}
function DV(a) {
  if (typeof a != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(a));
}
const J8 = (a) => typeof a == "bigint" && jk <= a;
function Qk(a, e, r) {
  return J8(a) && J8(e) && J8(r) && e <= a && a < r;
}
function yg(a, e, r, i) {
  if (!Qk(e, r, i))
    throw new Error("expected valid " + a + ": " + r + " <= n < " + i + ", got " + e);
}
function vN(a) {
  let e;
  for (e = 0; a > jk; a >>= $k, e += 1)
    ;
  return e;
}
function BV(a, e) {
  return a >> BigInt(e) & $k;
}
function MV(a, e, r) {
  return a | (r ? $k : jk) << BigInt(e);
}
const c7 = (a) => (PV << BigInt(a - 1)) - $k, X8 = (a) => new Uint8Array(a), ix = (a) => Uint8Array.from(a);
function wN(a, e, r) {
  if (typeof a != "number" || a < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let i = X8(a), u = X8(a), d = 0;
  const g = () => {
    i.fill(1), u.fill(0), d = 0;
  }, b = (...S) => r(u, i, ...S), y = (S = X8()) => {
    u = b(ix([0]), S), i = b(), S.length !== 0 && (u = b(ix([1]), S), i = b());
  }, k = () => {
    if (d++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let S = 0;
    const A = [];
    for (; S < e; ) {
      i = b();
      const x = i.slice();
      A.push(x), S += i.length;
    }
    return Kv(...A);
  };
  return (S, A) => {
    g(), y(S);
    let x;
    for (; !(x = A(k())); )
      y();
    return g(), x;
  };
}
const FV = {
  bigint: (a) => typeof a == "bigint",
  function: (a) => typeof a == "function",
  boolean: (a) => typeof a == "boolean",
  string: (a) => typeof a == "string",
  stringOrUint8Array: (a) => typeof a == "string" || Ng(a),
  isSafeInteger: (a) => Number.isSafeInteger(a),
  array: (a) => Array.isArray(a),
  field: (a, e) => e.Fp.isValid(a),
  hash: (a) => typeof a == "function" && Number.isSafeInteger(a.outputLen)
};
function gw(a, e, r = {}) {
  const i = (u, d, g) => {
    const b = FV[d];
    if (typeof b != "function")
      throw new Error("invalid validator function");
    const y = a[u];
    if (!(g && y === void 0) && !b(y, a))
      throw new Error("param " + String(u) + " is invalid. Expected " + d + ", got " + y);
  };
  for (const [u, d] of Object.entries(e))
    i(u, d, !1);
  for (const [u, d] of Object.entries(r))
    i(u, d, !0);
  return a;
}
const _V = () => {
  throw new Error("not implemented");
};
function lE(a) {
  const e = /* @__PURE__ */ new WeakMap();
  return (r, ...i) => {
    const u = e.get(r);
    if (u !== void 0)
      return u;
    const d = a(r, ...i);
    return e.set(r, d), d;
  };
}
const UV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange: yg,
  abool: Jy,
  abytes: pw,
  bitGet: BV,
  bitLen: vN,
  bitMask: c7,
  bitSet: MV,
  bytesToHex: Xy,
  bytesToNumberBE: mg,
  bytesToNumberLE: l7,
  concatBytes: Kv,
  createHmacDrbg: wN,
  ensureBytes: Fs,
  equalBytes: LV,
  hexToBytes: e1,
  hexToNumber: s7,
  inRange: Qk,
  isBytes: Ng,
  memoized: lE,
  notImplemented: _V,
  numberToBytesBE: t1,
  numberToBytesLE: u7,
  numberToHexUnpadded: xy,
  numberToVarBytesBE: RV,
  utf8ToBytes: DV,
  validateObject: gw
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Jr = BigInt(0), Kn = BigInt(1), Jp = /* @__PURE__ */ BigInt(2), zV = /* @__PURE__ */ BigInt(3), uE = /* @__PURE__ */ BigInt(4), sx = /* @__PURE__ */ BigInt(5), lx = /* @__PURE__ */ BigInt(8);
function Mi(a, e) {
  const r = a % e;
  return r >= Jr ? r : e + r;
}
function HV(a, e, r) {
  if (e < Jr)
    throw new Error("invalid exponent, negatives unsupported");
  if (r <= Jr)
    throw new Error("invalid modulus");
  if (r === Kn)
    return Jr;
  let i = Kn;
  for (; e > Jr; )
    e & Kn && (i = i * a % r), a = a * a % r, e >>= Kn;
  return i;
}
function cE(a, e) {
  if (a === Jr)
    throw new Error("invert: expected non-zero number");
  if (e <= Jr)
    throw new Error("invert: expected positive modulus, got " + e);
  let r = Mi(a, e), i = e, u = Jr, d = Kn;
  for (; r !== Jr; ) {
    const g = i / r, b = i % r, y = u - d * g;
    i = r, r = b, u = d, d = y;
  }
  if (i !== Kn)
    throw new Error("invert: does not exist");
  return Mi(u, e);
}
function VV(a) {
  const e = (a - Kn) / Jp;
  let r, i, u;
  for (r = a - Kn, i = 0; r % Jp === Jr; r /= Jp, i++)
    ;
  for (u = Jp; u < a && HV(u, e, a) !== a - Kn; u++)
    if (u > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  if (i === 1) {
    const g = (a + Kn) / uE;
    return function(b, y) {
      const k = b.pow(y, g);
      if (!b.eql(b.sqr(k), y))
        throw new Error("Cannot find square root");
      return k;
    };
  }
  const d = (r + Kn) / Jp;
  return function(g, b) {
    if (g.pow(b, e) === g.neg(g.ONE))
      throw new Error("Cannot find square root");
    let y = i, k = g.pow(g.mul(g.ONE, u), r), S = g.pow(b, d), A = g.pow(b, r);
    for (; !g.eql(A, g.ONE); ) {
      if (g.eql(A, g.ZERO))
        return g.ZERO;
      let x = 1;
      for (let D = g.sqr(A); x < y && !g.eql(D, g.ONE); x++)
        D = g.sqr(D);
      const M = g.pow(k, Kn << BigInt(y - x - 1));
      k = g.sqr(M), S = g.mul(S, M), A = g.mul(A, k), y = x;
    }
    return S;
  };
}
function WV(a) {
  if (a % uE === zV) {
    const e = (a + Kn) / uE;
    return function(r, i) {
      const u = r.pow(i, e);
      if (!r.eql(r.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  if (a % lx === sx) {
    const e = (a - sx) / lx;
    return function(r, i) {
      const u = r.mul(i, Jp), d = r.pow(u, e), g = r.mul(i, d), b = r.mul(r.mul(g, Jp), d), y = r.mul(g, r.sub(b, r.ONE));
      if (!r.eql(r.sqr(y), i))
        throw new Error("Cannot find square root");
      return y;
    };
  }
  return VV(a);
}
const GV = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function jV(a) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = GV.reduce((i, u) => (i[u] = "function", i), e);
  return gw(a, r);
}
function $V(a, e, r) {
  if (r < Jr)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === Jr)
    return a.ONE;
  if (r === Kn)
    return e;
  let i = a.ONE, u = e;
  for (; r > Jr; )
    r & Kn && (i = a.mul(i, u)), u = a.sqr(u), r >>= Kn;
  return i;
}
function QV(a, e) {
  const r = new Array(e.length), i = e.reduce((d, g, b) => a.is0(g) ? d : (r[b] = d, a.mul(d, g)), a.ONE), u = a.inv(i);
  return e.reduceRight((d, g, b) => a.is0(g) ? d : (r[b] = a.mul(d, r[b]), a.mul(d, g)), u), r;
}
function kN(a, e) {
  const r = e !== void 0 ? e : a.toString(2).length, i = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: i };
}
function EN(a, e, r = !1, i = {}) {
  if (a <= Jr)
    throw new Error("invalid field: expected ORDER > 0, got " + a);
  const { nBitLength: u, nByteLength: d } = kN(a, e);
  if (d > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let g;
  const b = Object.freeze({
    ORDER: a,
    isLE: r,
    BITS: u,
    BYTES: d,
    MASK: c7(u),
    ZERO: Jr,
    ONE: Kn,
    create: (y) => Mi(y, a),
    isValid: (y) => {
      if (typeof y != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof y);
      return Jr <= y && y < a;
    },
    is0: (y) => y === Jr,
    isOdd: (y) => (y & Kn) === Kn,
    neg: (y) => Mi(-y, a),
    eql: (y, k) => y === k,
    sqr: (y) => Mi(y * y, a),
    add: (y, k) => Mi(y + k, a),
    sub: (y, k) => Mi(y - k, a),
    mul: (y, k) => Mi(y * k, a),
    pow: (y, k) => $V(b, y, k),
    div: (y, k) => Mi(y * cE(k, a), a),
    // Same as above, but doesn't normalize
    sqrN: (y) => y * y,
    addN: (y, k) => y + k,
    subN: (y, k) => y - k,
    mulN: (y, k) => y * k,
    inv: (y) => cE(y, a),
    sqrt: i.sqrt || ((y) => (g || (g = WV(a)), g(b, y))),
    invertBatch: (y) => QV(b, y),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (y, k, S) => S ? k : y,
    toBytes: (y) => r ? u7(y, d) : t1(y, d),
    fromBytes: (y) => {
      if (y.length !== d)
        throw new Error("Field.fromBytes: expected " + d + " bytes, got " + y.length);
      return r ? l7(y) : mg(y);
    }
  });
  return Object.freeze(b);
}
function SN(a) {
  if (typeof a != "bigint")
    throw new Error("field order must be bigint");
  const e = a.toString(2).length;
  return Math.ceil(e / 8);
}
function AN(a) {
  const e = SN(a);
  return e + Math.ceil(e / 2);
}
function ZV(a, e, r = !1) {
  const i = a.length, u = SN(e), d = AN(e);
  if (i < 16 || i < d || i > 1024)
    throw new Error("expected " + d + "-1024 bytes of input, got " + i);
  const g = r ? l7(a) : mg(a), b = Mi(g, e - Kn) + Kn;
  return r ? u7(b, u) : t1(b, u);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ux = BigInt(0), k4 = BigInt(1);
function e5(a, e) {
  const r = e.negate();
  return a ? r : e;
}
function xN(a, e) {
  if (!Number.isSafeInteger(a) || a <= 0 || a > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + a);
}
function t5(a, e) {
  xN(a, e);
  const r = Math.ceil(e / a) + 1, i = 2 ** (a - 1);
  return { windows: r, windowSize: i };
}
function YV(a, e) {
  if (!Array.isArray(a))
    throw new Error("array expected");
  a.forEach((r, i) => {
    if (!(r instanceof e))
      throw new Error("invalid point at index " + i);
  });
}
function qV(a, e) {
  if (!Array.isArray(a))
    throw new Error("array of scalars expected");
  a.forEach((r, i) => {
    if (!e.isValid(r))
      throw new Error("invalid scalar at index " + i);
  });
}
const n5 = /* @__PURE__ */ new WeakMap(), CN = /* @__PURE__ */ new WeakMap();
function r5(a) {
  return CN.get(a) || 1;
}
function KV(a, e) {
  return {
    constTimeNegate: e5,
    hasPrecomputes(r) {
      return r5(r) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(r, i, u = a.ZERO) {
      let d = r;
      for (; i > ux; )
        i & k4 && (u = u.add(d)), d = d.double(), i >>= k4;
      return u;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(r, i) {
      const { windows: u, windowSize: d } = t5(i, e), g = [];
      let b = r, y = b;
      for (let k = 0; k < u; k++) {
        y = b, g.push(y);
        for (let S = 1; S < d; S++)
          y = y.add(b), g.push(y);
        b = y.double();
      }
      return g;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(r, i, u) {
      const { windows: d, windowSize: g } = t5(r, e);
      let b = a.ZERO, y = a.BASE;
      const k = BigInt(2 ** r - 1), S = 2 ** r, A = BigInt(r);
      for (let x = 0; x < d; x++) {
        const M = x * g;
        let D = Number(u & k);
        u >>= A, D > g && (D -= S, u += k4);
        const O = M, T = M + Math.abs(D) - 1, L = x % 2 !== 0, U = D < 0;
        D === 0 ? y = y.add(e5(L, i[O])) : b = b.add(e5(U, i[T]));
      }
      return { p: b, f: y };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(r, i, u, d = a.ZERO) {
      const { windows: g, windowSize: b } = t5(r, e), y = BigInt(2 ** r - 1), k = 2 ** r, S = BigInt(r);
      for (let A = 0; A < g; A++) {
        const x = A * b;
        if (u === ux)
          break;
        let M = Number(u & y);
        if (u >>= S, M > b && (M -= k, u += k4), M === 0)
          continue;
        let D = i[x + Math.abs(M) - 1];
        M < 0 && (D = D.negate()), d = d.add(D);
      }
      return d;
    },
    getPrecomputes(r, i, u) {
      let d = n5.get(i);
      return d || (d = this.precomputeWindow(i, r), r !== 1 && n5.set(i, u(d))), d;
    },
    wNAFCached(r, i, u) {
      const d = r5(r);
      return this.wNAF(d, this.getPrecomputes(d, r, u), i);
    },
    wNAFCachedUnsafe(r, i, u, d) {
      const g = r5(r);
      return g === 1 ? this.unsafeLadder(r, i, d) : this.wNAFUnsafe(g, this.getPrecomputes(g, r, u), i, d);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(r, i) {
      xN(i, e), CN.set(r, i), n5.delete(r);
    }
  };
}
function JV(a, e, r, i) {
  if (YV(r, a), qV(i, e), r.length !== i.length)
    throw new Error("arrays of points and scalars must have equal length");
  const u = a.ZERO, d = vN(BigInt(r.length)), g = d > 12 ? d - 3 : d > 4 ? d - 2 : d ? 2 : 1, b = (1 << g) - 1, y = new Array(b + 1).fill(u), k = Math.floor((e.BITS - 1) / g) * g;
  let S = u;
  for (let A = k; A >= 0; A -= g) {
    y.fill(u);
    for (let M = 0; M < i.length; M++) {
      const D = i[M], O = Number(D >> BigInt(A) & BigInt(b));
      y[O] = y[O].add(r[M]);
    }
    let x = u;
    for (let M = y.length - 1, D = u; M > 0; M--)
      D = D.add(y[M]), x = x.add(D);
    if (S = S.add(x), A !== 0)
      for (let M = 0; M < g; M++)
        S = S.double();
  }
  return S;
}
function TN(a) {
  return jV(a.Fp), gw(a, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...kN(a.n, a.nBitLength),
    ...a,
    p: a.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function cx(a) {
  a.lowS !== void 0 && Jy("lowS", a.lowS), a.prehash !== void 0 && Jy("prehash", a.prehash);
}
function XV(a) {
  const e = TN(a);
  gw(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: i, a: u } = e;
  if (r) {
    if (!i.eql(u, i.ZERO))
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: eW, hexToBytes: tW } = UV;
class nW extends Error {
  constructor(e = "") {
    super(e);
  }
}
const Sc = {
  // asn.1 DER encoding utils
  Err: nW,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (a, e) => {
      const { Err: r } = Sc;
      if (a < 0 || a > 256)
        throw new r("tlv.encode: wrong tag");
      if (e.length & 1)
        throw new r("tlv.encode: unpadded data");
      const i = e.length / 2, u = xy(i);
      if (u.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const d = i > 127 ? xy(u.length / 2 | 128) : "";
      return xy(a) + d + u + e;
    },
    // v - value, l - left bytes (unparsed)
    decode(a, e) {
      const { Err: r } = Sc;
      let i = 0;
      if (a < 0 || a > 256)
        throw new r("tlv.encode: wrong tag");
      if (e.length < 2 || e[i++] !== a)
        throw new r("tlv.decode: wrong tlv");
      const u = e[i++], d = !!(u & 128);
      let g = 0;
      if (!d)
        g = u;
      else {
        const y = u & 127;
        if (!y)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (y > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const k = e.subarray(i, i + y);
        if (k.length !== y)
          throw new r("tlv.decode: length bytes not complete");
        if (k[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const S of k)
          g = g << 8 | S;
        if (i += y, g < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const b = e.subarray(i, i + g);
      if (b.length !== g)
        throw new r("tlv.decode: wrong value length");
      return { v: b, l: e.subarray(i + g) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(a) {
      const { Err: e } = Sc;
      if (a < Rc)
        throw new e("integer: negative integers are not allowed");
      let r = xy(a);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new e("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(a) {
      const { Err: e } = Sc;
      if (a[0] & 128)
        throw new e("invalid signature integer: negative");
      if (a[0] === 0 && !(a[1] & 128))
        throw new e("invalid signature integer: unnecessary leading zero");
      return eW(a);
    }
  },
  toSig(a) {
    const { Err: e, _int: r, _tlv: i } = Sc, u = typeof a == "string" ? tW(a) : a;
    pw(u);
    const { v: d, l: g } = i.decode(48, u);
    if (g.length)
      throw new e("invalid signature: left bytes after parsing");
    const { v: b, l: y } = i.decode(2, d), { v: k, l: S } = i.decode(2, y);
    if (S.length)
      throw new e("invalid signature: left bytes after parsing");
    return { r: r.decode(b), s: r.decode(k) };
  },
  hexFromSig(a) {
    const { _tlv: e, _int: r } = Sc, i = e.encode(2, r.encode(a.r)), u = e.encode(2, r.encode(a.s)), d = i + u;
    return e.encode(48, d);
  }
}, Rc = BigInt(0), Mr = BigInt(1);
BigInt(2);
const fx = BigInt(3);
BigInt(4);
function rW(a) {
  const e = XV(a), { Fp: r } = e, i = EN(e.n, e.nBitLength), u = e.toBytes || ((O, T, L) => {
    const U = T.toAffine();
    return Kv(Uint8Array.from([4]), r.toBytes(U.x), r.toBytes(U.y));
  }), d = e.fromBytes || ((O) => {
    const T = O.subarray(1), L = r.fromBytes(T.subarray(0, r.BYTES)), U = r.fromBytes(T.subarray(r.BYTES, 2 * r.BYTES));
    return { x: L, y: U };
  });
  function g(O) {
    const { a: T, b: L } = e, U = r.sqr(O), W = r.mul(U, O);
    return r.add(r.add(W, r.mul(O, T)), L);
  }
  if (!r.eql(r.sqr(e.Gy), g(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function b(O) {
    return Qk(O, Mr, e.n);
  }
  function y(O) {
    const { allowedPrivateKeyLengths: T, nByteLength: L, wrapPrivateKey: U, n: W } = e;
    if (T && typeof O != "bigint") {
      if (Ng(O) && (O = Xy(O)), typeof O != "string" || !T.includes(O.length))
        throw new Error("invalid private key");
      O = O.padStart(L * 2, "0");
    }
    let Z;
    try {
      Z = typeof O == "bigint" ? O : mg(Fs("private key", O, L));
    } catch {
      throw new Error("invalid private key, expected hex or " + L + " bytes, got " + typeof O);
    }
    return U && (Z = Mi(Z, W)), yg("private key", Z, Mr, W), Z;
  }
  function k(O) {
    if (!(O instanceof x))
      throw new Error("ProjectivePoint expected");
  }
  const S = lE((O, T) => {
    const { px: L, py: U, pz: W } = O;
    if (r.eql(W, r.ONE))
      return { x: L, y: U };
    const Z = O.is0();
    T == null && (T = Z ? r.ONE : r.inv(W));
    const J = r.mul(L, T), Y = r.mul(U, T), X = r.mul(W, T);
    if (Z)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(X, r.ONE))
      throw new Error("invZ was invalid");
    return { x: J, y: Y };
  }), A = lE((O) => {
    if (O.is0()) {
      if (e.allowInfinityPoint && !r.is0(O.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: T, y: L } = O.toAffine();
    if (!r.isValid(T) || !r.isValid(L))
      throw new Error("bad point: x or y not FE");
    const U = r.sqr(L), W = g(T);
    if (!r.eql(U, W))
      throw new Error("bad point: equation left != right");
    if (!O.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class x {
    constructor(T, L, U) {
      if (this.px = T, this.py = L, this.pz = U, T == null || !r.isValid(T))
        throw new Error("x required");
      if (L == null || !r.isValid(L))
        throw new Error("y required");
      if (U == null || !r.isValid(U))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(T) {
      const { x: L, y: U } = T || {};
      if (!T || !r.isValid(L) || !r.isValid(U))
        throw new Error("invalid affine point");
      if (T instanceof x)
        throw new Error("projective point not allowed");
      const W = (Z) => r.eql(Z, r.ZERO);
      return W(L) && W(U) ? x.ZERO : new x(L, U, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(T) {
      const L = r.invertBatch(T.map((U) => U.pz));
      return T.map((U, W) => U.toAffine(L[W])).map(x.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(T) {
      const L = x.fromAffine(d(Fs("pointHex", T)));
      return L.assertValidity(), L;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(T) {
      return x.BASE.multiply(y(T));
    }
    // Multiscalar Multiplication
    static msm(T, L) {
      return JV(x, i, T, L);
    }
    // "Private method", don't use it directly
    _setWindowSize(T) {
      D.setWindowSize(this, T);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      A(this);
    }
    hasEvenY() {
      const { y: T } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(T);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(T) {
      k(T);
      const { px: L, py: U, pz: W } = this, { px: Z, py: J, pz: Y } = T, X = r.eql(r.mul(L, Y), r.mul(Z, W)), ee = r.eql(r.mul(U, Y), r.mul(J, W));
      return X && ee;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new x(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: T, b: L } = e, U = r.mul(L, fx), { px: W, py: Z, pz: J } = this;
      let Y = r.ZERO, X = r.ZERO, ee = r.ZERO, j = r.mul(W, W), ne = r.mul(Z, Z), ae = r.mul(J, J), he = r.mul(W, Z);
      return he = r.add(he, he), ee = r.mul(W, J), ee = r.add(ee, ee), Y = r.mul(T, ee), X = r.mul(U, ae), X = r.add(Y, X), Y = r.sub(ne, X), X = r.add(ne, X), X = r.mul(Y, X), Y = r.mul(he, Y), ee = r.mul(U, ee), ae = r.mul(T, ae), he = r.sub(j, ae), he = r.mul(T, he), he = r.add(he, ee), ee = r.add(j, j), j = r.add(ee, j), j = r.add(j, ae), j = r.mul(j, he), X = r.add(X, j), ae = r.mul(Z, J), ae = r.add(ae, ae), j = r.mul(ae, he), Y = r.sub(Y, j), ee = r.mul(ae, ne), ee = r.add(ee, ee), ee = r.add(ee, ee), new x(Y, X, ee);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(T) {
      k(T);
      const { px: L, py: U, pz: W } = this, { px: Z, py: J, pz: Y } = T;
      let X = r.ZERO, ee = r.ZERO, j = r.ZERO;
      const ne = e.a, ae = r.mul(e.b, fx);
      let he = r.mul(L, Z), Ie = r.mul(U, J), V = r.mul(W, Y), B = r.add(L, U), P = r.add(Z, J);
      B = r.mul(B, P), P = r.add(he, Ie), B = r.sub(B, P), P = r.add(L, W);
      let H = r.add(Z, Y);
      return P = r.mul(P, H), H = r.add(he, V), P = r.sub(P, H), H = r.add(U, W), X = r.add(J, Y), H = r.mul(H, X), X = r.add(Ie, V), H = r.sub(H, X), j = r.mul(ne, P), X = r.mul(ae, V), j = r.add(X, j), X = r.sub(Ie, j), j = r.add(Ie, j), ee = r.mul(X, j), Ie = r.add(he, he), Ie = r.add(Ie, he), V = r.mul(ne, V), P = r.mul(ae, P), Ie = r.add(Ie, V), V = r.sub(he, V), V = r.mul(ne, V), P = r.add(P, V), he = r.mul(Ie, P), ee = r.add(ee, he), he = r.mul(H, P), X = r.mul(B, X), X = r.sub(X, he), he = r.mul(B, Ie), j = r.mul(H, j), j = r.add(j, he), new x(X, ee, j);
    }
    subtract(T) {
      return this.add(T.negate());
    }
    is0() {
      return this.equals(x.ZERO);
    }
    wNAF(T) {
      return D.wNAFCached(this, T, x.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(T) {
      const { endo: L, n: U } = e;
      yg("scalar", T, Rc, U);
      const W = x.ZERO;
      if (T === Rc)
        return W;
      if (this.is0() || T === Mr)
        return this;
      if (!L || D.hasPrecomputes(this))
        return D.wNAFCachedUnsafe(this, T, x.normalizeZ);
      let { k1neg: Z, k1: J, k2neg: Y, k2: X } = L.splitScalar(T), ee = W, j = W, ne = this;
      for (; J > Rc || X > Rc; )
        J & Mr && (ee = ee.add(ne)), X & Mr && (j = j.add(ne)), ne = ne.double(), J >>= Mr, X >>= Mr;
      return Z && (ee = ee.negate()), Y && (j = j.negate()), j = new x(r.mul(j.px, L.beta), j.py, j.pz), ee.add(j);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(T) {
      const { endo: L, n: U } = e;
      yg("scalar", T, Mr, U);
      let W, Z;
      if (L) {
        const { k1neg: J, k1: Y, k2neg: X, k2: ee } = L.splitScalar(T);
        let { p: j, f: ne } = this.wNAF(Y), { p: ae, f: he } = this.wNAF(ee);
        j = D.constTimeNegate(J, j), ae = D.constTimeNegate(X, ae), ae = new x(r.mul(ae.px, L.beta), ae.py, ae.pz), W = j.add(ae), Z = ne.add(he);
      } else {
        const { p: J, f: Y } = this.wNAF(T);
        W = J, Z = Y;
      }
      return x.normalizeZ([W, Z])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(T, L, U) {
      const W = x.BASE, Z = (Y, X) => X === Rc || X === Mr || !Y.equals(W) ? Y.multiplyUnsafe(X) : Y.multiply(X), J = Z(this, L).add(Z(T, U));
      return J.is0() ? void 0 : J;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(T) {
      return S(this, T);
    }
    isTorsionFree() {
      const { h: T, isTorsionFree: L } = e;
      if (T === Mr)
        return !0;
      if (L)
        return L(x, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: T, clearCofactor: L } = e;
      return T === Mr ? this : L ? L(x, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(T = !0) {
      return Jy("isCompressed", T), this.assertValidity(), u(x, this, T);
    }
    toHex(T = !0) {
      return Jy("isCompressed", T), Xy(this.toRawBytes(T));
    }
  }
  x.BASE = new x(e.Gx, e.Gy, r.ONE), x.ZERO = new x(r.ZERO, r.ONE, r.ZERO);
  const M = e.nBitLength, D = KV(x, e.endo ? Math.ceil(M / 2) : M);
  return {
    CURVE: e,
    ProjectivePoint: x,
    normPrivateKeyToScalar: y,
    weierstrassEquation: g,
    isWithinCurveOrder: b
  };
}
function aW(a) {
  const e = TN(a);
  return gw(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function oW(a) {
  const e = aW(a), { Fp: r, n: i } = e, u = r.BYTES + 1, d = 2 * r.BYTES + 1;
  function g(V) {
    return Mi(V, i);
  }
  function b(V) {
    return cE(V, i);
  }
  const { ProjectivePoint: y, normPrivateKeyToScalar: k, weierstrassEquation: S, isWithinCurveOrder: A } = rW({
    ...e,
    toBytes(V, B, P) {
      const H = B.toAffine(), G = r.toBytes(H.x), ie = Kv;
      return Jy("isCompressed", P), P ? ie(Uint8Array.from([B.hasEvenY() ? 2 : 3]), G) : ie(Uint8Array.from([4]), G, r.toBytes(H.y));
    },
    fromBytes(V) {
      const B = V.length, P = V[0], H = V.subarray(1);
      if (B === u && (P === 2 || P === 3)) {
        const G = mg(H);
        if (!Qk(G, Mr, r.ORDER))
          throw new Error("Point is not on curve");
        const ie = S(G);
        let ce;
        try {
          ce = r.sqrt(ie);
        } catch (Ce) {
          const Be = Ce instanceof Error ? ": " + Ce.message : "";
          throw new Error("Point is not on curve" + Be);
        }
        const xe = (ce & Mr) === Mr;
        return (P & 1) === 1 !== xe && (ce = r.neg(ce)), { x: G, y: ce };
      } else if (B === d && P === 4) {
        const G = r.fromBytes(H.subarray(0, r.BYTES)), ie = r.fromBytes(H.subarray(r.BYTES, 2 * r.BYTES));
        return { x: G, y: ie };
      } else {
        const G = u, ie = d;
        throw new Error("invalid Point, expected length of " + G + ", or uncompressed " + ie + ", got " + B);
      }
    }
  }), x = (V) => Xy(t1(V, e.nByteLength));
  function M(V) {
    const B = i >> Mr;
    return V > B;
  }
  function D(V) {
    return M(V) ? g(-V) : V;
  }
  const O = (V, B, P) => mg(V.slice(B, P));
  class T {
    constructor(B, P, H) {
      this.r = B, this.s = P, this.recovery = H, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(B) {
      const P = e.nByteLength;
      return B = Fs("compactSignature", B, P * 2), new T(O(B, 0, P), O(B, P, 2 * P));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(B) {
      const { r: P, s: H } = Sc.toSig(Fs("DER", B));
      return new T(P, H);
    }
    assertValidity() {
      yg("r", this.r, Mr, i), yg("s", this.s, Mr, i);
    }
    addRecoveryBit(B) {
      return new T(this.r, this.s, B);
    }
    recoverPublicKey(B) {
      const { r: P, s: H, recovery: G } = this, ie = Y(Fs("msgHash", B));
      if (G == null || ![0, 1, 2, 3].includes(G))
        throw new Error("recovery id invalid");
      const ce = G === 2 || G === 3 ? P + e.n : P;
      if (ce >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const xe = G & 1 ? "03" : "02", Ce = y.fromHex(xe + x(ce)), Be = b(ce), Pe = g(-ie * Be), Fe = g(H * Be), Xe = y.BASE.multiplyAndAddUnsafe(Ce, Pe, Fe);
      if (!Xe)
        throw new Error("point at infinify");
      return Xe.assertValidity(), Xe;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return M(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new T(this.r, g(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return e1(this.toDERHex());
    }
    toDERHex() {
      return Sc.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return e1(this.toCompactHex());
    }
    toCompactHex() {
      return x(this.r) + x(this.s);
    }
  }
  const L = {
    isValidPrivateKey(V) {
      try {
        return k(V), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: k,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const V = AN(e.n);
      return ZV(e.randomBytes(V), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(V = 8, B = y.BASE) {
      return B._setWindowSize(V), B.multiply(BigInt(3)), B;
    }
  };
  function U(V, B = !0) {
    return y.fromPrivateKey(V).toRawBytes(B);
  }
  function W(V) {
    const B = Ng(V), P = typeof V == "string", H = (B || P) && V.length;
    return B ? H === u || H === d : P ? H === 2 * u || H === 2 * d : V instanceof y;
  }
  function Z(V, B, P = !0) {
    if (W(V))
      throw new Error("first arg must be private key");
    if (!W(B))
      throw new Error("second arg must be public key");
    return y.fromHex(B).multiply(k(V)).toRawBytes(P);
  }
  const J = e.bits2int || function(V) {
    if (V.length > 8192)
      throw new Error("input is too large");
    const B = mg(V), P = V.length * 8 - e.nBitLength;
    return P > 0 ? B >> BigInt(P) : B;
  }, Y = e.bits2int_modN || function(V) {
    return g(J(V));
  }, X = c7(e.nBitLength);
  function ee(V) {
    return yg("num < 2^" + e.nBitLength, V, Rc, X), t1(V, e.nByteLength);
  }
  function j(V, B, P = ne) {
    if (["recovered", "canonical"].some((tt) => tt in P))
      throw new Error("sign() legacy options not supported");
    const { hash: H, randomBytes: G } = e;
    let { lowS: ie, prehash: ce, extraEntropy: xe } = P;
    ie == null && (ie = !0), V = Fs("msgHash", V), cx(P), ce && (V = Fs("prehashed msgHash", H(V)));
    const Ce = Y(V), Be = k(B), Pe = [ee(Be), ee(Ce)];
    if (xe != null && xe !== !1) {
      const tt = xe === !0 ? G(r.BYTES) : xe;
      Pe.push(Fs("extraEntropy", tt));
    }
    const Fe = Kv(...Pe), Xe = Ce;
    function at(tt) {
      const Ye = J(tt);
      if (!A(Ye))
        return;
      const Ve = b(Ye), Je = y.BASE.multiply(Ye).toAffine(), _e = g(Je.x);
      if (_e === Rc)
        return;
      const rt = g(Ve * g(Xe + _e * Be));
      if (rt === Rc)
        return;
      let Gt = (Je.x === _e ? 0 : 2) | Number(Je.y & Mr), Er = rt;
      return ie && M(rt) && (Er = D(rt), Gt ^= 1), new T(_e, Er, Gt);
    }
    return { seed: Fe, k2sig: at };
  }
  const ne = { lowS: e.lowS, prehash: !1 }, ae = { lowS: e.lowS, prehash: !1 };
  function he(V, B, P = ne) {
    const { seed: H, k2sig: G } = j(V, B, P), ie = e;
    return wN(ie.hash.outputLen, ie.nByteLength, ie.hmac)(H, G);
  }
  y.BASE._setWindowSize(8);
  function Ie(V, B, P, H = ae) {
    const G = V;
    B = Fs("msgHash", B), P = Fs("publicKey", P);
    const { lowS: ie, prehash: ce, format: xe } = H;
    if (cx(H), "strict" in H)
      throw new Error("options.strict was renamed to lowS");
    if (xe !== void 0 && xe !== "compact" && xe !== "der")
      throw new Error("format must be compact or der");
    const Ce = typeof G == "string" || Ng(G), Be = !Ce && !xe && typeof G == "object" && G !== null && typeof G.r == "bigint" && typeof G.s == "bigint";
    if (!Ce && !Be)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let Pe, Fe;
    try {
      if (Be && (Pe = new T(G.r, G.s)), Ce) {
        try {
          xe !== "compact" && (Pe = T.fromDER(G));
        } catch (rt) {
          if (!(rt instanceof Sc.Err))
            throw rt;
        }
        !Pe && xe !== "der" && (Pe = T.fromCompact(G));
      }
      Fe = y.fromHex(P);
    } catch {
      return !1;
    }
    if (!Pe || ie && Pe.hasHighS())
      return !1;
    ce && (B = e.hash(B));
    const { r: Xe, s: at } = Pe, tt = Y(B), Ye = b(at), Ve = g(tt * Ye), Je = g(Xe * Ye), _e = y.BASE.multiplyAndAddUnsafe(Fe, Ve, Je)?.toAffine();
    return _e ? g(_e.x) === Xe : !1;
  }
  return {
    CURVE: e,
    getPublicKey: U,
    getSharedSecret: Z,
    sign: he,
    verify: Ie,
    ProjectivePoint: y,
    Signature: T,
    utils: L
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function iW(a) {
  return {
    hash: a,
    hmac: (e, ...r) => bN(a, e, wV(...r)),
    randomBytes: EV
  };
}
function sW(a, e) {
  const r = (i) => oW({ ...a, ...iW(i) });
  return { ...r(e), create: r };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const IN = EN(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")), lW = IN.create(BigInt("-3")), uW = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
sW({
  a: lW,
  // Equation params: a, b
  b: uW,
  Fp: IN,
  // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n
  // Curve order, total count of valid points in the field
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  // Base (generator) point (x, y)
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: !1
}, NV);
const dx = "embeddedWallet", lr = {
  SAPPHIRE_PROVIDER_NOT_INITIALIZED: "OAW_SAPPHIRE_PROVIDER_NOT_INITIALIZED",
  ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED: "OAW_ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED",
  NO_USERNAME: "OAW_NO_USERNAME",
  NO_PASSWORD: "OAW_NO_PASSWORD",
  NO_LOGIN_PROXY_DATA: "OAW_NO_LOGIN_PROXY_DATA",
  AUTHENTICATION_DATA_NOT_PROVIDED: "OAW_AUTHENTICATION_DATA_NOT_PROVIDED",
  CANT_GET_ACCOUNT_ADDRESS: "OAW_CANT_GET_ACCOUNT_ADDRESS",
  CANT_GET_ACCOUNT_WALLETS: "OAW_CANT_GET_ACCOUNT_WALLETS",
  NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID: "OAW_NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID",
  CROSS_CHAIN_PROVIDER_NOT_INITIALIZED: "OAW_CROSS_CHAIN_PROVIDER_NOT_INITIALIZED",
  OASIS_WALLET_NOT_INITIALIZED: "OAW_OASIS_WALLET_NOT_INITIALIZED",
  CANT_HASH_USERNAME: "OAW_CANT_HASH_USERNAME",
  CANT_GET_SIGNATURE: "CANT_GET_SIGNATURE",
  NO_APILLON_SESSION_TOKEN_CALLBACK: "NO_APILLON_SESSION_TOKEN_CALLBACK",
  INVALID_APILLON_SESSION_TOKEN: "INVALID_APILLON_SESSION_TOKEN",
  NO_APILLON_CLIENT_ID: "NO_APILLON_CLIENT_ID",
  CANT_GET_SIGNED_TX: "CANT_GET_SIGNED_TX",
  CHAIN_CHANGE_FAILED: "CHAIN_CHANGE_FAILED",
  XDOMAIN_NOT_INIT: "XDOMAIN_NOT_INIT",
  XDOMAIN_STOPPED: "XDOMAIN_STOPPED",
  XDOMAIN_BLOCKED: "XDOMAIN_BLOCKED",
  CANT_GET_WALLET_ADDRESS: "CANT_GET_WALLET_ADDRESS",
  WALLET_TITLE_UPDATE_FAILED: "WALLET_TITLE_UPDATE_FAILED"
};
lr.SAPPHIRE_PROVIDER_NOT_INITIALIZED + "", lr.ACCOUNT_MANAGER_CONTRACT_NOT_INITIALIZED + "", lr.NO_USERNAME + "", lr.NO_PASSWORD + "", lr.NO_LOGIN_PROXY_DATA + "", lr.AUTHENTICATION_DATA_NOT_PROVIDED + "", lr.CANT_GET_ACCOUNT_ADDRESS + "", lr.NO_RPC_URL_CONFIGURED_FOR_SELECTED_CHAINID + "", lr.CROSS_CHAIN_PROVIDER_NOT_INITIALIZED + "", lr.OASIS_WALLET_NOT_INITIALIZED + "", lr.CANT_HASH_USERNAME + "", lr.NO_APILLON_SESSION_TOKEN_CALLBACK + "", lr.INVALID_APILLON_SESSION_TOKEN + "", lr.NO_APILLON_CLIENT_ID + "", lr.CANT_GET_SIGNED_TX + "", lr.CHAIN_CHANGE_FAILED + "", lr.XDOMAIN_NOT_INIT + "", lr.XDOMAIN_STOPPED + "", lr.XDOMAIN_BLOCKED + "";
function fE(a, e = "Error") {
  const r = new Error(e);
  throw r.name = lr[a], r;
}
new lg.Sequence({
  name: "sig",
  value: [
    new lg.Integer({
      name: "r"
    }),
    new lg.Integer({
      name: "s"
    })
  ]
});
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function NN() {
  const [a, e] = Ct();
  Ln(() => {
    r();
  }, []);
  function r() {
    if (typeof window < "u" && window[dx]) {
      e(window[dx]);
      return;
    }
    setTimeout(r, 50);
  }
  return {
    wallet: a,
    signMessage: (i, u) => a.signMessage({
      message: i,
      mustConfirm: !0,
      ...u
    }),
    sendTransaction: async (i, u, d) => {
      const g = await a.signPlainTransaction({
        tx: i,
        mustConfirm: !0,
        ...u
      });
      return g?.signedTxData ? await a.broadcastTransaction(g.signedTxData, g.chainId, d) : fE("CANT_GET_SIGNED_TX");
    }
  };
}
function cW() {
  const { wallet: a } = NN(), [e, r] = Ct({
    username: "",
    activeWallet: void 0,
    authStrategy: "passkey"
  });
  Ln(() => {
    const u = ({ name: d, newValue: g }) => {
      d === "username" ? r((b) => ({ ...b, username: g })) : d === "walletIndex" ? r((b) => ({ ...b, activeWallet: a.lastAccount.wallets[g] })) : d === "wallets" && g.length ? r((b) => ({ ...b, activeWallet: g[a.lastAccount.walletIndex] })) : d === "authStrategy" && r((b) => ({ ...b, authStrategy: g }));
    };
    return a && (r({
      username: a.lastAccount.username,
      activeWallet: a.lastAccount.wallets[a.lastAccount.walletIndex],
      authStrategy: a.lastAccount.authStrategy
    }), a.events.on("dataUpdated", u)), () => {
      a && a.events.off("dataUpdated", u);
    };
  }, [a]);
  async function i(u = void 0) {
    return e.activeWallet ? await a?.getAccountBalance(e.activeWallet.address, u) : "0";
  }
  return {
    info: e,
    getBalance: i
  };
}
function AW({
  abi: a,
  address: e,
  chainId: r,
  mustConfirm: i = !0,
  //
  broadcast: u = !1
}) {
  const { wallet: d } = NN(), { info: g } = cW();
  async function b(k, S) {
    if (!d) {
      fE("OASIS_WALLET_NOT_INITIALIZED");
      return;
    }
    return await d.contractRead({
      contractAbi: a,
      contractAddress: e,
      contractFunctionName: k,
      contractFunctionValues: S,
      chainId: r
    });
  }
  async function y(k, S, A) {
    if (!d) {
      fE("OASIS_WALLET_NOT_INITIALIZED");
      return;
    }
    const x = await d.signContractWrite({
      contractAbi: a,
      contractAddress: e,
      contractFunctionName: k,
      contractFunctionValues: S,
      chainId: r,
      label: A,
      strategy: g.authStrategy,
      authData: { username: g.username },
      mustConfirm: i
    });
    return u && x ? await d.broadcastTransaction(x.signedTxData, x.chainId, A) : x;
  }
  return {
    read: b,
    write: y
  };
}
export {
  SW as EmbeddedWallet,
  cW as useAccount,
  AW as useContract,
  NN as useWallet
};
